var urlServer = 'http://103.1.210.135:6672/';
var isMapAPIDynamicLoad = false;
"undefined" == typeof jQuery && function (a, b) {
    function c(a) {
        return j.isWindow(a) ? a : 9 === a.nodeType ? a.defaultView || a.parentWindow : !1
    }

    function d(a) {
        if (!fa[a]) {
            var b = s.body, c = j("<" + a + ">").appendTo(b), d = c.css("display");
            c.remove();
            if ("none" === d || "" === d) {
                E || (E = s.createElement("iframe"), E.frameBorder = E.width = E.height = 0);
                b.appendChild(E);
                if (!R || !E.createElement)R = (E.contentWindow || E.contentDocument).document, R.write(("CSS1Compat" === s.compatMode ? "<!doctype html>" : "") + "<html><body>"), R.close();
                c = R.createElement(a);
                R.body.appendChild(c);
                d = j.css(c, "display");
                b.removeChild(E)
            }
            fa[a] = d
        }
        return fa[a]
    }

    function e(a, b) {
        var c = {};
        j.each(ra.concat.apply([], ra.slice(0, b)), function () {
            c[this] = a
        });
        return c
    }

    function f() {
        X = b
    }

    function g() {
        setTimeout(f, 0);
        return X = j.now()
    }

    function h() {
        try {
            return new a.XMLHttpRequest
        } catch (b) {
        }
    }

    function k(a, b, c, d) {
        if (j.isArray(b))j.each(b, function (b, e) {
            c || Qa.test(a) ? d(a, e) : k(a + "[" + ("object" == typeof e || j.isArray(e) ? b : "") + "]", e, c, d)
        }); else if (!c && null != b && "object" == typeof b)for (var e in b)k(a + "[" +
        e + "]", b[e], c, d); else d(a, b)
    }

    function l(a, c, d, e, f, g) {
        f = f || c.dataTypes[0];
        g = g || {};
        g[f] = !0;
        for (var f = a[f], h = 0, j = f ? f.length : 0, k = a === ga, m; h < j && (k || !m); h++)m = f[h](c, d, e), "string" == typeof m && (!k || g[m] ? m = b : (c.dataTypes.unshift(m), m = l(a, c, d, e, m, g)));
        (k || !m) && !g["*"] && (m = l(a, c, d, e, "*", g));
        return m
    }

    function m(a) {
        return function (b, c) {
            "string" != typeof b && (c = b, b = "*");
            if (j.isFunction(c))for (var d = b.toLowerCase().split(ta), e = 0, f = d.length, g, h, k; e < f; e++)g = d[e], k = /^\+/.test(g), k && (g = g.substr(1) || "*"), h = a[g] = a[g] || [],
                h[k ? "unshift" : "push"](c)
        }
    }

    function n(a, b, c) {
        var d = "width" === b ? a.offsetWidth : a.offsetHeight, e = "width" === b ? Ra : Sa;
        if (0 < d)return "border" !== c && j.each(e, function () {
            c || (d -= parseFloat(j.css(a, "padding" + this)) || 0);
            "margin" === c ? d += parseFloat(j.css(a, c + this)) || 0 : d -= parseFloat(j.css(a, "border" + this + "Width")) || 0
        }), d + "px";
        d = S(a, b, b);
        if (0 > d || null == d)d = a.style[b] || 0;
        d = parseFloat(d) || 0;
        c && j.each(e, function () {
            d += parseFloat(j.css(a, "padding" + this)) || 0;
            "padding" !== c && (d += parseFloat(j.css(a, "border" + this + "Width")) || 0);
            "margin" === c && (d += parseFloat(j.css(a, c + this)) || 0)
        });
        return d + "px"
    }

    function o(a, b) {
        b.src ? j.ajax({
            url: b.src,
            async: !1,
            dataType: "script"
        }) : j.globalEval((b.text || b.textContent || b.innerHTML || "").replace(Ta, "/*$0*/"));
        b.parentNode && b.parentNode.removeChild(b)
    }

    function p(a) {
        j.nodeName(a, "input") ? r(a) : "getElementsByTagName"in a && j.grep(a.getElementsByTagName("input"), r)
    }

    function r(a) {
        if ("checkbox" === a.type || "radio" === a.type)a.defaultChecked = a.checked
    }

    function u(a) {
        return "getElementsByTagName"in a ? a.getElementsByTagName("*") :
            "querySelectorAll"in a ? a.querySelectorAll("*") : []
    }

    function q(a, b) {
        var c;
        if (1 === b.nodeType) {
            b.clearAttributes && b.clearAttributes();
            b.mergeAttributes && b.mergeAttributes(a);
            c = b.nodeName.toLowerCase();
            if ("object" === c)b.outerHTML = a.outerHTML; else if ("input" !== c || "checkbox" !== a.type && "radio" !== a.type)if ("option" === c)b.selected = a.defaultSelected; else {
                if ("input" === c || "textarea" === c)b.defaultValue = a.defaultValue
            } else a.checked && (b.defaultChecked = b.checked = a.checked), b.value !== a.value && (b.value = a.value);
            b.removeAttribute(j.expando)
        }
    }

    function t(a, b) {
        if (1 === b.nodeType && j.hasData(a)) {
            var c = j.expando, d = j.data(a), e = j.data(b, d);
            if (d = d[c]) {
                var f = d.events, e = e[c] = j.extend({}, d);
                if (f) {
                    delete e.handle;
                    e.events = {};
                    for (var g in f) {
                        c = 0;
                        for (d = f[g].length; c < d; c++)j.event.add(b, g + (f[g][c].namespace ? "." : "") + f[g][c].namespace, f[g][c], f[g][c].data)
                    }
                }
            }
        }
    }

    function y(a, b, c) {
        b = b || 0;
        if (j.isFunction(b))return j.grep(a, function (a, d) {
            return !!b.call(a, d, a) === c
        });
        if (b.nodeType)return j.grep(a, function (a) {
            return a === b === c
        });
        if ("string" == typeof b) {
            var d = j.grep(a,
                function (a) {
                    return 1 === a.nodeType
                });
            if (Ua.test(b))return j.filter(b, d, !c);
            b = j.filter(b, d)
        }
        return j.grep(a, function (a) {
            return 0 <= j.inArray(a, b) === c
        })
    }

    function w(a, b) {
        return (a && "*" !== a ? a + "." : "") + b.replace(Va, "`").replace(Wa, "&")
    }

    function A(a) {
        var b, c, d, e, f, g, h, k, l, m, n, o = [];
        e = [];
        h = j._data(this, "events");
        if (!(a.liveFired === this || !h || !h.live || a.target.disabled || a.button && "click" === a.type)) {
            a.namespace && (n = RegExp("(^|\\.)" + a.namespace.split(".").join("\\.(?:.*\\.)?") + "(\\.|$)"));
            a.liveFired = this;
            var p =
                h.live.slice(0);
            for (h = 0; h < p.length; h++)f = p[h], f.origType.replace(ha, "") === a.type ? e.push(f.selector) : p.splice(h--, 1);
            e = j(a.target).closest(e, a.currentTarget);
            for (k = 0, l = e.length; k < l; k++) {
                m = e[k];
                for (h = 0; h < p.length; h++)if (f = p[h], m.selector === f.selector && (!n || n.test(f.namespace)) && !m.elem.disabled) {
                    g = m.elem;
                    d = null;
                    if ("mouseenter" === f.preType || "mouseleave" === f.preType)a.type = f.preType, d = j(a.relatedTarget).closest(f.selector)[0], d && j.contains(g, d) && (d = g);
                    (!d || d !== g) && o.push({elem: g, handleObj: f, level: m.level})
                }
            }
            for (k =
                     0, l = o.length; k < l; k++) {
                e = o[k];
                if (c && e.level > c)break;
                a.currentTarget = e.elem;
                a.data = e.handleObj.data;
                a.handleObj = e.handleObj;
                f = e.handleObj.origHandler.apply(e.elem, arguments);
                if (!1 === f || a.isPropagationStopped())if (c = e.level, !1 === f && (b = !1), a.isImmediatePropagationStopped())break
            }
            return b
        }
    }

    function L(a, c, d) {
        var e = j.extend({}, d[0]);
        e.type = a;
        e.originalEvent = {};
        e.liveFired = b;
        j.event.handle.call(c, e);
        e.isDefaultPrevented() && d[0].preventDefault()
    }

    function K() {
        return !0
    }

    function J() {
        return !1
    }

    function x(a, c, d) {
        var e =
            c + "defer", f = c + "queue", g = c + "mark", h = j.data(a, e, b, !0);
        h && ("queue" === d || !j.data(a, f, b, !0)) && ("mark" === d || !j.data(a, g, b, !0)) && setTimeout(function () {
            !j.data(a, f, b, !0) && !j.data(a, g, b, !0) && (j.removeData(a, e, !0), h.resolve())
        }, 0)
    }

    function B(a) {
        for (var b in a)if ("toJSON" !== b)return !1;
        return !0
    }

    function z(a, c, d) {
        if (d === b && 1 === a.nodeType)if (d = "data-" + c.replace(Xa, "$1-$2").toLowerCase(), d = a.getAttribute(d), "string" == typeof d) {
            try {
                d = "true" === d ? !0 : "false" === d ? !1 : "null" === d ? null : j.isNaN(d) ? Ya.test(d) ? j.parseJSON(d) :
                    d : parseFloat(d)
            } catch (e) {
            }
            j.data(a, c, d)
        } else d = b;
        return d
    }

    var s = a.document, P = a.navigator, Za = a.location, j = function () {
        function c() {
            if (!d.isReady) {
                try {
                    s.documentElement.doScroll("left")
                } catch (a) {
                    setTimeout(c, 1);
                    return
                }
                d.ready()
            }
        }

        var d = function (a, b) {
                return new d.fn.init(a, b, g)
            }, e = a.jQuery, f = a.$, g, h = /^(?:[^<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/, j = /\S/, k = /^\s+/, l = /\s+$/, m = /\d/, n = /^<(\w+)\s*\/?>(?:<\/\1>)?$/, o = /^[\],:{}\s]*$/, p = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, q = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,
            t = /(?:^|:|,)(?:\s*\[)+/g, r = /(webkit)[ \/]([\w.]+)/, u = /(opera)(?:.*version)?[ \/]([\w.]+)/, w = /(msie) ([\w.]+)/, y = /(mozilla)(?:.*? rv:([\w.]+))?/, $a = /-([a-z])/ig, ab = function (a, b) {
                return b.toUpperCase()
            }, bb = P.userAgent, ba, ca, T, cb = Object.prototype.toString, ja = Object.prototype.hasOwnProperty, x = Array.prototype.push, A = Array.prototype.slice, B = String.prototype.trim, z = Array.prototype.indexOf, L = {};
        d.fn = d.prototype = {
            constructor: d, init: function (a, c, e) {
                var f, v, g;
                if (!a)return this;
                if (a.nodeType)return this.context =
                    this[0] = a, this.length = 1, this;
                if ("body" === a && !c && s.body)return this.context = s, this[0] = s.body, this.selector = a, this.length = 1, this;
                if ("string" == typeof a) {
                    "<" !== a.charAt(0) || ">" !== a.charAt(a.length - 1) || 3 > a.length ? f = h.exec(a) : f = [null, a, null];
                    if (f && (f[1] || !c)) {
                        if (f[1])return c = c instanceof d ? c[0] : c, g = c ? c.ownerDocument || c : s, v = n.exec(a), v ? d.isPlainObject(c) ? (a = [s.createElement(v[1])], d.fn.attr.call(a, c, !0)) : a = [g.createElement(v[1])] : (v = d.buildFragment([f[1]], [g]), a = (v.cacheable ? d.clone(v.fragment) : v.fragment).childNodes),
                            d.merge(this, a);
                        if ((c = s.getElementById(f[2])) && c.parentNode) {
                            if (c.id !== f[2])return e.find(a);
                            this.length = 1;
                            this[0] = c
                        }
                        this.context = s;
                        this.selector = a;
                        return this
                    }
                    return !c || c.jquery ? (c || e).find(a) : this.constructor(c).find(a)
                }
                if (d.isFunction(a))return e.ready(a);
                a.selector !== b && (this.selector = a.selector, this.context = a.context);
                return d.makeArray(a, this)
            }, selector: "", jquery: "1.6.2", length: 0, size: function () {
                return this.length
            }, toArray: function () {
                return A.call(this, 0)
            }, get: function (a) {
                return null == a ? this.toArray() :
                    0 > a ? this[this.length + a] : this[a]
            }, pushStack: function (a, b, c) {
                var e = this.constructor();
                d.isArray(a) ? x.apply(e, a) : d.merge(e, a);
                e.prevObject = this;
                e.context = this.context;
                "find" === b ? e.selector = this.selector + (this.selector ? " " : "") + c : b && (e.selector = this.selector + "." + b + "(" + c + ")");
                return e
            }, each: function (a, b) {
                return d.each(this, a, b)
            }, ready: function (a) {
                d.bindReady();
                ca.done(a);
                return this
            }, eq: function (a) {
                return -1 === a ? this.slice(a) : this.slice(a, +a + 1)
            }, first: function () {
                return this.eq(0)
            }, last: function () {
                return this.eq(-1)
            },
            slice: function () {
                return this.pushStack(A.apply(this, arguments), "slice", A.call(arguments).join(","))
            }, map: function (a) {
                return this.pushStack(d.map(this, function (b, c) {
                    return a.call(b, c, b)
                }))
            }, end: function () {
                return this.prevObject || this.constructor(null)
            }, push: x, sort: [].sort, splice: [].splice
        };
        d.fn.init.prototype = d.fn;
        d.extend = d.fn.extend = function () {
            var a, c, e, f, v, g, h = arguments[0] || {}, j = 1, C = arguments.length, k = !1;
            for ("boolean" == typeof h && (k = h, h = arguments[1] || {}, j = 2), "object" != typeof h && !d.isFunction(h) &&
            (h = {}), C === j && (h = this, --j); j < C; j++)if (null != (a = arguments[j]))for (c in a)e = h[c], f = a[c], h !== f && (k && f && (d.isPlainObject(f) || (v = d.isArray(f))) ? (v ? (v = !1, g = e && d.isArray(e) ? e : []) : g = e && d.isPlainObject(e) ? e : {}, h[c] = d.extend(k, g, f)) : f !== b && (h[c] = f));
            return h
        };
        d.extend({
            noConflict: function (b) {
                a.$ === d && (a.$ = f);
                b && a.jQuery === d && (a.jQuery = e);
                return d
            }, isReady: !1, readyWait: 1, holdReady: function (a) {
                a ? d.readyWait++ : d.ready(!0)
            }, ready: function (a) {
                if (!0 === a && !--d.readyWait || !0 !== a && !d.isReady) {
                    if (!s.body)return setTimeout(d.ready,
                        1);
                    d.isReady = !0;
                    !0 !== a && 0 < --d.readyWait || (ca.resolveWith(s, [d]), d.fn.trigger && d(s).trigger("ready").unbind("ready"))
                }
            }, bindReady: function () {
                if (!ca) {
                    ca = d._Deferred();
                    if ("complete" === s.readyState)return setTimeout(d.ready, 1);
                    if (s.addEventListener)s.addEventListener("DOMContentLoaded", T, !1), a.addEventListener("load", d.ready, !1); else if (s.attachEvent) {
                        s.attachEvent("onreadystatechange", T);
                        a.attachEvent("onload", d.ready);
                        var b = !1;
                        try {
                            b = null == a.frameElement
                        } catch (e) {
                        }
                        s.documentElement.doScroll && b && c()
                    }
                }
            },
            isFunction: function (a) {
                return "function" === d.type(a)
            }, isArray: Array.isArray || function (a) {
                return "array" === d.type(a)
            }, isWindow: function (a) {
                return a && "object" == typeof a && "setInterval"in a
            }, isNaN: function (a) {
                return null == a || !m.test(a) || isNaN(a)
            }, type: function (a) {
                return null == a ? "" + a : L[cb.call(a)] || "object"
            }, isPlainObject: function (a) {
                if (!a || "object" !== d.type(a) || a.nodeType || d.isWindow(a) || a.constructor && !ja.call(a, "constructor") && !ja.call(a.constructor.prototype, "isPrototypeOf"))return !1;
                for (var c in a);
                return c === b || ja.call(a, c)
            }, isEmptyObject: function (a) {
                for (var b in a)return !1;
                return !0
            }, error: function (a) {
                throw a;
            }, parseJSON: function (b) {
                if ("string" != typeof b || !b)return null;
                b = d.trim(b);
                if (a.JSON && a.JSON.parse)return a.JSON.parse(b);
                if (o.test(b.replace(p, "@").replace(q, "]").replace(t, "")))return (new Function("return " + b))();
                d.error("Invalid JSON: " + b)
            }, parseXML: function (b, c, e) {
                a.DOMParser ? (e = new DOMParser, c = e.parseFromString(b, "text/xml")) : (c = new ActiveXObject("Microsoft.XMLDOM"), c.async = "false",
                    c.loadXML(b));
                e = c.documentElement;
                (!e || !e.nodeName || "parsererror" === e.nodeName) && d.error("Invalid XML: " + b);
                return c
            }, noop: function () {
            }, globalEval: function (b) {
                b && j.test(b) && (a.execScript || function (b) {
                    a.eval.call(a, b)
                })(b)
            }, camelCase: function (a) {
                return a.replace($a, ab)
            }, nodeName: function (a, b) {
                return a.nodeName && a.nodeName.toUpperCase() === b.toUpperCase()
            }, each: function (a, c, e) {
                var f, v = 0, g = a.length, h = g === b || d.isFunction(a);
                if (e)if (h)for (f in a) {
                    if (!1 === c.apply(a[f], e))break
                } else for (; v < g && !(!1 === c.apply(a[v++],
                    e));); else if (h)for (f in a) {
                    if (!1 === c.call(a[f], f, a[f]))break
                } else for (; v < g && !(!1 === c.call(a[v], v, a[v++])););
                return a
            }, trim: B ? function (a) {
                return null == a ? "" : B.call(a)
            } : function (a) {
                return null == a ? "" : (a + "").replace(k, "").replace(l, "")
            }, makeArray: function (a, b) {
                var c = b || [];
                if (null != a) {
                    var e = d.type(a);
                    null == a.length || "string" === e || "function" === e || "regexp" === e || d.isWindow(a) ? x.call(c, a) : d.merge(c, a)
                }
                return c
            }, inArray: function (a, b) {
                if (z)return z.call(b, a);
                for (var c = 0, d = b.length; c < d; c++)if (b[c] === a)return c;
                return -1
            }, merge: function (a, c) {
                var d = a.length, e = 0;
                if ("number" == typeof c.length)for (var f = c.length; e < f; e++)a[d++] = c[e]; else for (; c[e] !== b;)a[d++] = c[e++];
                a.length = d;
                return a
            }, grep: function (a, b, c) {
                for (var d = [], e, c = !!c, f = 0, v = a.length; f < v; f++)e = !!b(a[f], f), c !== e && d.push(a[f]);
                return d
            }, map: function (a, c, e) {
                var f, v, g = [], h = 0, j = a.length;
                if (a instanceof d || j !== b && "number" == typeof j && (0 < j && a[0] && a[j - 1] || 0 === j || d.isArray(a)))for (; h < j; h++)f = c(a[h], h, e), null != f && (g[g.length] = f); else for (v in a)f = c(a[v], v, e), null !=
                f && (g[g.length] = f);
                return g.concat.apply([], g)
            }, guid: 1, proxy: function (a, c) {
                if ("string" == typeof c) {
                    var e = a[c];
                    c = a;
                    a = e
                }
                if (!d.isFunction(a))return b;
                var f = A.call(arguments, 2), e = function () {
                    return a.apply(c, f.concat(A.call(arguments)))
                };
                e.guid = a.guid = a.guid || e.guid || d.guid++;
                return e
            }, access: function (a, c, e, f, v, g) {
                var h = a.length;
                if ("object" == typeof c) {
                    for (var j in c)d.access(a, j, c[j], f, v, e);
                    return a
                }
                if (e !== b) {
                    f = !g && f && d.isFunction(e);
                    for (j = 0; j < h; j++)v(a[j], c, f ? e.call(a[j], j, v(a[j], c)) : e, g);
                    return a
                }
                return h ?
                    v(a[0], c) : b
            }, now: function () {
                return (new Date).getTime()
            }, uaMatch: function (a) {
                a = a.toLowerCase();
                a = r.exec(a) || u.exec(a) || w.exec(a) || 0 > a.indexOf("compatible") && y.exec(a) || [];
                return {browser: a[1] || "", version: a[2] || "0"}
            }, sub: function () {
                function a(b, c) {
                    return new a.fn.init(b, c)
                }

                d.extend(!0, a, this);
                a.superclass = this;
                a.fn = a.prototype = this();
                a.fn.constructor = a;
                a.sub = this.sub;
                a.fn.init = function (c, e) {
                    e && e instanceof d && !(e instanceof a) && (e = a(e));
                    return d.fn.init.call(this, c, e, b)
                };
                a.fn.init.prototype = a.fn;
                var b =
                    a(s);
                return a
            }, browser: {}
        });
        d.each("Boolean,Number,String,Function,Array,Date,RegExp,Object".split(","), function (a, b) {
            L["[object " + b + "]"] = b.toLowerCase()
        });
        ba = d.uaMatch(bb);
        ba.browser && (d.browser[ba.browser] = !0, d.browser.version = ba.version);
        d.browser.webkit && (d.browser.safari = !0);
        j.test("\ufffd") && (k = /^[\s\xA0]+/, l = /[\s\xA0]+$/);
        g = d(s);
        s.addEventListener ? T = function () {
            s.removeEventListener("DOMContentLoaded", T, !1);
            d.ready()
        } : s.attachEvent && (T = function () {
            "complete" === s.readyState && (s.detachEvent("onreadystatechange",
                T), d.ready())
        });
        return d
    }(), ka = "done,fail,isResolved,isRejected,promise,then,always,pipe".split(","), ua = [].slice;
    j.extend({
        _Deferred: function () {
            var a = [], b, c, d, e = {
                done: function () {
                    if (!d) {
                        var c = arguments, f, g, h, C, k;
                        b && (k = b, b = 0);
                        for (f = 0, g = c.length; f < g; f++)h = c[f], C = j.type(h), "array" === C ? e.done.apply(e, h) : "function" === C && a.push(h);
                        k && e.resolveWith(k[0], k[1])
                    }
                    return this
                }, resolveWith: function (e, f) {
                    if (!d && !b && !c) {
                        f = f || [];
                        c = 1;
                        try {
                            for (; a[0];)a.shift().apply(e, f)
                        } finally {
                            b = [e, f], c = 0
                        }
                    }
                    return this
                }, resolve: function () {
                    e.resolveWith(this,
                        arguments);
                    return this
                }, isResolved: function () {
                    return !!c || !!b
                }, cancel: function () {
                    d = 1;
                    a = [];
                    return this
                }
            };
            return e
        }, Deferred: function (a) {
            var b = j._Deferred(), c = j._Deferred(), d;
            j.extend(b, {
                then: function (a, c) {
                    b.done(a).fail(c);
                    return this
                },
                always: function () {
                    return b.done.apply(b, arguments).fail.apply(this, arguments)
                },
                fail: c.done,
                rejectWith: c.resolveWith,
                reject: c.resolve,
                isRejected: c.isResolved,
                pipe: function (a, c) {
                    return j.Deferred(function (d) {
                        j.each({done: [a, "resolve"], fail: [c, "reject"]}, function (a, c) {
                            var e =
                                c[0], f = c[1], v;
                            j.isFunction(e) ? b[a](function () {
                                v = e.apply(this, arguments);
                                v && j.isFunction(v.promise) ? v.promise().then(d.resolve, d.reject) : d[f](v)
                            }) : b[a](d[f])
                        })
                    }).promise()
                },
                promise: function (a) {
                    if (null == a) {
                        if (d)return d;
                        d = a = {}
                    }
                    for (var c = ka.length; c--;)a[ka[c]] = b[ka[c]];
                    return a
                }
            });
            b.done(c.cancel).fail(b.cancel);
            delete b.cancel;
            a && a.call(b, b);
            return b
        }, when: function (a) {
            function b(a) {
                return function (b) {
                    c[a] = 1 < arguments.length ? ua.call(arguments, 0) : b;
                    --f || g.resolveWith(g, ua.call(c, 0))
                }
            }

            var c = arguments,
                d = 0, e = c.length, f = e, g = 1 >= e && a && j.isFunction(a.promise) ? a : j.Deferred();
            if (1 < e) {
                for (; d < e; d++)c[d] && j.isFunction(c[d].promise) ? c[d].promise().then(b(d), g.reject) : --f;
                f || g.resolveWith(g, c)
            } else g !== a && g.resolveWith(g, e ? [a] : []);
            return g.promise()
        }
    });
    j.support = function () {
        var a = s.createElement("div"), b = s.documentElement, c, d, e, f, g, h, k, l, m, n, o, p, q, t, r;
        a.setAttribute("className", "t");
        a.innerHTML = "   <link/><table></table><a href='/a' style='top:1px;float:left;opacity:.55;'>a</a><input type='checkbox'/>";
        c = a.getElementsByTagName("*");
        d = a.getElementsByTagName("a")[0];
        if (!c || !c.length || !d)return {};
        e = s.createElement("select");
        f = e.appendChild(s.createElement("option"));
        g = a.getElementsByTagName("input")[0];
        k = {
            leadingWhitespace: 3 === a.firstChild.nodeType,
            tbody: !a.getElementsByTagName("tbody").length,
            htmlSerialize: !!a.getElementsByTagName("link").length,
            style: /top/.test(d.getAttribute("style")),
            hrefNormalized: "/a" === d.getAttribute("href"),
            opacity: /^0.55$/.test(d.style.opacity),
            cssFloat: !!d.style.cssFloat,
            checkOn: "on" === g.value,
            optSelected: f.selected,
            getSetAttribute: "t" !== a.className,
            submitBubbles: !0,
            changeBubbles: !0,
            focusinBubbles: !1,
            deleteExpando: !0,
            noCloneEvent: !0,
            inlineBlockNeedsLayout: !1,
            shrinkWrapBlocks: !1,
            reliableMarginRight: !0
        };
        g.checked = !0;
        k.noCloneChecked = g.cloneNode(!0).checked;
        e.disabled = !0;
        k.optDisabled = !f.disabled;
        try {
            delete a.test
        } catch (u) {
            k.deleteExpando = !1
        }
        !a.addEventListener && a.attachEvent && a.fireEvent && (a.attachEvent("onclick", function () {
            k.noCloneEvent = !1
        }), a.cloneNode(!0).fireEvent("onclick"));
        g = s.createElement("input");
        g.value =
            "t";
        g.setAttribute("type", "radio");
        k.radioValue = "t" === g.value;
        g.setAttribute("checked", "checked");
        a.appendChild(g);
        l = s.createDocumentFragment();
        l.appendChild(a.firstChild);
        k.checkClone = l.cloneNode(!0).cloneNode(!0).lastChild.checked;
        a.innerHTML = "";
        a.style.width = a.style.paddingLeft = "1px";
        m = s.getElementsByTagName("body")[0];
        c = s.createElement(m ? "div" : "body");
        o = {visibility: "hidden", width: 0, height: 0, border: 0, margin: 0};
        m && j.extend(o, {position: "absolute", left: -1E3, top: -1E3});
        for (t in o)c.style[t] = o[t];
        c.appendChild(a);
        n = m || b;
        n.insertBefore(c, n.firstChild);
        k.appendChecked = g.checked;
        k.boxModel = 2 === a.offsetWidth;
        "zoom"in a.style && (a.style.display = "inline", a.style.zoom = 1, k.inlineBlockNeedsLayout = 2 === a.offsetWidth, a.style.display = "", a.innerHTML = "<div style='width:4px;'></div>", k.shrinkWrapBlocks = 2 !== a.offsetWidth);
        a.innerHTML = "<table><tr><td style='padding:0;border:0;display:none'></td><td>t</td></tr></table>";
        p = a.getElementsByTagName("td");
        r = 0 === p[0].offsetHeight;
        p[0].style.display = "";
        p[1].style.display = "none";
        k.reliableHiddenOffsets =
            r && 0 === p[0].offsetHeight;
        a.innerHTML = "";
        s.defaultView && s.defaultView.getComputedStyle && (h = s.createElement("div"), h.style.width = "0", h.style.marginRight = "0", a.appendChild(h), k.reliableMarginRight = 0 === (parseInt((s.defaultView.getComputedStyle(h, null) || {marginRight: 0}).marginRight, 10) || 0));
        c.innerHTML = "";
        n.removeChild(c);
        if (a.attachEvent)for (t in{
            submit: 1,
            change: 1,
            focusin: 1
        })q = "on" + t, r = q in a, r || (a.setAttribute(q, "return;"), r = "function" == typeof a[q]), k[t + "Bubbles"] = r;
        c = l = e = f = m = h = a = g = null;
        return k
    }();
    j.boxModel = j.support.boxModel;
    var Ya = /^(?:\{.*\}|\[.*\])$/, Xa = /([a-z])([A-Z])/g;
    j.extend({
        cache: {},
        uuid: 0,
        expando: "jQuery" + (j.fn.jquery + Math.random()).replace(/\D/g, ""),
        noData: {embed: !0, object: "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000", applet: !0},
        hasData: function (a) {
            a = a.nodeType ? j.cache[a[j.expando]] : a[j.expando];
            return !!a && !B(a)
        },
        data: function (a, c, d, e) {
            if (j.acceptData(a)) {
                var f = j.expando, g = "string" == typeof c, h, k = a.nodeType, l = k ? j.cache : a, m = k ? a[j.expando] : a[j.expando] && j.expando;
                if (m && (!e || !m || l[m][f]) || !(g && d === b)) {
                    m || (k ? a[j.expando] = m = ++j.uuid : m = j.expando);
                    l[m] || (l[m] = {}, k || (l[m].toJSON = j.noop));
                    if ("object" == typeof c || "function" == typeof c)e ? l[m][f] = j.extend(l[m][f], c) : l[m] = j.extend(l[m], c);
                    h = l[m];
                    e && (h[f] || (h[f] = {}), h = h[f]);
                    d !== b && (h[j.camelCase(c)] = d);
                    return "events" === c && !h[c] ? h[f] && h[f].events : g ? h[j.camelCase(c)] || h[c] : h
                }
            }
        },
        removeData: function (b, c, d) {
            if (j.acceptData(b)) {
                var e = j.expando, f = b.nodeType, g = f ? j.cache : b, h = f ? b[j.expando] : j.expando;
                if (g[h]) {
                    if (c) {
                        var k = d ? g[h][e] : g[h];
                        if (k && (delete k[c],
                                !B(k)))return
                    }
                    if (d && (delete g[h][e], !B(g[h])))return;
                    c = g[h][e];
                    j.support.deleteExpando || g != a ? delete g[h] : g[h] = null;
                    c ? (g[h] = {}, f || (g[h].toJSON = j.noop), g[h][e] = c) : f && (j.support.deleteExpando ? delete b[j.expando] : b.removeAttribute ? b.removeAttribute(j.expando) : b[j.expando] = null)
                }
            }
        },
        _data: function (a, b, c) {
            return j.data(a, b, c, !0)
        },
        acceptData: function (a) {
            if (a.nodeName) {
                var b = j.noData[a.nodeName.toLowerCase()];
                if (b)return !0 !== b && a.getAttribute("classid") === b
            }
            return !0
        }
    });
    j.fn.extend({
        data: function (a, c) {
            var d =
                null;
            if ("undefined" == typeof a) {
                if (this.length && (d = j.data(this[0]), 1 === this[0].nodeType))for (var e = this[0].attributes, f, g = 0, h = e.length; g < h; g++)f = e[g].name, 0 === f.indexOf("data-") && (f = j.camelCase(f.substring(5)), z(this[0], f, d[f]));
                return d
            }
            if ("object" == typeof a)return this.each(function () {
                j.data(this, a)
            });
            var k = a.split(".");
            k[1] = k[1] ? "." + k[1] : "";
            return c === b ? (d = this.triggerHandler("getData" + k[1] + "!", [k[0]]), d === b && this.length && (d = j.data(this[0], a), d = z(this[0], a, d)), d === b && k[1] ? this.data(k[0]) : d) : this.each(function () {
                var b =
                    j(this), d = [k[0], c];
                b.triggerHandler("setData" + k[1] + "!", d);
                j.data(this, a, c);
                b.triggerHandler("changeData" + k[1] + "!", d)
            })
        }, removeData: function (a) {
            return this.each(function () {
                j.removeData(this, a)
            })
        }
    });
    j.extend({
        _mark: function (a, c) {
            a && (c = (c || "fx") + "mark", j.data(a, c, (j.data(a, c, b, !0) || 0) + 1, !0))
        }, _unmark: function (a, c, d) {
            !0 !== a && (d = c, c = a, a = !1);
            if (c) {
                var d = d || "fx", e = d + "mark";
                (a = a ? 0 : (j.data(c, e, b, !0) || 1) - 1) ? j.data(c, e, a, !0) : (j.removeData(c, e, !0), x(c, d, "mark"))
            }
        }, queue: function (a, c, d) {
            if (a) {
                var c = (c || "fx") +
                    "queue", e = j.data(a, c, b, !0);
                d && (!e || j.isArray(d) ? e = j.data(a, c, j.makeArray(d), !0) : e.push(d));
                return e || []
            }
        }, dequeue: function (a, b) {
            var b = b || "fx", c = j.queue(a, b), d = c.shift();
            "inprogress" === d && (d = c.shift());
            d && ("fx" === b && c.unshift("inprogress"), d.call(a, function () {
                j.dequeue(a, b)
            }));
            c.length || (j.removeData(a, b + "queue", !0), x(a, b, "queue"))
        }
    });
    j.fn.extend({
        queue: function (a, c) {
            "string" != typeof a && (c = a, a = "fx");
            return c === b ? j.queue(this[0], a) : this.each(function () {
                var b = j.queue(this, a, c);
                "fx" === a && "inprogress" !==
                b[0] && j.dequeue(this, a)
            })
        }, dequeue: function (a) {
            return this.each(function () {
                j.dequeue(this, a)
            })
        }, delay: function (a, b) {
            a = j.fx ? j.fx.speeds[a] || a : a;
            b = b || "fx";
            return this.queue(b, function () {
                var c = this;
                setTimeout(function () {
                    j.dequeue(c, b)
                }, a)
            })
        }, clearQueue: function (a) {
            return this.queue(a || "fx", [])
        }, promise: function (a) {
            function c() {
                --g || d.resolveWith(e, [e])
            }

            "string" != typeof a && (a = b);
            a = a || "fx";
            for (var d = j.Deferred(), e = this, f = e.length, g = 1, h = a + "defer", k = a + "queue", a = a + "mark", l; f--;)if (l = j.data(e[f], h, b, !0) ||
                (j.data(e[f], k, b, !0) || j.data(e[f], a, b, !0)) && j.data(e[f], h, j._Deferred(), !0))g++, l.done(c);
            c();
            return d.promise()
        }
    });
    var va = /[\n\t\r]/g, la = /\s+/, db = /\r/g, eb = /^(?:button|input)$/i, fb = /^(?:button|input|object|select|textarea)$/i, gb = /^a(?:rea)?$/i, wa = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i, hb = /\:|^on/, F, xa;
    j.fn.extend({
        attr: function (a, b) {
            return j.access(this, a, b, !0, j.attr)
        }, removeAttr: function (a) {
            return this.each(function () {
                j.removeAttr(this,
                    a)
            })
        }, prop: function (a, b) {
            return j.access(this, a, b, !0, j.prop)
        }, removeProp: function (a) {
            a = j.propFix[a] || a;
            return this.each(function () {
                try {
                    this[a] = b, delete this[a]
                } catch (c) {
                }
            })
        }, addClass: function (a) {
            var b, c, d, e, f, g, h;
            if (j.isFunction(a))return this.each(function (b) {
                j(this).addClass(a.call(this, b, this.className))
            });
            if (a && "string" == typeof a) {
                b = a.split(la);
                for (c = 0, d = this.length; c < d; c++)if (e = this[c], 1 === e.nodeType)if (!e.className && 1 === b.length)e.className = a; else {
                    f = " " + e.className + " ";
                    for (g = 0, h = b.length; g <
                    h; g++)~f.indexOf(" " + b[g] + " ") || (f += b[g] + " ");
                    e.className = j.trim(f)
                }
            }
            return this
        }, removeClass: function (a) {
            var c, d, e, f, g, h, k;
            if (j.isFunction(a))return this.each(function (b) {
                j(this).removeClass(a.call(this, b, this.className))
            });
            if (a && "string" == typeof a || a === b) {
                c = (a || "").split(la);
                for (d = 0, e = this.length; d < e; d++)if (f = this[d], 1 === f.nodeType && f.className)if (a) {
                    g = (" " + f.className + " ").replace(va, " ");
                    for (h = 0, k = c.length; h < k; h++)g = g.replace(" " + c[h] + " ", " ");
                    f.className = j.trim(g)
                } else f.className = ""
            }
            return this
        },
        toggleClass: function (a, b) {
            var c = typeof a, d = "boolean" == typeof b;
            return j.isFunction(a) ? this.each(function (c) {
                j(this).toggleClass(a.call(this, c, this.className, b), b)
            }) : this.each(function () {
                if ("string" === c)for (var e, f = 0, g = j(this), h = b, k = a.split(la); e = k[f++];)h = d ? h : !g.hasClass(e), g[h ? "addClass" : "removeClass"](e); else if ("undefined" === c || "boolean" === c)this.className && j._data(this, "__className__", this.className), this.className = this.className || !1 === a ? "" : j._data(this, "__className__") || ""
            })
        }, hasClass: function (a) {
            for (var a =
                " " + a + " ", b = 0, c = this.length; b < c; b++)if (-1 < (" " + this[b].className + " ").replace(va, " ").indexOf(a))return !0;
            return !1
        }, val: function (a) {
            var c, d, e = this[0];
            if (!arguments.length) {
                if (e) {
                    if ((c = j.valHooks[e.nodeName.toLowerCase()] || j.valHooks[e.type]) && "get"in c && (d = c.get(e, "value")) !== b)return d;
                    d = e.value;
                    return "string" == typeof d ? d.replace(db, "") : null == d ? "" : d
                }
                return b
            }
            var f = j.isFunction(a);
            return this.each(function (d) {
                var e = j(this), g;
                if (1 === this.nodeType && (f ? g = a.call(this, d, e.val()) : g = a, null == g ? g = "" : "number" == typeof g ? g += "" : j.isArray(g) && (g = j.map(g, function (a) {
                        return null == a ? "" : a + ""
                    })), c = j.valHooks[this.nodeName.toLowerCase()] || j.valHooks[this.type], !c || !("set"in c) || c.set(this, g, "value") === b))this.value = g
            })
        }
    });
    j.extend({
        valHooks: {
            option: {
                get: function (a) {
                    var b = a.attributes.value;
                    return !b || b.specified ? a.value : a.text
                }
            }, select: {
                get: function (a) {
                    var b, c = a.selectedIndex, d = [], e = a.options, a = "select-one" === a.type;
                    if (0 > c)return null;
                    for (var f = a ? c : 0, g = a ? c + 1 : e.length; f < g; f++)if (b = e[f], b.selected && (j.support.optDisabled ?
                            !b.disabled : null === b.getAttribute("disabled")) && (!b.parentNode.disabled || !j.nodeName(b.parentNode, "optgroup"))) {
                        b = j(b).val();
                        if (a)return b;
                        d.push(b)
                    }
                    return a && !d.length && e.length ? j(e[c]).val() : d
                }, set: function (a, b) {
                    var c = j.makeArray(b);
                    j(a).find("option").each(function () {
                        this.selected = 0 <= j.inArray(j(this).val(), c)
                    });
                    c.length || (a.selectedIndex = -1);
                    return c
                }
            }
        },
        attrFn: {val: !0, css: !0, html: !0, text: !0, data: !0, width: !0, height: !0, offset: !0},
        attrFix: {tabindex: "tabIndex"},
        attr: function (a, c, d, e) {
            var f = a.nodeType;
            if (!a || 3 === f || 8 === f || 2 === f)return b;
            if (e && c in j.attrFn)return j(a)[c](d);
            if (!("getAttribute"in a))return j.prop(a, c, d);
            var g, h;
            (e = 1 !== f || !j.isXMLDoc(a)) && (c = j.attrFix[c] || c, h = j.attrHooks[c], h || (wa.test(c) ? h = xa : F && "className" !== c && (j.nodeName(a, "form") || hb.test(c)) && (h = F)));
            if (d !== b) {
                if (null === d)return j.removeAttr(a, c), b;
                if (h && "set"in h && e && (g = h.set(a, d, c)) !== b)return g;
                a.setAttribute(c, "" + d);
                return d
            }
            if (h && "get"in h && e && null !== (g = h.get(a, c)))return g;
            g = a.getAttribute(c);
            return null === g ? b : g
        },
        removeAttr: function (a,
                              b) {
            var c;
            1 === a.nodeType && (b = j.attrFix[b] || b, j.support.getSetAttribute ? a.removeAttribute(b) : (j.attr(a, b, ""), a.removeAttributeNode(a.getAttributeNode(b))), wa.test(b) && (c = j.propFix[b] || b)in a && (a[c] = !1))
        },
        attrHooks: {
            type: {
                set: function (a, b) {
                    if (eb.test(a.nodeName) && a.parentNode)j.error("type property can't be changed"); else if (!j.support.radioValue && "radio" === b && j.nodeName(a, "input")) {
                        var c = a.value;
                        a.setAttribute("type", b);
                        c && (a.value = c);
                        return b
                    }
                }
            }, tabIndex: {
                get: function (a) {
                    var c = a.getAttributeNode("tabIndex");
                    return c && c.specified ? parseInt(c.value, 10) : fb.test(a.nodeName) || gb.test(a.nodeName) && a.href ? 0 : b
                }
            }, value: {
                get: function (a, b) {
                    return F && j.nodeName(a, "button") ? F.get(a, b) : b in a ? a.value : null
                }, set: function (a, b, c) {
                    if (F && j.nodeName(a, "button"))return F.set(a, b, c);
                    a.value = b
                }
            }
        },
        propFix: {
            tabindex: "tabIndex",
            readonly: "readOnly",
            "for": "htmlFor",
            "class": "className",
            maxlength: "maxLength",
            cellspacing: "cellSpacing",
            cellpadding: "cellPadding",
            rowspan: "rowSpan",
            colspan: "colSpan",
            usemap: "useMap",
            frameborder: "frameBorder",
            contenteditable: "contentEditable"
        },
        prop: function (a, c, d) {
            var e = a.nodeType;
            if (!a || 3 === e || 8 === e || 2 === e)return b;
            var f, g;
            (1 !== e || !j.isXMLDoc(a)) && (c = j.propFix[c] || c, g = j.propHooks[c]);
            return d !== b ? g && "set"in g && (f = g.set(a, d, c)) !== b ? f : a[c] = d : g && "get"in g && (f = g.get(a, c)) !== b ? f : a[c]
        },
        propHooks: {}
    });
    xa = {
        get: function (a, c) {
            return j.prop(a, c) ? c.toLowerCase() : b
        }, set: function (a, b, c) {
            var d;
            !1 === b ? j.removeAttr(a, c) : (d = j.propFix[c] || c, d in a && (a[d] = !0), a.setAttribute(c, c.toLowerCase()));
            return c
        }
    };
    j.support.getSetAttribute ||
    (j.attrFix = j.propFix, F = j.attrHooks.name = j.attrHooks.title = j.valHooks.button = {
        get: function (a, c) {
            var d;
            return (d = a.getAttributeNode(c)) && "" !== d.nodeValue ? d.nodeValue : b
        }, set: function (a, b, c) {
            if (a = a.getAttributeNode(c))return a.nodeValue = b
        }
    }, j.each(["width", "height"], function (a, b) {
        j.attrHooks[b] = j.extend(j.attrHooks[b], {
            set: function (a, c) {
                if ("" === c)return a.setAttribute(b, "auto"), c
            }
        })
    }));
    j.support.hrefNormalized || j.each(["href", "src", "width", "height"], function (a, c) {
        j.attrHooks[c] = j.extend(j.attrHooks[c],
            {
                get: function (a) {
                    a = a.getAttribute(c, 2);
                    return null === a ? b : a
                }
            })
    });
    j.support.style || (j.attrHooks.style = {
        get: function (a) {
            return a.style.cssText.toLowerCase() || b
        }, set: function (a, b) {
            return a.style.cssText = "" + b
        }
    });
    j.support.optSelected || (j.propHooks.selected = j.extend(j.propHooks.selected, {
        get: function (a) {
            a = a.parentNode;
            a && (a.selectedIndex, a.parentNode && a.parentNode.selectedIndex)
        }
    }));
    j.support.checkOn || j.each(["radio", "checkbox"], function () {
        j.valHooks[this] = {
            get: function (a) {
                return null === a.getAttribute("value") ?
                    "on" : a.value
            }
        }
    });
    j.each(["radio", "checkbox"], function () {
        j.valHooks[this] = j.extend(j.valHooks[this], {
            set: function (a, b) {
                if (j.isArray(b))return a.checked = 0 <= j.inArray(j(a).val(), b)
            }
        })
    });
    var ha = /\.(.*)$/, ma = /^(?:textarea|input|select)$/i, Va = /\./g, Wa = / /g, ib = /[^\w\s.|`]/g, jb = function (a) {
        return a.replace(ib, "\\$&")
    };
    j.event = {
        add: function (a, c, d, e) {
            if (3 !== a.nodeType && 8 !== a.nodeType) {
                if (!1 === d)d = J; else if (!d)return;
                var f, g;
                d.handler && (f = d, d = f.handler);
                d.guid || (d.guid = j.guid++);
                var h = j._data(a);
                if (h) {
                    var k =
                        h.events, l = h.handle;
                    k || (h.events = k = {});
                    l || (h.handle = l = function (a) {
                        return "undefined" != typeof j && (!a || j.event.triggered !== a.type) ? j.event.handle.apply(l.elem, arguments) : b
                    });
                    l.elem = a;
                    c = c.split(" ");
                    for (var m = 0, n; h = c[m++];) {
                        g = f ? j.extend({}, f) : {handler: d, data: e};
                        -1 < h.indexOf(".") ? (n = h.split("."), h = n.shift(), g.namespace = n.slice(0).sort().join(".")) : (n = [], g.namespace = "");
                        g.type = h;
                        g.guid || (g.guid = d.guid);
                        var o = k[h], p = j.event.special[h] || {};
                        if (!o && (o = k[h] = [], !p.setup || !1 === p.setup.call(a, e, n, l)))a.addEventListener ?
                            a.addEventListener(h, l, !1) : a.attachEvent && a.attachEvent("on" + h, l);
                        p.add && (p.add.call(a, g), g.handler.guid || (g.handler.guid = d.guid));
                        o.push(g);
                        j.event.global[h] = !0
                    }
                    a = null
                }
            }
        },
        global: {},
        remove: function (a, c, d, e) {
            if (3 !== a.nodeType && 8 !== a.nodeType) {
                !1 === d && (d = J);
                var f, g, h = 0, k, l, m, n, o, p, q = j.hasData(a) && j._data(a), t = q && q.events;
                if (q && t)if (c && c.type && (d = c.handler, c = c.type), !c || "string" == typeof c && "." === c.charAt(0))for (f in c = c || "", t)j.event.remove(a, f + c); else {
                    for (c = c.split(" "); f = c[h++];)if (n = f, k = 0 > f.indexOf("."),
                            l = [], k || (l = f.split("."), f = l.shift(), m = RegExp("(^|\\.)" + j.map(l.slice(0).sort(), jb).join("\\.(?:.*\\.)?") + "(\\.|$)")), o = t[f], o)if (d) {
                        n = j.event.special[f] || {};
                        for (g = e || 0; g < o.length; g++)if (p = o[g], d.guid === p.guid) {
                            if (k || m.test(p.namespace))null == e && o.splice(g--, 1), n.remove && n.remove.call(a, p);
                            if (null != e)break
                        }
                        if (0 === o.length || null != e && 1 === o.length)(!n.teardown || !1 === n.teardown.call(a, l)) && j.removeEvent(a, f, q.handle), delete t[f]
                    } else for (g = 0; g < o.length; g++)if (p = o[g], k || m.test(p.namespace))j.event.remove(a,
                        n, p.handler, g), o.splice(g--, 1);
                    j.isEmptyObject(t) && (c = q.handle, c && (c.elem = null), delete q.events, delete q.handle, j.isEmptyObject(q) && j.removeData(a, b, !0))
                }
            }
        },
        customEvent: {getData: !0, setData: !0, changeData: !0},
        trigger: function (c, d, e, f) {
            var g = c.type || c, h = [], k;
            0 <= g.indexOf("!") && (g = g.slice(0, -1), k = !0);
            0 <= g.indexOf(".") && (h = g.split("."), g = h.shift(), h.sort());
            if (e && !j.event.customEvent[g] || j.event.global[g]) {
                c = "object" == typeof c ? c[j.expando] ? c : new j.Event(g, c) : new j.Event(g);
                c.type = g;
                c.exclusive = k;
                c.namespace =
                    h.join(".");
                c.namespace_re = RegExp("(^|\\.)" + h.join("\\.(?:.*\\.)?") + "(\\.|$)");
                if (f || !e)c.preventDefault(), c.stopPropagation();
                if (e) {
                    if (!(3 === e.nodeType || 8 === e.nodeType)) {
                        c.result = b;
                        c.target = e;
                        d = null != d ? j.makeArray(d) : [];
                        d.unshift(c);
                        h = e;
                        f = 0 > g.indexOf(":") ? "on" + g : "";
                        do k = j._data(h, "handle"), c.currentTarget = h, k && k.apply(h, d), f && j.acceptData(h) && h[f] && !1 === h[f].apply(h, d) && (c.result = !1, c.preventDefault()), h = h.parentNode || h.ownerDocument || h === c.target.ownerDocument && a; while (h && !c.isPropagationStopped());
                        if (!c.isDefaultPrevented()) {
                            var l, h = j.event.special[g] || {};
                            if ((!h._default || !1 === h._default.call(e.ownerDocument, c)) && ("click" !== g || !j.nodeName(e, "a")) && j.acceptData(e)) {
                                try {
                                    f && e[g] && (l = e[f], l && (e[f] = null), j.event.triggered = g, e[g]())
                                } catch (m) {
                                }
                                l && (e[f] = l);
                                j.event.triggered = b
                            }
                        }
                        return c.result
                    }
                } else j.each(j.cache, function () {
                    var a = this[j.expando];
                    a && a.events && a.events[g] && j.event.trigger(c, d, a.handle.elem)
                })
            }
        },
        handle: function (c) {
            var c = j.event.fix(c || a.event), d = ((j._data(this, "events") || {})[c.type] ||
            []).slice(0), e = !c.exclusive && !c.namespace, f = Array.prototype.slice.call(arguments, 0);
            f[0] = c;
            c.currentTarget = this;
            for (var g = 0, h = d.length; g < h; g++) {
                var k = d[g];
                if (e || c.namespace_re.test(k.namespace))if (c.handler = k.handler, c.data = k.data, c.handleObj = k, k = k.handler.apply(this, f), k !== b && (c.result = k, !1 === k && (c.preventDefault(), c.stopPropagation())), c.isImmediatePropagationStopped())break
            }
            return c.result
        },
        props: "altKey,attrChange,attrName,bubbles,button,cancelable,charCode,clientX,clientY,ctrlKey,currentTarget,data,detail,eventPhase,fromElement,handler,keyCode,layerX,layerY,metaKey,newValue,offsetX,offsetY,pageX,pageY,prevValue,relatedNode,relatedTarget,screenX,screenY,shiftKey,srcElement,target,toElement,view,wheelDelta,which".split(","),
        fix: function (a) {
            if (a[j.expando])return a;
            for (var c = a, a = j.Event(c), d = this.props.length, e; d;)e = this.props[--d], a[e] = c[e];
            a.target || (a.target = a.srcElement || s);
            3 === a.target.nodeType && (a.target = a.target.parentNode);
            !a.relatedTarget && a.fromElement && (a.relatedTarget = a.fromElement === a.target ? a.toElement : a.fromElement);
            null == a.pageX && null != a.clientX && (d = a.target.ownerDocument || s, c = d.documentElement, d = d.body, a.pageX = a.clientX + (c && c.scrollLeft || d && d.scrollLeft || 0) - (c && c.clientLeft || d && d.clientLeft || 0), a.pageY =
                a.clientY + (c && c.scrollTop || d && d.scrollTop || 0) - (c && c.clientTop || d && d.clientTop || 0));
            null == a.which && (null != a.charCode || null != a.keyCode) && (a.which = null != a.charCode ? a.charCode : a.keyCode);
            !a.metaKey && a.ctrlKey && (a.metaKey = a.ctrlKey);
            !a.which && a.button !== b && (a.which = a.button & 1 ? 1 : a.button & 2 ? 3 : a.button & 4 ? 2 : 0);
            return a
        },
        guid: 1E8,
        proxy: j.proxy,
        special: {
            ready: {setup: j.bindReady, teardown: j.noop}, live: {
                add: function (a) {
                    j.event.add(this, w(a.origType, a.selector), j.extend({}, a, {handler: A, guid: a.handler.guid}))
                }, remove: function (a) {
                    j.event.remove(this,
                        w(a.origType, a.selector), a)
                }
            }, beforeunload: {
                setup: function (a, b, c) {
                    j.isWindow(this) && (this.onbeforeunload = c)
                }, teardown: function (a, b) {
                    this.onbeforeunload === b && (this.onbeforeunload = null)
                }
            }
        }
    };
    j.removeEvent = s.removeEventListener ? function (a, b, c) {
        a.removeEventListener && a.removeEventListener(b, c, !1)
    } : function (a, b, c) {
        a.detachEvent && a.detachEvent("on" + b, c)
    };
    j.Event = function (a, b) {
        if (!this.preventDefault)return new j.Event(a, b);
        a && a.type ? (this.originalEvent = a, this.type = a.type, this.isDefaultPrevented = a.defaultPrevented ||
        !1 === a.returnValue || a.getPreventDefault && a.getPreventDefault() ? K : J) : this.type = a;
        b && j.extend(this, b);
        this.timeStamp = j.now();
        this[j.expando] = !0
    };
    j.Event.prototype = {
        preventDefault: function () {
            this.isDefaultPrevented = K;
            var a = this.originalEvent;
            !a || (a.preventDefault ? a.preventDefault() : a.returnValue = !1)
        }, stopPropagation: function () {
            this.isPropagationStopped = K;
            var a = this.originalEvent;
            !a || (a.stopPropagation && a.stopPropagation(), a.cancelBubble = !0)
        }, stopImmediatePropagation: function () {
            this.isImmediatePropagationStopped =
                K;
            this.stopPropagation()
        }, isDefaultPrevented: J, isPropagationStopped: J, isImmediatePropagationStopped: J
    };
    var ya = function (a) {
        var b = a.relatedTarget, c = !1, d = a.type;
        a.type = a.data;
        b !== this && (b && (c = j.contains(this, b)), c || (j.event.handle.apply(this, arguments), a.type = d))
    }, za = function (a) {
        a.type = a.data;
        j.event.handle.apply(this, arguments)
    };
    j.each({mouseenter: "mouseover", mouseleave: "mouseout"}, function (a, b) {
        j.event.special[a] = {
            setup: function (c) {
                j.event.add(this, b, c && c.selector ? za : ya, a)
            }, teardown: function (a) {
                j.event.remove(this,
                    b, a && a.selector ? za : ya)
            }
        }
    });
    j.support.submitBubbles || (j.event.special.submit = {
        setup: function () {
            if (j.nodeName(this, "form"))return !1;
            j.event.add(this, "click.specialSubmit", function (a) {
                var b = a.target, c = b.type;
                ("submit" === c || "image" === c) && j(b).closest("form").length && L("submit", this, arguments)
            });
            j.event.add(this, "keypress.specialSubmit", function (a) {
                var b = a.target, c = b.type;
                ("text" === c || "password" === c) && j(b).closest("form").length && 13 === a.keyCode && L("submit", this, arguments)
            })
        }, teardown: function () {
            j.event.remove(this,
                ".specialSubmit")
        }
    });
    if (!j.support.changeBubbles) {
        var W, Aa = function (a) {
            var b = a.type, c = a.value;
            "radio" === b || "checkbox" === b ? c = a.checked : "select-multiple" === b ? c = -1 < a.selectedIndex ? j.map(a.options, function (a) {
                return a.selected
            }).join("-") : "" : j.nodeName(a, "select") && (c = a.selectedIndex);
            return c
        }, da = function (a, c) {
            var d = a.target, e, f;
            if (ma.test(d.nodeName) && !d.readOnly && (e = j._data(d, "_change_data"), f = Aa(d), ("focusout" !== a.type || "radio" !== d.type) && j._data(d, "_change_data", f), !(e === b || f === e)))if (null != e || f)a.type =
                "change", a.liveFired = b, j.event.trigger(a, c, d)
        };
        j.event.special.change = {
            filters: {
                focusout: da, beforedeactivate: da, click: function (a) {
                    var b = a.target, c = j.nodeName(b, "input") ? b.type : "";
                    ("radio" === c || "checkbox" === c || j.nodeName(b, "select")) && da.call(this, a)
                }, keydown: function (a) {
                    var b = a.target, c = j.nodeName(b, "input") ? b.type : "";
                    (13 === a.keyCode && !j.nodeName(b, "textarea") || 32 === a.keyCode && ("checkbox" === c || "radio" === c) || "select-multiple" === c) && da.call(this, a)
                }, beforeactivate: function (a) {
                    a = a.target;
                    j._data(a, "_change_data",
                        Aa(a))
                }
            }, setup: function () {
                if ("file" === this.type)return !1;
                for (var a in W)j.event.add(this, a + ".specialChange", W[a]);
                return ma.test(this.nodeName)
            }, teardown: function () {
                j.event.remove(this, ".specialChange");
                return ma.test(this.nodeName)
            }
        };
        W = j.event.special.change.filters;
        W.focus = W.beforeactivate
    }
    j.support.focusinBubbles || j.each({focus: "focusin", blur: "focusout"}, function (a, b) {
        function c(a) {
            var d = j.event.fix(a);
            d.type = b;
            d.originalEvent = {};
            j.event.trigger(d, null, d.target);
            d.isDefaultPrevented() && a.preventDefault()
        }

        var d = 0;
        j.event.special[b] = {
            setup: function () {
                0 === d++ && s.addEventListener(a, c, !0)
            }, teardown: function () {
                0 === --d && s.removeEventListener(a, c, !0)
            }
        }
    });
    j.each(["bind", "one"], function (a, c) {
        j.fn[c] = function (a, d, e) {
            var f;
            if ("object" == typeof a) {
                for (var g in a)this[c](g, d, a[g], e);
                return this
            }
            if (2 === arguments.length || !1 === d)e = d, d = b;
            "one" === c ? (f = function (a) {
                j(this).unbind(a, f);
                return e.apply(this, arguments)
            }, f.guid = e.guid || j.guid++) : f = e;
            if ("unload" === a && "one" !== c)this.one(a, d, e); else {
                g = 0;
                for (var h = this.length; g <
                h; g++)j.event.add(this[g], a, f, d)
            }
            return this
        }
    });
    j.fn.extend({
        unbind: function (a, b) {
            if ("object" == typeof a && !a.preventDefault)for (var c in a)this.unbind(c, a[c]); else {
                c = 0;
                for (var d = this.length; c < d; c++)j.event.remove(this[c], a, b)
            }
            return this
        }, delegate: function (a, b, c, d) {
            return this.live(b, c, d, a)
        }, undelegate: function (a, b, c) {
            return 0 === arguments.length ? this.unbind("live") : this.die(b, null, c, a)
        }, trigger: function (a, b) {
            return this.each(function () {
                j.event.trigger(a, b, this)
            })
        }, triggerHandler: function (a, b) {
            if (this[0])return j.event.trigger(a,
                b, this[0], !0)
        }, toggle: function (a) {
            var b = arguments, c = a.guid || j.guid++, d = 0, e = function (c) {
                var e = (j.data(this, "lastToggle" + a.guid) || 0) % d;
                j.data(this, "lastToggle" + a.guid, e + 1);
                c.preventDefault();
                return b[e].apply(this, arguments) || !1
            };
            for (e.guid = c; d < b.length;)b[d++].guid = c;
            return this.click(e)
        }, hover: function (a, b) {
            return this.mouseenter(a).mouseleave(b || a)
        }
    });
    var na = {focus: "focusin", blur: "focusout", mouseenter: "mouseover", mouseleave: "mouseout"};
    j.each(["live", "die"], function (a, c) {
        j.fn[c] = function (a, d, e, f) {
            var g =
                0, h, k, v, l = f || this.selector, m = f ? this : j(this.context);
            if ("object" == typeof a && !a.preventDefault) {
                for (v in a)m[c](v, d, a[v], l);
                return this
            }
            if ("die" === c && !a && f && "." === f.charAt(0))return m.unbind(f), this;
            if (!1 === d || j.isFunction(d))e = d || J, d = b;
            for (a = (a || "").split(" "); null != (f = a[g++]);)if (h = ha.exec(f), k = "", h && (k = h[0], f = f.replace(ha, "")), "hover" === f)a.push("mouseenter" + k, "mouseleave" + k); else if (v = f, na[f] ? (a.push(na[f] + k), f += k) : f = (na[f] || f) + k, "live" === c) {
                k = 0;
                for (var n = m.length; k < n; k++)j.event.add(m[k], "live." +
                w(f, l), {data: d, selector: l, handler: e, origType: f, origHandler: e, preType: v})
            } else m.unbind("live." + w(f, l), e);
            return this
        }
    });
    j.each("blur,focus,focusin,focusout,load,resize,scroll,unload,click,dblclick,mousedown,mouseup,mousemove,mouseover,mouseout,mouseenter,mouseleave,change,select,submit,keydown,keypress,keyup,error".split(","), function (a, b) {
        j.fn[b] = function (a, c) {
            null == c && (c = a, a = null);
            return 0 < arguments.length ? this.bind(b, a, c) : this.trigger(b)
        };
        j.attrFn && (j.attrFn[b] = !0)
    });
    (function () {
        function a(b, c,
                   d, e, f, g) {
            for (var f = 0, h = e.length; f < h; f++) {
                var j = e[f];
                if (j) {
                    for (var k = !1, j = j[b]; j;) {
                        if (j.sizcache === d) {
                            k = e[j.sizset];
                            break
                        }
                        if (1 === j.nodeType)if (g || (j.sizcache = d, j.sizset = f), "string" != typeof c) {
                            if (j === c) {
                                k = !0;
                                break
                            }
                        } else if (0 < m.filter(c, [j]).length) {
                            k = j;
                            break
                        }
                        j = j[b]
                    }
                    e[f] = k
                }
            }
        }

        function c(a, b, d, e, f, g) {
            for (var f = 0, h = e.length; f < h; f++) {
                var j = e[f];
                if (j) {
                    for (var k = !1, j = j[a]; j;) {
                        if (j.sizcache === d) {
                            k = e[j.sizset];
                            break
                        }
                        1 === j.nodeType && !g && (j.sizcache = d, j.sizset = f);
                        if (j.nodeName.toLowerCase() === b) {
                            k = j;
                            break
                        }
                        j = j[a]
                    }
                    e[f] =
                        k
                }
            }
        }

        var d = /((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['"][^'"]*['"]|[^\[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g, e = 0, f = Object.prototype.toString, g = !1, h = !0, k = /\\/g, l = /\W/;
        [0, 0].sort(function () {
            h = !1;
            return 0
        });
        var m = function (a, b, c, e) {
            c = c || [];
            b = b || s;
            var g = b;
            if (1 !== b.nodeType && 9 !== b.nodeType)return [];
            if (!a || "string" != typeof a)return c;
            var h, j, k, v, l, D, I, p = !0, Y = m.isXML(b), q = [], sa = a;
            do if (d.exec(""), h = d.exec(sa), h && (sa = h[3], q.push(h[1]), h[2])) {
                v = h[3];
                break
            } while (h);
            if (1 < q.length &&
                o.exec(a))if (2 === q.length && n.relative[q[0]])j = y(q[0] + q[1], b); else for (j = n.relative[q[0]] ? [b] : m(q.shift(), b); q.length;)a = q.shift(), n.relative[a] && (a += q.shift()), j = y(a, j); else if (!e && 1 < q.length && 9 === b.nodeType && !Y && n.match.ID.test(q[0]) && !n.match.ID.test(q[q.length - 1]) && (l = m.find(q.shift(), b, Y), b = l.expr ? m.filter(l.expr, l.set)[0] : l.set[0]), b)for (l = e ? {
                expr: q.pop(),
                set: t(e)
            } : m.find(q.pop(), 1 === q.length && ("~" === q[0] || "+" === q[0]) && b.parentNode ? b.parentNode : b, Y), j = l.expr ? m.filter(l.expr, l.set) : l.set, 0 < q.length ?
                k = t(j) : p = !1; q.length;)D = q.pop(), I = D, n.relative[D] ? I = q.pop() : D = "", null == I && (I = b), n.relative[D](k, I, Y); else k = [];
            k || (k = j);
            k || m.error(D || a);
            if ("[object Array]" === f.call(k))if (p)if (b && 1 === b.nodeType)for (a = 0; null != k[a]; a++)k[a] && (!0 === k[a] || 1 === k[a].nodeType && m.contains(b, k[a])) && c.push(j[a]); else for (a = 0; null != k[a]; a++)k[a] && 1 === k[a].nodeType && c.push(j[a]); else c.push.apply(c, k); else t(k, c);
            v && (m(v, g, c, e), m.uniqueSort(c));
            return c
        };
        m.uniqueSort = function (a) {
            if (u && (g = h, a.sort(u), g))for (var b = 1; b < a.length; b++)a[b] ===
            a[b - 1] && a.splice(b--, 1);
            return a
        };
        m.matches = function (a, b) {
            return m(a, null, null, b)
        };
        m.matchesSelector = function (a, b) {
            return 0 < m(b, null, null, [a]).length
        };
        m.find = function (a, b, c) {
            var d;
            if (!a)return [];
            for (var e = 0, f = n.order.length; e < f; e++) {
                var g, h = n.order[e];
                if (g = n.leftMatch[h].exec(a)) {
                    var j = g[1];
                    g.splice(1, 1);
                    if ("\\" !== j.substr(j.length - 1) && (g[1] = (g[1] || "").replace(k, ""), d = n.find[h](g, b, c), null != d)) {
                        a = a.replace(n.match[h], "");
                        break
                    }
                }
            }
            d || (d = "undefined" != typeof b.getElementsByTagName ? b.getElementsByTagName("*") :
                []);
            return {set: d, expr: a}
        };
        m.filter = function (a, c, d, e) {
            for (var f, g, h = a, j = [], k = c, v = c && c[0] && m.isXML(c[0]); a && c.length;) {
                for (var l in n.filter)if (null != (f = n.leftMatch[l].exec(a)) && f[2]) {
                    var D, I, C = n.filter[l];
                    I = f[1];
                    g = !1;
                    f.splice(1, 1);
                    if ("\\" !== I.substr(I.length - 1)) {
                        k === j && (j = []);
                        if (n.preFilter[l])if (f = n.preFilter[l](f, k, d, j, e, v)) {
                            if (!0 === f)continue
                        } else g = D = !0;
                        if (f)for (var Z = 0; null != (I = k[Z]); Z++)if (I) {
                            D = C(I, f, Z, k);
                            var o = e ^ !!D;
                            d && null != D ? o ? g = !0 : k[Z] = !1 : o && (j.push(I), g = !0)
                        }
                        if (D !== b) {
                            d || (k = j);
                            a = a.replace(n.match[l],
                                "");
                            if (!g)return [];
                            break
                        }
                    }
                }
                if (a === h)if (null == g)m.error(a); else break;
                h = a
            }
            return k
        };
        m.error = function (a) {
            throw"Syntax error, unrecognized expression: " + a;
        };
        var n = m.selectors = {
            order: ["ID", "NAME", "TAG"], match: {
                ID: /#((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
                CLASS: /\.((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
                NAME: /\[name=['"]*((?:[\w\u00c0-\uFFFF\-]|\\.)+)['"]*\]/,
                ATTR: /\[\s*((?:[\w\u00c0-\uFFFF\-]|\\.)+)\s*(?:(\S?=)\s*(?:(['"])(.*?)\3|(#?(?:[\w\u00c0-\uFFFF\-]|\\.)*)|)|)\s*\]/,
                TAG: /^((?:[\w\u00c0-\uFFFF\*\-]|\\.)+)/,
                CHILD: /:(only|nth|last|first)-child(?:\(\s*(even|odd|(?:[+\-]?\d+|(?:[+\-]?\d*)?n\s*(?:[+\-]\s*\d+)?))\s*\))?/,
                POS: /:(nth|eq|gt|lt|first|last|even|odd)(?:\((\d*)\))?(?=[^\-]|$)/,
                PSEUDO: /:((?:[\w\u00c0-\uFFFF\-]|\\.)+)(?:\((['"]?)((?:\([^\)]+\)|[^\(\)]*)+)\2\))?/
            }, leftMatch: {}, attrMap: {"class": "className", "for": "htmlFor"}, attrHandle: {
                href: function (a) {
                    return a.getAttribute("href")
                }, type: function (a) {
                    return a.getAttribute("type")
                }
            }, relative: {
                "+": function (a, b) {
                    var c = "string" == typeof b, d = c && !l.test(b), c = c && !d;
                    d && (b = b.toLowerCase());
                    for (var d = 0, e = a.length, f; d < e; d++)if (f = a[d]) {
                        for (; (f = f.previousSibling) && 1 !== f.nodeType;);
                        a[d] = c || f && f.nodeName.toLowerCase() === b ? f || !1 : f === b
                    }
                    c && m.filter(b, a, !0)
                }, ">": function (a, b) {
                    var c, d = "string" == typeof b, e = 0, f = a.length;
                    if (d && !l.test(b))for (b = b.toLowerCase(); e < f; e++) {
                        if (c = a[e])c = c.parentNode, a[e] = c.nodeName.toLowerCase() === b ? c : !1
                    } else {
                        for (; e < f; e++)c = a[e], c && (a[e] = d ? c.parentNode : c.parentNode === b);
                        d && m.filter(b, a, !0)
                    }
                }, "": function (b, d, f) {
                    var g, h = e++, j = a;
                    "string" == typeof d && !l.test(d) && (d = d.toLowerCase(), g = d, j = c);
                    j("parentNode", d, h, b, g, f)
                }, "~": function (b, d, f) {
                    var g, h = e++, j = a;
                    "string" == typeof d && !l.test(d) && (d = d.toLowerCase(), g = d, j = c);
                    j("previousSibling", d, h, b, g, f)
                }
            }, find: {
                ID: function (a, b, c) {
                    if ("undefined" != typeof b.getElementById && !c)return (a = b.getElementById(a[1])) && a.parentNode ? [a] : []
                }, NAME: function (a, b) {
                    if ("undefined" != typeof b.getElementsByName) {
                        for (var c = [], d = b.getElementsByName(a[1]), e = 0, f = d.length; e < f; e++)d[e].getAttribute("name") === a[1] && c.push(d[e]);
                        return 0 === c.length ? null : c
                    }
                }, TAG: function (a, b) {
                    if ("undefined" != typeof b.getElementsByTagName)return b.getElementsByTagName(a[1])
                }
            },
            preFilter: {
                CLASS: function (a, b, c, d, e, f) {
                    a = " " + a[1].replace(k, "") + " ";
                    if (f)return a;
                    for (var f = 0, g; null != (g = b[f]); f++)g && (e ^ (g.className && 0 <= (" " + g.className + " ").replace(/[\t\n\r]/g, " ").indexOf(a)) ? c || d.push(g) : c && (b[f] = !1));
                    return !1
                }, ID: function (a) {
                    return a[1].replace(k, "")
                }, TAG: function (a) {
                    return a[1].replace(k, "").toLowerCase()
                }, CHILD: function (a) {
                    if ("nth" === a[1]) {
                        a[2] || m.error(a[0]);
                        a[2] = a[2].replace(/^\+|\s*/g, "");
                        var b = /(-?)(\d*)(?:n([+\-]?\d*))?/.exec("even" === a[2] && "2n" || "odd" === a[2] && "2n+1" ||
                        !/\D/.test(a[2]) && "0n+" + a[2] || a[2]);
                        a[2] = b[1] + (b[2] || 1) - 0;
                        a[3] = b[3] - 0
                    } else a[2] && m.error(a[0]);
                    a[0] = e++;
                    return a
                }, ATTR: function (a, b, c, d, e, f) {
                    b = a[1] = a[1].replace(k, "");
                    !f && n.attrMap[b] && (a[1] = n.attrMap[b]);
                    a[4] = (a[4] || a[5] || "").replace(k, "");
                    "~=" === a[2] && (a[4] = " " + a[4] + " ");
                    return a
                }, PSEUDO: function (a, b, c, e, f) {
                    if ("not" === a[1])if (1 < (d.exec(a[3]) || "").length || /^\w/.test(a[3]))a[3] = m(a[3], null, null, b); else return a = m.filter(a[3], b, c, 1 ^ f), c || e.push.apply(e, a), !1; else if (n.match.POS.test(a[0]) || n.match.CHILD.test(a[0]))return !0;
                    return a
                }, POS: function (a) {
                    a.unshift(!0);
                    return a
                }
            }, filters: {
                enabled: function (a) {
                    return !1 === a.disabled && "hidden" !== a.type
                }, disabled: function (a) {
                    return !0 === a.disabled
                }, checked: function (a) {
                    return !0 === a.checked
                }, selected: function (a) {
                    a.parentNode && a.parentNode.selectedIndex;
                    return !0 === a.selected
                }, parent: function (a) {
                    return !!a.firstChild
                }, empty: function (a) {
                    return !a.firstChild
                }, has: function (a, b, c) {
                    return !!m(c[3], a).length
                }, header: function (a) {
                    return /h\d/i.test(a.nodeName)
                }, text: function (a) {
                    var b = a.getAttribute("type"),
                        c = a.type;
                    return "input" === a.nodeName.toLowerCase() && "text" === c && (b === c || null === b)
                }, radio: function (a) {
                    return "input" === a.nodeName.toLowerCase() && "radio" === a.type
                }, checkbox: function (a) {
                    return "input" === a.nodeName.toLowerCase() && "checkbox" === a.type
                }, file: function (a) {
                    return "input" === a.nodeName.toLowerCase() && "file" === a.type
                }, password: function (a) {
                    return "input" === a.nodeName.toLowerCase() && "password" === a.type
                }, submit: function (a) {
                    var b = a.nodeName.toLowerCase();
                    return ("input" === b || "button" === b) && "submit" === a.type
                },
                image: function (a) {
                    return "input" === a.nodeName.toLowerCase() && "image" === a.type
                }, reset: function (a) {
                    var b = a.nodeName.toLowerCase();
                    return ("input" === b || "button" === b) && "reset" === a.type
                }, button: function (a) {
                    var b = a.nodeName.toLowerCase();
                    return "input" === b && "button" === a.type || "button" === b
                }, input: function (a) {
                    return /input|select|textarea|button/i.test(a.nodeName)
                }, focus: function (a) {
                    return a === a.ownerDocument.activeElement
                }
            }, setFilters: {
                first: function (a, b) {
                    return 0 === b
                }, last: function (a, b, c, d) {
                    return b === d.length -
                        1
                }, even: function (a, b) {
                    return 0 === b % 2
                }, odd: function (a, b) {
                    return 1 === b % 2
                }, lt: function (a, b, c) {
                    return b < c[3] - 0
                }, gt: function (a, b, c) {
                    return b > c[3] - 0
                }, nth: function (a, b, c) {
                    return c[3] - 0 === b
                }, eq: function (a, b, c) {
                    return c[3] - 0 === b
                }
            }, filter: {
                PSEUDO: function (a, b, c, d) {
                    var e = b[1], f = n.filters[e];
                    if (f)return f(a, c, b, d);
                    if ("contains" === e)return 0 <= (a.textContent || a.innerText || m.getText([a]) || "").indexOf(b[3]);
                    if ("not" === e) {
                        b = b[3];
                        c = 0;
                        for (d = b.length; c < d; c++)if (b[c] === a)return !1;
                        return !0
                    }
                    m.error(e)
                }, CHILD: function (a,
                                    b) {
                    var c = b[1], d = a;
                    switch (c) {
                        case "only":
                        case "first":
                            for (; d = d.previousSibling;)if (1 === d.nodeType)return !1;
                            if ("first" === c)return !0;
                            d = a;
                        case "last":
                            for (; d = d.nextSibling;)if (1 === d.nodeType)return !1;
                            return !0;
                        case "nth":
                            var c = b[2], e = b[3];
                            if (1 === c && 0 === e)return !0;
                            var f = b[0], g = a.parentNode;
                            if (g && (g.sizcache !== f || !a.nodeIndex)) {
                                for (var h = 0, d = g.firstChild; d; d = d.nextSibling)1 === d.nodeType && (d.nodeIndex = ++h);
                                g.sizcache = f
                            }
                            d = a.nodeIndex - e;
                            return 0 === c ? 0 === d : 0 === d % c && 0 <= d / c
                    }
                }, ID: function (a, b) {
                    return 1 === a.nodeType &&
                        a.getAttribute("id") === b
                }, TAG: function (a, b) {
                    return "*" === b && 1 === a.nodeType || a.nodeName.toLowerCase() === b
                }, CLASS: function (a, b) {
                    return -1 < (" " + (a.className || a.getAttribute("class")) + " ").indexOf(b)
                }, ATTR: function (a, b) {
                    var c = b[1], c = n.attrHandle[c] ? n.attrHandle[c](a) : null != a[c] ? a[c] : a.getAttribute(c), d = c + "", e = b[2], f = b[4];
                    return null == c ? "!=" === e : "=" === e ? d === f : "*=" === e ? 0 <= d.indexOf(f) : "~=" === e ? 0 <= (" " + d + " ").indexOf(f) : f ? "!=" === e ? d !== f : "^=" === e ? 0 === d.indexOf(f) : "$=" === e ? d.substr(d.length - f.length) === f : "|=" ===
                    e ? d === f || d.substr(0, f.length + 1) === f + "-" : !1 : d && !1 !== c
                }, POS: function (a, b, c, d) {
                    var e = n.setFilters[b[2]];
                    if (e)return e(a, c, b, d)
                }
            }
        }, o = n.match.POS, p = function (a, b) {
            return "\\" + (b - 0 + 1)
        }, q;
        for (q in n.match)n.match[q] = RegExp(n.match[q].source + /(?![^\[]*\])(?![^\(]*\))/.source), n.leftMatch[q] = RegExp(/(^(?:.|\r|\n)*?)/.source + n.match[q].source.replace(/\\(\d+)/g, p));
        var t = function (a, b) {
            a = Array.prototype.slice.call(a, 0);
            return b ? (b.push.apply(b, a), b) : a
        };
        try {
            Array.prototype.slice.call(s.documentElement.childNodes,
                0)[0].nodeType
        } catch (r) {
            t = function (a, b) {
                var c = 0, d = b || [];
                if ("[object Array]" === f.call(a))Array.prototype.push.apply(d, a); else if ("number" == typeof a.length)for (var e = a.length; c < e; c++)d.push(a[c]); else for (; a[c]; c++)d.push(a[c]);
                return d
            }
        }
        var u, w;
        s.documentElement.compareDocumentPosition ? u = function (a, b) {
            return a === b ? (g = !0, 0) : !a.compareDocumentPosition || !b.compareDocumentPosition ? a.compareDocumentPosition ? -1 : 1 : a.compareDocumentPosition(b) & 4 ? -1 : 1
        } : (u = function (a, b) {
            if (a === b)return g = !0, 0;
            if (a.sourceIndex &&
                b.sourceIndex)return a.sourceIndex - b.sourceIndex;
            var c, d, e = [], f = [];
            c = a.parentNode;
            d = b.parentNode;
            var h = c;
            if (c === d)return w(a, b);
            if (!c)return -1;
            if (!d)return 1;
            for (; h;)e.unshift(h), h = h.parentNode;
            for (h = d; h;)f.unshift(h), h = h.parentNode;
            c = e.length;
            d = f.length;
            for (h = 0; h < c && h < d; h++)if (e[h] !== f[h])return w(e[h], f[h]);
            return h === c ? w(a, f[h], -1) : w(e[h], b, 1)
        }, w = function (a, b, c) {
            if (a === b)return c;
            for (a = a.nextSibling; a;) {
                if (a === b)return -1;
                a = a.nextSibling
            }
            return 1
        });
        m.getText = function (a) {
            for (var b = "", c, d = 0; a[d]; d++)c =
                a[d], 3 === c.nodeType || 4 === c.nodeType ? b += c.nodeValue : 8 !== c.nodeType && (b += m.getText(c.childNodes));
            return b
        };
        (function () {
            var a = s.createElement("div"), c = "script" + (new Date).getTime(), d = s.documentElement;
            a.innerHTML = "<a name='" + c + "'/>";
            d.insertBefore(a, d.firstChild);
            s.getElementById(c) && (n.find.ID = function (a, c, d) {
                if ("undefined" != typeof c.getElementById && !d)return (c = c.getElementById(a[1])) ? c.id === a[1] || "undefined" != typeof c.getAttributeNode && c.getAttributeNode("id").nodeValue === a[1] ? [c] : b : []
            }, n.filter.ID =
                function (a, b) {
                    var c = "undefined" != typeof a.getAttributeNode && a.getAttributeNode("id");
                    return 1 === a.nodeType && c && c.nodeValue === b
                });
            d.removeChild(a);
            d = a = null
        })();
        (function () {
            var a = s.createElement("div");
            a.appendChild(s.createComment(""));
            0 < a.getElementsByTagName("*").length && (n.find.TAG = function (a, b) {
                var c = b.getElementsByTagName(a[1]);
                if ("*" === a[1]) {
                    for (var d = [], e = 0; c[e]; e++)1 === c[e].nodeType && d.push(c[e]);
                    c = d
                }
                return c
            });
            a.innerHTML = "<a href='#'></a>";
            a.firstChild && "undefined" != typeof a.firstChild.getAttribute &&
            "#" !== a.firstChild.getAttribute("href") && (n.attrHandle.href = function (a) {
                return a.getAttribute("href", 2)
            });
            a = null
        })();
        s.querySelectorAll && function () {
            var a = m, b = s.createElement("div");
            b.innerHTML = "<p class='TEST'></p>";
            if (!b.querySelectorAll || 0 !== b.querySelectorAll(".TEST").length) {
                m = function (b, c, d, e) {
                    c = c || s;
                    if (!e && !m.isXML(c)) {
                        var f = /^(\w+$)|^\.([\w\-]+$)|^#([\w\-]+$)/.exec(b);
                        if (f && (1 === c.nodeType || 9 === c.nodeType)) {
                            if (f[1])return t(c.getElementsByTagName(b), d);
                            if (f[2] && n.find.CLASS && c.getElementsByClassName)return t(c.getElementsByClassName(f[2]),
                                d)
                        }
                        if (9 === c.nodeType) {
                            if ("body" === b && c.body)return t([c.body], d);
                            if (f && f[3]) {
                                var g = c.getElementById(f[3]);
                                if (!g || !g.parentNode)return t([], d);
                                if (g.id === f[3])return t([g], d)
                            }
                            try {
                                return t(c.querySelectorAll(b), d)
                            } catch (h) {
                            }
                        } else if (1 === c.nodeType && "object" !== c.nodeName.toLowerCase()) {
                            var f = c, j = (g = c.getAttribute("id")) || "__sizzle__", k = c.parentNode, v = /^\s*[+~]/.test(b);
                            g ? j = j.replace(/'/g, "\\$&") : c.setAttribute("id", j);
                            v && k && (c = c.parentNode);
                            try {
                                if (!v || k)return t(c.querySelectorAll("[id='" + j + "'] " + b),
                                    d)
                            } catch (l) {
                            } finally {
                                g || f.removeAttribute("id")
                            }
                        }
                    }
                    return a(b, c, d, e)
                };
                for (var c in a)m[c] = a[c];
                b = null
            }
        }();
        (function () {
            var a = s.documentElement, b = a.matchesSelector || a.mozMatchesSelector || a.webkitMatchesSelector || a.msMatchesSelector;
            if (b) {
                var c = !b.call(s.createElement("div"), "div"), d = !1;
                try {
                    b.call(s.documentElement, "[test!='']:sizzle")
                } catch (e) {
                    d = !0
                }
                m.matchesSelector = function (a, e) {
                    e = e.replace(/\=\s*([^'"\]]*)\s*\]/g, "='$1']");
                    if (!m.isXML(a))try {
                        if (d || !n.match.PSEUDO.test(e) && !/!=/.test(e)) {
                            var f = b.call(a,
                                e);
                            if (f || !c || a.document && 11 !== a.document.nodeType)return f
                        }
                    } catch (g) {
                    }
                    return 0 < m(e, null, null, [a]).length
                }
            }
        })();
        (function () {
            var a = s.createElement("div");
            a.innerHTML = "<div class='test e'></div><div class='test'></div>";
            a.getElementsByClassName && 0 !== a.getElementsByClassName("e").length && (a.lastChild.className = "e", 1 !== a.getElementsByClassName("e").length && (n.order.splice(1, 0, "CLASS"), n.find.CLASS = function (a, b, c) {
                if ("undefined" != typeof b.getElementsByClassName && !c)return b.getElementsByClassName(a[1])
            },
                a = null))
        })();
        s.documentElement.contains ? m.contains = function (a, b) {
            return a !== b && (a.contains ? a.contains(b) : !0)
        } : s.documentElement.compareDocumentPosition ? m.contains = function (a, b) {
            return !!(a.compareDocumentPosition(b) & 16)
        } : m.contains = function () {
            return !1
        };
        m.isXML = function (a) {
            return (a = (a ? a.ownerDocument || a : 0).documentElement) ? "HTML" !== a.nodeName : !1
        };
        var y = function (a, b) {
            for (var c, d = [], e = "", f = b.nodeType ? [b] : b; c = n.match.PSEUDO.exec(a);)e += c[0], a = a.replace(n.match.PSEUDO, "");
            a = n.relative[a] ? a + "*" : a;
            c = 0;
            for (var g =
                f.length; c < g; c++)m(a, f[c], d);
            return m.filter(e, d)
        };
        j.find = m;
        j.expr = m.selectors;
        j.expr[":"] = j.expr.filters;
        j.unique = m.uniqueSort;
        j.text = m.getText;
        j.isXMLDoc = m.isXML;
        j.contains = m.contains
    })();
    var kb = /Until$/, lb = /^(?:parents|prevUntil|prevAll)/, mb = /,/, Ua = /^.[^:#\[\.,]*$/, nb = Array.prototype.slice, Ba = j.expr.match.POS, ob = {
        children: !0,
        contents: !0,
        next: !0,
        prev: !0
    };
    j.fn.extend({
        find: function (a) {
            var b = this, c, d;
            if ("string" != typeof a)return j(a).filter(function () {
                for (c = 0, d = b.length; c < d; c++)if (j.contains(b[c],
                        this))return !0
            });
            var e = this.pushStack("", "find", a), f, g, h;
            for (c = 0, d = this.length; c < d; c++)if (f = e.length, j.find(a, this[c], e), 0 < c)for (g = f; g < e.length; g++)for (h = 0; h < f; h++)if (e[h] === e[g]) {
                e.splice(g--, 1);
                break
            }
            return e
        }, has: function (a) {
            var b = j(a);
            return this.filter(function () {
                for (var a = 0, c = b.length; a < c; a++)if (j.contains(this, b[a]))return !0
            })
        }, not: function (a) {
            return this.pushStack(y(this, a, !1), "not", a)
        }, filter: function (a) {
            return this.pushStack(y(this, a, !0), "filter", a)
        }, is: function (a) {
            return !!a && ("string" == typeof a ? 0 < j.filter(a, this).length : 0 < this.filter(a).length)
        }, closest: function (a, b) {
            var c = [], d, e, f = this[0];
            if (j.isArray(a)) {
                var g, h, k = {}, l = 1;
                if (f && a.length) {
                    for (d = 0, e = a.length; d < e; d++)h = a[d], k[h] || (k[h] = Ba.test(h) ? j(h, b || this.context) : h);
                    for (; f && f.ownerDocument && f !== b;) {
                        for (h in k)g = k[h], (g.jquery ? -1 < g.index(f) : j(f).is(g)) && c.push({
                            selector: h,
                            elem: f,
                            level: l
                        });
                        f = f.parentNode;
                        l++
                    }
                }
                return c
            }
            g = Ba.test(a) || "string" != typeof a ? j(a, b || this.context) : 0;
            for (d = 0, e = this.length; d < e; d++)for (f = this[d]; f;) {
                if (g ? -1 <
                    g.index(f) : j.find.matchesSelector(f, a)) {
                    c.push(f);
                    break
                }
                f = f.parentNode;
                if (!f || !f.ownerDocument || f === b || 11 === f.nodeType)break
            }
            c = 1 < c.length ? j.unique(c) : c;
            return this.pushStack(c, "closest", a)
        }, index: function (a) {
            return !a || "string" == typeof a ? j.inArray(this[0], a ? j(a) : this.parent().children()) : j.inArray(a.jquery ? a[0] : a, this)
        }, add: function (a, b) {
            var c = "string" == typeof a ? j(a, b) : j.makeArray(a && a.nodeType ? [a] : a), d = j.merge(this.get(), c);
            return this.pushStack(!c[0] || !c[0].parentNode || 11 === c[0].parentNode.nodeType || !d[0] || !d[0].parentNode || 11 === d[0].parentNode.nodeType ? d : j.unique(d))
        }, andSelf: function () {
            return this.add(this.prevObject)
        }
    });
    j.each({
        parent: function (a) {
            return (a = a.parentNode) && 11 !== a.nodeType ? a : null
        }, parents: function (a) {
            return j.dir(a, "parentNode")
        }, parentsUntil: function (a, b, c) {
            return j.dir(a, "parentNode", c)
        }, next: function (a) {
            return j.nth(a, 2, "nextSibling")
        }, prev: function (a) {
            return j.nth(a, 2, "previousSibling")
        }, nextAll: function (a) {
            return j.dir(a, "nextSibling")
        }, prevAll: function (a) {
            return j.dir(a,
                "previousSibling")
        }, nextUntil: function (a, b, c) {
            return j.dir(a, "nextSibling", c)
        }, prevUntil: function (a, b, c) {
            return j.dir(a, "previousSibling", c)
        }, siblings: function (a) {
            return j.sibling(a.parentNode.firstChild, a)
        }, children: function (a) {
            return j.sibling(a.firstChild)
        }, contents: function (a) {
            return j.nodeName(a, "iframe") ? a.contentDocument || a.contentWindow.document : j.makeArray(a.childNodes)
        }
    }, function (a, b) {
        j.fn[a] = function (c, d) {
            var e = j.map(this, b, c), f = nb.call(arguments);
            kb.test(a) || (d = c);
            d && "string" == typeof d &&
            (e = j.filter(d, e));
            e = 1 < this.length && !ob[a] ? j.unique(e) : e;
            (1 < this.length || mb.test(d)) && lb.test(a) && (e = e.reverse());
            return this.pushStack(e, a, f.join(","))
        }
    });
    j.extend({
        filter: function (a, b, c) {
            c && (a = ":not(" + a + ")");
            return 1 === b.length ? j.find.matchesSelector(b[0], a) ? [b[0]] : [] : j.find.matches(a, b)
        }, dir: function (a, c, d) {
            for (var e = [], a = a[c]; a && 9 !== a.nodeType && (d === b || 1 !== a.nodeType || !j(a).is(d));)1 === a.nodeType && e.push(a), a = a[c];
            return e
        }, nth: function (a, b, c) {
            for (var b = b || 1, d = 0; a && !(1 === a.nodeType && ++d === b); a =
                a[c]);
            return a
        }, sibling: function (a, b) {
            for (var c = []; a; a = a.nextSibling)1 === a.nodeType && a !== b && c.push(a);
            return c
        }
    });
    var pb = / jQuery\d+="(?:\d+|null)"/g, oa = /^\s+/, Ca = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/ig, Da = /<([\w:]+)/, qb = /<tbody/i, rb = /<|&#?\w+;/, Ea = /<(?:script|object|embed|option|style)/i, Fa = /checked\s*(?:[^=]|=\s*.checked.)/i, sb = /\/(java|ecma)script/i, Ta = /^\s*<!(?:\[CDATA\[|\-\-)/, G = {
        option: [1, "<select multiple='multiple'>", "</select>"],
        legend: [1, "<fieldset>", "</fieldset>"],
        thead: [1, "<table>", "</table>"],
        tr: [2, "<table><tbody>", "</tbody></table>"],
        td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
        col: [2, "<table><tbody></tbody><colgroup>", "</colgroup></table>"],
        area: [1, "<map>", "</map>"],
        _default: [0, "", ""]
    };
    G.optgroup = G.option;
    G.tbody = G.tfoot = G.colgroup = G.caption = G.thead;
    G.th = G.td;
    j.support.htmlSerialize || (G._default = [1, "div<div>", "</div>"]);
    j.fn.extend({
        text: function (a) {
            return j.isFunction(a) ? this.each(function (b) {
                var c = j(this);
                c.text(a.call(this, b, c.text()))
            }) : "object" != typeof a && a !== b ? this.empty().append((this[0] && this[0].ownerDocument || s).createTextNode(a)) : j.text(this)
        }, wrapAll: function (a) {
            if (j.isFunction(a))return this.each(function (b) {
                j(this).wrapAll(a.call(this, b))
            });
            if (this[0]) {
                var b = j(a, this[0].ownerDocument).eq(0).clone(!0);
                this[0].parentNode && b.insertBefore(this[0]);
                b.map(function () {
                    for (var a = this; a.firstChild && 1 === a.firstChild.nodeType;)a = a.firstChild;
                    return a
                }).append(this)
            }
            return this
        }, wrapInner: function (a) {
            return j.isFunction(a) ? this.each(function (b) {
                j(this).wrapInner(a.call(this,
                    b))
            }) : this.each(function () {
                var b = j(this), c = b.contents();
                c.length ? c.wrapAll(a) : b.append(a)
            })
        }, wrap: function (a) {
            return this.each(function () {
                j(this).wrapAll(a)
            })
        }, unwrap: function () {
            return this.parent().each(function () {
                j.nodeName(this, "body") || j(this).replaceWith(this.childNodes)
            }).end()
        }, append: function () {
            return this.domManip(arguments, !0, function (a) {
                1 === this.nodeType && this.appendChild(a)
            })
        }, prepend: function () {
            return this.domManip(arguments, !0, function (a) {
                1 === this.nodeType && this.insertBefore(a, this.firstChild)
            })
        },
        before: function () {
            if (this[0] && this[0].parentNode)return this.domManip(arguments, !1, function (a) {
                this.parentNode.insertBefore(a, this)
            });
            if (arguments.length) {
                var a = j(arguments[0]);
                a.push.apply(a, this.toArray());
                return this.pushStack(a, "before", arguments)
            }
        }, after: function () {
            if (this[0] && this[0].parentNode)return this.domManip(arguments, !1, function (a) {
                this.parentNode.insertBefore(a, this.nextSibling)
            });
            if (arguments.length) {
                var a = this.pushStack(this, "after", arguments);
                a.push.apply(a, j(arguments[0]).toArray());
                return a
            }
        }, remove: function (a, b) {
            for (var c = 0, d; null != (d = this[c]); c++)if (!a || j.filter(a, [d]).length)!b && 1 === d.nodeType && (j.cleanData(d.getElementsByTagName("*")), j.cleanData([d])), d.parentNode && d.parentNode.removeChild(d);
            return this
        }, empty: function () {
            for (var a = 0, b; null != (b = this[a]); a++)for (1 === b.nodeType && j.cleanData(b.getElementsByTagName("*")); b.firstChild;)b.removeChild(b.firstChild);
            return this
        }, clone: function (a, b) {
            a = null == a ? !1 : a;
            b = null == b ? a : b;
            return this.map(function () {
                return j.clone(this, a, b)
            })
        },
        html: function (a) {
            if (a === b)return this[0] && 1 === this[0].nodeType ? this[0].innerHTML.replace(pb, "") : null;
            if ("string" == typeof a && !Ea.test(a) && (j.support.leadingWhitespace || !oa.test(a)) && !G[(Da.exec(a) || ["", ""])[1].toLowerCase()]) {
                a = a.replace(Ca, "<$1></$2>");
                try {
                    for (var c = 0, d = this.length; c < d; c++)1 === this[c].nodeType && (j.cleanData(this[c].getElementsByTagName("*")), this[c].innerHTML = a)
                } catch (e) {
                    this.empty().append(a)
                }
            } else j.isFunction(a) ? this.each(function (b) {
                var c = j(this);
                c.html(a.call(this, b, c.html()))
            }) :
                this.empty().append(a);
            return this
        }, replaceWith: function (a) {
            if (this[0] && this[0].parentNode) {
                if (j.isFunction(a))return this.each(function (b) {
                    var c = j(this), d = c.html();
                    c.replaceWith(a.call(this, b, d))
                });
                "string" != typeof a && (a = j(a).detach());
                return this.each(function () {
                    var b = this.nextSibling, c = this.parentNode;
                    j(this).remove();
                    b ? j(b).before(a) : j(c).append(a)
                })
            }
            return this.length ? this.pushStack(j(j.isFunction(a) ? a() : a), "replaceWith", a) : this
        }, detach: function (a) {
            return this.remove(a, !0)
        }, domManip: function (a,
                               c, d) {
            var e, f, g, h, k = a[0], l = [];
            if (!j.support.checkClone && 3 === arguments.length && "string" == typeof k && Fa.test(k))return this.each(function () {
                j(this).domManip(a, c, d, !0)
            });
            if (j.isFunction(k))return this.each(function (e) {
                var f = j(this);
                a[0] = k.call(this, e, c ? f.html() : b);
                f.domManip(a, c, d)
            });
            if (this[0]) {
                h = k && k.parentNode;
                j.support.parentNode && h && 11 === h.nodeType && h.childNodes.length === this.length ? e = {fragment: h} : e = j.buildFragment(a, this, l);
                g = e.fragment;
                1 === g.childNodes.length ? f = g = g.firstChild : f = g.firstChild;
                if (f) {
                    c =
                        c && j.nodeName(f, "tr");
                    f = 0;
                    h = this.length;
                    for (var m = h - 1; f < h; f++)d.call(c ? j.nodeName(this[f], "table") ? this[f].getElementsByTagName("tbody")[0] || this[f].appendChild(this[f].ownerDocument.createElement("tbody")) : this[f] : this[f], e.cacheable || 1 < h && f < m ? j.clone(g, !0, !0) : g)
                }
                l.length && j.each(l, o)
            }
            return this
        }
    });
    j.buildFragment = function (a, b, c) {
        var d, e, f, g;
        b && b[0] && (g = b[0].ownerDocument || b[0]);
        g.createDocumentFragment || (g = s);
        1 === a.length && "string" == typeof a[0] && 512 > a[0].length && g === s && "<" === a[0].charAt(0) && !Ea.test(a[0]) &&
        (j.support.checkClone || !Fa.test(a[0])) && (e = !0, f = j.fragments[a[0]], f && 1 !== f && (d = f));
        d || (d = g.createDocumentFragment(), j.clean(a, g, d, c));
        e && (j.fragments[a[0]] = f ? d : 1);
        return {fragment: d, cacheable: e}
    };
    j.fragments = {};
    j.each({
        appendTo: "append",
        prependTo: "prepend",
        insertBefore: "before",
        insertAfter: "after",
        replaceAll: "replaceWith"
    }, function (a, b) {
        j.fn[a] = function (c) {
            var d = [], c = j(c), e = 1 === this.length && this[0].parentNode;
            if (e && 11 === e.nodeType && 1 === e.childNodes.length && 1 === c.length)return c[b](this[0]), this;
            for (var e =
                0, f = c.length; e < f; e++) {
                var g = (0 < e ? this.clone(!0) : this).get();
                j(c[e])[b](g);
                d = d.concat(g)
            }
            return this.pushStack(d, a, c.selector)
        }
    });
    j.extend({
        clone: function (a, b, c) {
            var d = a.cloneNode(!0), e, f, g;
            if ((!j.support.noCloneEvent || !j.support.noCloneChecked) && (1 === a.nodeType || 11 === a.nodeType) && !j.isXMLDoc(a)) {
                q(a, d);
                e = u(a);
                f = u(d);
                for (g = 0; e[g]; ++g)q(e[g], f[g])
            }
            if (b && (t(a, d), c)) {
                e = u(a);
                f = u(d);
                for (g = 0; e[g]; ++g)t(e[g], f[g])
            }
            return d
        }, clean: function (a, b, c, d) {
            b = b || s;
            "undefined" == typeof b.createElement && (b = b.ownerDocument ||
            b[0] && b[0].ownerDocument || s);
            for (var e = [], f, g = 0, h; null != (h = a[g]); g++)if ("number" == typeof h && (h += ""), h) {
                if ("string" == typeof h)if (rb.test(h)) {
                    h = h.replace(Ca, "<$1></$2>");
                    f = (Da.exec(h) || ["", ""])[1].toLowerCase();
                    var k = G[f] || G._default, l = k[0], m = b.createElement("div");
                    for (m.innerHTML = k[1] + h + k[2]; l--;)m = m.lastChild;
                    if (!j.support.tbody) {
                        l = qb.test(h);
                        k = "table" === f && !l ? m.firstChild && m.firstChild.childNodes : "<table>" === k[1] && !l ? m.childNodes : [];
                        for (f = k.length - 1; 0 <= f; --f)j.nodeName(k[f], "tbody") && !k[f].childNodes.length &&
                        k[f].parentNode.removeChild(k[f])
                    }
                    !j.support.leadingWhitespace && oa.test(h) && m.insertBefore(b.createTextNode(oa.exec(h)[0]), m.firstChild);
                    h = m.childNodes
                } else h = b.createTextNode(h);
                var n;
                if (!j.support.appendChecked)if (h[0] && "number" == typeof(n = h.length))for (f = 0; f < n; f++)p(h[f]); else p(h);
                h.nodeType ? e.push(h) : e = j.merge(e, h)
            }
            if (c) {
                a = function (a) {
                    return !a.type || sb.test(a.type)
                };
                for (g = 0; e[g]; g++)d && j.nodeName(e[g], "script") && (!e[g].type || "text/javascript" === e[g].type.toLowerCase()) ? d.push(e[g].parentNode ?
                    e[g].parentNode.removeChild(e[g]) : e[g]) : (1 === e[g].nodeType && (b = j.grep(e[g].getElementsByTagName("script"), a), e.splice.apply(e, [g + 1, 0].concat(b))), c.appendChild(e[g]))
            }
            return e
        }, cleanData: function (a) {
            for (var b, c, d = j.cache, e = j.expando, f = j.event.special, g = j.support.deleteExpando, h = 0, k; null != (k = a[h]); h++)if (!k.nodeName || !j.noData[k.nodeName.toLowerCase()])if (c = k[j.expando]) {
                if ((b = d[c] && d[c][e]) && b.events) {
                    for (var l in b.events)f[l] ? j.event.remove(k, l) : j.removeEvent(k, l, b.handle);
                    b.handle && (b.handle.elem =
                        null)
                }
                g ? delete k[j.expando] : k.removeAttribute && k.removeAttribute(j.expando);
                delete d[c]
            }
        }
    });
    var Ga = /alpha\([^)]*\)/i, tb = /opacity=([^)]*)/, ub = /([A-Z]|^ms)/g, Ha = /^-?\d+(?:px)?$/i, vb = /^-?\d/, wb = /^[+\-]=/, xb = /[^+\-\.\de]+/g, yb = {
        position: "absolute",
        visibility: "hidden",
        display: "block"
    }, Ra = ["Left", "Right"], Sa = ["Top", "Bottom"], S, Ia, Ja;
    j.fn.css = function (a, c) {
        return 2 === arguments.length && c === b ? this : j.access(this, a, c, !0, function (a, c, d) {
            return d !== b ? j.style(a, c, d) : j.css(a, c)
        })
    };
    j.extend({
        cssHooks: {
            opacity: {
                get: function (a,
                               b) {
                    if (b) {
                        var c = S(a, "opacity", "opacity");
                        return "" === c ? "1" : c
                    }
                    return a.style.opacity
                }
            }
        },
        cssNumber: {
            fillOpacity: !0,
            fontWeight: !0,
            lineHeight: !0,
            opacity: !0,
            orphans: !0,
            widows: !0,
            zIndex: !0,
            zoom: !0
        },
        cssProps: {"float": j.support.cssFloat ? "cssFloat" : "styleFloat"},
        style: function (a, c, d, e) {
            if (a && 3 !== a.nodeType && 8 !== a.nodeType && a.style) {
                var f, g = j.camelCase(c), h = a.style, k = j.cssHooks[g], c = j.cssProps[g] || g;
                if (d === b)return k && "get"in k && (f = k.get(a, !1, e)) !== b ? f : h[c];
                e = typeof d;
                if (!("number" === e && isNaN(d) || null == d))if ("string" ===
                    e && wb.test(d) && (d = +d.replace(xb, "") + parseFloat(j.css(a, c)), e = "number"), "number" === e && !j.cssNumber[g] && (d += "px"), !k || !("set"in k) || (d = k.set(a, d)) !== b)try {
                    h[c] = d
                } catch (l) {
                }
            }
        },
        css: function (a, c, d) {
            var e, f;
            c = j.camelCase(c);
            f = j.cssHooks[c];
            c = j.cssProps[c] || c;
            "cssFloat" === c && (c = "float");
            if (f && "get"in f && (e = f.get(a, !0, d)) !== b)return e;
            if (S)return S(a, c)
        },
        swap: function (a, b, c) {
            var d = {}, e;
            for (e in b)d[e] = a.style[e], a.style[e] = b[e];
            c.call(a);
            for (e in b)a.style[e] = d[e]
        }
    });
    j.curCSS = j.css;
    j.each(["height", "width"],
        function (a, b) {
            j.cssHooks[b] = {
                get: function (a, c, d) {
                    var e;
                    if (c) {
                        if (0 !== a.offsetWidth)return n(a, b, d);
                        j.swap(a, yb, function () {
                            e = n(a, b, d)
                        });
                        return e
                    }
                }, set: function (a, b) {
                    if (!Ha.test(b))return b;
                    b = parseFloat(b);
                    if (0 <= b)return b + "px"
                }
            }
        });
    j.support.opacity || (j.cssHooks.opacity = {
        get: function (a, b) {
            return tb.test((b && a.currentStyle ? a.currentStyle.filter : a.style.filter) || "") ? parseFloat(RegExp.$1) / 100 + "" : b ? "1" : ""
        }, set: function (a, b) {
            var c = a.style, d = a.currentStyle;
            c.zoom = 1;
            var e = j.isNaN(b) ? "" : "alpha(opacity=" + 100 *
            b + ")", d = d && d.filter || c.filter || "";
            c.filter = Ga.test(d) ? d.replace(Ga, e) : d + " " + e
        }
    });
    j(function () {
        j.support.reliableMarginRight || (j.cssHooks.marginRight = {
            get: function (a, b) {
                var c;
                j.swap(a, {display: "inline-block"}, function () {
                    b ? c = S(a, "margin-right", "marginRight") : c = a.style.marginRight
                });
                return c
            }
        })
    });
    s.defaultView && s.defaultView.getComputedStyle && (Ia = function (a, c) {
        var d, e, c = c.replace(ub, "-$1").toLowerCase();
        if (!(e = a.ownerDocument.defaultView))return b;
        if (e = e.getComputedStyle(a, null))d = e.getPropertyValue(c),
        "" === d && !j.contains(a.ownerDocument.documentElement, a) && (d = j.style(a, c));
        return d
    });
    s.documentElement.currentStyle && (Ja = function (a, b) {
        var c, d = a.currentStyle && a.currentStyle[b], e = a.runtimeStyle && a.runtimeStyle[b], f = a.style;
        !Ha.test(d) && vb.test(d) && (c = f.left, e && (a.runtimeStyle.left = a.currentStyle.left), f.left = "fontSize" === b ? "1em" : d || 0, d = f.pixelLeft + "px", f.left = c, e && (a.runtimeStyle.left = e));
        return "" === d ? "auto" : d
    });
    S = Ia || Ja;
    j.expr && j.expr.filters && (j.expr.filters.hidden = function (a) {
        var b = a.offsetHeight;
        return 0 === a.offsetWidth && 0 === b || !j.support.reliableHiddenOffsets && "none" === (a.style.display || j.css(a, "display"))
    }, j.expr.filters.visible = function (a) {
        return !j.expr.filters.hidden(a)
    });
    var zb = /%20/g, Qa = /\[\]$/, Ka = /\r?\n/g, Ab = /#.*$/, Bb = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg, Cb = /^(?:color|date|datetime|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i, Db = /^(?:GET|HEAD)$/, Eb = /^\/\//, La = /\?/, Fb = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, Gb = /^(?:select|textarea)/i, ta = /\s+/,
        Hb = /([?&])_=[^&]*/, Ma = /^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+))?)?/, Na = j.fn.load, ga = {}, Oa = {}, H, M;
    try {
        H = Za.href
    } catch (Nb) {
        H = s.createElement("a"), H.href = "", H = H.href
    }
    M = Ma.exec(H.toLowerCase()) || [];
    j.fn.extend({
        load: function (a, c, d) {
            if ("string" != typeof a && Na)return Na.apply(this, arguments);
            if (!this.length)return this;
            var e = a.indexOf(" ");
            if (0 <= e)var f = a.slice(e, a.length), a = a.slice(0, e);
            e = "GET";
            c && (j.isFunction(c) ? (d = c, c = b) : "object" == typeof c && (c = j.param(c, j.ajaxSettings.traditional), e = "POST"));
            var g =
                this;
            j.ajax({
                url: a, type: e, dataType: "html", data: c, complete: function (a, b, c) {
                    c = a.responseText;
                    a.isResolved() && (a.done(function (a) {
                        c = a
                    }), g.html(f ? j("<div>").append(c.replace(Fb, "")).find(f) : c));
                    d && g.each(d, [c, b, a])
                }
            });
            return this
        }, serialize: function () {
            return j.param(this.serializeArray())
        }, serializeArray: function () {
            return this.map(function () {
                return this.elements ? j.makeArray(this.elements) : this
            }).filter(function () {
                return this.name && !this.disabled && (this.checked || Gb.test(this.nodeName) || Cb.test(this.type))
            }).map(function (a,
                             b) {
                var c = j(this).val();
                return null == c ? null : j.isArray(c) ? j.map(c, function (a) {
                    return {name: b.name, value: a.replace(Ka, "\r\n")}
                }) : {name: b.name, value: c.replace(Ka, "\r\n")}
            }).get()
        }
    });
    j.each("ajaxStart,ajaxStop,ajaxComplete,ajaxError,ajaxSuccess,ajaxSend".split(","), function (a, b) {
        j.fn[b] = function (a) {
            return this.bind(b, a)
        }
    });
    j.each(["get", "post"], function (a, c) {
        j[c] = function (a, d, e, f) {
            j.isFunction(d) && (f = f || e, e = d, d = b);
            return j.ajax({type: c, url: a, data: d, success: e, dataType: f})
        }
    });
    j.extend({
        getScript: function (a,
                             c) {
            return j.get(a, b, c, "script")
        }, getJSON: function (a, b, c) {
            return j.get(a, b, c, "json")
        }, ajaxSetup: function (a, b) {
            b ? j.extend(!0, a, j.ajaxSettings, b) : (b = a, a = j.extend(!0, j.ajaxSettings, b));
            for (var c in{context: 1, url: 1})c in b ? a[c] = b[c] : c in j.ajaxSettings && (a[c] = j.ajaxSettings[c]);
            return a
        }, ajaxSettings: {
            url: H,
            isLocal: /^(?:about|app|app\-storage|.+\-extension|file|widget):$/.test(M[1]),
            global: !0,
            type: "GET",
            contentType: "application/x-www-form-urlencoded",
            processData: !0,
            async: !0,
            accepts: {
                xml: "application/xml, text/xml",
                html: "text/html", text: "text/plain", json: "application/json, text/javascript", "*": "*/*"
            },
            contents: {xml: /xml/, html: /html/, json: /json/},
            responseFields: {xml: "responseXML", text: "responseText"},
            converters: {"* text": a.String, "text html": !0, "text json": j.parseJSON, "text xml": j.parseXML}
        }, ajaxPrefilter: m(ga), ajaxTransport: m(Oa), ajax: function (a, c) {
            function d(a, c, l, v) {
                if (2 !== w) {
                    w = 2;
                    u && clearTimeout(u);
                    r = b;
                    q = v || "";
                    x.readyState = a ? 4 : 0;
                    var o, p, D;
                    if (l) {
                        var v = e, t = x, s = v.contents, C = v.dataTypes, A = v.responseFields, B, z,
                            N, L;
                        for (z in A)z in l && (t[A[z]] = l[z]);
                        for (; "*" === C[0];)C.shift(), B === b && (B = v.mimeType || t.getResponseHeader("content-type"));
                        if (B)for (z in s)if (s[z] && s[z].test(B)) {
                            C.unshift(z);
                            break
                        }
                        if (C[0]in l)N = C[0]; else {
                            for (z in l) {
                                if (!C[0] || v.converters[z + " " + C[0]]) {
                                    N = z;
                                    break
                                }
                                L || (L = z)
                            }
                            N = N || L
                        }
                        N ? (N !== C[0] && C.unshift(N), l = l[N]) : l = void 0
                    } else l = b;
                    if (200 <= a && 300 > a || 304 === a) {
                        if (e.ifModified) {
                            if (B = x.getResponseHeader("Last-Modified"))j.lastModified[n] = B;
                            if (B = x.getResponseHeader("Etag"))j.etag[n] = B
                        }
                        if (304 === a)c = "notmodified",
                            o = !0; else try {
                            B = e;
                            B.dataFilter && (l = B.dataFilter(l, B.dataType));
                            var J = B.dataTypes;
                            z = {};
                            var K, aa, G = J.length, E, O = J[0], P, ia, Q, F, H;
                            for (K = 1; K < G; K++) {
                                if (1 === K)for (aa in B.converters)"string" == typeof aa && (z[aa.toLowerCase()] = B.converters[aa]);
                                P = O;
                                O = J[K];
                                if ("*" === O)O = P; else if ("*" !== P && P !== O) {
                                    ia = P + " " + O;
                                    Q = z[ia] || z["* " + O];
                                    if (!Q)for (F in H = b, z)if (E = F.split(" "), E[0] === P || "*" === E[0])if (H = z[E[1] + " " + O]) {
                                        F = z[F];
                                        !0 === F ? Q = H : !0 === H && (Q = F);
                                        break
                                    }
                                    !Q && !H && j.error("No conversion from " + ia.replace(" ", " to "));
                                    !0 !== Q &&
                                    (l = Q ? Q(l) : H(F(l)))
                                }
                            }
                            p = l;
                            c = "success";
                            o = !0
                        } catch (M) {
                            c = "parsererror", D = M
                        }
                    } else if (D = c, !c || a)c = "error", 0 > a && (a = 0);
                    x.status = a;
                    x.statusText = c;
                    o ? h.resolveWith(f, [p, c, x]) : h.rejectWith(f, [x, c, D]);
                    x.statusCode(m);
                    m = b;
                    y && g.trigger("ajax" + (o ? "Success" : "Error"), [x, e, o ? p : D]);
                    k.resolveWith(f, [x, c]);
                    y && (g.trigger("ajaxComplete", [x, e]), --j.active || j.event.trigger("ajaxStop"))
                }
            }

            "object" == typeof a && (c = a, a = b);
            c = c || {};
            var e = j.ajaxSetup({}, c), f = e.context || e, g = f !== e && (f.nodeType || f instanceof j) ? j(f) : j.event, h = j.Deferred(),
                k = j._Deferred(), m = e.statusCode || {}, n, o = {}, p = {}, q, t, r, u, s, w = 0, y, A, x = {
                    readyState: 0,
                    setRequestHeader: function (a, b) {
                        if (!w) {
                            var c = a.toLowerCase();
                            a = p[c] = p[c] || a;
                            o[a] = b
                        }
                        return this
                    },
                    getAllResponseHeaders: function () {
                        return 2 === w ? q : null
                    },
                    getResponseHeader: function (a) {
                        var c;
                        if (2 === w) {
                            if (!t)for (t = {}; c = Bb.exec(q);)t[c[1].toLowerCase()] = c[2];
                            c = t[a.toLowerCase()]
                        }
                        return c === b ? null : c
                    },
                    overrideMimeType: function (a) {
                        w || (e.mimeType = a);
                        return this
                    },
                    abort: function (a) {
                        a = a || "abort";
                        r && r.abort(a);
                        d(0, a);
                        return this
                    }
                };
            h.promise(x);
            x.success = x.done;
            x.error = x.fail;
            x.complete = k.done;
            x.statusCode = function (a) {
                if (a) {
                    var b;
                    if (2 > w)for (b in a)m[b] = [m[b], a[b]]; else b = a[x.status], x.then(b, b)
                }
                return this
            };
            e.url = ((a || e.url) + "").replace(Ab, "").replace(Eb, M[1] + "//");
            e.dataTypes = j.trim(e.dataType || "*").toLowerCase().split(ta);
            null == e.crossDomain && (s = Ma.exec(e.url.toLowerCase()), e.crossDomain = !(!s || s[1] == M[1] && s[2] == M[2] && (s[3] || ("http:" === s[1] ? 80 : 443)) == (M[3] || ("http:" === M[1] ? 80 : 443))));
            e.data && e.processData && "string" != typeof e.data && (e.data =
                j.param(e.data, e.traditional));
            l(ga, e, c, x);
            if (2 === w)return !1;
            y = e.global;
            e.type = e.type.toUpperCase();
            e.hasContent = !Db.test(e.type);
            y && 0 === j.active++ && j.event.trigger("ajaxStart");
            if (!e.hasContent && (e.data && (e.url += (La.test(e.url) ? "&" : "?") + e.data), n = e.url, !1 === e.cache)) {
                s = j.now();
                var B = e.url.replace(Hb, "$1_=" + s);
                e.url = B + (B === e.url ? (La.test(e.url) ? "&" : "?") + "_=" + s : "")
            }
            (e.data && e.hasContent && !1 !== e.contentType || c.contentType) && x.setRequestHeader("Content-Type", e.contentType);
            e.ifModified && (n = n || e.url,
            j.lastModified[n] && x.setRequestHeader("If-Modified-Since", j.lastModified[n]), j.etag[n] && x.setRequestHeader("If-None-Match", j.etag[n]));
            x.setRequestHeader("Accept", e.dataTypes[0] && e.accepts[e.dataTypes[0]] ? e.accepts[e.dataTypes[0]] + ("*" !== e.dataTypes[0] ? ", */*; q=0.01" : "") : e.accepts["*"]);
            for (A in e.headers)x.setRequestHeader(A, e.headers[A]);
            if (e.beforeSend && (!1 === e.beforeSend.call(f, x, e) || 2 === w))return x.abort(), !1;
            for (A in{success: 1, error: 1, complete: 1})x[A](e[A]);
            if (r = l(Oa, e, c, x)) {
                x.readyState = 1;
                y && g.trigger("ajaxSend", [x, e]);
                e.async && 0 < e.timeout && (u = setTimeout(function () {
                    x.abort("timeout")
                }, e.timeout));
                try {
                    w = 1, r.send(o, d)
                } catch (z) {
                    2 > status ? d(-1, z) : j.error(z)
                }
            } else d(-1, "No Transport");
            return x
        }, param: function (a, c) {
            var d = [], e = function (a, b) {
                b = j.isFunction(b) ? b() : b;
                d[d.length] = encodeURIComponent(a) + "=" + encodeURIComponent(b)
            };
            c === b && (c = j.ajaxSettings.traditional);
            if (j.isArray(a) || a.jquery && !j.isPlainObject(a))j.each(a, function () {
                e(this.name, this.value)
            }); else for (var f in a)k(f, a[f], c, e);
            return d.join("&").replace(zb,
                "+")
        }
    });
    j.extend({active: 0, lastModified: {}, etag: {}});
    var Ib = j.now(), ea = /(\=)\?(&|$)|\?\?/i;
    j.ajaxSetup({
        jsonp: "callback", jsonpCallback: function () {
            return j.expando + "_" + Ib++
        }
    });
    j.ajaxPrefilter("json jsonp", function (b, c, d) {
        c = "application/x-www-form-urlencoded" === b.contentType && "string" == typeof b.data;
        if ("jsonp" === b.dataTypes[0] || !1 !== b.jsonp && (ea.test(b.url) || c && ea.test(b.data))) {
            var e, f = b.jsonpCallback = j.isFunction(b.jsonpCallback) ? b.jsonpCallback() : b.jsonpCallback, g = a[f], h = b.url, k = b.data, l = "$1" + f +
                "$2";
            !1 !== b.jsonp && (h = h.replace(ea, l), b.url === h && (c && (k = k.replace(ea, l)), b.data === k && (h += (/\?/.test(h) ? "&" : "?") + b.jsonp + "=" + f)));
            b.url = h;
            b.data = k;
            a[f] = function (a) {
                e = [a]
            };
            d.always(function () {
                a[f] = g;
                e && j.isFunction(g) && a[f](e[0])
            });
            b.converters["script json"] = function () {
                e || j.error(f + " was not called");
                return e[0]
            };
            b.dataTypes[0] = "json";
            return "script"
        }
    });
    j.ajaxSetup({
        accepts: {script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},
        contents: {script: /javascript|ecmascript/},
        converters: {
            "text script": function (a) {
                j.globalEval(a);
                return a
            }
        }
    });
    j.ajaxPrefilter("script", function (a) {
        a.cache === b && (a.cache = !1);
        a.crossDomain && (a.type = "GET", a.global = !1)
    });
    j.ajaxTransport("script", function (a) {
        if (a.crossDomain) {
            var c, d = s.head || s.getElementsByTagName("head")[0] || s.documentElement;
            return {
                send: function (e, f) {
                    c = s.createElement("script");
                    c.async = "async";
                    a.scriptCharset && (c.charset = a.scriptCharset);
                    c.src = a.url;
                    c.onload = c.onreadystatechange = function (a, e) {
                        if (e || !c.readyState || /loaded|complete/.test(c.readyState))c.onload =
                            c.onreadystatechange = null, d && c.parentNode && d.removeChild(c), c = b, e || f(200, "success")
                    };
                    d.insertBefore(c, d.firstChild)
                }, abort: function () {
                    c && c.onload(0, 1)
                }
            }
        }
    });
    var pa = a.ActiveXObject ? function () {
        for (var a in U)U[a](0, 1)
    } : !1, Jb = 0, U;
    j.ajaxSettings.xhr = a.ActiveXObject ? function () {
        var b;
        if (!(b = !this.isLocal && h()))a:{
            try {
                b = new a.ActiveXObject("Microsoft.XMLHTTP");
                break a
            } catch (c) {
            }
            b = void 0
        }
        return b
    } : h;
    (function (a) {
        j.extend(j.support, {ajax: !!a, cors: !!a && "withCredentials"in a})
    })(j.ajaxSettings.xhr());
    j.support.ajax &&
    j.ajaxTransport(function (c) {
        if (!c.crossDomain || j.support.cors) {
            var d;
            return {
                send: function (e, f) {
                    var g = c.xhr(), h, k;
                    c.username ? g.open(c.type, c.url, c.async, c.username, c.password) : g.open(c.type, c.url, c.async);
                    if (c.xhrFields)for (k in c.xhrFields)g[k] = c.xhrFields[k];
                    c.mimeType && g.overrideMimeType && g.overrideMimeType(c.mimeType);
                    !c.crossDomain && !e["X-Requested-With"] && (e["X-Requested-With"] = "XMLHttpRequest");
                    try {
                        for (k in e)g.setRequestHeader(k, e[k])
                    } catch (l) {
                    }
                    g.send(c.hasContent && c.data || null);
                    d = function (a,
                                  e) {
                        var k, l, m, n, o;
                        try {
                            if (d && (e || 4 === g.readyState))if (d = b, h && (g.onreadystatechange = j.noop, pa && delete U[h]), e)4 !== g.readyState && g.abort(); else {
                                k = g.status;
                                m = g.getAllResponseHeaders();
                                n = {};
                                o = g.responseXML;
                                o && o.documentElement && (n.xml = o);
                                n.text = g.responseText;
                                try {
                                    l = g.statusText
                                } catch (p) {
                                    l = ""
                                }
                                !k && c.isLocal && !c.crossDomain ? k = n.text ? 200 : 404 : 1223 === k && (k = 204)
                            }
                        } catch (q) {
                            e || f(-1, q)
                        }
                        n && f(k, l, n, m)
                    };
                    !c.async || 4 === g.readyState ? d() : (h = ++Jb, pa && (U || (U = {}, j(a).unload(pa)), U[h] = d), g.onreadystatechange = d)
                }, abort: function () {
                    d &&
                    d(0, 1)
                }
            }
        }
    });
    var fa = {}, E, R, Kb = /^(?:toggle|show|hide)$/, Lb = /^([+\-]=)?([\d+.\-]+)([a-z%]*)$/i, V, ra = [["height", "marginTop", "marginBottom", "paddingTop", "paddingBottom"], ["width", "marginLeft", "marginRight", "paddingLeft", "paddingRight"], ["opacity"]], X, qa = a.webkitRequestAnimationFrame || a.mozRequestAnimationFrame || a.oRequestAnimationFrame;
    j.fn.extend({
        show: function (a, b, c) {
            var f, g;
            if (a || 0 === a)return this.animate(e("show", 3), a, b, c);
            a = 0;
            for (b = this.length; a < b; a++)f = this[a], f.style && (g = f.style.display, !j._data(f,
                "olddisplay") && "none" === g && (g = f.style.display = ""), "" === g && "none" === j.css(f, "display") && j._data(f, "olddisplay", d(f.nodeName)));
            for (a = 0; a < b; a++)if (f = this[a], f.style && (g = f.style.display, "" === g || "none" === g))f.style.display = j._data(f, "olddisplay") || "";
            return this
        }, hide: function (a, b, c) {
            if (a || 0 === a)return this.animate(e("hide", 3), a, b, c);
            a = 0;
            for (b = this.length; a < b; a++)this[a].style && (c = j.css(this[a], "display"), "none" !== c && !j._data(this[a], "olddisplay") && j._data(this[a], "olddisplay", c));
            for (a = 0; a < b; a++)this[a].style &&
            (this[a].style.display = "none");
            return this
        }, _toggle: j.fn.toggle, toggle: function (a, b, c) {
            var d = "boolean" == typeof a;
            j.isFunction(a) && j.isFunction(b) ? this._toggle.apply(this, arguments) : null == a || d ? this.each(function () {
                var b = d ? a : j(this).is(":hidden");
                j(this)[b ? "show" : "hide"]()
            }) : this.animate(e("toggle", 3), a, b, c);
            return this
        }, fadeTo: function (a, b, c, d) {
            return this.filter(":hidden").css("opacity", 0).show().end().animate({opacity: b}, a, c, d)
        }, animate: function (a, b, c, e) {
            var f = j.speed(b, c, e);
            if (j.isEmptyObject(a))return this.each(f.complete,
                [!1]);
            a = j.extend({}, a);
            return this[!1 === f.queue ? "each" : "queue"](function () {
                !1 === f.queue && j._mark(this);
                var b = j.extend({}, f), c = 1 === this.nodeType, e = c && j(this).is(":hidden"), g, h, k, l, m, n, o, p, q;
                b.animatedProperties = {};
                for (k in a) {
                    g = j.camelCase(k);
                    k !== g && (a[g] = a[k], delete a[k]);
                    h = a[g];
                    j.isArray(h) ? (b.animatedProperties[g] = h[1], h = a[g] = h[0]) : b.animatedProperties[g] = b.specialEasing && b.specialEasing[g] || b.easing || "swing";
                    if ("hide" === h && e || "show" === h && !e)return b.complete.call(this);
                    c && ("height" === g || "width" ===
                    g) && (b.overflow = [this.style.overflow, this.style.overflowX, this.style.overflowY], "inline" === j.css(this, "display") && "none" === j.css(this, "float") && (j.support.inlineBlockNeedsLayout ? (l = d(this.nodeName), "inline" === l ? this.style.display = "inline-block" : (this.style.display = "inline", this.style.zoom = 1)) : this.style.display = "inline-block"))
                }
                null != b.overflow && (this.style.overflow = "hidden");
                for (k in a)m = new j.fx(this, b, k), h = a[k], Kb.test(h) ? m["toggle" === h ? e ? "show" : "hide" : h]() : (n = Lb.exec(h), o = m.cur(), n ? (p = parseFloat(n[2]),
                    q = n[3] || (j.cssNumber[k] ? "" : "px"), "px" !== q && (j.style(this, k, (p || 1) + q), o *= (p || 1) / m.cur(), j.style(this, k, o + q)), n[1] && (p = ("-=" === n[1] ? -1 : 1) * p + o), m.custom(o, p, q)) : m.custom(o, h, ""));
                return !0
            })
        }, stop: function (a, b) {
            a && this.queue([]);
            this.each(function () {
                var a = j.timers, c = a.length;
                for (b || j._unmark(!0, this); c--;)a[c].elem === this && (b && a[c](!0), a.splice(c, 1))
            });
            b || this.dequeue();
            return this
        }
    });
    j.each({
        slideDown: e("show", 1),
        slideUp: e("hide", 1),
        slideToggle: e("toggle", 1),
        fadeIn: {opacity: "show"},
        fadeOut: {opacity: "hide"},
        fadeToggle: {opacity: "toggle"}
    }, function (a, b) {
        j.fn[a] = function (a, c, d) {
            return this.animate(b, a, c, d)
        }
    });
    j.extend({
        speed: function (a, b, c) {
            var d = a && "object" == typeof a ? j.extend({}, a) : {
                complete: c || !c && b || j.isFunction(a) && a,
                duration: a,
                easing: c && b || b && !j.isFunction(b) && b
            };
            d.duration = j.fx.off ? 0 : "number" == typeof d.duration ? d.duration : d.duration in j.fx.speeds ? j.fx.speeds[d.duration] : j.fx.speeds._default;
            d.old = d.complete;
            d.complete = function (a) {
                j.isFunction(d.old) && d.old.call(this);
                !1 !== d.queue ? j.dequeue(this) :
                !1 !== a && j._unmark(this)
            };
            return d
        }, easing: {
            linear: function (a, b, c, d) {
                return c + d * a
            }, swing: function (a, b, c, d) {
                return (-Math.cos(a * Math.PI) / 2 + 0.5) * d + c
            }
        }, timers: [], fx: function (a, b, c) {
            this.options = b;
            this.elem = a;
            this.prop = c;
            b.orig = b.orig || {}
        }
    });
    j.fx.prototype = {
        update: function () {
            this.options.step && this.options.step.call(this.elem, this.now, this);
            (j.fx.step[this.prop] || j.fx.step._default)(this)
        }, cur: function () {
            if (null != this.elem[this.prop] && (!this.elem.style || null == this.elem.style[this.prop]))return this.elem[this.prop];
            var a, b = j.css(this.elem, this.prop);
            return isNaN(a = parseFloat(b)) ? !b || "auto" === b ? 0 : b : a
        }, custom: function (a, b, c) {
            function d(a) {
                return e.step(a)
            }

            var e = this, f = j.fx, h;
            this.startTime = X || g();
            this.start = a;
            this.end = b;
            this.unit = c || this.unit || (j.cssNumber[this.prop] ? "" : "px");
            this.now = this.start;
            this.pos = this.state = 0;
            d.elem = this.elem;
            d() && j.timers.push(d) && !V && (qa ? (V = !0, h = function () {
                V && (qa(h), f.tick())
            }, qa(h)) : V = setInterval(f.tick, f.interval))
        }, show: function () {
            this.options.orig[this.prop] = j.style(this.elem, this.prop);
            this.options.show = !0;
            this.custom("width" === this.prop || "height" === this.prop ? 1 : 0, this.cur());
            j(this.elem).show()
        }, hide: function () {
            this.options.orig[this.prop] = j.style(this.elem, this.prop);
            this.options.hide = !0;
            this.custom(this.cur(), 0)
        }, step: function (a) {
            var b = X || g(), c = !0, d = this.elem, e = this.options, f, h;
            if (a || b >= e.duration + this.startTime) {
                this.now = this.end;
                this.pos = this.state = 1;
                this.update();
                e.animatedProperties[this.prop] = !0;
                for (f in e.animatedProperties)!0 !== e.animatedProperties[f] && (c = !1);
                if (c) {
                    null !=
                    e.overflow && !j.support.shrinkWrapBlocks && j.each(["", "X", "Y"], function (a, b) {
                        d.style["overflow" + b] = e.overflow[a]
                    });
                    e.hide && j(d).hide();
                    if (e.hide || e.show)for (var k in e.animatedProperties)j.style(d, k, e.orig[k]);
                    e.complete.call(d)
                }
                return !1
            }
            Infinity == e.duration ? this.now = b : (h = b - this.startTime, this.state = h / e.duration, this.pos = j.easing[e.animatedProperties[this.prop]](this.state, h, 0, 1, e.duration), this.now = this.start + (this.end - this.start) * this.pos);
            this.update();
            return !0
        }
    };
    j.extend(j.fx, {
        tick: function () {
            for (var a =
                j.timers, b = 0; b < a.length; ++b)a[b]() || a.splice(b--, 1);
            a.length || j.fx.stop()
        }, interval: 13, stop: function () {
            clearInterval(V);
            V = null
        }, speeds: {slow: 600, fast: 200, _default: 400}, step: {
            opacity: function (a) {
                j.style(a.elem, "opacity", a.now)
            }, _default: function (a) {
                a.elem.style && null != a.elem.style[a.prop] ? a.elem.style[a.prop] = ("width" === a.prop || "height" === a.prop ? Math.max(0, a.now) : a.now) + a.unit : a.elem[a.prop] = a.now
            }
        }
    });
    j.expr && j.expr.filters && (j.expr.filters.animated = function (a) {
        return j.grep(j.timers, function (b) {
            return a ===
                b.elem
        }).length
    });
    var Mb = /^t(?:able|d|h)$/i, Pa = /^(?:body|html)$/i;
    "getBoundingClientRect"in s.documentElement ? j.fn.offset = function (a) {
        var b = this[0], d;
        if (a)return this.each(function (b) {
            j.offset.setOffset(this, a, b)
        });
        if (!b || !b.ownerDocument)return null;
        if (b === b.ownerDocument.body)return j.offset.bodyOffset(b);
        try {
            d = b.getBoundingClientRect()
        } catch (e) {
        }
        var f = b.ownerDocument, g = f.documentElement;
        if (!d || !j.contains(g, b))return d ? {top: d.top, left: d.left} : {top: 0, left: 0};
        b = f.body;
        f = c(f);
        return {
            top: d.top + (f.pageYOffset ||
            j.support.boxModel && g.scrollTop || b.scrollTop) - (g.clientTop || b.clientTop || 0),
            left: d.left + (f.pageXOffset || j.support.boxModel && g.scrollLeft || b.scrollLeft) - (g.clientLeft || b.clientLeft || 0)
        }
    } : j.fn.offset = function (a) {
        var b = this[0];
        if (a)return this.each(function (b) {
            j.offset.setOffset(this, a, b)
        });
        if (!b || !b.ownerDocument)return null;
        if (b === b.ownerDocument.body)return j.offset.bodyOffset(b);
        j.offset.initialize();
        for (var c, d = b.offsetParent, e = b.ownerDocument, f = e.documentElement, g = e.body, h = (e = e.defaultView) ? e.getComputedStyle(b,
            null) : b.currentStyle, k = b.offsetTop, l = b.offsetLeft; (b = b.parentNode) && b !== g && b !== f && !(j.offset.supportsFixedPosition && "fixed" === h.position);) {
            c = e ? e.getComputedStyle(b, null) : b.currentStyle;
            k -= b.scrollTop;
            l -= b.scrollLeft;
            b === d && (k += b.offsetTop, l += b.offsetLeft, j.offset.doesNotAddBorder && (!j.offset.doesAddBorderForTableAndCells || !Mb.test(b.nodeName)) && (k += parseFloat(c.borderTopWidth) || 0, l += parseFloat(c.borderLeftWidth) || 0), d = b.offsetParent);
            j.offset.subtractsBorderForOverflowNotVisible && "visible" !== c.overflow &&
            (k += parseFloat(c.borderTopWidth) || 0, l += parseFloat(c.borderLeftWidth) || 0);
            h = c
        }
        if ("relative" === h.position || "static" === h.position)k += g.offsetTop, l += g.offsetLeft;
        j.offset.supportsFixedPosition && "fixed" === h.position && (k += Math.max(f.scrollTop, g.scrollTop), l += Math.max(f.scrollLeft, g.scrollLeft));
        return {top: k, left: l}
    };
    j.offset = {
        initialize: function () {
            var a = s.body, b = s.createElement("div"), c, d, e, f = parseFloat(j.css(a, "marginTop")) || 0;
            j.extend(b.style, {
                position: "absolute", top: 0, left: 0, margin: 0, border: 0, width: "1px",
                height: "1px", visibility: "hidden"
            });
            b.innerHTML = "<div style='position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;'><div></div></div><table style='position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;' cellpadding='0' cellspacing='0'><tr><td></td></tr></table>";
            a.insertBefore(b, a.firstChild);
            c = b.firstChild;
            d = c.firstChild;
            e = c.nextSibling.firstChild.firstChild;
            this.doesNotAddBorder = 5 !== d.offsetTop;
            this.doesAddBorderForTableAndCells =
                5 === e.offsetTop;
            d.style.position = "fixed";
            d.style.top = "20px";
            this.supportsFixedPosition = 20 === d.offsetTop || 15 === d.offsetTop;
            d.style.position = d.style.top = "";
            c.style.overflow = "hidden";
            c.style.position = "relative";
            this.subtractsBorderForOverflowNotVisible = -5 === d.offsetTop;
            this.doesNotIncludeMarginInBodyOffset = a.offsetTop !== f;
            a.removeChild(b);
            j.offset.initialize = j.noop
        }, bodyOffset: function (a) {
            var b = a.offsetTop, c = a.offsetLeft;
            j.offset.initialize();
            j.offset.doesNotIncludeMarginInBodyOffset && (b += parseFloat(j.css(a,
                "marginTop")) || 0, c += parseFloat(j.css(a, "marginLeft")) || 0);
            return {top: b, left: c}
        }, setOffset: function (a, b, c) {
            var d = j.css(a, "position");
            "static" === d && (a.style.position = "relative");
            var e = j(a), f = e.offset(), g = j.css(a, "top"), h = j.css(a, "left"), k = {}, l = {}, m, n;
            ("absolute" === d || "fixed" === d) && -1 < j.inArray("auto", [g, h]) ? (l = e.position(), m = l.top, n = l.left) : (m = parseFloat(g) || 0, n = parseFloat(h) || 0);
            j.isFunction(b) && (b = b.call(a, c, f));
            null != b.top && (k.top = b.top - f.top + m);
            null != b.left && (k.left = b.left - f.left + n);
            "using"in b ?
                b.using.call(a, k) : e.css(k)
        }
    };
    j.fn.extend({
        position: function () {
            if (!this[0])return null;
            var a = this[0], b = this.offsetParent(), c = this.offset(), d = Pa.test(b[0].nodeName) ? {
                top: 0,
                left: 0
            } : b.offset();
            c.top -= parseFloat(j.css(a, "marginTop")) || 0;
            c.left -= parseFloat(j.css(a, "marginLeft")) || 0;
            d.top += parseFloat(j.css(b[0], "borderTopWidth")) || 0;
            d.left += parseFloat(j.css(b[0], "borderLeftWidth")) || 0;
            return {top: c.top - d.top, left: c.left - d.left}
        }, offsetParent: function () {
            return this.map(function () {
                for (var a = this.offsetParent ||
                    s.body; a && !Pa.test(a.nodeName) && "static" === j.css(a, "position");)a = a.offsetParent;
                return a
            })
        }
    });
    j.each(["Left", "Top"], function (a, d) {
        var e = "scroll" + d;
        j.fn[e] = function (d) {
            var f, g;
            if (d === b) {
                f = this[0];
                return !f ? null : (g = c(f)) ? "pageXOffset"in g ? g[a ? "pageYOffset" : "pageXOffset"] : j.support.boxModel && g.document.documentElement[e] || g.document.body[e] : f[e]
            }
            return this.each(function () {
                g = c(this);
                g ? g.scrollTo(a ? j(g).scrollLeft() : d, a ? d : j(g).scrollTop()) : this[e] = d
            })
        }
    });
    j.each(["Height", "Width"], function (a, c) {
        var d =
            c.toLowerCase();
        j.fn["inner" + c] = function () {
            var a = this[0];
            return a && a.style ? parseFloat(j.css(a, d, "padding")) : null
        };
        j.fn["outer" + c] = function (a) {
            var b = this[0];
            return b && b.style ? parseFloat(j.css(b, d, a ? "margin" : "border")) : null
        };
        j.fn[d] = function (a) {
            var e = this[0];
            if (!e)return null == a ? null : this;
            if (j.isFunction(a))return this.each(function (b) {
                var c = j(this);
                c[d](a.call(this, b, c[d]()))
            });
            if (j.isWindow(e)) {
                var f = e.document.documentElement["client" + c];
                return "CSS1Compat" === e.document.compatMode && f || e.document.body["client" +
                    c] || f
            }
            if (9 === e.nodeType)return Math.max(e.documentElement["client" + c], e.body["scroll" + c], e.documentElement["scroll" + c], e.body["offset" + c], e.documentElement["offset" + c]);
            return a === b ? (e = j.css(e, d), f = parseFloat(e), j.isNaN(f) ? e : f) : this.css(d, "string" == typeof a ? a : a + "px")
        }
    });
    a.jQuery = a.$ = j
}(window);
function HashSet(a, b) {
    var c = new Hashtable(a, b);
    this.add = function (a) {
        c.put(a, !0)
    };
    this.addAll = function (a) {
        for (var b = a.length; b--;)c.put(a[b], !0)
    };
    this.values = function () {
        return c.keys()
    };
    this.remove = function (a) {
        return c.remove(a) ? a : null
    };
    this.contains = function (a) {
        return c.containsKey(a)
    };
    this.clear = function () {
        c.clear()
    };
    this.size = function () {
        return c.size()
    };
    this.isEmpty = function () {
        return c.isEmpty()
    };
    this.clone = function () {
        var d = new HashSet(a, b);
        d.addAll(c.keys());
        return d
    };
    this.intersection = function (d) {
        for (var e =
            new HashSet(a, b), d = d.values(), f = d.length, g; f--;)g = d[f], c.containsKey(g) && e.add(g);
        return e
    };
    this.union = function (a) {
        for (var b = this.clone(), a = a.values(), f = a.length, g; f--;)g = a[f], c.containsKey(g) || b.add(g);
        return b
    };
    this.isSubsetOf = function (a) {
        for (var b = c.keys(), f = b.length; f--;)if (!a.contains(b[f]))return !1;
        return !0
    }
}
var Hashtable = function () {
    function a(b) {
        if ("string" == typeof b)return b;
        return typeof b.hashCode == l ? (b = b.hashCode(), "string" == typeof b ? b : a(b)) : typeof b.toString == l ? b.toString() : "" + b
    }

    function b(a, b) {
        return a.equals(b)
    }

    function c(a, b) {
        return typeof b.equals == l ? b.equals(a) : a === b
    }

    function d(a) {
        return function (b) {
            if (null === b)throw Error("null is not a valid " + a);
            if ("undefined" == typeof b)throw Error(a + " must not be undefined");
        }
    }

    function e(a, b, c, d) {
        this[0] = a;
        this.entries = [];
        this.addEntry(b, c);
        null !== d && (this.getEqualityFunction =
            function () {
                return d
            })
    }

    function f(a) {
        return function (b) {
            for (var c = this.entries.length, d, e = this.getEqualityFunction(b); c--;)if (d = this.entries[c], e(b, d[0]))switch (a) {
                case p:
                    return !0;
                case r:
                    return d;
                case u:
                    return [c, d[1]]
            }
            return !1
        }
    }

    function g(a) {
        return function (b) {
            for (var c = b.length, d = 0, e = this.entries.length; d < e; ++d)b[c + d] = this.entries[d][a]
        }
    }

    function h(a, b) {
        var c = a[b];
        return c && c instanceof e ? c : null
    }

    function k(b, c) {
        var d = this, f = [], g = {}, p = typeof b == l ? b : a, r = typeof c == l ? c : null;
        this.put = function (a, b) {
            n(a);
            o(b);
            var c = p(a), d, k = null;
            (d = h(g, c)) ? (c = d.getEntryForKey(a)) ? (k = c[1], c[1] = b) : d.addEntry(a, b) : (d = new e(c, a, b, r), f[f.length] = d, g[c] = d);
            return k
        };
        this.get = function (a) {
            n(a);
            var b = p(a);
            if (b = h(g, b))if (a = b.getEntryForKey(a))return a[1];
            return null
        };
        this.containsKey = function (a) {
            n(a);
            var b = p(a);
            return (b = h(g, b)) ? b.containsKey(a) : !1
        };
        this.containsValue = function (a) {
            o(a);
            for (var b = f.length; b--;)if (f[b].containsValue(a))return !0;
            return !1
        };
        this.clear = function () {
            f.length = 0;
            g = {}
        };
        this.isEmpty = function () {
            return !f.length
        };
        var u = function (a) {
            return function () {
                for (var b = [], c = f.length; c--;)f[c][a](b);
                return b
            }
        };
        this.keys = u("keys");
        this.values = u("values");
        this.entries = u("getEntries");
        this.remove = function (a) {
            n(a);
            var b = p(a), c = null, d = h(g, b);
            if (d && (c = d.removeEntryForKey(a), null !== c && !d.entries.length)) {
                a:{
                    for (a = f.length; a--;)if (d = f[a], b === d[0])break a;
                    a = null
                }
                m(f, a);
                delete g[b]
            }
            return c
        };
        this.size = function () {
            for (var a = 0, b = f.length; b--;)a += f[b].entries.length;
            return a
        };
        this.each = function (a) {
            for (var b = d.entries(), c = b.length,
                     e; c--;)e = b[c], a(e[0], e[1])
        };
        this.putAll = function (a, b) {
            for (var c = a.entries(), e, f, g, h = c.length, k = typeof b == l; h--;) {
                e = c[h];
                f = e[0];
                e = e[1];
                if (k && (g = d.get(f)))e = b(f, g, e);
                d.put(f, e)
            }
        };
        this.clone = function () {
            var a = new k(b, c);
            a.putAll(d);
            return a
        }
    }

    var l = "function", m = typeof Array.prototype.splice == l ? function (a, b) {
        a.splice(b, 1)
    } : function (a, b) {
        var c, d, e;
        if (b === a.length - 1)a.length = b; else {
            c = a.slice(b + 1);
            a.length = b;
            for (d = 0, e = c.length; d < e; ++d)a[b + d] = c[d]
        }
    }, n = d("key"), o = d("value"), p = 0, r = 1, u = 2;
    e.prototype = {
        getEqualityFunction: function (a) {
            return typeof a.equals ==
            l ? b : c
        }, getEntryForKey: f(r), getEntryAndIndexForKey: f(u), removeEntryForKey: function (a) {
            return (a = this.getEntryAndIndexForKey(a)) ? (m(this.entries, a[0]), a[1]) : null
        }, addEntry: function (a, b) {
            this.entries[this.entries.length] = [a, b]
        }, keys: g(0), values: g(1), getEntries: function (a) {
            for (var b = a.length, c = 0, d = this.entries.length; c < d; ++c)a[b + c] = this.entries[c].slice(0)
        }, containsKey: f(p), containsValue: function (a) {
            for (var b = this.entries.length; b--;)if (a === this.entries[b][1])return !0;
            return !1
        }
    };
    return k
}();
Array.indexOf || (Array.prototype.indexOf = function (a) {
    for (var b = 0; b < this.length; b++)if (this[b] == a)return b;
    return -1
});
"undefined" == typeof viettel && (viettel = {});
viettel.Language = {
    MapType: {
        TrafficTitle: "Giao Th&#244;ng",
        AdminTitle: "H&#224;nh ch&#237;nh",
        GTrafficTitle: "Google",
        GSatelliteTitle: "V&#7879; tinh"
    },
    SearchControl: {searchButtonValue: "T\u00ecm ki\u1ebfm", defaultText: "T\u00ecm ki\u1ebfm b\u1ea3n \u0111\u1ed3"},
    RoutingRenderer: {
        routeWaitingValue: "&#272;ang t&#236;m l&#7897; tr&#236;nh, xin vui l&#242;ng ch&#7901; trong gi&#226;y l&#225;t...",
        routeEmptyValue: "Kh&#244;ng t&#236;m th&#7845;y k&#7871;t qu&#7843; n&#224;o. Xin vui l&#242;ng xem l&#7841;i th&#244;ng tin &#273;&#7847;u v&#224;o!",
        routeErrorValue: "C&#243; l&#7895;i x&#7843;y ra. C&#243; th&#7875; do b&#7841;n ch&#432;a thi&#7871;t l&#7853;p &#273;&#7847;y &#273;&#7911; th&#244;ng tin.",
        routeNoResultValue: "Kh&#244;ng t&#236;m th&#7845;y l&#7897; tr&#236;nh n&#224;o ph&#249; h&#7907;p.",
        instructionStartValue: "B&#x1EAF;t &#x111;&#x1EA7;u t&#x1EEB; ",
        instructionRoundAboutValue: "V&#224;o b&#249;ng binh r&#x1ED3;i ",
        instructionToValue: "sang",
        instructionIntoValue: " v&#224;o",
        instructionAtValue: " t&#7841;i",
        lengthTotalValue: "T&#x1ED5;ng chi&#x1EC1;u d&#224;i",
        alternativeRouteTitle: "Tuy&#7871;n g&#7907;i &#253",
        unknownRoadName: "&#272;&#432;&#7901;ng kh&#244;ng t&#234;n",
        instructionHeadOnValue: "B&#7855;t &#273;&#7847;u t&#7915;",
        instructionGoAheadValue: "&#x110;i th&#x1EB3;ng",
        instructionLeftLaneValue: "Ch&#x1EBF;ch sang tr&#225;i",
        instructionRightLaneValue: "Ch&#x1EBF;ch sang ph&#x1EA3;i",
        instructionTurnLeftValue: "R&#x1EBD; tr&#225;i",
        instructionTurnRightValue: "R&#x1EBD; ph&#x1EA3;i",
        instructionTwistLeftValue: "V&#242;ng sang tr&#225;i",
        instructionTwistRightValue: "V&#242;ng sang ph&#x1EA3;i",
        instructionTurnBackValue: "Quay &#x111;&#x1EA7;u xe",
        instructionToDestinationValue: "V&#x1EC1; &#x111;&#237;ch"
    },
    RoadDrawer: {
        infoBoxRouteTitle: "Th&#244;ng tin tuy&#7871;n v&#7869;",
        infoBoxTotalLengthTitle: "T&#7893;ng kho&#7843;ng c&#225;ch",
        routeStopDrawMessage: "B\u001eA1n c\u00f3 ch\u001eAFc k\u001eBFt th\u00fac v\u001eBD tuy\u001eBFt kh\u00f4ng?",
        routeDrawCompleteMessage: "Ho&#224;n th&#224;nh v&#7869; tuy&#7871;n",
        noRouteToPointMessage: "Kh&#244;ng c&#243; &#273;&#432;&#7901;ng &#273;i t&#7899;i &#273;i&#7875;m v&#7915;a ch&#7885;n"
    }
};
var key = "TTUDCNTT_KEY_TEST", enableSlideDragging = !1, CONTROL_ZINDEX = 1E3, INFOWINDOW_ZINDEX_DEFAULT = 802, DOM_LAYER_ZINDEX = 800, EVENT_LAYER_ZINDEX = 801, EARTH_RADIUS = 6378137, API_VERSION = 2, vtMapService = "VTMapService/", wmsService = vtMapService + "wms", routingService = vtMapService + "routing", geoprocessingService = vtMapService + "geoprocessing", geocodeService = vtMapService + "geocoding", geodataService = vtMapService + "geodata", administrationService = vtMapService + "administrationService", pointService = vtMapService + "poiEventService",
    imageService = vtMapService + "imageService", jQuery4Map = jQuery.noConflict(), mapUnit = "degrees", bgMapColor = "0xf4f3f0", originalProjectionName = "EPSG:900913";
"undefined" == typeof urlServer && (urlServer = "http://103.1.210.129:6672/");
var OpenLayersEX_ImgLoc = urlServer + "map/ol/img_ext/", OpenLayersEX_CSSLoc = urlServer + "map/ol/img_ext/style_ex.css", OpenLayersEX_DrawCSSLoc = urlServer + "map/ol/img_ext/road_drawer.css", OpenLayersEx_OpenHandCursor = urlServer + "map/ol/img_ext/openhand.cur", OpenLayersEx_ClosedHandCursor = urlServer + "map/ol/img_ext/closedhand.cur", OpenLayers = {
    VERSION_NUMBER: "Release 2.12", singleFile: !0, _getScriptLocation: function () {
        for (var a = /(^|(.*?\/))(OpenLayers[^\/]*?\.js)(\?|$)/, b = document.getElementsByTagName("script"), c,
                 d = "", e = 0, f = b.length; e < f; e++)if (c = b[e].getAttribute("src"))if (c = c.match(a)) {
            d = c[1];
            break
        }
        return function () {
            return d
        }
    }(), ImgPath: urlServer + "/map/ol/img/"
};
OpenLayers.Class = function () {
    var a = arguments.length, b = arguments[0], c = arguments[a - 1], d = "function" == typeof c.initialize ? c.initialize : function () {
        b.prototype.initialize.apply(this, arguments)
    };
    1 < a ? (a = [d, b].concat(Array.prototype.slice.call(arguments).slice(1, a - 1), c), OpenLayers.inherit.apply(null, a)) : d.prototype = c;
    return d
};
OpenLayers.inherit = function (a, b) {
    var c = function () {
    };
    c.prototype = b.prototype;
    a.prototype = new c;
    var d, e;
    for (c = 2, d = arguments.length; c < d; c++)e = arguments[c], "function" === typeof e && (e = e.prototype), OpenLayers.Util.extend(a.prototype, e)
};
OpenLayers.Util = OpenLayers.Util || {};
OpenLayers.Util.extend = function (a, b) {
    a = a || {};
    if (b) {
        for (var c in b) {
            var d = b[c];
            void 0 !== d && (a[c] = d)
        }
        !("function" == typeof window.Event && b instanceof window.Event) && b.hasOwnProperty && b.hasOwnProperty("toString") && (a.toString = b.toString)
    }
    return a
};
OpenLayers.Util = OpenLayers.Util || {};
OpenLayers.Util.getElement = function () {
    for (var a = [], b = 0, c = arguments.length; b < c; b++) {
        var d = arguments[b];
        "string" == typeof d && (d = document.getElementById(d));
        if (1 == arguments.length)return d;
        a.push(d)
    }
    return a
};
OpenLayers.Util.isElement = function (a) {
    return !!(a && 1 === a.nodeType)
};
OpenLayers.Util.isArray = function (a) {
    return "[object Array]" === Object.prototype.toString.call(a)
};
"undefined" === typeof window.$ && (window.$ = OpenLayers.Util.getElement);
OpenLayers.Util.removeItem = function (a, b) {
    for (var c = a.length - 1; 0 <= c; c--)a[c] == b && a.splice(c, 1);
    return a
};
OpenLayers.Util.indexOf = function (a, b) {
    if ("function" == typeof a.indexOf)return a.indexOf(b);
    for (var c = 0, d = a.length; c < d; c++)if (a[c] == b)return c;
    return -1
};
OpenLayers.Util.modifyDOMElement = function (a, b, c, d, e, f, g, h) {
    b && (a.id = b);
    c && (a.style.left = c.x + "px", a.style.top = c.y + "px");
    d && (a.style.width = d.w + "px", a.style.height = d.h + "px");
    e && (a.style.position = e);
    f && (a.style.border = f);
    g && (a.style.overflow = g);
    0 <= parseFloat(h) && 1 > parseFloat(h) ? (a.style.filter = "alpha(opacity=" + 100 * h + ")", a.style.opacity = h) : 1 == parseFloat(h) && (a.style.filter = "", a.style.opacity = "")
};
OpenLayers.Util.createDiv = function (a, b, c, d, e, f, g, h) {
    var k = document.createElement("div");
    d && (k.style.backgroundImage = "url(" + d + ")");
    a || (a = OpenLayers.Util.createUniqueID("OpenLayersDiv"));
    e || (e = "absolute");
    OpenLayers.Util.modifyDOMElement(k, a, b, c, e, f, g, h);
    return k
};
OpenLayers.Util.createImage = function (a, b, c, d, e, f, g, h) {
    var k = document.createElement("img");
    a || (a = OpenLayers.Util.createUniqueID("OpenLayersDiv"));
    e || (e = "relative");
    OpenLayers.Util.modifyDOMElement(k, a, b, c, e, f, null, g);
    h && (k.style.display = "none", b = function () {
        k.style.display = "";
        OpenLayers.Event.stopObservingElement(k)
    }, OpenLayers.Event.observe(k, "load", b), OpenLayers.Event.observe(k, "error", b));
    k.style.alt = a;
    k.galleryImg = "no";
    d && (k.src = d);
    return k
};
OpenLayers.IMAGE_RELOAD_ATTEMPTS = 0;
OpenLayers.Util.alphaHackNeeded = null;
OpenLayers.Util.alphaHack = function () {
    if (null == OpenLayers.Util.alphaHackNeeded) {
        var a = navigator.appVersion.split("MSIE"), a = parseFloat(a[1]), b = !1;
        try {
            b = !!document.body.filters
        } catch (c) {
        }
        OpenLayers.Util.alphaHackNeeded = b && 5.5 <= a && 7 > a
    }
    return OpenLayers.Util.alphaHackNeeded
};
OpenLayers.Util.modifyAlphaImageDiv = function (a, b, c, d, e, f, g, h, k) {
    OpenLayers.Util.modifyDOMElement(a, b, c, d, f, null, null, k);
    b = a.childNodes[0];
    e && (b.src = e);
    OpenLayers.Util.modifyDOMElement(b, a.id + "_innerImage", null, d, "relative", g);
    OpenLayers.Util.alphaHack() && ("none" != a.style.display && (a.style.display = "inline-block"), null == h && (h = "scale"), a.style.filter = "progid:DXImageTransform.Microsoft.AlphaImageLoader(src='" + b.src + "', sizingMethod='" + h + "')", 0 <= parseFloat(a.style.opacity) && 1 > parseFloat(a.style.opacity) &&
    (a.style.filter += " alpha(opacity=" + 100 * a.style.opacity + ")"), b.style.filter = "alpha(opacity=0)")
};
OpenLayers.Util.createAlphaImageDiv = function (a, b, c, d, e, f, g, h, k) {
    var l = OpenLayers.Util.createDiv(), k = OpenLayers.Util.createImage(null, null, null, null, null, null, null, k);
    k.className = "olAlphaImg";
    l.appendChild(k);
    OpenLayers.Util.modifyAlphaImageDiv(l, a, b, c, d, e, f, g, h);
    return l
};
OpenLayers.Util.upperCaseObject = function (a) {
    var b = {}, c;
    for (c in a)b[c.toUpperCase()] = a[c];
    return b
};
OpenLayers.Util.applyDefaults = function (a, b) {
    var a = a || {}, c = "function" == typeof window.Event && b instanceof window.Event, d;
    for (d in b)if (void 0 === a[d] || !c && b.hasOwnProperty && b.hasOwnProperty(d) && !a.hasOwnProperty(d))a[d] = b[d];
    !c && b && b.hasOwnProperty && b.hasOwnProperty("toString") && !a.hasOwnProperty("toString") && (a.toString = b.toString);
    return a
};
OpenLayers.Util.getParameterString = function (a) {
    var b = [], c;
    for (c in a) {
        var d = a[c];
        if (null != d && "function" != typeof d) {
            if ("object" == typeof d && d.constructor == Array) {
                for (var e = [], f, g = 0, h = d.length; g < h; g++)f = d[g], e.push(encodeURIComponent(null === f || void 0 === f ? "" : f));
                d = e.join(",")
            } else d = encodeURIComponent(d);
            b.push(encodeURIComponent(c) + "=" + d)
        }
    }
    return b.join("&")
};
OpenLayers.Util.urlAppend = function (a, b) {
    var c = a;
    if (b)var d = (a + " ").split(/[?&]/), c = c + (" " === d.pop() ? b : d.length ? "&" + b : "?" + b);
    return c
};
OpenLayers.Util.getImagesLocation = function () {
    return OpenLayers.ImgPath || OpenLayers._getScriptLocation() + "img/"
};
OpenLayers.Util.getImageLocation = function (a) {
    return OpenLayers.Util.getImagesLocation() + a
};
OpenLayers.Util.Try = function () {
    for (var a = null, b = 0, c = arguments.length; b < c; b++) {
        var d = arguments[b];
        try {
            a = d();
            break
        } catch (e) {
        }
    }
    return a
};
OpenLayers.Util.getXmlNodeValue = function (a) {
    var b = null;
    OpenLayers.Util.Try(function () {
        (b = a.text) || (b = a.textContent);
        b || (b = a.firstChild.nodeValue)
    }, function () {
        b = a.textContent
    });
    return b
};
OpenLayers.Util.mouseLeft = function (a, b) {
    for (var c = a.relatedTarget ? a.relatedTarget : a.toElement; c != b && null != c;)c = c.parentNode;
    return c != b
};
OpenLayers.Util.DEFAULT_PRECISION = 14;
OpenLayers.Util.toFloat = function (a, b) {
    null == b && (b = OpenLayers.Util.DEFAULT_PRECISION);
    "number" !== typeof a && (a = parseFloat(a));
    return 0 === b ? a : parseFloat(a.toPrecision(b))
};
OpenLayers.Util.rad = function (a) {
    return a * Math.PI / 180
};
OpenLayers.Util.deg = function (a) {
    return 180 * a / Math.PI
};
OpenLayers.Util.VincentyConstants = {a: 6378137, b: 6356752.3142, f: 1 / 298.257223563};
OpenLayers.Util.distVincenty = function (a, b) {
    for (var c = OpenLayers.Util.VincentyConstants, d = c.a, e = c.b, c = c.f, f = OpenLayers.Util.rad(b.lon - a.lon), g = Math.atan((1 - c) * Math.tan(OpenLayers.Util.rad(a.lat))), h = Math.atan((1 - c) * Math.tan(OpenLayers.Util.rad(b.lat))), k = Math.sin(g), g = Math.cos(g), l = Math.sin(h), h = Math.cos(h), m = f, n = 2 * Math.PI, o = 20; 1.0E-12 < Math.abs(m - n) && 0 < --o;) {
        var p = Math.sin(m), r = Math.cos(m), u = Math.sqrt(h * p * h * p + (g * l - k * h * r) * (g * l - k * h * r));
        if (0 == u)return 0;
        var r = k * l + g * h * r, q = Math.atan2(u, r), t = Math.asin(g *
        h * p / u), y = Math.cos(t) * Math.cos(t), p = r - 2 * k * l / y, w = c / 16 * y * (4 + c * (4 - 3 * y)), n = m, m = f + (1 - w) * c * Math.sin(t) * (q + w * u * (p + w * r * (-1 + 2 * p * p)))
    }
    if (0 == o)return NaN;
    d = y * (d * d - e * e) / (e * e);
    c = d / 1024 * (256 + d * (-128 + d * (74 - 47 * d)));
    return (e * (1 + d / 16384 * (4096 + d * (-768 + d * (320 - 175 * d)))) * (q - c * u * (p + c / 4 * (r * (-1 + 2 * p * p) - c / 6 * p * (-3 + 4 * u * u) * (-3 + 4 * p * p))))).toFixed(3) / 1E3
};
OpenLayers.Util.destinationVincenty = function (a, b, c) {
    for (var d = OpenLayers.Util, e = d.VincentyConstants, f = e.a, g = e.b, h = e.f, e = a.lon, a = a.lat, k = d.rad(b), b = Math.sin(k), k = Math.cos(k), a = (1 - h) * Math.tan(d.rad(a)), l = 1 / Math.sqrt(1 + a * a), m = a * l, n = Math.atan2(a, k), a = l * b, o = 1 - a * a, f = o * (f * f - g * g) / (g * g), p = 1 + f / 16384 * (4096 + f * (-768 + f * (320 - 175 * f))), r = f / 1024 * (256 + f * (-128 + f * (74 - 47 * f))), f = c / (g * p), u = 2 * Math.PI; 1.0E-12 < Math.abs(f - u);)var q = Math.cos(2 * n + f), t = Math.sin(f), y = Math.cos(f), w = r * t * (q + r / 4 * (y * (-1 + 2 * q * q) - r / 6 * q * (-3 + 4 * t * t) * (-3 + 4 *
        q * q))), u = f, f = c / (g * p) + w;
    c = m * t - l * y * k;
    g = Math.atan2(m * y + l * t * k, (1 - h) * Math.sqrt(a * a + c * c));
    b = Math.atan2(t * b, l * y - m * t * k);
    k = h / 16 * o * (4 + h * (4 - 3 * o));
    q = b - (1 - k) * h * a * (f + k * t * (q + k * y * (-1 + 2 * q * q)));
    Math.atan2(a, -c);
    return new OpenLayers.LonLat(e + d.deg(q), d.deg(g))
};
OpenLayers.Util.getParameters = function (a) {
    var a = null === a || void 0 === a ? window.location.href : a, b = "";
    if (OpenLayers.String.contains(a, "?"))var b = a.indexOf("?") + 1, c = OpenLayers.String.contains(a, "#") ? a.indexOf("#") : a.length, b = a.substring(b, c);
    for (var a = {}, b = b.split(/[&;]/), c = 0, d = b.length; c < d; ++c) {
        var e = b[c].split("=");
        if (e[0]) {
            var f = e[0];
            try {
                f = decodeURIComponent(f)
            } catch (g) {
                f = unescape(f)
            }
            e = (e[1] || "").replace(/\+/g, " ");
            try {
                e = decodeURIComponent(e)
            } catch (h) {
                e = unescape(e)
            }
            e = e.split(",");
            1 == e.length && (e = e[0]);
            a[f] = e
        }
    }
    return a
};
OpenLayers.Util.lastSeqID = 0;
OpenLayers.Util.createUniqueID = function (a) {
    null == a && (a = "id_");
    OpenLayers.Util.lastSeqID += 1;
    return a + OpenLayers.Util.lastSeqID
};
OpenLayers.INCHES_PER_UNIT = {inches: 1, ft: 12, mi: 63360, m: 39.3701, km: 39370.1, dd: 4374754, yd: 36};
OpenLayers.INCHES_PER_UNIT["in"] = OpenLayers.INCHES_PER_UNIT.inches;
OpenLayers.INCHES_PER_UNIT.degrees = OpenLayers.INCHES_PER_UNIT.dd;
OpenLayers.INCHES_PER_UNIT.nmi = 1852 * OpenLayers.INCHES_PER_UNIT.m;
OpenLayers.METERS_PER_INCH = 0.0254000508001016;
OpenLayers.Util.extend(OpenLayers.INCHES_PER_UNIT, {
    Inch: OpenLayers.INCHES_PER_UNIT.inches,
    Meter: 1 / OpenLayers.METERS_PER_INCH,
    Foot: 0.3048006096012192 / OpenLayers.METERS_PER_INCH,
    IFoot: 0.3048 / OpenLayers.METERS_PER_INCH,
    ClarkeFoot: 0.3047972651151 / OpenLayers.METERS_PER_INCH,
    SearsFoot: 0.30479947153867626 / OpenLayers.METERS_PER_INCH,
    GoldCoastFoot: 0.3047997101815088 / OpenLayers.METERS_PER_INCH,
    IInch: 0.0254 / OpenLayers.METERS_PER_INCH,
    MicroInch: 2.54E-5 / OpenLayers.METERS_PER_INCH,
    Mil: 2.54E-8 / OpenLayers.METERS_PER_INCH,
    Centimeter: 0.01 / OpenLayers.METERS_PER_INCH,
    Kilometer: 1E3 / OpenLayers.METERS_PER_INCH,
    Yard: 0.9144018288036576 / OpenLayers.METERS_PER_INCH,
    SearsYard: 0.914398414616029 / OpenLayers.METERS_PER_INCH,
    IndianYard: 0.9143985307444408 / OpenLayers.METERS_PER_INCH,
    IndianYd37: 0.91439523 / OpenLayers.METERS_PER_INCH,
    IndianYd62: 0.9143988 / OpenLayers.METERS_PER_INCH,
    IndianYd75: 0.9143985 / OpenLayers.METERS_PER_INCH,
    IndianFoot: 0.30479951 / OpenLayers.METERS_PER_INCH,
    IndianFt37: 0.30479841 / OpenLayers.METERS_PER_INCH,
    IndianFt62: 0.3047996 /
    OpenLayers.METERS_PER_INCH,
    IndianFt75: 0.3047995 / OpenLayers.METERS_PER_INCH,
    Mile: 1609.3472186944373 / OpenLayers.METERS_PER_INCH,
    IYard: 0.9144 / OpenLayers.METERS_PER_INCH,
    IMile: 1609.344 / OpenLayers.METERS_PER_INCH,
    NautM: 1852 / OpenLayers.METERS_PER_INCH,
    "Lat-66": 110943.31648893273 / OpenLayers.METERS_PER_INCH,
    "Lat-83": 110946.25736872235 / OpenLayers.METERS_PER_INCH,
    Decimeter: 0.1 / OpenLayers.METERS_PER_INCH,
    Millimeter: 0.001 / OpenLayers.METERS_PER_INCH,
    Dekameter: 10 / OpenLayers.METERS_PER_INCH,
    Decameter: 10 / OpenLayers.METERS_PER_INCH,
    Hectometer: 100 / OpenLayers.METERS_PER_INCH,
    GermanMeter: 1.0000135965 / OpenLayers.METERS_PER_INCH,
    CaGrid: 0.999738 / OpenLayers.METERS_PER_INCH,
    ClarkeChain: 20.1166194976 / OpenLayers.METERS_PER_INCH,
    GunterChain: 20.11684023368047 / OpenLayers.METERS_PER_INCH,
    BenoitChain: 20.116782494375872 / OpenLayers.METERS_PER_INCH,
    SearsChain: 20.11676512155 / OpenLayers.METERS_PER_INCH,
    ClarkeLink: 0.201166194976 / OpenLayers.METERS_PER_INCH,
    GunterLink: 0.2011684023368047 / OpenLayers.METERS_PER_INCH,
    BenoitLink: 0.20116782494375873 / OpenLayers.METERS_PER_INCH,
    SearsLink: 0.2011676512155 / OpenLayers.METERS_PER_INCH,
    Rod: 5.02921005842012 / OpenLayers.METERS_PER_INCH,
    IntnlChain: 20.1168 / OpenLayers.METERS_PER_INCH,
    IntnlLink: 0.201168 / OpenLayers.METERS_PER_INCH,
    Perch: 5.02921005842012 / OpenLayers.METERS_PER_INCH,
    Pole: 5.02921005842012 / OpenLayers.METERS_PER_INCH,
    Furlong: 201.1684023368046 / OpenLayers.METERS_PER_INCH,
    Rood: 3.778266898 / OpenLayers.METERS_PER_INCH,
    CapeFoot: 0.3047972615 / OpenLayers.METERS_PER_INCH,
    Brealey: 375 / OpenLayers.METERS_PER_INCH,
    ModAmFt: 0.304812252984506 /
    OpenLayers.METERS_PER_INCH,
    Fathom: 1.8288 / OpenLayers.METERS_PER_INCH,
    "NautM-UK": 1853.184 / OpenLayers.METERS_PER_INCH,
    "50kilometers": 5E4 / OpenLayers.METERS_PER_INCH,
    "150kilometers": 15E4 / OpenLayers.METERS_PER_INCH
});
OpenLayers.Util.extend(OpenLayers.INCHES_PER_UNIT, {
    mm: OpenLayers.INCHES_PER_UNIT.Meter / 1E3,
    cm: OpenLayers.INCHES_PER_UNIT.Meter / 100,
    dm: 100 * OpenLayers.INCHES_PER_UNIT.Meter,
    km: 1E3 * OpenLayers.INCHES_PER_UNIT.Meter,
    kmi: OpenLayers.INCHES_PER_UNIT.nmi,
    fath: OpenLayers.INCHES_PER_UNIT.Fathom,
    ch: OpenLayers.INCHES_PER_UNIT.IntnlChain,
    link: OpenLayers.INCHES_PER_UNIT.IntnlLink,
    "us-in": OpenLayers.INCHES_PER_UNIT.inches,
    "us-ft": OpenLayers.INCHES_PER_UNIT.Foot,
    "us-yd": OpenLayers.INCHES_PER_UNIT.Yard,
    "us-ch": OpenLayers.INCHES_PER_UNIT.GunterChain,
    "us-mi": OpenLayers.INCHES_PER_UNIT.Mile,
    "ind-yd": OpenLayers.INCHES_PER_UNIT.IndianYd37,
    "ind-ft": OpenLayers.INCHES_PER_UNIT.IndianFt37,
    "ind-ch": 20.11669506 / OpenLayers.METERS_PER_INCH
});
OpenLayers.DOTS_PER_INCH = 72;
OpenLayers.Util.normalizeScale = function (a) {
    return 1 < a ? 1 / a : a
};
OpenLayers.Util.getResolutionFromScale = function (a, b) {
    var c;
    a && (null == b && (b = "degrees"), c = 1 / (OpenLayers.Util.normalizeScale(a) * OpenLayers.INCHES_PER_UNIT[b] * OpenLayers.DOTS_PER_INCH));
    return c
};
OpenLayers.Util.getScaleFromResolution = function (a, b) {
    null == b && (b = "degrees");
    return a * OpenLayers.INCHES_PER_UNIT[b] * OpenLayers.DOTS_PER_INCH
};
OpenLayers.Util.pagePosition = function (a) {
    var b = [0, 0], c = OpenLayers.Util.getViewportElement();
    if (!a || a == window || a == c)return b;
    var d = OpenLayers.IS_GECKO && document.getBoxObjectFor && "absolute" == OpenLayers.Element.getStyle(a, "position") && ("" == a.style.top || "" == a.style.left), e = null;
    if (a.getBoundingClientRect)a = a.getBoundingClientRect(), e = c.scrollTop, b[0] = a.left + c.scrollLeft, b[1] = a.top + e; else if (document.getBoxObjectFor && !d)a = document.getBoxObjectFor(a), c = document.getBoxObjectFor(c), b[0] = a.screenX - c.screenX,
        b[1] = a.screenY - c.screenY; else {
        b[0] = a.offsetLeft;
        b[1] = a.offsetTop;
        e = a.offsetParent;
        if (e != a)for (; e;)b[0] += e.offsetLeft, b[1] += e.offsetTop, e = e.offsetParent;
        c = OpenLayers.BROWSER_NAME;
        if ("opera" == c || "safari" == c && "absolute" == OpenLayers.Element.getStyle(a, "position"))b[1] -= document.body.offsetTop;
        for (e = a.offsetParent; e && e != document.body;) {
            b[0] -= e.scrollLeft;
            if ("opera" != c || "TR" != e.tagName)b[1] -= e.scrollTop;
            e = e.offsetParent
        }
    }
    return b
};
OpenLayers.Util.getViewportElement = function () {
    var a = arguments.callee.viewportElement;
    void 0 == a && (a = "msie" == OpenLayers.BROWSER_NAME && "CSS1Compat" != document.compatMode ? document.body : document.documentElement, arguments.callee.viewportElement = a);
    return a
};
OpenLayers.Util.isEquivalentUrl = function (a, b, c) {
    c = c || {};
    OpenLayers.Util.applyDefaults(c, {ignoreCase: !0, ignorePort80: !0, ignoreHash: !0});
    var a = OpenLayers.Util.createUrlObject(a, c), b = OpenLayers.Util.createUrlObject(b, c), d;
    for (d in a)if ("args" !== d && a[d] != b[d])return !1;
    for (d in a.args) {
        if (a.args[d] != b.args[d])return !1;
        delete b.args[d]
    }
    for (d in b.args)return !1;
    return !0
};
OpenLayers.Util.createUrlObject = function (a, b) {
    b = b || {};
    if (!/^\w+:\/\//.test(a)) {
        var c = window.location, d = c.port ? ":" + c.port : "", d = c.protocol + "//" + c.host.split(":").shift() + d;
        0 === a.indexOf("/") ? a = d + a : (c = c.pathname.split("/"), c.pop(), a = d + c.join("/") + "/" + a)
    }
    b.ignoreCase && (a = a.toLowerCase());
    c = document.createElement("a");
    c.href = a;
    d = {};
    d.host = c.host.split(":").shift();
    d.protocol = c.protocol;
    d.port = b.ignorePort80 ? "80" == c.port || "0" == c.port ? "" : c.port : "" == c.port || "0" == c.port ? "80" : c.port;
    d.hash = b.ignoreHash || "#" ===
    c.hash ? "" : c.hash;
    var e = c.search;
    e || (e = a.indexOf("?"), e = -1 != e ? a.substr(e) : "");
    d.args = OpenLayers.Util.getParameters(e);
    d.pathname = "/" == c.pathname.charAt(0) ? c.pathname : "/" + c.pathname;
    return d
};
OpenLayers.Util.removeTail = function (a) {
    var b = null, b = a.indexOf("?"), c = a.indexOf("#");
    return -1 == b ? -1 != c ? a.substr(0, c) : a : -1 != c ? a.substr(0, Math.min(b, c)) : a.substr(0, b)
};
OpenLayers.IS_GECKO = function () {
    var a = navigator.userAgent.toLowerCase();
    return -1 == a.indexOf("webkit") && -1 != a.indexOf("gecko")
}();
OpenLayers.CANVAS_SUPPORTED = function () {
    var a = document.createElement("canvas");
    return !(!a.getContext || !a.getContext("2d"))
}();
OpenLayers.BROWSER_NAME = function () {
    var a = "", b = navigator.userAgent.toLowerCase();
    -1 != b.indexOf("opera") ? a = "opera" : -1 != b.indexOf("msie") ? a = "msie" : -1 != b.indexOf("safari") ? a = "safari" : -1 != b.indexOf("mozilla") && (a = -1 != b.indexOf("firefox") ? "firefox" : "mozilla");
    return a
}();
OpenLayers.Util.getBrowserName = function () {
    return OpenLayers.BROWSER_NAME
};
OpenLayers.Util.getRenderedDimensions = function (a, b, c) {
    var d, e, f = document.createElement("div");
    f.style.visibility = "hidden";
    for (var g = c && c.containerElement ? c.containerElement : document.body, h = !1, k = null, l = g; l && "body" != l.tagName.toLowerCase();) {
        var m = OpenLayers.Element.getStyle(l, "position");
        if ("absolute" == m) {
            h = !0;
            break
        } else if (m && "static" != m)break;
        l = l.parentNode
    }
    if (h && (0 === g.clientHeight || 0 === g.clientWidth))k = document.createElement("div"), k.style.visibility = "hidden", k.style.position = "absolute", k.style.overflow =
        "visible", k.style.width = document.body.clientWidth + "px", k.style.height = document.body.clientHeight + "px", k.appendChild(f);
    f.style.position = "absolute";
    b && (b.w ? (d = b.w, f.style.width = d + "px") : b.h && (e = b.h, f.style.height = e + "px"));
    c && c.displayClass && (f.className = c.displayClass);
    b = document.createElement("div");
    b.innerHTML = a;
    b.style.overflow = "visible";
    if (b.childNodes) {
        a = 0;
        for (c = b.childNodes.length; a < c; a++)b.childNodes[a].style && (b.childNodes[a].style.overflow = "visible")
    }
    f.appendChild(b);
    k ? g.appendChild(k) : g.appendChild(f);
    d || (d = parseInt(b.scrollWidth), f.style.width = d + "px");
    e || (e = parseInt(b.scrollHeight));
    f.removeChild(b);
    k ? (k.removeChild(f), g.removeChild(k)) : g.removeChild(f);
    return new OpenLayers.Size(d, e)
};
OpenLayers.Util.getScrollbarWidth = function () {
    var a = OpenLayers.Util._scrollbarWidth;
    if (null == a) {
        var b = null, c = null, b = document.createElement("div");
        b.style.position = "absolute";
        b.style.top = "-1000px";
        b.style.left = "-1000px";
        b.style.width = "100px";
        b.style.height = "50px";
        b.style.overflow = "hidden";
        c = document.createElement("div");
        c.style.width = "100%";
        c.style.height = "200px";
        b.appendChild(c);
        document.body.appendChild(b);
        a = c.offsetWidth;
        b.style.overflow = "scroll";
        b = c.offsetWidth;
        document.body.removeChild(document.body.lastChild);
        OpenLayers.Util._scrollbarWidth = a - b;
        a = OpenLayers.Util._scrollbarWidth
    }
    return a
};
OpenLayers.Util.getFormattedLonLat = function (a, b, c) {
    c || (c = "dms");
    var a = (a + 540) % 360 - 180, d = Math.abs(a), e = Math.floor(d), f = d = (d - e) / (1 / 60), d = Math.floor(d), f = Math.round(10 * ((f - d) / (1 / 60))), f = f / 10;
    60 <= f && (f -= 60, d += 1, 60 <= d && (d -= 60, e += 1));
    10 > e && (e = "0" + e);
    e += "\u00b0";
    0 <= c.indexOf("dm") && (10 > d && (d = "0" + d), e += d + "'", 0 <= c.indexOf("dms") && (10 > f && (f = "0" + f), e += f + '"'));
    return "lon" == b ? e + (0 > a ? OpenLayers.i18n("W") : OpenLayers.i18n("E")) : e + (0 > a ? OpenLayers.i18n("S") : OpenLayers.i18n("N"))
};
OpenLayers.Animation = function (a) {
    var b = !(!a.requestAnimationFrame && !a.webkitRequestAnimationFrame && !a.mozRequestAnimationFrame && !a.oRequestAnimationFrame && !a.msRequestAnimationFrame), c = function () {
        var b = a.requestAnimationFrame || a.webkitRequestAnimationFrame || a.mozRequestAnimationFrame || a.oRequestAnimationFrame || a.msRequestAnimationFrame || function (b) {
                a.setTimeout(b, 16)
            };
        return function (c, d) {
            b.apply(a, [c, d])
        }
    }(), d = 0, e = {};
    return {
        isNative: b, requestFrame: c, start: function (a, b, h) {
            var b = 0 < b ? b : Number.POSITIVE_INFINITY,
                k = ++d, l = +new Date;
            e[k] = function () {
                e[k] && +new Date - l <= b ? (a(), e[k] && c(e[k], h)) : delete e[k]
            };
            c(e[k], h);
            return k
        }, stop: function (a) {
            delete e[a]
        }
    }
}(window);
OpenLayers.String = {
    startsWith: function (a, b) {
        return 0 == a.indexOf(b)
    },
    contains: function (a, b) {
        return -1 != a.indexOf(b)
    },
    trim: function (a) {
        return a.replace(/^\s\s*/, "").replace(/\s\s*$/, "")
    },
    camelize: function (a) {
        for (var a = a.split("-"), b = a[0], c = 1, d = a.length; c < d; c++)var e = a[c], b = b + (e.charAt(0).toUpperCase() + e.substring(1));
        return b
    },
    format: function (a, b, c) {
        b || (b = window);
        return a.replace(OpenLayers.String.tokenRegEx, function (a, e) {
            for (var f, g = e.split(/\.+/), h = 0; h < g.length; h++)0 == h && (f = b), f = f[g[h]];
            "function" == typeof f && (f = c ? f.apply(null, c) : f());
            return "undefined" == typeof f ? "undefined" : f
        })
    },
    tokenRegEx: /\$\{([\w.]+?)\}/g,
    numberRegEx: /^([+-]?)(?=\d|\.\d)\d*(\.\d*)?([Ee]([+-]?\d+))?$/,
    isNumeric: function (a) {
        return OpenLayers.String.numberRegEx.test(a)
    },
    numericIf: function (a) {
        return OpenLayers.String.isNumeric(a) ? parseFloat(a) : a
    }
};
OpenLayers.Number = {
    decimalSeparator: ".", thousandsSeparator: ",", limitSigDigs: function (a, b) {
        var c = 0;
        0 < b && (c = parseFloat(a.toPrecision(b)));
        return c
    }, format: function (a, b, c, d) {
        b = "undefined" != typeof b ? b : 0;
        c = "undefined" != typeof c ? c : OpenLayers.Number.thousandsSeparator;
        d = "undefined" != typeof d ? d : OpenLayers.Number.decimalSeparator;
        null != b && (a = parseFloat(a.toFixed(b)));
        var e = a.toString().split(".");
        1 == e.length && null == b && (b = 0);
        a = e[0];
        if (c)for (var f = /(-?[0-9]+)([0-9]{3})/; f.test(a);)a = a.replace(f, "$1" + c + "$2");
        0 == b ? b = a : (c = 1 < e.length ? e[1] : "0", null != b && (c += Array(b - c.length + 1).join("0")), b = a + d + c);
        return b
    }
};
OpenLayers.Function = {
    bind: function (a, b) {
        var c = Array.prototype.slice.apply(arguments, [2]);
        return function () {
            var d = c.concat(Array.prototype.slice.apply(arguments, [0]));
            return a.apply(b, d)
        }
    }, bindAsEventListener: function (a, b) {
        return function (c) {
            return a.call(b, c || window.event)
        }
    }, False: function () {
        return !1
    }, True: function () {
        return !0
    }, Void: function () {
    }
};
OpenLayers.Array = {
    filter: function (a, b, c) {
        var d = [];
        if (Array.prototype.filter)d = a.filter(b, c); else {
            var e = a.length;
            if ("function" != typeof b)throw new TypeError;
            for (var f = 0; f < e; f++)if (f in a) {
                var g = a[f];
                b.call(c, g, f, a) && d.push(g)
            }
        }
        return d
    }
};
OpenLayers.Bounds = OpenLayers.Class({
    left: null, bottom: null, right: null, top: null, centerLonLat: null, initialize: function (a, b, c, d) {
        OpenLayers.Util.isArray(a) && (d = a[3], c = a[2], b = a[1], a = a[0]);
        null != a && (this.left = OpenLayers.Util.toFloat(a));
        null != b && (this.bottom = OpenLayers.Util.toFloat(b));
        null != c && (this.right = OpenLayers.Util.toFloat(c));
        null != d && (this.top = OpenLayers.Util.toFloat(d))
    }, clone: function () {
        return new OpenLayers.Bounds(this.left, this.bottom, this.right, this.top)
    }, equals: function (a) {
        var b = !1;
        null !=
        a && (b = this.left == a.left && this.right == a.right && this.top == a.top && this.bottom == a.bottom);
        return b
    }, toString: function () {
        return [this.left, this.bottom, this.right, this.top].join()
    }, toArray: function (a) {
        return !0 === a ? [this.bottom, this.left, this.top, this.right] : [this.left, this.bottom, this.right, this.top]
    }, toBBOX: function (a, b) {
        null == a && (a = 6);
        var c = Math.pow(10, a), d = Math.round(this.left * c) / c, e = Math.round(this.bottom * c) / c, f = Math.round(this.right * c) / c, c = Math.round(this.top * c) / c;
        return !0 === b ? e + "," + d + "," + c + "," + f : d +
        "," + e + "," + f + "," + c
    }, toGeometry: function () {
        return new OpenLayers.Geometry.Polygon([new OpenLayers.Geometry.LinearRing([new OpenLayers.Geometry.Point(this.left, this.bottom), new OpenLayers.Geometry.Point(this.right, this.bottom), new OpenLayers.Geometry.Point(this.right, this.top), new OpenLayers.Geometry.Point(this.left, this.top)])])
    }, getWidth: function () {
        return this.right - this.left
    }, getHeight: function () {
        return this.top - this.bottom
    }, getSize: function () {
        return new OpenLayers.Size(this.getWidth(), this.getHeight())
    },
    getCenterPixel: function () {
        return new OpenLayers.Pixel((this.left + this.right) / 2, (this.bottom + this.top) / 2)
    }, getCenterLonLat: function () {
        this.centerLonLat || (this.centerLonLat = new OpenLayers.LonLat((this.left + this.right) / 2, (this.bottom + this.top) / 2));
        return this.centerLonLat
    }, scale: function (a, b) {
        null == b && (b = this.getCenterLonLat());
        var c, d;
        "OpenLayers.LonLat" == b.CLASS_NAME ? (c = b.lon, d = b.lat) : (c = b.x, d = b.y);
        return new OpenLayers.Bounds((this.left - c) * a + c, (this.bottom - d) * a + d, (this.right - c) * a + c, (this.top - d) * a +
        d)
    }, add: function (a, b) {
        if (null == a || null == b)throw new TypeError("Bounds.add cannot receive null values");
        return new OpenLayers.Bounds(this.left + a, this.bottom + b, this.right + a, this.top + b)
    }, extend: function (a) {
        var b = null;
        if (a) {
            switch (a.CLASS_NAME) {
                case "OpenLayers.LonLat":
                    b = new OpenLayers.Bounds(a.lon, a.lat, a.lon, a.lat);
                    break;
                case "OpenLayers.Geometry.Point":
                    b = new OpenLayers.Bounds(a.x, a.y, a.x, a.y);
                    break;
                case "OpenLayers.Bounds":
                    b = a
            }
            if (b) {
                this.centerLonLat = null;
                if (null == this.left || b.left < this.left)this.left =
                    b.left;
                if (null == this.bottom || b.bottom < this.bottom)this.bottom = b.bottom;
                if (null == this.right || b.right > this.right)this.right = b.right;
                if (null == this.top || b.top > this.top)this.top = b.top
            }
        }
    }, containsLonLat: function (a, b) {
        "boolean" === typeof b && (b = {inclusive: b});
        var b = b || {}, c = this.contains(a.lon, a.lat, b.inclusive), d = b.worldBounds;
        d && !c && (c = d.getWidth(), d = Math.round((a.lon - (d.left + d.right) / 2) / c), c = this.containsLonLat({
            lon: a.lon - d * c,
            lat: a.lat
        }, {inclusive: b.inclusive}));
        return c
    }, containsPixel: function (a, b) {
        return this.contains(a.x,
            a.y, b)
    }, contains: function (a, b, c) {
        null == c && (c = !0);
        if (null == a || null == b)return !1;
        a = OpenLayers.Util.toFloat(a);
        b = OpenLayers.Util.toFloat(b);
        return c ? a >= this.left && a <= this.right && b >= this.bottom && b <= this.top : a > this.left && a < this.right && b > this.bottom && b < this.top
    }, intersectsBounds: function (a, b) {
        "boolean" === typeof b && (b = {inclusive: b});
        b = b || {};
        if (b.worldBounds)var c = this.wrapDateLine(b.worldBounds), a = a.wrapDateLine(b.worldBounds); else c = this;
        null == b.inclusive && (b.inclusive = !0);
        var d = !1, e = c.left == a.right || c.right ==
            a.left || c.top == a.bottom || c.bottom == a.top;
        if (b.inclusive || !e)var d = a.top >= c.bottom && a.top <= c.top || c.top > a.bottom && c.top < a.top, e = a.left >= c.left && a.left <= c.right || c.left >= a.left && c.left <= a.right, f = a.right >= c.left && a.right <= c.right || c.right >= a.left && c.right <= a.right, d = (a.bottom >= c.bottom && a.bottom <= c.top || c.bottom >= a.bottom && c.bottom <= a.top || d) && (e || f);
        if (b.worldBounds && !d) {
            var g = b.worldBounds, e = g.getWidth(), f = !g.containsBounds(c), g = !g.containsBounds(a);
            f && !g ? (a = a.add(-e, 0), d = c.intersectsBounds(a, {inclusive: b.inclusive})) :
            g && !f && (c = c.add(-e, 0), d = a.intersectsBounds(c, {inclusive: b.inclusive}))
        }
        return d
    }, containsBounds: function (a, b, c) {
        null == b && (b = !1);
        null == c && (c = !0);
        var d = this.contains(a.left, a.bottom, c), e = this.contains(a.right, a.bottom, c), f = this.contains(a.left, a.top, c), a = this.contains(a.right, a.top, c);
        return b ? d || e || f || a : d && e && f && a
    }, determineQuadrant: function (a) {
        var b = "", c = this.getCenterLonLat(), b = b + (a.lat < c.lat ? "b" : "t");
        return b + (a.lon < c.lon ? "l" : "r")
    }, transform: function (a, b) {
        this.centerLonLat = null;
        var c = OpenLayers.Projection.transform({
            x: this.left,
            y: this.bottom
        }, a, b), d = OpenLayers.Projection.transform({
            x: this.right,
            y: this.bottom
        }, a, b), e = OpenLayers.Projection.transform({
            x: this.left,
            y: this.top
        }, a, b), f = OpenLayers.Projection.transform({x: this.right, y: this.top}, a, b);
        this.left = Math.min(c.x, e.x);
        this.bottom = Math.min(c.y, d.y);
        this.right = Math.max(d.x, f.x);
        this.top = Math.max(e.y, f.y);
        return this
    }, wrapDateLine: function (a, b) {
        var b = b || {}, c = b.leftTolerance || 0, d = b.rightTolerance || 0, e = this.clone();
        if (a) {
            for (var f = a.getWidth(); e.left < a.left && e.right - d <= a.left;)e =
                e.add(f, 0);
            for (; e.left + c >= a.right && e.right > a.right;)e = e.add(-f, 0);
            c = e.left + c;
            c < a.right && c > a.left && e.right - d > a.right && (e = e.add(-f, 0))
        }
        return e
    }, CLASS_NAME: "OpenLayers.Bounds"
});
OpenLayers.Bounds.fromString = function (a, b) {
    var c = a.split(",");
    return OpenLayers.Bounds.fromArray(c, b)
};
OpenLayers.Bounds.fromArray = function (a, b) {
    return !0 === b ? new OpenLayers.Bounds(a[1], a[0], a[3], a[2]) : new OpenLayers.Bounds(a[0], a[1], a[2], a[3])
};
OpenLayers.Bounds.fromSize = function (a) {
    return new OpenLayers.Bounds(0, a.h, a.w, 0)
};
OpenLayers.Bounds.oppositeQuadrant = function (a) {
    return "" + ("t" == a.charAt(0) ? "b" : "t") + ("l" == a.charAt(1) ? "r" : "l")
};
OpenLayers.Date = {
    toISOString: function () {
        if ("toISOString"in Date.prototype)return function (a) {
            return a.toISOString()
        };
        var a = function (a, c) {
            for (var d = a + ""; d.length < c;)d = "0" + d;
            return d
        };
        return function (b) {
            return isNaN(b.getTime()) ? "Invalid Date" : b.getUTCFullYear() + "-" + a(b.getUTCMonth() + 1, 2) + "-" + a(b.getUTCDate(), 2) + "T" + a(b.getUTCHours(), 2) + ":" + a(b.getUTCMinutes(), 2) + ":" + a(b.getUTCSeconds(), 2) + "." + a(b.getUTCMilliseconds(), 3) + "Z"
        }
    }(), parse: function (a) {
        var b;
        if ((a = a.match(/^(?:(\d{4})(?:-(\d{2})(?:-(\d{2}))?)?)?(?:(?:T(\d{1,2}):(\d{2}):(\d{2}(?:\.\d+)?)(Z|(?:[+-]\d{1,2}(?::(\d{2}))?)))|Z)?$/)) &&
            (a[1] || a[7])) {
            b = parseInt(a[1], 10) || 0;
            var c = parseInt(a[2], 10) - 1 || 0, d = parseInt(a[3], 10) || 1;
            b = new Date(Date.UTC(b, c, d));
            if (c = a[7]) {
                var d = parseInt(a[4], 10), e = parseInt(a[5], 10), f = parseFloat(a[6]), g = f | 0, f = Math.round(1E3 * (f - g));
                b.setUTCHours(d, e, g, f);
                "Z" !== c && (c = parseInt(c, 10), a = parseInt(a[8], 10) || 0, b = new Date(b.getTime() + -1E3 * (3600 * c + 60 * a)))
            }
        } else b = new Date("invalid");
        return b
    }
};
OpenLayers.Element = {
    visible: function (a) {
        return "none" != OpenLayers.Util.getElement(a).style.display
    }, toggle: function () {
        for (var a = 0, b = arguments.length; a < b; a++) {
            var c = OpenLayers.Util.getElement(arguments[a]), d = OpenLayers.Element.visible(c) ? "none" : "";
            c.style.display = d
        }
    }, remove: function (a) {
        a = OpenLayers.Util.getElement(a);
        a.parentNode.removeChild(a)
    }, getHeight: function (a) {
        a = OpenLayers.Util.getElement(a);
        return a.offsetHeight
    }, hasClass: function (a, b) {
        var c = a.className;
        return !!c && RegExp("(^|\\s)" + b + "(\\s|$)").test(c)
    },
    addClass: function (a, b) {
        OpenLayers.Element.hasClass(a, b) || (a.className += (a.className ? " " : "") + b);
        return a
    }, removeClass: function (a, b) {
        var c = a.className;
        c && (a.className = OpenLayers.String.trim(c.replace(RegExp("(^|\\s+)" + b + "(\\s+|$)"), " ")));
        return a
    }, toggleClass: function (a, b) {
        OpenLayers.Element.hasClass(a, b) ? OpenLayers.Element.removeClass(a, b) : OpenLayers.Element.addClass(a, b);
        return a
    }, getStyle: function (a, b) {
        var a = OpenLayers.Util.getElement(a), c = null;
        if (a && a.style) {
            (c = a.style[OpenLayers.String.camelize(b)]) ||
            (document.defaultView && document.defaultView.getComputedStyle ? c = (c = document.defaultView.getComputedStyle(a, null)) ? c.getPropertyValue(b) : null : a.currentStyle && (c = a.currentStyle[OpenLayers.String.camelize(b)]));
            var d = ["left", "top", "right", "bottom"];
            window.opera && -1 != OpenLayers.Util.indexOf(d, b) && "static" == OpenLayers.Element.getStyle(a, "position") && (c = "auto")
        }
        return "auto" == c ? null : c
    }
};
OpenLayers.LonLat = OpenLayers.Class({
    lon: 0, lat: 0, initialize: function (a, b) {
        OpenLayers.Util.isArray(a) && (b = a[1], a = a[0]);
        this.lon = OpenLayers.Util.toFloat(a);
        this.lat = OpenLayers.Util.toFloat(b)
    }, toString: function () {
        return "lon=" + this.lon + ",lat=" + this.lat
    }, toShortString: function () {
        return this.lon + ", " + this.lat
    }, clone: function () {
        return new OpenLayers.LonLat(this.lon, this.lat)
    }, add: function (a, b) {
        if (null == a || null == b)throw new TypeError("LonLat.add cannot receive null values");
        return new OpenLayers.LonLat(this.lon +
        OpenLayers.Util.toFloat(a), this.lat + OpenLayers.Util.toFloat(b))
    }, equals: function (a) {
        var b = !1;
        null != a && (b = this.lon == a.lon && this.lat == a.lat || isNaN(this.lon) && isNaN(this.lat) && isNaN(a.lon) && isNaN(a.lat));
        return b
    }, transform: function (a, b) {
        var c = OpenLayers.Projection.transform({x: this.lon, y: this.lat}, a, b);
        this.lon = c.x;
        this.lat = c.y;
        return this
    }, wrapDateLine: function (a) {
        var b = this.clone();
        if (a) {
            for (; b.lon < a.left;)b.lon += a.getWidth();
            for (; b.lon > a.right;)b.lon -= a.getWidth()
        }
        return b
    }, CLASS_NAME: "OpenLayers.LonLat"
});
OpenLayers.LonLat.fromString = function (a) {
    a = a.split(",");
    return new OpenLayers.LonLat(a[0], a[1])
};
OpenLayers.LonLat.fromArray = function (a) {
    var b = OpenLayers.Util.isArray(a);
    return new OpenLayers.LonLat(b && a[0], b && a[1])
};
OpenLayers.Pixel = OpenLayers.Class({
    x: 0, y: 0, initialize: function (a, b) {
        this.x = parseFloat(a);
        this.y = parseFloat(b)
    }, toString: function () {
        return "x=" + this.x + ",y=" + this.y
    }, clone: function () {
        return new OpenLayers.Pixel(this.x, this.y)
    }, equals: function (a) {
        var b = !1;
        null != a && (b = this.x == a.x && this.y == a.y || isNaN(this.x) && isNaN(this.y) && isNaN(a.x) && isNaN(a.y));
        return b
    }, distanceTo: function (a) {
        return Math.sqrt(Math.pow(this.x - a.x, 2) + Math.pow(this.y - a.y, 2))
    }, add: function (a, b) {
        if (null == a || null == b)throw new TypeError("Pixel.add cannot receive null values");
        return new OpenLayers.Pixel(this.x + a, this.y + b)
    }, offset: function (a) {
        var b = this.clone();
        a && (b = this.add(a.x, a.y));
        return b
    }, CLASS_NAME: "OpenLayers.Pixel"
});
OpenLayers.Size = OpenLayers.Class({
    w: 0, h: 0, initialize: function (a, b) {
        this.w = parseFloat(a);
        this.h = parseFloat(b)
    }, toString: function () {
        return "w=" + this.w + ",h=" + this.h
    }, clone: function () {
        return new OpenLayers.Size(this.w, this.h)
    }, equals: function (a) {
        var b = !1;
        null != a && (b = this.w == a.w && this.h == a.h || isNaN(this.w) && isNaN(this.h) && isNaN(a.w) && isNaN(a.h));
        return b
    }, CLASS_NAME: "OpenLayers.Size"
});
OpenLayers.Console = {
    log: function () {
    }, debug: function () {
    }, info: function () {
    }, warn: function () {
    }, error: function () {
    }, userError: function (a) {
        alert(a)
    }, assert: function () {
    }, dir: function () {
    }, dirxml: function () {
    }, trace: function () {
    }, group: function () {
    }, groupEnd: function () {
    }, time: function () {
    }, timeEnd: function () {
    }, profile: function () {
    }, profileEnd: function () {
    }, count: function () {
    }, CLASS_NAME: "OpenLayers.Console"
};
(function () {
    for (var a = document.getElementsByTagName("script"), b = 0, c = a.length; b < c; ++b)if (-1 != a[b].src.indexOf("firebug.js") && console) {
        OpenLayers.Util.extend(OpenLayers.Console, console);
        break
    }
})();
OpenLayers.Tween = OpenLayers.Class({
    easing: null,
    begin: null,
    finish: null,
    duration: null,
    callbacks: null,
    time: null,
    animationId: null,
    playing: !1,
    initialize: function (a) {
        this.easing = a ? a : OpenLayers.Easing.Expo.easeOut
    },
    start: function (a, b, c, d) {
        this.playing = !0;
        this.begin = a;
        this.finish = b;
        this.duration = c;
        this.callbacks = d.callbacks;
        this.time = 0;
        OpenLayers.Animation.stop(this.animationId);
        this.animationId = null;
        this.callbacks && this.callbacks.start && this.callbacks.start.call(this, this.begin);
        this.animationId = OpenLayers.Animation.start(OpenLayers.Function.bind(this.play,
            this))
    },
    stop: function () {
        this.playing && (this.callbacks && this.callbacks.done && this.callbacks.done.call(this, this.finish), OpenLayers.Animation.stop(this.animationId), this.animationId = null, this.playing = !1)
    },
    play: function () {
        var a = {}, b;
        for (b in this.begin) {
            var c = this.begin[b], d = this.finish[b];
            if (null == c || null == d || isNaN(c) || isNaN(d))throw new TypeError("invalid value for Tween");
            a[b] = this.easing.apply(this, [this.time, c, d - c, this.duration])
        }
        this.time++;
        this.callbacks && this.callbacks.eachStep && this.callbacks.eachStep.call(this,
            a);
        this.time > this.duration && this.stop()
    },
    CLASS_NAME: "OpenLayers.Tween"
});
OpenLayers.Easing = {CLASS_NAME: "OpenLayers.Easing"};
OpenLayers.Easing.Linear = {
    easeIn: function (a, b, c, d) {
        return c * a / d + b
    }, easeOut: function (a, b, c, d) {
        return c * a / d + b
    }, easeInOut: function (a, b, c, d) {
        return c * a / d + b
    }, CLASS_NAME: "OpenLayers.Easing.Linear"
};
OpenLayers.Easing.Expo = {
    easeIn: function (a, b, c, d) {
        return 0 == a ? b : c * Math.pow(2, 10 * (a / d - 1)) + b
    }, easeOut: function (a, b, c, d) {
        return a == d ? b + c : c * (-Math.pow(2, -10 * a / d) + 1) + b
    }, easeInOut: function (a, b, c, d) {
        return 0 == a ? b : a == d ? b + c : 1 > (a /= d / 2) ? c / 2 * Math.pow(2, 10 * (a - 1)) + b : c / 2 * (-Math.pow(2, -10 * --a) + 2) + b
    }, CLASS_NAME: "OpenLayers.Easing.Expo"
};
OpenLayers.Easing.Quad = {
    easeIn: function (a, b, c, d) {
        return c * (a /= d) * a + b
    }, easeOut: function (a, b, c, d) {
        return -c * (a /= d) * (a - 2) + b
    }, easeInOut: function (a, b, c, d) {
        return 1 > (a /= d / 2) ? c / 2 * a * a + b : -c / 2 * (--a * (a - 2) - 1) + b
    }, CLASS_NAME: "OpenLayers.Easing.Quad"
};
OpenLayers.Kinetic = OpenLayers.Class({
    threshold: 0,
    deceleration: 0.0035,
    nbPoints: 100,
    delay: 200,
    points: void 0,
    timerId: void 0,
    initialize: function (a) {
        OpenLayers.Util.extend(this, a)
    },
    begin: function () {
        OpenLayers.Animation.stop(this.timerId);
        this.timerId = void 0;
        this.points = []
    },
    update: function (a) {
        this.points.unshift({xy: a, tick: (new Date).getTime()});
        this.points.length > this.nbPoints && this.points.pop()
    },
    end: function (a) {
        for (var b, c = (new Date).getTime(), d = 0, e = this.points.length, f; d < e; d++) {
            f = this.points[d];
            if (c -
                f.tick > this.delay)break;
            b = f
        }
        if (b && (d = (new Date).getTime() - b.tick, c = Math.sqrt(Math.pow(a.x - b.xy.x, 2) + Math.pow(a.y - b.xy.y, 2)), d = c / d, !(0 == d || d < this.threshold)))return c = Math.asin((a.y - b.xy.y) / c), b.xy.x <= a.x && (c = Math.PI - c), {
            speed: d,
            theta: c
        }
    },
    move: function (a, b) {
        var c = a.speed, d = Math.cos(a.theta), e = -Math.sin(a.theta), f = (new Date).getTime(), g = 0, h = 0;
        this.timerId = OpenLayers.Animation.start(OpenLayers.Function.bind(function () {
            if (null != this.timerId) {
                var a = (new Date).getTime() - f, l = -this.deceleration * Math.pow(a,
                        2) / 2 + c * a, m = l * d, l = l * e, n, o;
                n = !1;
                0 >= -this.deceleration * a + c && (OpenLayers.Animation.stop(this.timerId), this.timerId = null, n = !0);
                a = m - g;
                o = l - h;
                g = m;
                h = l;
                b(a, o, n)
            }
        }, this))
    },
    CLASS_NAME: "OpenLayers.Kinetic"
});
OpenLayers.Console.warn("OpenLayers.Rico is deprecated");
OpenLayers.Rico = OpenLayers.Rico || {};
OpenLayers.Rico.Corner = {
    round: function (a, b) {
        a = OpenLayers.Util.getElement(a);
        this._setOptions(b);
        var c = this.options.color;
        "fromElement" == this.options.color && (c = this._background(a));
        var d = this.options.bgColor;
        "fromParent" == this.options.bgColor && (d = this._background(a.offsetParent));
        this._roundCornersImpl(a, c, d)
    }, changeColor: function (a, b) {
        a.style.backgroundColor = b;
        for (var c = a.parentNode.getElementsByTagName("span"), d = 0; d < c.length; d++)c[d].style.backgroundColor = b
    }, changeOpacity: function (a, b) {
        var c = "alpha(opacity=" +
            100 * b + ")";
        a.style.opacity = b;
        a.style.filter = c;
        for (var d = a.parentNode.getElementsByTagName("span"), e = 0; e < d.length; e++)d[e].style.opacity = b, d[e].style.filter = c
    }, reRound: function (a, b) {
        var c = a.parentNode.childNodes[2];
        a.parentNode.removeChild(a.parentNode.childNodes[0]);
        a.parentNode.removeChild(c);
        this.round(a.parentNode, b)
    }, _roundCornersImpl: function (a, b, c) {
        this.options.border && this._renderBorder(a, c);
        this._isTopRounded() && this._roundTopCorners(a, b, c);
        this._isBottomRounded() && this._roundBottomCorners(a,
            b, c)
    }, _renderBorder: function (a, b) {
        var c = "1px solid " + this._borderColor(b);
        a.innerHTML = "<div " + ("style='border-left: " + c + ";" + ("border-right: " + c) + "'") + ">" + a.innerHTML + "</div>"
    }, _roundTopCorners: function (a, b, c) {
        for (var d = this._createCorner(c), e = 0; e < this.options.numSlices; e++)d.appendChild(this._createCornerSlice(b, c, e, "top"));
        a.style.paddingTop = 0;
        a.insertBefore(d, a.firstChild)
    }, _roundBottomCorners: function (a, b, c) {
        for (var d = this._createCorner(c), e = this.options.numSlices - 1; 0 <= e; e--)d.appendChild(this._createCornerSlice(b,
            c, e, "bottom"));
        a.style.paddingBottom = 0;
        a.appendChild(d)
    }, _createCorner: function (a) {
        var b = document.createElement("div");
        b.style.backgroundColor = this._isTransparent() ? "transparent" : a;
        return b
    }, _createCornerSlice: function (a, b, c, d) {
        var e = document.createElement("span"), f = e.style;
        f.backgroundColor = a;
        f.display = "block";
        f.height = "1px";
        f.overflow = "hidden";
        f.fontSize = "1px";
        a = this._borderColor(a, b);
        this.options.border && 0 == c ? (f.borderTopStyle = "solid", f.borderTopWidth = "1px", f.borderLeftWidth = "0px", f.borderRightWidth =
            "0px", f.borderBottomWidth = "0px", f.height = "0px", f.borderColor = a) : a && (f.borderColor = a, f.borderStyle = "solid", f.borderWidth = "0px 1px");
        !this.options.compact && c == this.options.numSlices - 1 && (f.height = "2px");
        this._setMargin(e, c, d);
        this._setBorder(e, c, d);
        return e
    }, _setOptions: function (a) {
        this.options = {
            corners: "all",
            color: "fromElement",
            bgColor: "fromParent",
            blend: !0,
            border: !1,
            compact: !1
        };
        OpenLayers.Util.extend(this.options, a || {});
        this.options.numSlices = this.options.compact ? 2 : 4;
        this._isTransparent() && (this.options.blend = !1)
    }, _whichSideTop: function () {
        return this._hasString(this.options.corners, "all", "top") || 0 <= this.options.corners.indexOf("tl") && 0 <= this.options.corners.indexOf("tr") ? "" : 0 <= this.options.corners.indexOf("tl") ? "left" : 0 <= this.options.corners.indexOf("tr") ? "right" : ""
    }, _whichSideBottom: function () {
        return this._hasString(this.options.corners, "all", "bottom") || 0 <= this.options.corners.indexOf("bl") && 0 <= this.options.corners.indexOf("br") ? "" : 0 <= this.options.corners.indexOf("bl") ? "left" : 0 <= this.options.corners.indexOf("br") ?
            "right" : ""
    }, _borderColor: function (a, b) {
        return "transparent" == a ? b : this.options.border ? this.options.border : this.options.blend ? this._blend(b, a) : ""
    }, _setMargin: function (a, b, c) {
        b = this._marginSize(b);
        c = "top" == c ? this._whichSideTop() : this._whichSideBottom();
        "left" == c ? (a.style.marginLeft = b + "px", a.style.marginRight = "0px") : "right" == c ? (a.style.marginRight = b + "px", a.style.marginLeft = "0px") : (a.style.marginLeft = b + "px", a.style.marginRight = b + "px")
    }, _setBorder: function (a, b, c) {
        b = this._borderSize(b);
        c = "top" == c ? this._whichSideTop() :
            this._whichSideBottom();
        "left" == c ? (a.style.borderLeftWidth = b + "px", a.style.borderRightWidth = "0px") : "right" == c ? (a.style.borderRightWidth = b + "px", a.style.borderLeftWidth = "0px") : (a.style.borderLeftWidth = b + "px", a.style.borderRightWidth = b + "px");
        !1 != this.options.border && (a.style.borderLeftWidth = b + "px", a.style.borderRightWidth = b + "px")
    }, _marginSize: function (a) {
        if (this._isTransparent())return 0;
        var b = [5, 3, 2, 1], c = [3, 2, 1, 0], d = [2, 1], e = [1, 0];
        return this.options.compact && this.options.blend ? e[a] : this.options.compact ?
            d[a] : this.options.blend ? c[a] : b[a]
    }, _borderSize: function (a) {
        var b = [5, 3, 2, 1], c = [2, 1, 1, 1], d = [1, 0], e = [0, 2, 0, 0];
        return this.options.compact && (this.options.blend || this._isTransparent()) ? 1 : this.options.compact ? d[a] : this.options.blend ? c[a] : this.options.border ? e[a] : this._isTransparent() ? b[a] : 0
    }, _hasString: function (a) {
        for (var b = 1; b < arguments.length; b++)if (0 <= a.indexOf(arguments[b]))return !0;
        return !1
    }, _blend: function (a, b) {
        var c = OpenLayers.Rico.Color.createFromHex(a);
        c.blend(OpenLayers.Rico.Color.createFromHex(b));
        return c
    }, _background: function (a) {
        try {
            return OpenLayers.Rico.Color.createColorFromBackground(a).asHex()
        } catch (b) {
            return "#ffffff"
        }
    }, _isTransparent: function () {
        return "transparent" == this.options.color
    }, _isTopRounded: function () {
        return this._hasString(this.options.corners, "all", "top", "tl", "tr")
    }, _isBottomRounded: function () {
        return this._hasString(this.options.corners, "all", "bottom", "bl", "br")
    }, _hasSingleTextChild: function (a) {
        return 1 == a.childNodes.length && 3 == a.childNodes[0].nodeType
    }
};
OpenLayers.Console.warn("OpenLayers.Rico is deprecated");
OpenLayers.Rico = OpenLayers.Rico || {};
OpenLayers.Rico.Color = OpenLayers.Class({
    initialize: function (a, b, c) {
        this.rgb = {r: a, g: b, b: c}
    }, setRed: function (a) {
        this.rgb.r = a
    }, setGreen: function (a) {
        this.rgb.g = a
    }, setBlue: function (a) {
        this.rgb.b = a
    }, setHue: function (a) {
        var b = this.asHSB();
        b.h = a;
        this.rgb = OpenLayers.Rico.Color.HSBtoRGB(b.h, b.s, b.b)
    }, setSaturation: function (a) {
        var b = this.asHSB();
        b.s = a;
        this.rgb = OpenLayers.Rico.Color.HSBtoRGB(b.h, b.s, b.b)
    }, setBrightness: function (a) {
        var b = this.asHSB();
        b.b = a;
        this.rgb = OpenLayers.Rico.Color.HSBtoRGB(b.h, b.s, b.b)
    },
    darken: function (a) {
        var b = this.asHSB();
        this.rgb = OpenLayers.Rico.Color.HSBtoRGB(b.h, b.s, Math.max(b.b - a, 0))
    }, brighten: function (a) {
        var b = this.asHSB();
        this.rgb = OpenLayers.Rico.Color.HSBtoRGB(b.h, b.s, Math.min(b.b + a, 1))
    }, blend: function (a) {
        this.rgb.r = Math.floor((this.rgb.r + a.rgb.r) / 2);
        this.rgb.g = Math.floor((this.rgb.g + a.rgb.g) / 2);
        this.rgb.b = Math.floor((this.rgb.b + a.rgb.b) / 2)
    }, isBright: function () {
        this.asHSB();
        return 0.5 < this.asHSB().b
    }, isDark: function () {
        return !this.isBright()
    }, asRGB: function () {
        return "rgb(" +
            this.rgb.r + "," + this.rgb.g + "," + this.rgb.b + ")"
    }, asHex: function () {
        return "#" + this.rgb.r.toColorPart() + this.rgb.g.toColorPart() + this.rgb.b.toColorPart()
    }, asHSB: function () {
        return OpenLayers.Rico.Color.RGBtoHSB(this.rgb.r, this.rgb.g, this.rgb.b)
    }, toString: function () {
        return this.asHex()
    }
});
OpenLayers.Rico.Color.createFromHex = function (a) {
    if (4 == a.length)for (var b = a, a = "#", c = 1; 4 > c; c++)a += b.charAt(c) + b.charAt(c);
    0 == a.indexOf("#") && (a = a.substring(1));
    b = a.substring(0, 2);
    c = a.substring(2, 4);
    a = a.substring(4, 6);
    return new OpenLayers.Rico.Color(parseInt(b, 16), parseInt(c, 16), parseInt(a, 16))
};
OpenLayers.Rico.Color.createColorFromBackground = function (a) {
    var b = OpenLayers.Element.getStyle(OpenLayers.Util.getElement(a), "backgroundColor");
    return "transparent" == b && a.parentNode ? OpenLayers.Rico.Color.createColorFromBackground(a.parentNode) : null == b ? new OpenLayers.Rico.Color(255, 255, 255) : 0 == b.indexOf("rgb(") ? (a = b.substring(4, b.length - 1).split(","), new OpenLayers.Rico.Color(parseInt(a[0]), parseInt(a[1]), parseInt(a[2]))) : 0 == b.indexOf("#") ? OpenLayers.Rico.Color.createFromHex(b) : new OpenLayers.Rico.Color(255,
        255, 255)
};
OpenLayers.Rico.Color.HSBtoRGB = function (a, b, c) {
    var d = 0, e = 0, f = 0;
    if (0 == b)f = e = d = parseInt(255 * c + 0.5); else {
        var a = 6 * (a - Math.floor(a)), g = a - Math.floor(a), h = c * (1 - b), k = c * (1 - b * g), b = c * (1 - b * (1 - g));
        switch (parseInt(a)) {
            case 0:
                d = 255 * c + 0.5;
                e = 255 * b + 0.5;
                f = 255 * h + 0.5;
                break;
            case 1:
                d = 255 * k + 0.5;
                e = 255 * c + 0.5;
                f = 255 * h + 0.5;
                break;
            case 2:
                d = 255 * h + 0.5;
                e = 255 * c + 0.5;
                f = 255 * b + 0.5;
                break;
            case 3:
                d = 255 * h + 0.5;
                e = 255 * k + 0.5;
                f = 255 * c + 0.5;
                break;
            case 4:
                d = 255 * b + 0.5;
                e = 255 * h + 0.5;
                f = 255 * c + 0.5;
                break;
            case 5:
                d = 255 * c + 0.5, e = 255 * h + 0.5, f = 255 * k + 0.5
        }
    }
    return {
        r: parseInt(d), g: parseInt(e),
        b: parseInt(f)
    }
};
OpenLayers.Rico.Color.RGBtoHSB = function (a, b, c) {
    var d, e = a > b ? a : b;
    c > e && (e = c);
    var f = a < b ? a : b;
    c < f && (f = c);
    d = 0 != e ? (e - f) / e : 0;
    if (0 == d)a = 0; else {
        var g = (e - a) / (e - f), h = (e - b) / (e - f), c = (e - c) / (e - f), a = (a == e ? c - h : b == e ? 2 + g - c : 4 + h - g) / 6;
        0 > a && (a += 1)
    }
    return {h: a, s: d, b: e / 255}
};
OpenLayers.Event = {
    observers: !1,
    KEY_SPACE: 32,
    KEY_BACKSPACE: 8,
    KEY_TAB: 9,
    KEY_RETURN: 13,
    KEY_ESC: 27,
    KEY_LEFT: 37,
    KEY_UP: 38,
    KEY_RIGHT: 39,
    KEY_DOWN: 40,
    KEY_DELETE: 46,
    element: function (a) {
        return a.target || a.srcElement
    },
    isSingleTouch: function (a) {
        return a.touches && 1 == a.touches.length
    },
    isMultiTouch: function (a) {
        return a.touches && 1 < a.touches.length
    },
    isLeftClick: function (a) {
        return a.which && 1 == a.which || a.button && 1 == a.button
    },
    isRightClick: function (a) {
        return a.which && 3 == a.which || a.button && 2 == a.button
    },
    stop: function (a,
                    b) {
        b || (a.preventDefault ? a.preventDefault() : a.returnValue = !1);
        a.stopPropagation ? a.stopPropagation() : a.cancelBubble = !0
    },
    findElement: function (a, b) {
        for (var c = OpenLayers.Event.element(a); c.parentNode && (!c.tagName || c.tagName.toUpperCase() != b.toUpperCase());)c = c.parentNode;
        return c
    },
    observe: function (a, b, c, d) {
        a = OpenLayers.Util.getElement(a);
        d = d || !1;
        if ("keypress" == b && (navigator.appVersion.match(/Konqueror|Safari|KHTML/) || a.attachEvent))b = "keydown";
        this.observers || (this.observers = {});
        if (!a._eventCacheID) {
            var e =
                "eventCacheID_";
            a.id && (e = a.id + "_" + e);
            a._eventCacheID = OpenLayers.Util.createUniqueID(e)
        }
        e = a._eventCacheID;
        this.observers[e] || (this.observers[e] = []);
        this.observers[e].push({element: a, name: b, observer: c, useCapture: d});
        a.addEventListener ? a.addEventListener(b, c, d) : a.attachEvent && a.attachEvent("on" + b, c)
    },
    stopObservingElement: function (a) {
        a = OpenLayers.Util.getElement(a)._eventCacheID;
        this._removeElementObservers(OpenLayers.Event.observers[a])
    },
    _removeElementObservers: function (a) {
        if (a)for (var b = a.length - 1; 0 <=
        b; b--) {
            var c = a[b];
            OpenLayers.Event.stopObserving.apply(this, [c.element, c.name, c.observer, c.useCapture])
        }
    },
    stopObserving: function (a, b, c, d) {
        var d = d || !1, a = OpenLayers.Util.getElement(a), e = a._eventCacheID;
        if ("keypress" == b && (navigator.appVersion.match(/Konqueror|Safari|KHTML/) || a.detachEvent))b = "keydown";
        var f = !1, g = OpenLayers.Event.observers[e];
        if (g)for (var h = 0; !f && h < g.length;) {
            var k = g[h];
            if (k.name == b && k.observer == c && k.useCapture == d) {
                g.splice(h, 1);
                0 == g.length && delete OpenLayers.Event.observers[e];
                f = !0;
                break
            }
            h++
        }
        f && (a.removeEventListener ? a.removeEventListener(b, c, d) : a && a.detachEvent && a.detachEvent("on" + b, c));
        return f
    },
    unloadCache: function () {
        if (OpenLayers.Event && OpenLayers.Event.observers) {
            for (var a in OpenLayers.Event.observers)OpenLayers.Event._removeElementObservers.apply(this, [OpenLayers.Event.observers[a]]);
            OpenLayers.Event.observers = !1
        }
    },
    CLASS_NAME: "OpenLayers.Event"
};
OpenLayers.Event.observe(window, "unload", OpenLayers.Event.unloadCache, !1);
OpenLayers.Events = OpenLayers.Class({
    BROWSER_EVENTS: "mouseover,mouseout,mousedown,mouseup,mousemove,click,dblclick,rightclick,dblrightclick,resize,focus,blur,touchstart,touchmove,touchend,keydown".split(","),
    listeners: null,
    object: null,
    element: null,
    eventHandler: null,
    fallThrough: null,
    includeXY: !1,
    extensions: null,
    extensionCount: null,
    clearMouseListener: null,
    initialize: function (a, b, c, d, e) {
        OpenLayers.Util.extend(this, e);
        this.object = a;
        this.fallThrough = d;
        this.listeners = {};
        this.extensions = {};
        this.extensionCount =
        {};
        null != b && this.attachToElement(b)
    },
    destroy: function () {
        for (var a in this.extensions)"boolean" !== typeof this.extensions[a] && this.extensions[a].destroy();
        this.extensions = null;
        this.element && (OpenLayers.Event.stopObservingElement(this.element), this.element.hasScrollEvent && OpenLayers.Event.stopObserving(window, "scroll", this.clearMouseListener));
        this.eventHandler = this.fallThrough = this.object = this.listeners = this.element = null
    },
    addEventType: function () {
    },
    attachToElement: function (a) {
        this.element ? OpenLayers.Event.stopObservingElement(this.element) :
            (this.eventHandler = OpenLayers.Function.bindAsEventListener(this.handleBrowserEvent, this), this.clearMouseListener = OpenLayers.Function.bind(this.clearMouseCache, this));
        this.element = a;
        for (var b = 0, c = this.BROWSER_EVENTS.length; b < c; b++)OpenLayers.Event.observe(a, this.BROWSER_EVENTS[b], this.eventHandler);
        OpenLayers.Event.observe(a, "dragstart", OpenLayers.Event.stop)
    },
    on: function (a) {
        for (var b in a)"scope" != b && a.hasOwnProperty(b) && this.register(b, a.scope, a[b])
    },
    register: function (a, b, c, d) {
        a in OpenLayers.Events && !this.extensions[a] && (this.extensions[a] = new OpenLayers.Events[a](this));
        if (null != c) {
            null == b && (b = this.object);
            var e = this.listeners[a];
            e || (e = [], this.listeners[a] = e, this.extensionCount[a] = 0);
            b = {obj: b, func: c};
            d ? (e.splice(this.extensionCount[a], 0, b), "object" === typeof d && d.extension && this.extensionCount[a]++) : e.push(b)
        }
    },
    registerPriority: function (a, b, c) {
        this.register(a, b, c, !0)
    },
    un: function (a) {
        for (var b in a)"scope" != b && a.hasOwnProperty(b) && this.unregister(b, a.scope, a[b])
    },
    unregister: function (a, b, c) {
        null ==
        b && (b = this.object);
        a = this.listeners[a];
        if (null != a)for (var d = 0, e = a.length; d < e; d++)if (a[d].obj == b && a[d].func == c) {
            a.splice(d, 1);
            break
        }
    },
    remove: function (a) {
        null != this.listeners[a] && (this.listeners[a] = [])
    },
    triggerEvent: function (a, b) {
        var c = this.listeners[a];
        if (c && 0 != c.length) {
            null == b && (b = {});
            b.object = this.object;
            b.element = this.element;
            b.type || (b.type = a);
            for (var c = c.slice(), d, e = 0, f = c.length; e < f && !(d = c[e], d = d.func.apply(d.obj, [b]), void 0 != d && !1 == d); e++);
            this.fallThrough || OpenLayers.Event.stop(b, !0);
            return d
        }
    },
    handleBrowserEvent: function (a) {
        var b = a.type, c = this.listeners[b];
        if (c && 0 != c.length) {
            if ((c = a.touches) && c[0]) {
                for (var d = 0, e = 0, f = c.length, g, h = 0; h < f; ++h)g = c[h], d += g.clientX, e += g.clientY;
                a.clientX = d / f;
                a.clientY = e / f
            }
            this.includeXY && (a.xy = this.getMousePosition(a));
            this.triggerEvent(b, a)
        }
    },
    clearMouseCache: function () {
        this.element.scrolls = null;
        this.element.lefttop = null;
        var a = document.body;
        if (a && (!(0 != a.scrollTop || 0 != a.scrollLeft) || !navigator.userAgent.match(/iPhone/i)))this.element.offsets = null
    },
    getMousePosition: function (a) {
        this.includeXY ?
        this.element.hasScrollEvent || (OpenLayers.Event.observe(window, "scroll", this.clearMouseListener), this.element.hasScrollEvent = !0) : this.clearMouseCache();
        if (!this.element.scrolls) {
            var b = OpenLayers.Util.getViewportElement();
            this.element.scrolls = [b.scrollLeft, b.scrollTop]
        }
        this.element.lefttop || (this.element.lefttop = [document.documentElement.clientLeft || 0, document.documentElement.clientTop || 0]);
        this.element.offsets || (this.element.offsets = OpenLayers.Util.pagePosition(this.element));
        return new OpenLayers.Pixel(a.clientX +
        this.element.scrolls[0] - this.element.offsets[0] - this.element.lefttop[0], a.clientY + this.element.scrolls[1] - this.element.offsets[1] - this.element.lefttop[1])
    },
    CLASS_NAME: "OpenLayers.Events"
});
OpenLayers.Events.buttonclick = OpenLayers.Class({
    target: null,
    events: "mousedown,mouseup,click,dblclick,touchstart,touchmove,touchend,keydown".split(","),
    startRegEx: /^mousedown|touchstart$/,
    cancelRegEx: /^touchmove$/,
    completeRegEx: /^mouseup|touchend$/,
    initialize: function (a) {
        this.target = a;
        for (a = this.events.length - 1; 0 <= a; --a)this.target.register(this.events[a], this, this.buttonClick, {extension: !0})
    },
    destroy: function () {
        for (var a = this.events.length - 1; 0 <= a; --a)this.target.unregister(this.events[a], this, this.buttonClick);
        delete this.target
    },
    getPressedButton: function (a) {
        var b = 3, c;
        do {
            if (OpenLayers.Element.hasClass(a, "olButton")) {
                c = a;
                break
            }
            a = a.parentNode
        } while (0 < --b && a);
        return c
    },
    buttonClick: function (a) {
        var b = !0, c = OpenLayers.Event.element(a);
        if (c && (OpenLayers.Event.isLeftClick(a) || !~a.type.indexOf("mouse")))if (c = this.getPressedButton(c)) {
            if ("keydown" === a.type)switch (a.keyCode) {
                case OpenLayers.Event.KEY_RETURN:
                case OpenLayers.Event.KEY_SPACE:
                    this.target.triggerEvent("buttonclick", {buttonElement: c}), OpenLayers.Event.stop(a),
                        b = !1
            } else this.startEvt && (this.completeRegEx.test(a.type) && (b = OpenLayers.Util.pagePosition(c), this.target.triggerEvent("buttonclick", {
                buttonElement: c,
                buttonXY: {x: this.startEvt.clientX - b[0], y: this.startEvt.clientY - b[1]}
            })), this.cancelRegEx.test(a.type) && delete this.startEvt, OpenLayers.Event.stop(a), b = !1);
            this.startRegEx.test(a.type) && (this.startEvt = a, OpenLayers.Event.stop(a), b = !1)
        } else delete this.startEvt;
        return b
    }
});
OpenLayers.ProxyHost = "";
OpenLayers.Request = {
    DEFAULT_CONFIG: {
        method: "GET",
        url: window.location.href,
        async: !0,
        user: void 0,
        password: void 0,
        params: null,
        proxy: OpenLayers.ProxyHost,
        headers: {},
        data: null,
        callback: function () {
        },
        success: null,
        failure: null,
        scope: null
    },
    URL_SPLIT_REGEX: /([^:]*:)\/\/([^:]*:?[^@]*@)?([^:\/\?]*):?([^\/\?]*)/,
    events: new OpenLayers.Events(this),
    makeSameOrigin: function (a, b) {
        var c = 0 !== a.indexOf("http"), d = !c && a.match(this.URL_SPLIT_REGEX);
        if (d) {
            var e = window.location, c = d[1] == e.protocol && d[3] == e.hostname, d = d[4],
                e = e.port;
            if (80 != d && "" != d || "80" != e && "" != e)c = c && d == e
        }
        c || (b ? a = "function" == typeof b ? b(a) : b + encodeURIComponent(a) : OpenLayers.Console.warn(OpenLayers.i18n("proxyNeeded"), {url: a}));
        return a
    },
    issue: function (a) {
        var b = OpenLayers.Util.extend(this.DEFAULT_CONFIG, {proxy: OpenLayers.ProxyHost}), a = OpenLayers.Util.applyDefaults(a, b), b = !1, c;
        for (c in a.headers)a.headers.hasOwnProperty(c) && "x-requested-with" === c.toLowerCase() && (b = !0);
        !1 === b && (a.headers["X-Requested-With"] = "XMLHttpRequest");
        var d = new OpenLayers.Request.XMLHttpRequest,
            e = OpenLayers.Util.urlAppend(a.url, OpenLayers.Util.getParameterString(a.params || {})), e = OpenLayers.Request.makeSameOrigin(e, a.proxy);
        d.open(a.method, e, a.async, a.user, a.password);
        for (var f in a.headers)d.setRequestHeader(f, a.headers[f]);
        var g = this.events, h = this;
        d.onreadystatechange = function () {
            d.readyState == OpenLayers.Request.XMLHttpRequest.DONE && !1 !== g.triggerEvent("complete", {
                request: d,
                config: a,
                requestUrl: e
            }) && h.runCallbacks({request: d, config: a, requestUrl: e})
        };
        !1 === a.async ? d.send(a.data) : window.setTimeout(function () {
            0 !==
            d.readyState && d.send(a.data)
        }, 0);
        return d
    },
    runCallbacks: function (a) {
        var b = a.request, c = a.config, d = c.scope ? OpenLayers.Function.bind(c.callback, c.scope) : c.callback, e;
        c.success && (e = c.scope ? OpenLayers.Function.bind(c.success, c.scope) : c.success);
        var f;
        c.failure && (f = c.scope ? OpenLayers.Function.bind(c.failure, c.scope) : c.failure);
        "file:" == OpenLayers.Util.createUrlObject(c.url).protocol && b.responseText && (b.status = 200);
        d(b);
        if (!b.status || 200 <= b.status && 300 > b.status)this.events.triggerEvent("success", a), e && e(b);
        if (b.status && (200 > b.status || 300 <= b.status))this.events.triggerEvent("failure", a), f && f(b)
    },
    GET: function (a) {
        a = OpenLayers.Util.extend(a, {method: "GET"});
        return OpenLayers.Request.issue(a)
    },
    POST: function (a) {
        a = OpenLayers.Util.extend(a, {method: "POST"});
        a.headers = a.headers ? a.headers : {};
        "CONTENT-TYPE"in OpenLayers.Util.upperCaseObject(a.headers) || (a.headers["Content-Type"] = "application/xml");
        return OpenLayers.Request.issue(a)
    },
    PUT: function (a) {
        a = OpenLayers.Util.extend(a, {method: "PUT"});
        a.headers = a.headers ?
            a.headers : {};
        "CONTENT-TYPE"in OpenLayers.Util.upperCaseObject(a.headers) || (a.headers["Content-Type"] = "application/xml");
        return OpenLayers.Request.issue(a)
    },
    DELETE: function (a) {
        a = OpenLayers.Util.extend(a, {method: "DELETE"});
        return OpenLayers.Request.issue(a)
    },
    HEAD: function (a) {
        a = OpenLayers.Util.extend(a, {method: "HEAD"});
        return OpenLayers.Request.issue(a)
    },
    OPTIONS: function (a) {
        a = OpenLayers.Util.extend(a, {method: "OPTIONS"});
        return OpenLayers.Request.issue(a)
    }
};
(function () {
    function a() {
        this._object = f && !k ? new f : new window.ActiveXObject("Microsoft.XMLHTTP");
        this._listeners = []
    }

    function b() {
        return new a
    }

    function c(a) {
        b.onreadystatechange && b.onreadystatechange.apply(a);
        a.dispatchEvent({type: "readystatechange", bubbles: !1, cancelable: !1, timeStamp: new Date + 0})
    }

    function d(a) {
        try {
            a.responseText = a._object.responseText
        } catch (b) {
        }
        try {
            var c = a._object, d = c.responseXML, e = c.responseText;
            h && e && d && !d.documentElement && c.getResponseHeader("Content-Type").match(/[^\/]+\/[^\+]+\+xml/) &&
            (d = new window.ActiveXObject("Microsoft.XMLDOM"), d.async = !1, d.validateOnParse = !1, d.loadXML(e));
            a.responseXML = d && (h && 0 != d.parseError || !d.documentElement || d.documentElement && "parsererror" == d.documentElement.tagName) ? null : d
        } catch (f) {
        }
        try {
            a.status = a._object.status
        } catch (g) {
        }
        try {
            a.statusText = a._object.statusText
        } catch (k) {
        }
    }

    function e(a) {
        a._object.onreadystatechange = new window.Function
    }

    var f = window.XMLHttpRequest, g = !!window.controllers, h = window.document.all && !window.opera, k = h && window.navigator.userAgent.match(/MSIE 7.0/);
    b.prototype = a.prototype;
    g && f.wrapped && (b.wrapped = f.wrapped);
    b.UNSENT = 0;
    b.OPENED = 1;
    b.HEADERS_RECEIVED = 2;
    b.LOADING = 3;
    b.DONE = 4;
    b.prototype.readyState = b.UNSENT;
    b.prototype.responseText = "";
    b.prototype.responseXML = null;
    b.prototype.status = 0;
    b.prototype.statusText = "";
    b.prototype.priority = "NORMAL";
    b.prototype.onreadystatechange = null;
    b.onreadystatechange = null;
    b.onopen = null;
    b.onsend = null;
    b.onabort = null;
    b.prototype.open = function (a, f, k, o, p) {
        delete this._headers;
        3 > arguments.length && (k = !0);
        this._async = k;
        var r = this,
            u = this.readyState, q;
        h && k && (q = function () {
            u != b.DONE && (e(r), r.abort())
        }, window.attachEvent("onunload", q));
        b.onopen && b.onopen.apply(this, arguments);
        4 < arguments.length ? this._object.open(a, f, k, o, p) : 3 < arguments.length ? this._object.open(a, f, k, o) : this._object.open(a, f, k);
        this.readyState = b.OPENED;
        c(this);
        this._object.onreadystatechange = function () {
            if (!g || k)r.readyState = r._object.readyState, d(r), r._aborted ? r.readyState = b.UNSENT : (r.readyState == b.DONE && (delete r._data, e(r), h && k && window.detachEvent("onunload", q)),
            u != r.readyState && c(r), u = r.readyState)
        }
    };
    b.prototype.send = function (a) {
        b.onsend && b.onsend.apply(this, arguments);
        arguments.length || (a = null);
        a && a.nodeType && (a = window.XMLSerializer ? (new window.XMLSerializer).serializeToString(a) : a.xml, this._headers["Content-Type"] || this._object.setRequestHeader("Content-Type", "application/xml"));
        this._data = a;
        this._object.send(this._data);
        if (g && !this._async) {
            this.readyState = b.OPENED;
            for (d(this); this.readyState < b.DONE && !(this.readyState++, c(this), this._aborted););
        }
    };
    b.prototype.abort =
        function () {
            b.onabort && b.onabort.apply(this, arguments);
            this.readyState > b.UNSENT && (this._aborted = !0);
            this._object.abort();
            e(this);
            this.readyState = b.UNSENT;
            delete this._data
        };
    b.prototype.getAllResponseHeaders = function () {
        return this._object.getAllResponseHeaders()
    };
    b.prototype.getResponseHeader = function (a) {
        return this._object.getResponseHeader(a)
    };
    b.prototype.setRequestHeader = function (a, b) {
        this._headers || (this._headers = {});
        this._headers[a] = b;
        return this._object.setRequestHeader(a, b)
    };
    b.prototype.addEventListener =
        function (a, b, c) {
            for (var d = 0, e; e = this._listeners[d]; d++)if (e[0] == a && e[1] == b && e[2] == c)return;
            this._listeners.push([a, b, c])
        };
    b.prototype.removeEventListener = function (a, b, c) {
        for (var d = 0, e; (e = this._listeners[d]) && !(e[0] == a && e[1] == b && e[2] == c); d++);
        e && this._listeners.splice(d, 1)
    };
    b.prototype.dispatchEvent = function (a) {
        a = {
            type: a.type,
            target: this,
            currentTarget: this,
            eventPhase: 2,
            bubbles: a.bubbles,
            cancelable: a.cancelable,
            timeStamp: a.timeStamp,
            stopPropagation: function () {
            },
            preventDefault: function () {
            },
            initEvent: function () {
            }
        };
        "readystatechange" == a.type && this.onreadystatechange && (this.onreadystatechange.handleEvent || this.onreadystatechange).apply(this, [a]);
        for (var b = 0, c; c = this._listeners[b]; b++)c[0] == a.type && !c[2] && (c[1].handleEvent || c[1]).apply(this, [a])
    };
    b.prototype.toString = function () {
        return "[object XMLHttpRequest]"
    };
    b.toString = function () {
        return "[XMLHttpRequest]"
    };
    window.Function.prototype.apply || (window.Function.prototype.apply = function (a, b) {
        b || (b = []);
        a.__func = this;
        a.__func(b[0], b[1], b[2], b[3], b[4]);
        delete a.__func
    });
    OpenLayers.Request.XMLHttpRequest = b
})();
OpenLayers.Projection = OpenLayers.Class({
    proj: null, projCode: null, titleRegEx: /\+title=[^\+]*/, initialize: function (a, b) {
        OpenLayers.Util.extend(this, b);
        this.projCode = a;
        window.Proj4js && (this.proj = new Proj4js.Proj(a))
    }, getCode: function () {
        return this.proj ? this.proj.srsCode : this.projCode
    }, getUnits: function () {
        return this.proj ? this.proj.units : null
    }, toString: function () {
        return this.getCode()
    }, equals: function (a) {
        var b = !1;
        a && (a instanceof OpenLayers.Projection || (a = new OpenLayers.Projection(a)), window.Proj4js &&
        this.proj.defData && a.proj.defData ? b = this.proj.defData.replace(this.titleRegEx, "") == a.proj.defData.replace(this.titleRegEx, "") : a.getCode && (b = this.getCode(), a = a.getCode(), b = b == a || !!OpenLayers.Projection.transforms[b] && OpenLayers.Projection.transforms[b][a] === OpenLayers.Projection.nullTransform));
        return b
    }, destroy: function () {
        delete this.proj;
        delete this.projCode
    }, CLASS_NAME: "OpenLayers.Projection"
});
OpenLayers.Projection.transforms = {};
OpenLayers.Projection.defaults = {
    "EPSG:4326": {units: "degrees", maxExtent: [-180, -90, 180, 90], yx: !0},
    "CRS:84": {units: "degrees", maxExtent: [-180, -90, 180, 90]},
    "EPSG:900913": {units: "m", maxExtent: [-2.003750834E7, -2.003750834E7, 2.003750834E7, 2.003750834E7]}
};
OpenLayers.Projection.addTransform = function (a, b, c) {
    if (c === OpenLayers.Projection.nullTransform) {
        var d = OpenLayers.Projection.defaults[a];
        d && !OpenLayers.Projection.defaults[b] && (OpenLayers.Projection.defaults[b] = d)
    }
    OpenLayers.Projection.transforms[a] || (OpenLayers.Projection.transforms[a] = {});
    OpenLayers.Projection.transforms[a][b] = c
};
OpenLayers.Projection.transform = function (a, b, c) {
    if (b && c)if (b instanceof OpenLayers.Projection || (b = new OpenLayers.Projection(b)), c instanceof OpenLayers.Projection || (c = new OpenLayers.Projection(c)), b.proj && c.proj)a = Proj4js.transform(b.proj, c.proj, a); else {
        var b = b.getCode(), c = c.getCode(), d = OpenLayers.Projection.transforms;
        if (d[b] && d[b][c])d[b][c](a)
    }
    return a
};
OpenLayers.Projection.nullTransform = function (a) {
    return a
};
(function () {
    function a(a) {
        a.x = 180 * a.x / d;
        a.y = 180 / Math.PI * (2 * Math.atan(Math.exp(a.y / d * Math.PI)) - Math.PI / 2);
        return a
    }

    function b(a) {
        a.x = a.x * d / 180;
        a.y = Math.log(Math.tan((90 + a.y) * Math.PI / 360)) / Math.PI * d;
        return a
    }

    function c(c, d) {
        var e = OpenLayers.Projection.addTransform, f = OpenLayers.Projection.nullTransform, g, o, p, r, u;
        for (g = 0, o = d.length; g < o; ++g) {
            p = d[g];
            e(c, p, b);
            e(p, c, a);
            for (u = g + 1; u < o; ++u)r = d[u], e(p, r, f), e(r, p, f)
        }
    }

    var d = 2.003750834E7, e = ["EPSG:900913", "EPSG:3857", "EPSG:102113", "EPSG:102100"], f = ["CRS:84", "urn:ogc:def:crs:EPSG:6.6:4326",
        "EPSG:4326"], g;
    for (g = e.length - 1; 0 <= g; --g)c(e[g], f);
    for (g = f.length - 1; 0 <= g; --g)c(f[g], e)
})();
OpenLayers.Map = OpenLayers.Class({
    Z_INDEX_BASE: {BaseLayer: 100, Overlay: 325, Feature: 225, Marker: 600, Popup: 750, Control: 1E3},
    id: null,
    fractionalZoom: !1,
    events: null,
    allOverlays: !1,
    div: null,
    dragging: !1,
    size: null,
    viewPortDiv: null,
    layerContainerOrigin: null,
    layerContainerDiv: null,
    layers: null,
    controls: null,
    popups: null,
    baseLayer: null,
    center: null,
    resolution: null,
    zoom: 0,
    panRatio: 1.5,
    options: null,
    tileSize: null,
    projection: "EPSG:4326",
    units: null,
    resolutions: null,
    maxResolution: null,
    minResolution: null,
    maxScale: null,
    minScale: null,
    maxExtent: null,
    minExtent: null,
    restrictedExtent: null,
    numZoomLevels: 16,
    theme: null,
    displayProjection: null,
    fallThrough: !0,
    panTween: null,
    eventListeners: null,
    panMethod: OpenLayers.Easing.Expo.easeOut,
    panDuration: 50,
    paddingForPopups: null,
    minPx: null,
    maxPx: null,
    initialize: function (a, b) {
        1 === arguments.length && "object" === typeof a && (a = (b = a) && b.div);
        this.tileSize = new OpenLayers.Size(OpenLayers.Map.TILE_WIDTH, OpenLayers.Map.TILE_HEIGHT);
        this.paddingForPopups = new OpenLayers.Bounds(15, 15, 15, 15);
        this.theme = urlServer +
        "map/ol/theme/default/style.css";
        this.options = OpenLayers.Util.extend({}, b);
        OpenLayers.Util.extend(this, b);
        OpenLayers.Util.applyDefaults(this, OpenLayers.Projection.defaults[this.projection instanceof OpenLayers.Projection ? this.projection.projCode : this.projection]);
        this.maxExtent && !(this.maxExtent instanceof OpenLayers.Bounds) && (this.maxExtent = new OpenLayers.Bounds(this.maxExtent));
        this.minExtent && !(this.minExtent instanceof OpenLayers.Bounds) && (this.minExtent = new OpenLayers.Bounds(this.minExtent));
        this.restrictedExtent && !(this.restrictedExtent instanceof OpenLayers.Bounds) && (this.restrictedExtent = new OpenLayers.Bounds(this.restrictedExtent));
        this.center && !(this.center instanceof OpenLayers.LonLat) && (this.center = new OpenLayers.LonLat(this.center));
        this.layers = [];
        this.id = OpenLayers.Util.createUniqueID("OpenLayers.Map_");
        (this.div = OpenLayers.Util.getElement(a)) || (this.div = document.createElement("div"), this.div.style.height = "1px", this.div.style.width = "1px");
        OpenLayers.Element.addClass(this.div,
            "olMap");
        var c = this.id + "_OpenLayers_ViewPort";
        this.viewPortDiv = OpenLayers.Util.createDiv(c, null, null, null, "relative", null, "hidden");
        this.viewPortDiv.style.width = "100%";
        this.viewPortDiv.style.height = "100%";
        this.viewPortDiv.className = "olMapViewport";
        this.div.appendChild(this.viewPortDiv);
        this.events = new OpenLayers.Events(this, this.viewPortDiv, null, this.fallThrough, {includeXY: !0});
        c = this.id + "_OpenLayers_Container";
        this.layerContainerDiv = OpenLayers.Util.createDiv(c);
        this.layerContainerDiv.style.width =
            "100px";
        this.layerContainerDiv.style.height = "100px";
        this.layerContainerDiv.style.zIndex = this.Z_INDEX_BASE.Popup - 1;
        this.viewPortDiv.appendChild(this.layerContainerDiv);
        this.updateSize();
        if (this.eventListeners instanceof Object)this.events.on(this.eventListeners);
        9 > parseFloat(navigator.appVersion.split("MSIE")[1]) ? this.events.register("resize", this, this.updateSize) : (this.updateSizeDestroy = OpenLayers.Function.bind(this.updateSize, this), OpenLayers.Event.observe(window, "resize", this.updateSizeDestroy));
        if (this.theme) {
            for (var c = !0, d = document.getElementsByTagName("link"), e = 0, f = d.length; e < f; ++e)if (OpenLayers.Util.isEquivalentUrl(d.item(e).href, this.theme)) {
                c = !1;
                break
            }
            c && (c = document.createElement("link"), c.setAttribute("rel", "stylesheet"), c.setAttribute("type", "text/css"), c.setAttribute("href", this.theme), document.getElementsByTagName("head")[0].appendChild(c))
        }
        null == this.controls && (this.controls = [], null != OpenLayers.Control && (OpenLayers.Control.Navigation ? this.controls.push(new OpenLayers.Control.Navigation) :
        OpenLayers.Control.TouchNavigation && this.controls.push(new OpenLayers.Control.TouchNavigation), OpenLayers.Control.Zoom ? this.controls.push(new OpenLayers.Control.Zoom) : OpenLayers.Control.PanZoom && this.controls.push(new OpenLayers.Control.PanZoom), OpenLayers.Control.ArgParser && this.controls.push(new OpenLayers.Control.ArgParser), OpenLayers.Control.Attribution && this.controls.push(new OpenLayers.Control.Attribution)));
        e = 0;
        for (f = this.controls.length; e < f; e++)this.addControlToMap(this.controls[e]);
        this.popups =
            [];
        this.unloadDestroy = OpenLayers.Function.bind(this.destroy, this);
        OpenLayers.Event.observe(window, "unload", this.unloadDestroy);
        b && b.layers && (delete this.center, this.addLayers(b.layers), b.center && !this.getCenter() && this.setCenter(b.center, b.zoom))
    },
    getViewport: function () {
        return this.viewPortDiv
    },
    render: function (a) {
        this.div = OpenLayers.Util.getElement(a);
        OpenLayers.Element.addClass(this.div, "olMap");
        this.viewPortDiv.parentNode.removeChild(this.viewPortDiv);
        this.div.appendChild(this.viewPortDiv);
        this.updateSize()
    },
    unloadDestroy: null,
    updateSizeDestroy: null,
    destroy: function () {
        if (!this.unloadDestroy)return !1;
        this.panTween && (this.panTween.stop(), this.panTween = null);
        OpenLayers.Event.stopObserving(window, "unload", this.unloadDestroy);
        this.unloadDestroy = null;
        this.updateSizeDestroy ? OpenLayers.Event.stopObserving(window, "resize", this.updateSizeDestroy) : this.events.unregister("resize", this, this.updateSize);
        this.paddingForPopups = null;
        if (null != this.controls) {
            for (var a = this.controls.length - 1; 0 <= a; --a)this.controls[a].destroy();
            this.controls = null
        }
        if (null != this.layers) {
            for (a = this.layers.length - 1; 0 <= a; --a)this.layers[a].destroy(!1);
            this.layers = null
        }
        this.viewPortDiv && this.div.removeChild(this.viewPortDiv);
        this.viewPortDiv = null;
        this.eventListeners && (this.events.un(this.eventListeners), this.eventListeners = null);
        this.events.destroy();
        this.options = this.events = null
    },
    setOptions: function (a) {
        var b = this.minPx && a.restrictedExtent != this.restrictedExtent;
        OpenLayers.Util.extend(this, a);
        b && this.moveTo(this.getCachedCenter(), this.zoom, {forceZoomChange: !0})
    },
    getTileSize: function () {
        return this.tileSize
    },
    getBy: function (a, b, c) {
        var d = "function" == typeof c.test;
        return OpenLayers.Array.filter(this[a], function (a) {
            return a[b] == c || d && c.test(a[b])
        })
    },
    getLayersBy: function (a, b) {
        return this.getBy("layers", a, b)
    },
    getLayersByName: function (a) {
        return this.getLayersBy("name", a)
    },
    getLayersByClass: function (a) {
        return this.getLayersBy("CLASS_NAME", a)
    },
    getControlsBy: function (a, b) {
        return this.getBy("controls", a, b)
    },
    getControlsByClass: function (a) {
        return this.getControlsBy("CLASS_NAME",
            a)
    },
    getLayer: function (a) {
        for (var b = null, c = 0, d = this.layers.length; c < d; c++) {
            var e = this.layers[c];
            if (e.id == a) {
                b = e;
                break
            }
        }
        return b
    },
    setLayerZIndex: function (a, b) {
        var c = "Overlay";
        a.isBaseLayer ? c = "BaseLayer" : "OpenLayers.Layer.Markers" == a.CLASS_NAME ? c = "Marker" : "OpenLayers.Layer.Vector" == a.CLASS_NAME && (c = "Feature");
        a.setZIndex(this.Z_INDEX_BASE[c] + 5 * b)
    },
    resetLayersZIndex: function () {
        for (var a = 0, b = this.layers.length; a < b; a++)this.setLayerZIndex(this.layers[a], a)
    },
    addLayer: function (a) {
        for (var b = 0, c = this.layers.length; b <
        c; b++)if (this.layers[b] == a)return !1;
        if (!1 === this.events.triggerEvent("preaddlayer", {layer: a}))return !1;
        this.allOverlays && (a.isBaseLayer = !1);
        a.div.className = "olLayerDiv";
        a.div.style.overflow = "";
        this.setLayerZIndex(a, this.layers.length);
        a.isFixed ? this.viewPortDiv.appendChild(a.div) : this.layerContainerDiv.appendChild(a.div);
        this.layers.push(a);
        a.setMap(this);
        a.isBaseLayer || this.allOverlays && !this.baseLayer ? null == this.baseLayer ? this.setBaseLayer(a) : a.setVisibility(!1) : a.redraw();
        this.events.triggerEvent("addlayer",
            {layer: a});
        a.events.triggerEvent("added", {map: this, layer: a});
        a.afterAdd();
        return !0
    },
    addLayers: function (a) {
        for (var b = 0, c = a.length; b < c; b++)this.addLayer(a[b])
    },
    removeLayer: function (a, b) {
        if (!1 !== this.events.triggerEvent("preremovelayer", {layer: a})) {
            null == b && (b = !0);
            a.isFixed ? this.viewPortDiv.removeChild(a.div) : this.layerContainerDiv.removeChild(a.div);
            OpenLayers.Util.removeItem(this.layers, a);
            a.removeMap(this);
            a.map = null;
            if (this.baseLayer == a && (this.baseLayer = null, b))for (var c = 0, d = this.layers.length; c <
            d; c++) {
                var e = this.layers[c];
                if (e.isBaseLayer || this.allOverlays) {
                    this.setBaseLayer(e);
                    break
                }
            }
            this.resetLayersZIndex();
            this.events.triggerEvent("removelayer", {layer: a});
            a.events.triggerEvent("removed", {map: this, layer: a})
        }
    },
    getNumLayers: function () {
        return this.layers.length
    },
    getLayerIndex: function (a) {
        return OpenLayers.Util.indexOf(this.layers, a)
    },
    setLayerIndex: function (a, b) {
        var c = this.getLayerIndex(a);
        0 > b ? b = 0 : b > this.layers.length && (b = this.layers.length);
        if (c != b) {
            this.layers.splice(c, 1);
            this.layers.splice(b,
                0, a);
            for (var c = 0, d = this.layers.length; c < d; c++)this.setLayerZIndex(this.layers[c], c);
            this.events.triggerEvent("changelayer", {layer: a, property: "order"});
            this.allOverlays && (0 === b ? this.setBaseLayer(a) : this.baseLayer !== this.layers[0] && this.setBaseLayer(this.layers[0]))
        }
    },
    raiseLayer: function (a, b) {
        var c = this.getLayerIndex(a) + b;
        this.setLayerIndex(a, c)
    },
    setBaseLayer: function (a) {
        if (a != this.baseLayer && -1 != OpenLayers.Util.indexOf(this.layers, a)) {
            var b = this.getCachedCenter(), c = OpenLayers.Util.getResolutionFromScale(this.getScale(),
                a.units);
            null != this.baseLayer && !this.allOverlays && this.baseLayer.setVisibility(!1);
            this.baseLayer = a;
            if (!this.allOverlays || this.baseLayer.visibility)this.baseLayer.setVisibility(!0), !1 === this.baseLayer.inRange && this.baseLayer.redraw();
            null != b && (a = this.getZoomForResolution(c || this.resolution, !0), this.setCenter(b, a, !1, !0));
            this.events.triggerEvent("changebaselayer", {layer: this.baseLayer})
        }
    },
    addControl: function (a, b) {
        this.controls.push(a);
        this.addControlToMap(a, b)
    },
    addControls: function (a, b) {
        for (var c =
            1 === arguments.length ? [] : b, d = 0, e = a.length; d < e; d++)this.addControl(a[d], c[d] ? c[d] : null)
    },
    addControlToMap: function (a, b) {
        a.outsideViewport = null != a.div;
        this.displayProjection && !a.displayProjection && (a.displayProjection = this.displayProjection);
        a.setMap(this);
        var c = a.draw(b);
        c && !a.outsideViewport && (c.style.zIndex = this.Z_INDEX_BASE.Control + this.controls.length, this.viewPortDiv.appendChild(c));
        a.autoActivate && a.activate()
    },
    getControl: function (a) {
        for (var b = null, c = 0, d = this.controls.length; c < d; c++) {
            var e = this.controls[c];
            if (e.id == a) {
                b = e;
                break
            }
        }
        return b
    },
    removeControl: function (a) {
        a && a == this.getControl(a.id) && (a.div && a.div.parentNode == this.viewPortDiv && this.viewPortDiv.removeChild(a.div), OpenLayers.Util.removeItem(this.controls, a))
    },
    addPopup: function (a, b) {
        if (b)for (var c = this.popups.length - 1; 0 <= c; --c)this.removePopup(this.popups[c]);
        a.map = this;
        this.popups.push(a);
        if (c = a.draw())c.style.zIndex = this.Z_INDEX_BASE.Popup + this.popups.length, this.layerContainerDiv.appendChild(c)
    },
    removePopup: function (a) {
        OpenLayers.Util.removeItem(this.popups,
            a);
        if (a.div)try {
            this.layerContainerDiv.removeChild(a.div)
        } catch (b) {
        }
        a.map = null
    },
    getSize: function () {
        var a = null;
        null != this.size && (a = this.size.clone());
        return a
    },
    updateSize: function () {
        var a = this.getCurrentSize();
        if (a && !isNaN(a.h) && !isNaN(a.w)) {
            this.events.clearMouseCache();
            var b = this.getSize();
            null == b && (this.size = b = a);
            if (!a.equals(b)) {
                this.size = a;
                a = 0;
                for (b = this.layers.length; a < b; a++)this.layers[a].onMapResize();
                a = this.getCachedCenter();
                null != this.baseLayer && null != a && (b = this.getZoom(), this.zoom = null,
                    this.setCenter(a, b))
            }
        }
    },
    getCurrentSize: function () {
        var a = new OpenLayers.Size(this.div.clientWidth, this.div.clientHeight);
        if (0 == a.w && 0 == a.h || isNaN(a.w) && isNaN(a.h))a.w = this.div.offsetWidth, a.h = this.div.offsetHeight;
        if (0 == a.w && 0 == a.h || isNaN(a.w) && isNaN(a.h))a.w = parseInt(this.div.style.width), a.h = parseInt(this.div.style.height);
        return a
    },
    calculateBounds: function (a, b) {
        var c = null;
        null == a && (a = this.getCachedCenter());
        null == b && (b = this.getResolution());
        if (null != a && null != b)var c = this.size.w * b / 2, d = this.size.h *
            b / 2, c = new OpenLayers.Bounds(a.lon - c, a.lat - d, a.lon + c, a.lat + d);
        return c
    },
    getCenter: function () {
        var a = null, b = this.getCachedCenter();
        b && (a = b.clone());
        return a
    },
    getCachedCenter: function () {
        !this.center && this.size && (this.center = this.getLonLatFromViewPortPx({
            x: this.size.w / 2,
            y: this.size.h / 2
        }));
        return this.center
    },
    getZoom: function () {
        return this.zoom
    },
    pan: function (a, b, c) {
        c = OpenLayers.Util.applyDefaults(c, {animate: !0, dragging: !1});
        if (c.dragging)(0 != a || 0 != b) && this.moveByPx(a, b); else {
            var d = this.getViewPortPxFromLonLat(this.getCachedCenter()),
                a = d.add(a, b);
            if (this.dragging || !a.equals(d))d = this.getLonLatFromViewPortPx(a), c.animate ? this.panTo(d) : (this.moveTo(d), this.dragging && (this.dragging = !1, this.events.triggerEvent("moveend")))
        }
    },
    panTo: function (a) {
        if (this.panMethod && this.getExtent().scale(this.panRatio).containsLonLat(a)) {
            this.panTween || (this.panTween = new OpenLayers.Tween(this.panMethod));
            var b = this.getCachedCenter();
            if (!a.equals(b)) {
                var b = this.getPixelFromLonLat(b), c = this.getPixelFromLonLat(a), d = 0, e = 0;
                this.panTween.start({x: 0, y: 0}, {
                    x: c.x -
                    b.x, y: c.y - b.y
                }, this.panDuration, {
                    callbacks: {
                        eachStep: OpenLayers.Function.bind(function (a) {
                            this.moveByPx(a.x - d, a.y - e);
                            d = Math.round(a.x);
                            e = Math.round(a.y)
                        }, this), done: OpenLayers.Function.bind(function () {
                            this.moveTo(a);
                            this.dragging = !1;
                            this.events.triggerEvent("moveend")
                        }, this)
                    }
                })
            }
        } else this.setCenter(a)
    },
    setCenter: function (a, b, c, d) {
        this.panTween && this.panTween.stop();
        this.moveTo(a, b, {dragging: c, forceZoomChange: d})
    },
    moveByPx: function (a, b) {
        var c = this.size.w / 2, d = this.size.h / 2, e = c + a, f = d + b, g = this.baseLayer.wrapDateLine,
            h = 0, k = 0;
        this.restrictedExtent && (h = c, k = d, g = !1);
        a = g || e <= this.maxPx.x - h && e >= this.minPx.x + h ? Math.round(a) : 0;
        b = f <= this.maxPx.y - k && f >= this.minPx.y + k ? Math.round(b) : 0;
        if (a || b) {
            this.dragging || (this.dragging = !0, this.events.triggerEvent("movestart"));
            this.center = null;
            a && (this.layerContainerDiv.style.left = parseInt(this.layerContainerDiv.style.left) - a + "px", this.minPx.x -= a, this.maxPx.x -= a);
            b && (this.layerContainerDiv.style.top = parseInt(this.layerContainerDiv.style.top) - b + "px", this.minPx.y -= b, this.maxPx.y -= b);
            for (d =
                     0, e = this.layers.length; d < e; ++d)if (c = this.layers[d], c.visibility && (c === this.baseLayer || c.inRange))c.moveByPx(a, b), c.events.triggerEvent("move");
            this.events.triggerEvent("move")
        }
    },
    adjustZoom: function (a) {
        var b = this.baseLayer.resolutions, c = this.getMaxExtent().getWidth() / this.size.w;
        if (this.getResolutionForZoom(a) > c)for (var d = a | 0, e = b.length; d < e; ++d)if (b[d] <= c) {
            a = d;
            break
        }
        return a
    },
    moveTo: function (a, b, c) {
        null != a && !(a instanceof OpenLayers.LonLat) && (a = new OpenLayers.LonLat(a));
        c || (c = {});
        null != b && (b = parseFloat(b),
        this.fractionalZoom || (b = Math.round(b)));
        if (this.baseLayer.wrapDateLine) {
            var d = b, b = this.adjustZoom(b);
            b !== d && (a = this.getCenter())
        }
        var d = c.dragging || this.dragging, e = c.forceZoomChange;
        !this.getCachedCenter() && !this.isValidLonLat(a) && (a = this.maxExtent.getCenterLonLat(), this.center = a.clone());
        if (null != this.restrictedExtent) {
            null == a && (a = this.center);
            null == b && (b = this.getZoom());
            var f = this.getResolutionForZoom(b), f = this.calculateBounds(a, f);
            if (!this.restrictedExtent.containsBounds(f)) {
                var g = this.restrictedExtent.getCenterLonLat();
                f.getWidth() > this.restrictedExtent.getWidth() ? a = new OpenLayers.LonLat(g.lon, a.lat) : f.left < this.restrictedExtent.left ? a = a.add(this.restrictedExtent.left - f.left, 0) : f.right > this.restrictedExtent.right && (a = a.add(this.restrictedExtent.right - f.right, 0));
                f.getHeight() > this.restrictedExtent.getHeight() ? a = new OpenLayers.LonLat(a.lon, g.lat) : f.bottom < this.restrictedExtent.bottom ? a = a.add(0, this.restrictedExtent.bottom - f.bottom) : f.top > this.restrictedExtent.top && (a = a.add(0, this.restrictedExtent.top - f.top))
            }
        }
        e =
            e || this.isValidZoomLevel(b) && b != this.getZoom();
        f = this.isValidLonLat(a) && !a.equals(this.center);
        if (e || f || d) {
            d || this.events.triggerEvent("movestart");
            f && (!e && this.center && this.centerLayerContainer(a), this.center = a.clone());
            a = e ? this.getResolutionForZoom(b) : this.getResolution();
            if (e || null == this.layerContainerOrigin) {
                this.layerContainerOrigin = this.getCachedCenter();
                this.layerContainerDiv.style.left = "0px";
                this.layerContainerDiv.style.top = "0px";
                var f = this.getMaxExtent({restricted: !0}), h = f.getCenterLonLat(),
                    g = this.center.lon - h.lon, h = h.lat - this.center.lat, k = Math.round(f.getWidth() / a), l = Math.round(f.getHeight() / a);
                this.minPx = {x: (this.size.w - k) / 2 - g / a, y: (this.size.h - l) / 2 - h / a};
                this.maxPx = {
                    x: this.minPx.x + Math.round(f.getWidth() / a),
                    y: this.minPx.y + Math.round(f.getHeight() / a)
                }
            }
            e && (this.zoom = b, this.resolution = a);
            a = this.getExtent();
            this.baseLayer.visibility && (this.baseLayer.moveTo(a, e, c.dragging), c.dragging || this.baseLayer.events.triggerEvent("moveend", {zoomChanged: e}));
            a = this.baseLayer.getExtent();
            for (b = this.layers.length -
            1; 0 <= b; --b)f = this.layers[b], f !== this.baseLayer && !f.isBaseLayer && (g = f.calculateInRange(), f.inRange != g && ((f.inRange = g) || f.display(!1), this.events.triggerEvent("changelayer", {
                layer: f,
                property: "visibility"
            })), g && f.visibility && (f.moveTo(a, e, c.dragging), c.dragging || f.events.triggerEvent("moveend", {zoomChanged: e})));
            this.events.triggerEvent("move");
            d || this.events.triggerEvent("moveend");
            if (e) {
                b = 0;
                for (c = this.popups.length; b < c; b++)this.popups[b].updatePosition();
                this.events.triggerEvent("zoomend")
            }
        }
    },
    centerLayerContainer: function (a) {
        var b =
            this.getViewPortPxFromLonLat(this.layerContainerOrigin), c = this.getViewPortPxFromLonLat(a);
        if (null != b && null != c) {
            var d = parseInt(this.layerContainerDiv.style.left), a = parseInt(this.layerContainerDiv.style.top), e = Math.round(b.x - c.x), b = Math.round(b.y - c.y);
            this.layerContainerDiv.style.left = e + "px";
            this.layerContainerDiv.style.top = b + "px";
            d -= e;
            a -= b;
            this.minPx.x -= d;
            this.maxPx.x -= d;
            this.minPx.y -= a;
            this.maxPx.y -= a
        }
    },
    isValidZoomLevel: function (a) {
        return null != a && 0 <= a && a < this.getNumZoomLevels()
    },
    isValidLonLat: function (a) {
        var b =
            !1;
        null != a && (b = this.getMaxExtent(), b = b.containsLonLat(a, {worldBounds: this.baseLayer.wrapDateLine && b}));
        return b
    },
    getProjection: function () {
        var a = this.getProjectionObject();
        return a ? a.getCode() : null
    },
    getProjectionObject: function () {
        var a = null;
        null != this.baseLayer && (a = this.baseLayer.projection);
        return a
    },
    getMaxResolution: function () {
        var a = null;
        null != this.baseLayer && (a = this.baseLayer.maxResolution);
        return a
    },
    getMaxExtent: function (a) {
        var b = null;
        a && a.restricted && this.restrictedExtent ? b = this.restrictedExtent :
        null != this.baseLayer && (b = this.baseLayer.maxExtent);
        return b
    },
    getNumZoomLevels: function () {
        var a = null;
        null != this.baseLayer && (a = this.baseLayer.numZoomLevels);
        return a
    },
    getExtent: function () {
        var a = null;
        null != this.baseLayer && (a = this.baseLayer.getExtent());
        return a
    },
    getResolution: function () {
        var a = null;
        null != this.baseLayer ? a = this.baseLayer.getResolution() : !0 === this.allOverlays && 0 < this.layers.length && (a = this.layers[0].getResolution());
        return a
    },
    getUnits: function () {
        var a = null;
        null != this.baseLayer && (a = this.baseLayer.units);
        return a
    },
    getScale: function () {
        var a = null;
        null != this.baseLayer && (a = this.getResolution(), a = OpenLayers.Util.getScaleFromResolution(a, this.baseLayer.units));
        return a
    },
    getZoomForExtent: function (a, b) {
        var c = null;
        null != this.baseLayer && (c = this.baseLayer.getZoomForExtent(a, b));
        return c
    },
    getResolutionForZoom: function (a) {
        var b = null;
        this.baseLayer && (b = this.baseLayer.getResolutionForZoom(a));
        return b
    },
    getZoomForResolution: function (a, b) {
        var c = null;
        null != this.baseLayer && (c = this.baseLayer.getZoomForResolution(a, b));
        return c
    },
    zoomTo: function (a) {
        this.isValidZoomLevel(a) && this.setCenter(null, a)
    },
    zoomIn: function () {
        this.zoomTo(this.getZoom() + 1)
    },
    zoomOut: function () {
        this.zoomTo(this.getZoom() - 1)
    },
    zoomToExtent: function (a, b) {
        a instanceof OpenLayers.Bounds || (a = new OpenLayers.Bounds(a));
        var c = a.getCenterLonLat();
        if (this.baseLayer.wrapDateLine) {
            c = this.getMaxExtent();
            for (a = a.clone(); a.right < a.left;)a.right += c.getWidth();
            c = a.getCenterLonLat().wrapDateLine(c)
        }
        this.setCenter(c, this.getZoomForExtent(a, b))
    },
    zoomToMaxExtent: function (a) {
        this.zoomToExtent(this.getMaxExtent({
            restricted: a ?
                a.restricted : !0
        }))
    },
    zoomToScale: function (a, b) {
        var c = OpenLayers.Util.getResolutionFromScale(a, this.baseLayer.units), d = this.size.w * c / 2, c = this.size.h * c / 2, e = this.getCachedCenter();
        this.zoomToExtent(new OpenLayers.Bounds(e.lon - d, e.lat - c, e.lon + d, e.lat + c), b)
    },
    getLonLatFromViewPortPx: function (a) {
        var b = null;
        null != this.baseLayer && (b = this.baseLayer.getLonLatFromViewPortPx(a));
        return b
    },
    getViewPortPxFromLonLat: function (a) {
        var b = null;
        null != this.baseLayer && (b = this.baseLayer.getViewPortPxFromLonLat(a));
        return b
    },
    getLonLatFromPixel: function (a) {
        return this.getLonLatFromViewPortPx(a)
    },
    getPixelFromLonLat: function (a) {
        a = this.getViewPortPxFromLonLat(a);
        a.x = Math.round(a.x);
        a.y = Math.round(a.y);
        return a
    },
    getGeodesicPixelSize: function (a) {
        var b = a ? this.getLonLatFromPixel(a) : this.getCachedCenter() || new OpenLayers.LonLat(0, 0), c = this.getResolution(), a = b.add(-c / 2, 0), d = b.add(c / 2, 0), e = b.add(0, -c / 2), b = b.add(0, c / 2), c = new OpenLayers.Projection("EPSG:4326"), f = this.getProjectionObject() || c;
        f.equals(c) || (a.transform(f, c), d.transform(f,
            c), e.transform(f, c), b.transform(f, c));
        return new OpenLayers.Size(OpenLayers.Util.distVincenty(a, d), OpenLayers.Util.distVincenty(e, b))
    },
    getViewPortPxFromLayerPx: function (a) {
        var b = null;
        if (null != a)var b = parseInt(this.layerContainerDiv.style.left), c = parseInt(this.layerContainerDiv.style.top), b = a.add(b, c);
        return b
    },
    getLayerPxFromViewPortPx: function (a) {
        var b = null;
        if (null != a) {
            var b = -parseInt(this.layerContainerDiv.style.left), c = -parseInt(this.layerContainerDiv.style.top), b = a.add(b, c);
            if (isNaN(b.x) || isNaN(b.y))b =
                null
        }
        return b
    },
    getLonLatFromLayerPx: function (a) {
        a = this.getViewPortPxFromLayerPx(a);
        return this.getLonLatFromViewPortPx(a)
    },
    getLayerPxFromLonLat: function (a) {
        return this.getLayerPxFromViewPortPx(this.getPixelFromLonLat(a))
    },
    CLASS_NAME: "OpenLayers.Map"
});
OpenLayers.Map.TILE_WIDTH = 256;
OpenLayers.Map.TILE_HEIGHT = 256;
OpenLayers.Layer = OpenLayers.Class({
    id: null,
    name: null,
    div: null,
    opacity: 1,
    alwaysInRange: null,
    RESOLUTION_PROPERTIES: "scales,resolutions,maxScale,minScale,maxResolution,minResolution,numZoomLevels,maxZoomLevel".split(","),
    events: null,
    map: null,
    isBaseLayer: !1,
    alpha: !1,
    displayInLayerSwitcher: !0,
    visibility: !0,
    attribution: null,
    inRange: !1,
    imageSize: null,
    options: null,
    eventListeners: null,
    gutter: 0,
    projection: null,
    units: null,
    scales: null,
    resolutions: null,
    maxExtent: null,
    minExtent: null,
    maxResolution: null,
    minResolution: null,
    numZoomLevels: null,
    minScale: null,
    maxScale: null,
    displayOutsideMaxExtent: !1,
    wrapDateLine: !1,
    metadata: null,
    initialize: function (a, b) {
        this.metadata = {};
        this.addOptions(b);
        this.name = a;
        if (null == this.id && (this.id = OpenLayers.Util.createUniqueID(this.CLASS_NAME + "_"), this.div = OpenLayers.Util.createDiv(this.id), this.div.style.width = "100%", this.div.style.height = "100%", this.div.dir = "ltr", this.events = new OpenLayers.Events(this, this.div), this.eventListeners instanceof Object))this.events.on(this.eventListeners)
    },
    destroy: function (a) {
        null == a && (a = !0);
        null != this.map && this.map.removeLayer(this, a);
        this.options = this.div = this.name = this.map = this.projection = null;
        this.events && (this.eventListeners && this.events.un(this.eventListeners), this.events.destroy());
        this.events = this.eventListeners = null
    },
    clone: function (a) {
        null == a && (a = new OpenLayers.Layer(this.name, this.getOptions()));
        OpenLayers.Util.applyDefaults(a, this);
        a.map = null;
        return a
    },
    getOptions: function () {
        var a = {}, b;
        for (b in this.options)a[b] = this[b];
        return a
    },
    setName: function (a) {
        a !=
        this.name && (this.name = a, null != this.map && this.map.events.triggerEvent("changelayer", {
            layer: this,
            property: "name"
        }))
    },
    addOptions: function (a, b) {
        null == this.options && (this.options = {});
        a && ("string" == typeof a.projection && (a.projection = new OpenLayers.Projection(a.projection)), a.projection && OpenLayers.Util.applyDefaults(a, OpenLayers.Projection.defaults[a.projection.getCode()]), a.maxExtent && !(a.maxExtent instanceof OpenLayers.Bounds) && (a.maxExtent = new OpenLayers.Bounds(a.maxExtent)), a.minExtent && !(a.minExtent instanceof
        OpenLayers.Bounds) && (a.minExtent = new OpenLayers.Bounds(a.minExtent)));
        OpenLayers.Util.extend(this.options, a);
        OpenLayers.Util.extend(this, a);
        this.projection && this.projection.getUnits() && (this.units = this.projection.getUnits());
        if (this.map) {
            var c = this.map.getResolution(), d = this.RESOLUTION_PROPERTIES.concat(["projection", "units", "minExtent", "maxExtent"]), e;
            for (e in a)if (a.hasOwnProperty(e) && 0 <= OpenLayers.Util.indexOf(d, e)) {
                this.initResolutions();
                b && this.map.baseLayer === this && (this.map.setCenter(this.map.getCenter(),
                    this.map.getZoomForResolution(c), !1, !0), this.map.events.triggerEvent("changebaselayer", {layer: this}));
                break
            }
        }
    },
    onMapResize: function () {
    },
    redraw: function () {
        var a = !1;
        if (this.map) {
            this.inRange = this.calculateInRange();
            var b = this.getExtent();
            b && this.inRange && this.visibility && (this.moveTo(b, !0, !1), this.events.triggerEvent("moveend", {zoomChanged: !0}), a = !0)
        }
        return a
    },
    moveTo: function () {
        var a = this.visibility;
        this.isBaseLayer || (a = a && this.inRange);
        this.display(a)
    },
    moveByPx: function () {
    },
    setMap: function (a) {
        null ==
        this.map && (this.map = a, this.maxExtent = this.maxExtent || this.map.maxExtent, this.minExtent = this.minExtent || this.map.minExtent, this.projection = this.projection || this.map.projection, "string" == typeof this.projection && (this.projection = new OpenLayers.Projection(this.projection)), this.units = this.projection.getUnits() || this.units || this.map.units, this.initResolutions(), this.isBaseLayer || (this.inRange = this.calculateInRange(), this.div.style.display = this.visibility && this.inRange ? "" : "none"), this.setTileSize())
    },
    afterAdd: function () {
    },
    removeMap: function () {
    },
    getImageSize: function () {
        return this.imageSize || this.tileSize
    },
    setTileSize: function (a) {
        this.tileSize = a = a ? a : this.tileSize ? this.tileSize : this.map.getTileSize();
        this.gutter && (this.imageSize = new OpenLayers.Size(a.w + 2 * this.gutter, a.h + 2 * this.gutter))
    },
    getVisibility: function () {
        return this.visibility
    },
    setVisibility: function (a) {
        a != this.visibility && (this.visibility = a, this.display(a), this.redraw(), null != this.map && this.map.events.triggerEvent("changelayer", {
            layer: this,
            property: "visibility"
        }),
            this.events.triggerEvent("visibilitychanged"))
    },
    display: function (a) {
        a != ("none" != this.div.style.display) && (this.div.style.display = a && this.calculateInRange() ? "block" : "none")
    },
    calculateInRange: function () {
        var a = !1;
        this.alwaysInRange ? a = !0 : this.map && (a = this.map.getResolution(), a = a >= this.minResolution && a <= this.maxResolution);
        return a
    },
    setIsBaseLayer: function (a) {
        a != this.isBaseLayer && (this.isBaseLayer = a, null != this.map && this.map.events.triggerEvent("changebaselayer", {layer: this}))
    },
    initResolutions: function () {
        var a,
            b, c, d = {}, e = !0;
        for (a = 0, b = this.RESOLUTION_PROPERTIES.length; a < b; a++)c = this.RESOLUTION_PROPERTIES[a], d[c] = this.options[c], e && this.options[c] && (e = !1);
        null == this.alwaysInRange && (this.alwaysInRange = e);
        null == d.resolutions && (d.resolutions = this.resolutionsFromScales(d.scales));
        null == d.resolutions && (d.resolutions = this.calculateResolutions(d));
        if (null == d.resolutions) {
            for (a = 0, b = this.RESOLUTION_PROPERTIES.length; a < b; a++)c = this.RESOLUTION_PROPERTIES[a], d[c] = null != this.options[c] ? this.options[c] : this.map[c];
            null ==
            d.resolutions && (d.resolutions = this.resolutionsFromScales(d.scales));
            null == d.resolutions && (d.resolutions = this.calculateResolutions(d))
        }
        var f;
        this.options.maxResolution && "auto" !== this.options.maxResolution && (f = this.options.maxResolution);
        this.options.minScale && (f = OpenLayers.Util.getResolutionFromScale(this.options.minScale, this.units));
        var g;
        this.options.minResolution && "auto" !== this.options.minResolution && (g = this.options.minResolution);
        this.options.maxScale && (g = OpenLayers.Util.getResolutionFromScale(this.options.maxScale,
            this.units));
        d.resolutions && (d.resolutions.sort(function (a, b) {
            return b - a
        }), f || (f = d.resolutions[0]), g || (g = d.resolutions[d.resolutions.length - 1]));
        if (this.resolutions = d.resolutions) {
            b = this.resolutions.length;
            this.scales = Array(b);
            for (a = 0; a < b; a++)this.scales[a] = OpenLayers.Util.getScaleFromResolution(this.resolutions[a], this.units);
            this.numZoomLevels = b
        }
        if (this.minResolution = g)this.maxScale = OpenLayers.Util.getScaleFromResolution(g, this.units);
        if (this.maxResolution = f)this.minScale = OpenLayers.Util.getScaleFromResolution(f,
            this.units)
    },
    resolutionsFromScales: function (a) {
        if (null != a) {
            var b, c, d;
            d = a.length;
            b = Array(d);
            for (c = 0; c < d; c++)b[c] = OpenLayers.Util.getResolutionFromScale(a[c], this.units);
            return b
        }
    },
    calculateResolutions: function (a) {
        var b, c, d = a.maxResolution;
        null != a.minScale ? d = OpenLayers.Util.getResolutionFromScale(a.minScale, this.units) : "auto" == d && null != this.maxExtent && (b = this.map.getSize(), c = this.maxExtent.getWidth() / b.w, b = this.maxExtent.getHeight() / b.h, d = Math.max(c, b));
        c = a.minResolution;
        null != a.maxScale ? c = OpenLayers.Util.getResolutionFromScale(a.maxScale,
            this.units) : "auto" == a.minResolution && null != this.minExtent && (b = this.map.getSize(), c = this.minExtent.getWidth() / b.w, b = this.minExtent.getHeight() / b.h, c = Math.max(c, b));
        "number" !== typeof d && "number" !== typeof c && null != this.maxExtent && (d = this.map.getTileSize(), d = Math.max(this.maxExtent.getWidth() / d.w, this.maxExtent.getHeight() / d.h));
        b = a.maxZoomLevel;
        a = a.numZoomLevels;
        "number" === typeof c && "number" === typeof d && void 0 === a ? a = Math.floor(Math.log(d / c) / Math.log(2)) + 1 : void 0 === a && null != b && (a = b + 1);
        if (!("number" !== typeof a || 0 >= a || "number" !== typeof d && "number" !== typeof c)) {
            b = Array(a);
            var e = 2;
            "number" == typeof c && "number" == typeof d && (e = Math.pow(d / c, 1 / (a - 1)));
            var f;
            if ("number" === typeof d)for (f = 0; f < a; f++)b[f] = d / Math.pow(e, f); else for (f = 0; f < a; f++)b[a - 1 - f] = c * Math.pow(e, f);
            return b
        }
    },
    getResolution: function () {
        return this.getResolutionForZoom(this.map.getZoom())
    },
    getExtent: function () {
        return this.map.calculateBounds()
    },
    getZoomForExtent: function (a, b) {
        var c = this.map.getSize();
        return this.getZoomForResolution(Math.max(a.getWidth() /
        c.w, a.getHeight() / c.h), b)
    },
    getDataExtent: function () {
    },
    getResolutionForZoom: function (a) {
        a = Math.max(0, Math.min(a, this.resolutions.length - 1));
        if (this.map.fractionalZoom)var b = Math.floor(a), c = Math.ceil(a), a = this.resolutions[b] - (a - b) * (this.resolutions[b] - this.resolutions[c]); else a = this.resolutions[Math.round(a)];
        return a
    },
    getZoomForResolution: function (a, b) {
        var c, d;
        if (this.map.fractionalZoom) {
            var e = 0, f = this.resolutions[e], g = this.resolutions[this.resolutions.length - 1], h;
            for (c = 0, d = this.resolutions.length; c <
            d; ++c)if (h = this.resolutions[c], h >= a && (f = h, e = c), h <= a) {
                g = h;
                break
            }
            c = f - g;
            c = 0 < c ? e + (f - a) / c : e
        } else {
            f = Number.POSITIVE_INFINITY;
            for (c = 0, d = this.resolutions.length; c < d; c++)if (b) {
                e = Math.abs(this.resolutions[c] - a);
                if (e > f)break;
                f = e
            } else if (this.resolutions[c] < a)break;
            c = Math.max(0, c - 1)
        }
        return c
    },
    getLonLatFromViewPortPx: function (a) {
        var b = null, c = this.map;
        if (null != a && c.minPx) {
            var b = c.getResolution(), d = c.getMaxExtent({restricted: !0}), b = new OpenLayers.LonLat((a.x - c.minPx.x) * b + d.left, (c.minPx.y - a.y) * b + d.top);
            this.wrapDateLine &&
            (b = b.wrapDateLine(this.maxExtent))
        }
        return b
    },
    getViewPortPxFromLonLat: function (a, b) {
        var c = null;
        null != a && (b = b || this.map.getResolution(), c = this.map.calculateBounds(null, b), c = new OpenLayers.Pixel(1 / b * (a.lon - c.left), 1 / b * (c.top - a.lat)));
        return c
    },
    setOpacity: function (a) {
        if (a != this.opacity) {
            this.opacity = a;
            for (var b = this.div.childNodes, c = 0, d = b.length; c < d; ++c) {
                var e = b[c].firstChild || b[c], f = b[c].lastChild;
                f && "iframe" === f.nodeName.toLowerCase() && (e = f.parentNode);
                OpenLayers.Util.modifyDOMElement(e, null, null, null,
                    null, null, null, a)
            }
            null != this.map && this.map.events.triggerEvent("changelayer", {layer: this, property: "opacity"})
        }
    },
    getZIndex: function () {
        return this.div.style.zIndex
    },
    setZIndex: function (a) {
        this.div.style.zIndex = a
    },
    adjustBounds: function (a) {
        if (this.gutter)var b = this.gutter * this.map.getResolution(), a = new OpenLayers.Bounds(a.left - b, a.bottom - b, a.right + b, a.top + b);
        this.wrapDateLine && (b = {
            rightTolerance: this.getResolution(),
            leftTolerance: this.getResolution()
        }, a = a.wrapDateLine(this.maxExtent, b));
        return a
    },
    CLASS_NAME: "OpenLayers.Layer"
});
OpenLayers.Icon = OpenLayers.Class({
    url: null,
    size: null,
    offset: null,
    calculateOffset: null,
    imageDiv: null,
    px: null,
    initialize: function (a, b, c, d) {
        this.url = a;
        this.size = b || {w: 20, h: 20};
        this.offset = c || {x: -(this.size.w / 2), y: -(this.size.h / 2)};
        this.calculateOffset = d;
        a = OpenLayers.Util.createUniqueID("OL_Icon_");
        this.imageDiv = OpenLayers.Util.createAlphaImageDiv(a)
    },
    destroy: function () {
        this.erase();
        OpenLayers.Event.stopObservingElement(this.imageDiv.firstChild);
        this.imageDiv.innerHTML = "";
        this.imageDiv = null
    },
    clone: function () {
        return new OpenLayers.Icon(this.url,
            this.size, this.offset, this.calculateOffset)
    },
    setSize: function (a) {
        null != a && (this.size = a);
        this.draw()
    },
    setUrl: function (a) {
        null != a && (this.url = a);
        this.draw()
    },
    draw: function (a) {
        OpenLayers.Util.modifyAlphaImageDiv(this.imageDiv, null, null, this.size, this.url, "absolute");
        this.moveTo(a);
        return this.imageDiv
    },
    erase: function () {
        null != this.imageDiv && null != this.imageDiv.parentNode && OpenLayers.Element.remove(this.imageDiv)
    },
    setOpacity: function (a) {
        OpenLayers.Util.modifyAlphaImageDiv(this.imageDiv, null, null, null, null,
            null, null, null, a)
    },
    moveTo: function (a) {
        null != a && (this.px = a);
        null != this.imageDiv && (null == this.px ? this.display(!1) : (this.calculateOffset && (this.offset = this.calculateOffset(this.size)), OpenLayers.Util.modifyAlphaImageDiv(this.imageDiv, null, {
            x: this.px.x + this.offset.x,
            y: this.px.y + this.offset.y
        })))
    },
    display: function (a) {
        this.imageDiv.style.display = a ? "" : "none"
    },
    isDrawn: function () {
        return this.imageDiv && this.imageDiv.parentNode && 11 != this.imageDiv.parentNode.nodeType
    },
    CLASS_NAME: "OpenLayers.Icon"
});
OpenLayers.Marker = OpenLayers.Class({
    icon: null, lonlat: null, events: null, map: null, initialize: function (a, b) {
        this.lonlat = a;
        var c = b ? b : OpenLayers.Marker.defaultIcon();
        null == this.icon ? this.icon = c : (this.icon.url = c.url, this.icon.size = c.size, this.icon.offset = c.offset, this.icon.calculateOffset = c.calculateOffset);
        this.events = new OpenLayers.Events(this, this.icon.imageDiv)
    }, destroy: function () {
        this.erase();
        this.map = null;
        this.events.destroy();
        this.events = null;
        null != this.icon && (this.icon.destroy(), this.icon = null)
    },
    draw: function (a) {
        return this.icon.draw(a)
    }, erase: function () {
        null != this.icon && this.icon.erase()
    }, moveTo: function (a) {
        null != a && null != this.icon && this.icon.moveTo(a);
        this.lonlat = this.map.getLonLatFromLayerPx(a)
    }, isDrawn: function () {
        return this.icon && this.icon.isDrawn()
    }, onScreen: function () {
        var a = !1;
        this.map && (a = this.map.getExtent().containsLonLat(this.lonlat));
        return a
    }, inflate: function (a) {
        this.icon && this.icon.setSize({w: this.icon.size.w * a, h: this.icon.size.h * a})
    }, setOpacity: function (a) {
        this.icon.setOpacity(a)
    },
    setUrl: function (a) {
        this.icon.setUrl(a)
    }, display: function (a) {
        this.icon.display(a)
    }, CLASS_NAME: "OpenLayers.Marker"
});
OpenLayers.Marker.defaultIcon = function () {
    return new OpenLayers.Icon(OpenLayers.Util.getImageLocation("marker.png"), {w: 21, h: 25}, {x: -10.5, y: -25})
};
OpenLayers.Marker.Box = OpenLayers.Class(OpenLayers.Marker, {
    bounds: null, div: null, initialize: function (a, b, c) {
        this.bounds = a;
        this.div = OpenLayers.Util.createDiv();
        this.div.style.overflow = "hidden";
        this.events = new OpenLayers.Events(this, this.div);
        this.setBorder(b, c)
    }, destroy: function () {
        this.div = this.bounds = null;
        OpenLayers.Marker.prototype.destroy.apply(this, arguments)
    }, setBorder: function (a, b) {
        a || (a = "red");
        b || (b = 2);
        this.div.style.border = b + "px solid " + a
    }, draw: function (a, b) {
        OpenLayers.Util.modifyDOMElement(this.div,
            null, a, b);
        return this.div
    }, onScreen: function () {
        var a = !1;
        this.map && (a = this.map.getExtent().containsBounds(this.bounds, !0, !0));
        return a
    }, display: function (a) {
        this.div.style.display = a ? "" : "none"
    }, CLASS_NAME: "OpenLayers.Marker.Box"
});
OpenLayers.Popup = OpenLayers.Class({
    events: null,
    id: "",
    lonlat: null,
    div: null,
    contentSize: null,
    size: null,
    contentHTML: null,
    backgroundColor: "",
    opacity: "",
    border: "",
    contentDiv: null,
    groupDiv: null,
    closeDiv: null,
    autoSize: !1,
    minSize: null,
    maxSize: null,
    displayClass: "olPopup",
    contentDisplayClass: "olPopupContent",
    padding: 0,
    disableFirefoxOverflowHack: !1,
    fixPadding: function () {
        "number" == typeof this.padding && (this.padding = new OpenLayers.Bounds(this.padding, this.padding, this.padding, this.padding))
    },
    panMapIfOutOfView: !1,
    keepInMap: !1,
    closeOnMove: !1,
    map: null,
    initialize: function (a, b, c, d, e, f) {
        null == a && (a = OpenLayers.Util.createUniqueID(this.CLASS_NAME + "_"));
        this.id = a;
        this.lonlat = b;
        this.contentSize = null != c ? c : new OpenLayers.Size(OpenLayers.Popup.WIDTH, OpenLayers.Popup.HEIGHT);
        null != d && (this.contentHTML = d);
        this.backgroundColor = OpenLayers.Popup.COLOR;
        this.opacity = OpenLayers.Popup.OPACITY;
        this.border = OpenLayers.Popup.BORDER;
        this.div = OpenLayers.Util.createDiv(this.id, null, null, null, null, null, "hidden");
        this.div.className = this.displayClass;
        this.groupDiv = OpenLayers.Util.createDiv(this.id + "_GroupDiv", null, null, null, "relative", null, "hidden");
        a = this.div.id + "_contentDiv";
        this.contentDiv = OpenLayers.Util.createDiv(a, null, this.contentSize.clone(), null, "relative");
        this.contentDiv.className = this.contentDisplayClass;
        this.groupDiv.appendChild(this.contentDiv);
        this.div.appendChild(this.groupDiv);
        e && this.addCloseBox(f);
        this.registerEvents()
    },
    destroy: function () {
        this.border = this.opacity = this.backgroundColor = this.contentHTML = this.size = this.lonlat = this.id =
            null;
        this.closeOnMove && this.map && this.map.events.unregister("movestart", this, this.hide);
        this.events.destroy();
        this.events = null;
        this.closeDiv && (OpenLayers.Event.stopObservingElement(this.closeDiv), this.groupDiv.removeChild(this.closeDiv));
        this.closeDiv = null;
        this.div.removeChild(this.groupDiv);
        this.groupDiv = null;
        null != this.map && this.map.removePopup(this);
        this.panMapIfOutOfView = this.padding = this.maxSize = this.minSize = this.autoSize = this.div = this.map = null
    },
    draw: function (a) {
        null == a && null != this.lonlat && null !=
        this.map && (a = this.map.getLayerPxFromLonLat(this.lonlat));
        this.closeOnMove && this.map.events.register("movestart", this, this.hide);
        !this.disableFirefoxOverflowHack && "firefox" == OpenLayers.BROWSER_NAME && (this.map.events.register("movestart", this, function () {
            var a = document.defaultView.getComputedStyle(this.contentDiv, null).getPropertyValue("overflow");
            "hidden" != a && (this.contentDiv._oldOverflow = a, this.contentDiv.style.overflow = "hidden")
        }), this.map.events.register("moveend", this, function () {
            var a = this.contentDiv._oldOverflow;
            a && (this.contentDiv.style.overflow = a, this.contentDiv._oldOverflow = null)
        }));
        this.moveTo(a);
        !this.autoSize && !this.size && this.setSize(this.contentSize);
        this.setBackgroundColor();
        this.setOpacity();
        this.setBorder();
        this.setContentHTML();
        this.panMapIfOutOfView && this.panIntoView();
        return this.div
    },
    updatePosition: function () {
        if (this.lonlat && this.map) {
            var a = this.map.getLayerPxFromLonLat(this.lonlat);
            a && this.moveTo(a)
        }
    },
    moveTo: function (a) {
        null != a && null != this.div && (this.div.style.left = a.x + "px", this.div.style.top =
            a.y + "px")
    },
    visible: function () {
        return OpenLayers.Element.visible(this.div)
    },
    toggle: function () {
        this.visible() ? this.hide() : this.show()
    },
    show: function () {
        this.div.style.display = "";
        this.panMapIfOutOfView && this.panIntoView()
    },
    hide: function () {
        this.div.style.display = "none"
    },
    setSize: function (a) {
        this.size = a.clone();
        var b = this.getContentDivPadding(), c = b.left + b.right, d = b.top + b.bottom;
        this.fixPadding();
        c += this.padding.left + this.padding.right;
        d += this.padding.top + this.padding.bottom;
        if (this.closeDiv)var e = parseInt(this.closeDiv.style.width),
            c = c + (e + b.right);
        this.size.w += c;
        this.size.h += d;
        "msie" == OpenLayers.BROWSER_NAME && (this.contentSize.w += b.left + b.right, this.contentSize.h += b.bottom + b.top);
        null != this.div && (this.div.style.width = this.size.w + "px", this.div.style.height = this.size.h + "px");
        null != this.contentDiv && (this.contentDiv.style.width = a.w + "px", this.contentDiv.style.height = a.h + "px")
    },
    updateSize: function () {
        var a = "<div class='" + this.contentDisplayClass + "'>" + this.contentDiv.innerHTML + "</div>", b = this.map ? this.map.div : document.body, c = OpenLayers.Util.getRenderedDimensions(a,
            null, {displayClass: this.displayClass, containerElement: b}), d = this.getSafeContentSize(c), e = null;
        d.equals(c) ? e = c : (c = {
            w: d.w < c.w ? d.w : null,
            h: d.h < c.h ? d.h : null
        }, c.w && c.h ? e = d : (a = OpenLayers.Util.getRenderedDimensions(a, c, {
            displayClass: this.contentDisplayClass,
            containerElement: b
        }), "hidden" != OpenLayers.Element.getStyle(this.contentDiv, "overflow") && a.equals(d) && (d = OpenLayers.Util.getScrollbarWidth(), c.w ? a.h += d : a.w += d), e = this.getSafeContentSize(a)));
        this.setSize(e)
    },
    setBackgroundColor: function (a) {
        void 0 != a && (this.backgroundColor =
            a);
        null != this.div && (this.div.style.backgroundColor = this.backgroundColor)
    },
    setOpacity: function (a) {
        void 0 != a && (this.opacity = a);
        null != this.div && (this.div.style.opacity = this.opacity, this.div.style.filter = "alpha(opacity=" + 100 * this.opacity + ")")
    },
    setBorder: function (a) {
        void 0 != a && (this.border = a);
        null != this.div && (this.div.style.border = this.border)
    },
    setContentHTML: function (a) {
        null != a && (this.contentHTML = a);
        null != this.contentDiv && null != this.contentHTML && this.contentHTML != this.contentDiv.innerHTML && (this.contentDiv.innerHTML =
            this.contentHTML, this.autoSize && (this.registerImageListeners(), this.updateSize()))
    },
    registerImageListeners: function () {
        for (var a = function () {
            null !== this.popup.id && (this.popup.updateSize(), this.popup.visible() && this.popup.panMapIfOutOfView && this.popup.panIntoView(), OpenLayers.Event.stopObserving(this.img, "load", this.img._onImageLoad))
        }, b = this.contentDiv.getElementsByTagName("img"), c = 0, d = b.length; c < d; c++) {
            var e = b[c];
            if (0 == e.width || 0 == e.height)e._onImgLoad = OpenLayers.Function.bind(a, {popup: this, img: e}),
                OpenLayers.Event.observe(e, "load", e._onImgLoad)
        }
    },
    getSafeContentSize: function (a) {
        var a = a.clone(), b = this.getContentDivPadding(), c = b.left + b.right, d = b.top + b.bottom;
        this.fixPadding();
        c += this.padding.left + this.padding.right;
        d += this.padding.top + this.padding.bottom;
        if (this.closeDiv)var e = parseInt(this.closeDiv.style.width), c = c + (e + b.right);
        this.minSize && (a.w = Math.max(a.w, this.minSize.w - c), a.h = Math.max(a.h, this.minSize.h - d));
        this.maxSize && (a.w = Math.min(a.w, this.maxSize.w - c), a.h = Math.min(a.h, this.maxSize.h -
        d));
        if (this.map && this.map.size) {
            e = b = 0;
            if (this.keepInMap && !this.panMapIfOutOfView)switch (e = this.map.getPixelFromLonLat(this.lonlat), this.relativePosition) {
                case "tr":
                    b = e.x;
                    e = this.map.size.h - e.y;
                    break;
                case "tl":
                    b = this.map.size.w - e.x;
                    e = this.map.size.h - e.y;
                    break;
                case "bl":
                    b = this.map.size.w - e.x;
                    e = e.y;
                    break;
                case "br":
                    b = e.x;
                    e = e.y;
                    break;
                default:
                    b = e.x, e = this.map.size.h - e.y
            }
            d = this.map.size.h - this.map.paddingForPopups.top - this.map.paddingForPopups.bottom - d - e;
            a.w = Math.min(a.w, this.map.size.w - this.map.paddingForPopups.left -
            this.map.paddingForPopups.right - c - b);
            a.h = Math.min(a.h, d)
        }
        return a
    },
    getContentDivPadding: function () {
        var a = this._contentDivPadding;
        a || (null == this.div.parentNode && (this.div.style.display = "none", document.body.appendChild(this.div)), this._contentDivPadding = a = new OpenLayers.Bounds(OpenLayers.Element.getStyle(this.contentDiv, "padding-left"), OpenLayers.Element.getStyle(this.contentDiv, "padding-bottom"), OpenLayers.Element.getStyle(this.contentDiv, "padding-right"), OpenLayers.Element.getStyle(this.contentDiv,
            "padding-top")), this.div.parentNode == document.body && (document.body.removeChild(this.div), this.div.style.display = ""));
        return a
    },
    addCloseBox: function (a) {
        this.closeDiv = OpenLayers.Util.createDiv(this.id + "_close", null, {w: 17, h: 17});
        this.closeDiv.className = "olPopupCloseBox";
        var b = this.getContentDivPadding();
        this.closeDiv.style.right = b.right + "px";
        this.closeDiv.style.top = b.top + "px";
        this.groupDiv.appendChild(this.closeDiv);
        a = a || function (a) {
            this.hide();
            OpenLayers.Event.stop(a)
        };
        OpenLayers.Event.observe(this.closeDiv,
            "touchend", OpenLayers.Function.bindAsEventListener(a, this));
        OpenLayers.Event.observe(this.closeDiv, "click", OpenLayers.Function.bindAsEventListener(a, this))
    },
    panIntoView: function () {
        var a = this.map.getSize(), b = this.map.getViewPortPxFromLayerPx(new OpenLayers.Pixel(parseInt(this.div.style.left), parseInt(this.div.style.top))), c = b.clone();
        b.x < this.map.paddingForPopups.left ? c.x = this.map.paddingForPopups.left : b.x + this.size.w > a.w - this.map.paddingForPopups.right && (c.x = a.w - this.map.paddingForPopups.right - this.size.w);
        b.y < this.map.paddingForPopups.top ? c.y = this.map.paddingForPopups.top : b.y + this.size.h > a.h - this.map.paddingForPopups.bottom && (c.y = a.h - this.map.paddingForPopups.bottom - this.size.h);
        this.map.pan(b.x - c.x, b.y - c.y)
    },
    registerEvents: function () {
        this.events = new OpenLayers.Events(this, this.div, null, !0);
        this.events.on({
            mousedown: this.onmousedown,
            mousemove: this.onmousemove,
            mouseup: this.onmouseup,
            click: this.onclick,
            mouseout: this.onmouseout,
            dblclick: this.ondblclick,
            touchstart: function (a) {
                OpenLayers.Event.stop(a, !0)
            },
            scope: this
        })
    },
    onmousedown: function (a) {
        this.mousedown = !0;
        OpenLayers.Event.stop(a, !0)
    },
    onmousemove: function (a) {
        this.mousedown && OpenLayers.Event.stop(a, !0)
    },
    onmouseup: function (a) {
        this.mousedown && (this.mousedown = !1, OpenLayers.Event.stop(a, !0))
    },
    onclick: function (a) {
        OpenLayers.Event.stop(a, !0)
    },
    onmouseout: function () {
        this.mousedown = !1
    },
    ondblclick: function (a) {
        OpenLayers.Event.stop(a, !0)
    },
    CLASS_NAME: "OpenLayers.Popup"
});
OpenLayers.Popup.WIDTH = 200;
OpenLayers.Popup.HEIGHT = 200;
OpenLayers.Popup.COLOR = "white";
OpenLayers.Popup.OPACITY = 1;
OpenLayers.Popup.BORDER = "0px";
OpenLayers.Tile = OpenLayers.Class({
    events: null,
    eventListeners: null,
    id: null,
    layer: null,
    url: null,
    bounds: null,
    size: null,
    position: null,
    isLoading: !1,
    initialize: function (a, b, c, d, e, f) {
        this.layer = a;
        this.position = b.clone();
        this.setBounds(c);
        this.url = d;
        e && (this.size = e.clone());
        this.id = OpenLayers.Util.createUniqueID("Tile_");
        OpenLayers.Util.extend(this, f);
        this.events = new OpenLayers.Events(this);
        if (this.eventListeners instanceof Object)this.events.on(this.eventListeners)
    },
    unload: function () {
        this.isLoading && (this.isLoading = !1, this.events.triggerEvent("unload"))
    },
    destroy: function () {
        this.position = this.size = this.bounds = this.layer = null;
        this.eventListeners && this.events.un(this.eventListeners);
        this.events.destroy();
        this.events = this.eventListeners = null
    },
    draw: function (a) {
        a || this.clear();
        var b = this.shouldDraw();
        b && !a && (b = !1 !== this.events.triggerEvent("beforedraw"));
        return b
    },
    shouldDraw: function () {
        var a = !1, b = this.layer.maxExtent;
        if (b) {
            var c = this.layer.map, c = c.baseLayer.wrapDateLine && c.getMaxExtent();
            this.bounds.intersectsBounds(b,
                {inclusive: !1, worldBounds: c}) && (a = !0)
        }
        return a || this.layer.displayOutsideMaxExtent
    },
    setBounds: function (a) {
        a = a.clone();
        if (this.layer.map.baseLayer.wrapDateLine)var b = this.layer.map.getMaxExtent(), c = this.layer.map.getResolution(), a = a.wrapDateLine(b, {
            leftTolerance: c,
            rightTolerance: c
        });
        this.bounds = a
    },
    moveTo: function (a, b, c) {
        null == c && (c = !0);
        this.setBounds(a);
        this.position = b.clone();
        c && this.draw()
    },
    clear: function () {
    },
    CLASS_NAME: "OpenLayers.Tile"
});
OpenLayers.Tile.Image = OpenLayers.Class(OpenLayers.Tile, {
    url: null,
    imgDiv: null,
    frame: null,
    imageReloadAttempts: null,
    layerAlphaHack: null,
    asyncRequestId: null,
    blankImageUrl: "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAQAIBRAA7",
    maxGetUrlLength: null,
    canvasContext: null,
    crossOriginKeyword: null,
    initialize: function (a, b, c, d, e, f) {
        OpenLayers.Tile.prototype.initialize.apply(this, arguments);
        this.url = d;
        this.layerAlphaHack = this.layer.alpha && OpenLayers.Util.alphaHack();
        if (null != this.maxGetUrlLength ||
            this.layer.gutter || this.layerAlphaHack)this.frame = document.createElement("div"), this.frame.style.position = "absolute", this.frame.style.overflow = "hidden";
        null != this.maxGetUrlLength && OpenLayers.Util.extend(this, OpenLayers.Tile.Image.IFrame)
    },
    destroy: function () {
        this.imgDiv && (this.clear(), this.frame = this.imgDiv = null);
        this.asyncRequestId = null;
        OpenLayers.Tile.prototype.destroy.apply(this, arguments)
    },
    draw: function () {
        var a = OpenLayers.Tile.prototype.draw.apply(this, arguments);
        a ? (this.layer != this.layer.map.baseLayer &&
        this.layer.reproject && (this.bounds = this.getBoundsFromBaseLayer(this.position)), this.isLoading ? this._loadEvent = "reload" : (this.isLoading = !0, this._loadEvent = "loadstart"), this.positionTile(), this.renderTile()) : this.unload();
        return a
    },
    renderTile: function () {
        this.layer.div.appendChild(this.getTile());
        if (this.layer.async) {
            var a = this.asyncRequestId = (this.asyncRequestId || 0) + 1;
            this.layer.getURLasync(this.bounds, function (b) {
                a == this.asyncRequestId && (this.url = b, this.initImage())
            }, this)
        } else this.url = this.layer.getURL(this.bounds),
            this.initImage()
    },
    positionTile: function () {
        var a = this.getTile().style, b = this.frame ? this.size : this.layer.getImageSize(this.bounds);
        a.left = this.position.x + "%";
        a.top = this.position.y + "%";
        a.width = b.w + "%";
        a.height = b.h + "%"
    },
    clear: function () {
        OpenLayers.Tile.prototype.clear.apply(this, arguments);
        var a = this.imgDiv;
        if (a) {
            OpenLayers.Event.stopObservingElement(a);
            var b = this.getTile();
            b.parentNode === this.layer.div && this.layer.div.removeChild(b);
            this.setImgSrc();
            !0 === this.layerAlphaHack && (a.style.filter = "");
            OpenLayers.Element.removeClass(a,
                "olImageLoadError")
        }
        this.canvasContext = null
    },
    getImage: function () {
        if (!this.imgDiv) {
            this.imgDiv = document.createElement("img");
            this.imgDiv.className = "olTileImage";
            this.imgDiv.galleryImg = "no";
            var a = this.imgDiv.style;
            if (this.frame) {
                var b = 0, c = 0;
                this.layer.gutter && (b = 100 * (this.layer.gutter / this.layer.tileSize.w), c = 100 * (this.layer.gutter / this.layer.tileSize.h));
                a.left = -b + "%";
                a.top = -c + "%";
                a.width = 2 * b + 100 + "%";
                a.height = 2 * c + 100 + "%"
            }
            a.visibility = "hidden";
            a.opacity = 0;
            1 > this.layer.opacity && (a.filter = "alpha(opacity=" +
            100 * this.layer.opacity + ")");
            a.position = "absolute";
            this.layerAlphaHack && (a.paddingTop = a.height, a.height = "0", a.width = "100%");
            this.frame && this.frame.appendChild(this.imgDiv)
        }
        return this.imgDiv
    },
    initImage: function () {
        this.events.triggerEvent(this._loadEvent);
        var a = this.getImage();
        if (this.url && a.getAttribute("src") == this.url)this.onImageLoad(); else {
            var b = OpenLayers.Function.bind(function () {
                OpenLayers.Event.stopObservingElement(a);
                OpenLayers.Event.observe(a, "load", OpenLayers.Function.bind(this.onImageLoad,
                    this));
                OpenLayers.Event.observe(a, "error", OpenLayers.Function.bind(this.onImageError, this));
                this.imageReloadAttempts = 0;
                this.setImgSrc(this.url)
            }, this);
            a.getAttribute("src") == this.blankImageUrl ? b() : (OpenLayers.Event.observe(a, "load", b), OpenLayers.Event.observe(a, "error", b), this.crossOriginKeyword && a.removeAttribute("crossorigin"), a.src = this.blankImageUrl)
        }
    },
    setImgSrc: function (a) {
        var b = this.imgDiv;
        b.style.visibility = "hidden";
        b.style.opacity = 0;
        a && (this.crossOriginKeyword && ("data:" !== a.substr(0, 5) ? b.setAttribute("crossorigin",
            this.crossOriginKeyword) : b.removeAttribute("crossorigin")), b.src = a)
    },
    getTile: function () {
        return this.frame ? this.frame : this.getImage()
    },
    createBackBuffer: function () {
        if (this.imgDiv && !this.isLoading) {
            var a;
            this.frame ? (a = this.frame.cloneNode(!1), a.appendChild(this.imgDiv)) : a = this.imgDiv;
            this.imgDiv = null;
            return a
        }
    },
    onImageLoad: function () {
        var a = this.imgDiv;
        OpenLayers.Event.stopObservingElement(a);
        a.style.visibility = "inherit";
        a.style.opacity = this.layer.opacity;
        this.isLoading = !1;
        this.canvasContext = null;
        this.events.triggerEvent("loadend");
        if (7 > parseFloat(navigator.appVersion.split("MSIE")[1]) && this.layer && this.layer.div) {
            var b = document.createElement("span");
            b.style.display = "none";
            var c = this.layer.div;
            c.appendChild(b);
            window.setTimeout(function () {
                b.parentNode === c && b.parentNode.removeChild(b)
            }, 0)
        }
        !0 === this.layerAlphaHack && (a.style.filter = "progid:DXImageTransform.Microsoft.AlphaImageLoader(src='" + a.src + "', sizingMethod='scale')")
    },
    onImageError: function () {
        var a = this.imgDiv;
        null != a.src && (this.imageReloadAttempts++, this.imageReloadAttempts <=
        OpenLayers.IMAGE_RELOAD_ATTEMPTS ? this.setImgSrc(this.layer.getURL(this.bounds)) : (OpenLayers.Element.addClass(a, "olImageLoadError"), this.events.triggerEvent("loaderror"), this.onImageLoad()))
    },
    getCanvasContext: function () {
        if (OpenLayers.CANVAS_SUPPORTED && this.imgDiv && !this.isLoading) {
            if (!this.canvasContext) {
                var a = document.createElement("canvas");
                a.width = this.size.w;
                a.height = this.size.h;
                this.canvasContext = a.getContext("2d");
                this.canvasContext.drawImage(this.imgDiv, 0, 0)
            }
            return this.canvasContext
        }
    },
    CLASS_NAME: "OpenLayers.Tile.Image"
});
OpenLayers.Tile.Image.IFrame = {
    useIFrame: null, draw: function () {
        if (OpenLayers.Tile.Image.prototype.shouldDraw.call(this)) {
            var a = this.layer.getURL(this.bounds), b = this.useIFrame;
            this.useIFrame = null !== this.maxGetUrlLength && !this.layer.async && a.length > this.maxGetUrlLength;
            a = b && !this.useIFrame;
            b = !b && this.useIFrame;
            if (a || b)this.imgDiv && this.imgDiv.parentNode === this.frame && this.frame.removeChild(this.imgDiv), this.imgDiv = null, a ? (this.blankImageUrl = this._blankImageUrl, this.frame.removeChild(this.frame.firstChild)) :
                (this._blankImageUrl = this.blankImageUrl, this.blankImageUrl = "about:blank")
        }
        return OpenLayers.Tile.Image.prototype.draw.apply(this, arguments)
    }, getImage: function () {
        if (!0 === this.useIFrame) {
            if (!this.frame.childNodes.length) {
                var a = document.createElement("div"), b = a.style;
                b.position = "absolute";
                b.width = "100%";
                b.height = "100%";
                b.zIndex = 1;
                b.backgroundImage = "url(" + this._blankImageUrl + ")";
                this.frame.appendChild(a)
            }
            a = this.id + "_iFrame";
            9 > parseFloat(navigator.appVersion.split("MSIE")[1]) ? (b = document.createElement('<iframe name="' +
            a + '">'), b.style.backgroundColor = "#FFFFFF", b.style.filter = "chroma(color=#FFFFFF)") : (b = document.createElement("iframe"), b.style.backgroundColor = "transparent", b.name = a);
            b.scrolling = "no";
            b.marginWidth = "0px";
            b.marginHeight = "0px";
            b.frameBorder = "0";
            b.style.position = "absolute";
            b.style.width = "100%";
            b.style.height = "100%";
            1 > this.layer.opacity && OpenLayers.Util.modifyDOMElement(b, null, null, null, null, null, null, this.layer.opacity);
            this.frame.appendChild(b);
            return this.imgDiv = b
        }
        return OpenLayers.Tile.Image.prototype.getImage.apply(this,
            arguments)
    }, createRequestForm: function () {
        var a = document.createElement("form");
        a.method = "POST";
        var b = this.layer.params._OLSALT, b = (b ? b + "_" : "") + this.bounds.toBBOX();
        a.action = OpenLayers.Util.urlAppend(this.layer.url, b);
        a.target = this.id + "_iFrame";
        this.layer.getImageSize();
        var b = OpenLayers.Util.getParameters(this.url), c, d;
        for (d in b)c = document.createElement("input"), c.type = "hidden", c.name = d, c.value = b[d], a.appendChild(c);
        return a
    }, setImgSrc: function (a) {
        if (!0 === this.useIFrame)if (a) {
            var b = this.createRequestForm();
            this.frame.appendChild(b);
            b.submit();
            this.frame.removeChild(b)
        } else this.imgDiv.parentNode === this.frame && (this.frame.removeChild(this.imgDiv), this.imgDiv = null); else OpenLayers.Tile.Image.prototype.setImgSrc.apply(this, arguments)
    }, onImageLoad: function () {
        OpenLayers.Tile.Image.prototype.onImageLoad.apply(this, arguments);
        !0 === this.useIFrame && (this.imgDiv.style.opacity = 1, this.frame.style.opacity = this.layer.opacity)
    }, createBackBuffer: function () {
        var a;
        !1 === this.useIFrame && (a = OpenLayers.Tile.Image.prototype.createBackBuffer.call(this));
        return a
    }
};
OpenLayers.Tile.UTFGrid = OpenLayers.Class(OpenLayers.Tile, {
    url: null, utfgridResolution: 2, json: null, format: null, destroy: function () {
        this.clear();
        OpenLayers.Tile.prototype.destroy.apply(this, arguments)
    }, draw: function () {
        var a = OpenLayers.Tile.prototype.draw.apply(this, arguments);
        if (a)if (this.isLoading ? (this.abortLoading(), this.events.triggerEvent("reload")) : (this.isLoading = !0, this.events.triggerEvent("loadstart")), this.url = this.layer.getURL(this.bounds), this.layer.useJSONP) {
            var b = new OpenLayers.Protocol.Script({
                url: this.url, callback: function (a) {
                    this.isLoading = !1;
                    this.events.triggerEvent("loadend");
                    this.json = a.data
                }, scope: this
            });
            b.read();
            this.request = b
        } else this.request = OpenLayers.Request.GET({
            url: this.url, callback: function (a) {
                this.isLoading = !1;
                this.events.triggerEvent("loadend");
                200 === a.status && this.parseData(a.responseText)
            }, scope: this
        }); else this.unload();
        return a
    }, abortLoading: function () {
        this.request && (this.request.abort(), delete this.request);
        this.isLoading = !1
    }, getFeatureInfo: function (a, b) {
        var c = null;
        if (this.json) {
            var d = this.getFeatureId(a, b);
            null !==
            d && (c = {id: d, data: this.json.data[d]})
        }
        return c
    }, getFeatureId: function (a, b) {
        var c = null;
        if (this.json) {
            var d = this.utfgridResolution, d = this.indexFromCharCode(this.json.grid[Math.floor(b / d)].charCodeAt(Math.floor(a / d))), e = this.json.keys;
            !isNaN(d) && d in e && (c = e[d])
        }
        return c
    }, indexFromCharCode: function (a) {
        93 <= a && a--;
        35 <= a && a--;
        return a - 32
    }, parseData: function (a) {
        this.format || (this.format = new OpenLayers.Format.JSON);
        this.json = this.format.read(a)
    }, clear: function () {
        this.json = null
    }, CLASS_NAME: "OpenLayers.Tile.UTFGrid"
});
OpenLayers.Layer.Image = OpenLayers.Class(OpenLayers.Layer, {
    isBaseLayer: !0,
    url: null,
    extent: null,
    size: null,
    tile: null,
    aspectRatio: null,
    initialize: function (a, b, c, d, e) {
        this.url = b;
        this.maxExtent = this.extent = c;
        this.size = d;
        OpenLayers.Layer.prototype.initialize.apply(this, [a, e]);
        this.aspectRatio = this.extent.getHeight() / this.size.h / (this.extent.getWidth() / this.size.w)
    },
    destroy: function () {
        this.tile && (this.removeTileMonitoringHooks(this.tile), this.tile.destroy(), this.tile = null);
        OpenLayers.Layer.prototype.destroy.apply(this,
            arguments)
    },
    clone: function (a) {
        null == a && (a = new OpenLayers.Layer.Image(this.name, this.url, this.extent, this.size, this.getOptions()));
        return OpenLayers.Layer.prototype.clone.apply(this, [a])
    },
    setMap: function (a) {
        null == this.options.maxResolution && (this.options.maxResolution = this.aspectRatio * this.extent.getWidth() / this.size.w);
        OpenLayers.Layer.prototype.setMap.apply(this, arguments)
    },
    moveTo: function (a, b, c) {
        OpenLayers.Layer.prototype.moveTo.apply(this, arguments);
        var d = null == this.tile;
        if (b || d) {
            this.setTileSize();
            var e = this.map.getLayerPxFromLonLat({lon: this.extent.left, lat: this.extent.top});
            d ? (this.tile = new OpenLayers.Tile.Image(this, e, this.extent, null, this.tileSize), this.addTileMonitoringHooks(this.tile)) : (this.tile.size = this.tileSize.clone(), this.tile.position = e.clone());
            this.tile.draw()
        }
    },
    setTileSize: function () {
        var a = this.extent.getWidth() / this.map.getResolution(), b = this.extent.getHeight() / this.map.getResolution();
        this.tileSize = new OpenLayers.Size(a, b)
    },
    addTileMonitoringHooks: function (a) {
        a.onLoadStart =
            function () {
                this.events.triggerEvent("loadstart")
            };
        a.events.register("loadstart", this, a.onLoadStart);
        a.onLoadEnd = function () {
            this.events.triggerEvent("loadend")
        };
        a.events.register("loadend", this, a.onLoadEnd);
        a.events.register("unload", this, a.onLoadEnd)
    },
    removeTileMonitoringHooks: function (a) {
        a.unload();
        a.events.un({loadstart: a.onLoadStart, loadend: a.onLoadEnd, unload: a.onLoadEnd, scope: this})
    },
    setUrl: function (a) {
        this.url = a;
        this.tile.draw()
    },
    getURL: function () {
        return this.url
    },
    CLASS_NAME: "OpenLayers.Layer.Image"
});
OpenLayers.Layer.SphericalMercator = {
    getExtent: function () {
        return this.sphericalMercator ? this.map.calculateBounds() : OpenLayers.Layer.FixedZoomLevels.prototype.getExtent.apply(this)
    }, getLonLatFromViewPortPx: function (a) {
        return OpenLayers.Layer.prototype.getLonLatFromViewPortPx.apply(this, arguments)
    }, getViewPortPxFromLonLat: function (a) {
        return OpenLayers.Layer.prototype.getViewPortPxFromLonLat.apply(this, arguments)
    }, initMercatorParameters: function () {
        this.RESOLUTIONS = [];
        for (var a = 0; a <= this.MAX_ZOOM_LEVEL; ++a)this.RESOLUTIONS[a] =
            156543.03390625 / Math.pow(2, a);
        this.units = "m";
        this.projection = this.projection || "EPSG:900913"
    }, forwardMercator: function () {
        var a = new OpenLayers.Projection("EPSG:4326"), b = new OpenLayers.Projection("EPSG:900913");
        return function (c, d) {
            var e = OpenLayers.Projection.transform({x: c, y: d}, a, b);
            return new OpenLayers.LonLat(e.x, e.y)
        }
    }(), inverseMercator: function () {
        var a = new OpenLayers.Projection("EPSG:4326"), b = new OpenLayers.Projection("EPSG:900913");
        return function (c, d) {
            var e = OpenLayers.Projection.transform({
                x: c,
                y: d
            }, b, a);
            return new OpenLayers.LonLat(e.x, e.y)
        }
    }()
};
OpenLayers.Layer.EventPane = OpenLayers.Class(OpenLayers.Layer, {
    smoothDragPan: !0, isBaseLayer: !0, isFixed: !0, pane: null, mapObject: null, initialize: function (a, b) {
        OpenLayers.Layer.prototype.initialize.apply(this, arguments);
        null == this.pane && (this.pane = OpenLayers.Util.createDiv(this.div.id + "_EventPane"))
    }, destroy: function () {
        this.pane = this.mapObject = null;
        OpenLayers.Layer.prototype.destroy.apply(this, arguments)
    }, setMap: function (a) {
        OpenLayers.Layer.prototype.setMap.apply(this, arguments);
        this.pane.style.zIndex =
            parseInt(this.div.style.zIndex) + 1;
        this.pane.style.display = this.div.style.display;
        this.pane.style.width = "100%";
        this.pane.style.height = "100%";
        "msie" == OpenLayers.BROWSER_NAME && (this.pane.style.background = "url(" + OpenLayers.Util.getImageLocation("blank.gif") + ")");
        this.isFixed ? this.map.viewPortDiv.appendChild(this.pane) : this.map.layerContainerDiv.appendChild(this.pane);
        this.loadMapObject();
        null == this.mapObject && this.loadWarningMessage()
    }, removeMap: function (a) {
        this.pane && this.pane.parentNode && this.pane.parentNode.removeChild(this.pane);
        OpenLayers.Layer.prototype.removeMap.apply(this, arguments)
    }, loadWarningMessage: function () {
        this.div.style.backgroundColor = "darkblue";
        var a = this.map.getSize(), b = Math.min(a.w, 300), c = Math.min(a.h, 200), b = new OpenLayers.Size(b, c), a = (new OpenLayers.Pixel(a.w / 2, a.h / 2)).add(-b.w / 2, -b.h / 2), a = OpenLayers.Util.createDiv(this.name + "_warning", a, b, null, null, null, "auto");
        a.style.padding = "7px";
        a.style.backgroundColor = "yellow";
        a.innerHTML = this.getWarningHTML();
        this.div.appendChild(a)
    }, getWarningHTML: function () {
        return ""
    },
    display: function (a) {
        OpenLayers.Layer.prototype.display.apply(this, arguments);
        this.pane.style.display = this.div.style.display
    }, setZIndex: function (a) {
        OpenLayers.Layer.prototype.setZIndex.apply(this, arguments);
        this.pane.style.zIndex = parseInt(this.div.style.zIndex) + 1
    }, moveByPx: function (a, b) {
        OpenLayers.Layer.prototype.moveByPx.apply(this, arguments);
        this.dragPanMapObject ? this.dragPanMapObject(a, -b) : this.moveTo(this.map.getCachedCenter())
    }, moveTo: function (a, b, c) {
        OpenLayers.Layer.prototype.moveTo.apply(this,
            arguments);
        if (null != this.mapObject) {
            var d = this.map.getCenter(), e = this.map.getZoom();
            if (null != d) {
                var f = this.getOLLonLatFromMapObjectLonLat(this.getMapObjectCenter()), g = this.getOLZoomFromMapObjectZoom(this.getMapObjectZoom());
                if (!d.equals(f) || e != g)!b && f && this.dragPanMapObject && this.smoothDragPan ? (e = this.map.getViewPortPxFromLonLat(f), d = this.map.getViewPortPxFromLonLat(d), this.dragPanMapObject(d.x - e.x, e.y - d.y)) : (d = this.getMapObjectLonLatFromOLLonLat(d), e = this.getMapObjectZoomFromOLZoom(e), this.setMapObjectCenter(d,
                    e, c))
            }
        }
    }, getLonLatFromViewPortPx: function (a) {
        var b = null;
        null != this.mapObject && null != this.getMapObjectCenter() && (b = this.getOLLonLatFromMapObjectLonLat(this.getMapObjectLonLatFromMapObjectPixel(this.getMapObjectPixelFromOLPixel(a))));
        return b
    }, getViewPortPxFromLonLat: function (a) {
        var b = null;
        null != this.mapObject && null != this.getMapObjectCenter() && (b = this.getOLPixelFromMapObjectPixel(this.getMapObjectPixelFromMapObjectLonLat(this.getMapObjectLonLatFromOLLonLat(a))));
        return b
    }, getOLLonLatFromMapObjectLonLat: function (a) {
        var b =
            null;
        null != a && (b = this.getLongitudeFromMapObjectLonLat(a), a = this.getLatitudeFromMapObjectLonLat(a), b = new OpenLayers.LonLat(b, a));
        return b
    }, getMapObjectLonLatFromOLLonLat: function (a) {
        var b = null;
        null != a && (b = this.getMapObjectLonLatFromLonLat(a.lon, a.lat));
        return b
    }, getOLPixelFromMapObjectPixel: function (a) {
        var b = null;
        null != a && (b = this.getXFromMapObjectPixel(a), a = this.getYFromMapObjectPixel(a), b = new OpenLayers.Pixel(b, a));
        return b
    }, getMapObjectPixelFromOLPixel: function (a) {
        var b = null;
        null != a && (b = this.getMapObjectPixelFromXY(a.x,
            a.y));
        return b
    }, CLASS_NAME: "OpenLayers.Layer.EventPane"
});
OpenLayers.Layer.FixedZoomLevels = OpenLayers.Class({
    initialize: function () {
    }, initResolutions: function () {
        for (var a = ["minZoomLevel", "maxZoomLevel", "numZoomLevels"], b = 0, c = a.length; b < c; b++) {
            var d = a[b];
            this[d] = null != this.options[d] ? this.options[d] : this.map[d]
        }
        if (null == this.minZoomLevel || this.minZoomLevel < this.MIN_ZOOM_LEVEL)this.minZoomLevel = this.MIN_ZOOM_LEVEL;
        a = this.MAX_ZOOM_LEVEL - this.minZoomLevel + 1;
        b = null == this.options.numZoomLevels && null != this.options.maxZoomLevel || null == this.numZoomLevels && null != this.maxZoomLevel ?
        this.maxZoomLevel - this.minZoomLevel + 1 : this.numZoomLevels;
        this.numZoomLevels = null != b ? Math.min(b, a) : a;
        this.maxZoomLevel = this.minZoomLevel + this.numZoomLevels - 1;
        if (null != this.RESOLUTIONS) {
            a = 0;
            this.resolutions = [];
            for (b = this.minZoomLevel; b <= this.maxZoomLevel; b++)this.resolutions[a++] = this.RESOLUTIONS[b];
            this.maxResolution = this.resolutions[0];
            this.minResolution = this.resolutions[this.resolutions.length - 1]
        }
    }, getResolution: function () {
        if (null != this.resolutions)return OpenLayers.Layer.prototype.getResolution.apply(this,
            arguments);
        var a = null, b = this.map.getSize(), c = this.getExtent();
        null != b && null != c && (a = Math.max(c.getWidth() / b.w, c.getHeight() / b.h));
        return a
    }, getExtent: function () {
        var a = this.map.getSize(), b = this.getLonLatFromViewPortPx({
            x: 0,
            y: 0
        }), a = this.getLonLatFromViewPortPx({x: a.w, y: a.h});
        return null != b && null != a ? new OpenLayers.Bounds(b.lon, a.lat, a.lon, b.lat) : null
    }, getZoomForResolution: function (a) {
        return null != this.resolutions ? OpenLayers.Layer.prototype.getZoomForResolution.apply(this, arguments) : this.getZoomForExtent(OpenLayers.Layer.prototype.getExtent.apply(this,
            []))
    }, getOLZoomFromMapObjectZoom: function (a) {
        var b = null;
        null != a && (b = a - this.minZoomLevel, this.map.baseLayer !== this && (b = this.map.baseLayer.getZoomForResolution(this.getResolutionForZoom(b))));
        return b
    }, getMapObjectZoomFromOLZoom: function (a) {
        var b = null;
        null != a && (b = a + this.minZoomLevel, this.map.baseLayer !== this && (b = this.getZoomForResolution(this.map.baseLayer.getResolutionForZoom(b))));
        return b
    }, CLASS_NAME: "OpenLayers.Layer.FixedZoomLevels"
});
OpenLayers.Layer.Google = OpenLayers.Class(OpenLayers.Layer.EventPane, OpenLayers.Layer.FixedZoomLevels, {
    MIN_ZOOM_LEVEL: 0,
    MAX_ZOOM_LEVEL: 21,
    RESOLUTIONS: [1.40625, 0.703125, 0.3515625, 0.17578125, 0.087890625, 0.0439453125, 0.02197265625, 0.010986328125, 0.0054931640625, 0.00274658203125, 0.001373291015625, 6.866455078125E-4, 3.4332275390625E-4, 1.71661376953125E-4, 8.58306884765625E-5, 4.291534423828125E-5, 2.145767211914062E-5, 1.072883605957031E-5, 5.36441802978515E-6, 2.68220901489257E-6, 1.341104507446289E-6, 6.705522537231445E-7],
    type: null,
    wrapDateLine: !0,
    sphericalMercator: !1,
    version: null,
    initialize: function (a, b) {
        b = b || {};
        b.version || (b.version = "function" === typeof GMap2 ? "2" : "3");
        var c = OpenLayers.Layer.Google["v" + b.version.replace(/\./g, "_")];
        if (c)OpenLayers.Util.applyDefaults(b, c); else throw"Unsupported Google Maps API version: " + b.version;
        OpenLayers.Util.applyDefaults(b, c.DEFAULTS);
        b.maxExtent && (b.maxExtent = b.maxExtent.clone());
        OpenLayers.Layer.EventPane.prototype.initialize.apply(this, [a, b]);
        OpenLayers.Layer.FixedZoomLevels.prototype.initialize.apply(this,
            [a, b]);
        this.sphericalMercator && (OpenLayers.Util.extend(this, OpenLayers.Layer.SphericalMercator), this.initMercatorParameters())
    },
    clone: function () {
        return new OpenLayers.Layer.Google(this.name, this.getOptions())
    },
    setVisibility: function (a) {
        var b = null == this.opacity ? 1 : this.opacity;
        OpenLayers.Layer.EventPane.prototype.setVisibility.apply(this, arguments);
        this.setOpacity(b)
    },
    display: function (a) {
        this._dragging || this.setGMapVisibility(a);
        OpenLayers.Layer.EventPane.prototype.display.apply(this, arguments)
    },
    moveTo: function (a,
                      b, c) {
        this._dragging = c;
        OpenLayers.Layer.EventPane.prototype.moveTo.apply(this, arguments);
        delete this._dragging
    },
    setOpacity: function (a) {
        a !== this.opacity && (null != this.map && this.map.events.triggerEvent("changelayer", {
            layer: this,
            property: "opacity"
        }), this.opacity = a);
        if (this.getVisibility()) {
            var b = this.getMapContainer();
            OpenLayers.Util.modifyDOMElement(b, null, null, null, null, null, null, a)
        }
    },
    destroy: function () {
        if (this.map) {
            this.setGMapVisibility(!1);
            var a = OpenLayers.Layer.Google.cache[this.map.id];
            a && 1 >= a.count &&
            this.removeGMapElements()
        }
        OpenLayers.Layer.EventPane.prototype.destroy.apply(this, arguments)
    },
    removeGMapElements: function () {
        var a = OpenLayers.Layer.Google.cache[this.map.id];
        if (a) {
            var b = this.mapObject && this.getMapContainer();
            b && b.parentNode && b.parentNode.removeChild(b);
            (b = a.termsOfUse) && b.parentNode && b.parentNode.removeChild(b);
            (a = a.poweredBy) && a.parentNode && a.parentNode.removeChild(a)
        }
    },
    removeMap: function (a) {
        this.visibility && this.mapObject && this.setGMapVisibility(!1);
        var b = OpenLayers.Layer.Google.cache[a.id];
        b && (1 >= b.count ? (this.removeGMapElements(), delete OpenLayers.Layer.Google.cache[a.id]) : --b.count);
        delete this.termsOfUse;
        delete this.poweredBy;
        delete this.mapObject;
        delete this.dragObject;
        OpenLayers.Layer.EventPane.prototype.removeMap.apply(this, arguments)
    },
    getOLBoundsFromMapObjectBounds: function (a) {
        var b = null;
        null != a && (b = a.getSouthWest(), a = a.getNorthEast(), this.sphericalMercator ? (b = this.forwardMercator(b.lng(), b.lat()), a = this.forwardMercator(a.lng(), a.lat())) : (b = new OpenLayers.LonLat(b.lng(), b.lat()),
            a = new OpenLayers.LonLat(a.lng(), a.lat())), b = new OpenLayers.Bounds(b.lon, b.lat, a.lon, a.lat));
        return b
    },
    getWarningHTML: function () {
        return OpenLayers.i18n("googleWarning")
    },
    getMapObjectCenter: function () {
        return this.mapObject.getCenter()
    },
    getMapObjectZoom: function () {
        return this.mapObject.getZoom()
    },
    getLongitudeFromMapObjectLonLat: function (a) {
        return this.sphericalMercator ? this.forwardMercator(a.lng(), a.lat()).lon : a.lng()
    },
    getLatitudeFromMapObjectLonLat: function (a) {
        return this.sphericalMercator ? this.forwardMercator(a.lng(),
            a.lat()).lat : a.lat()
    },
    getXFromMapObjectPixel: function (a) {
        return a.x
    },
    getYFromMapObjectPixel: function (a) {
        return a.y
    },
    CLASS_NAME: "OpenLayers.Layer.Google"
});
OpenLayers.Layer.Google.cache = {};
OpenLayers.Layer.Google.v2 = {
    termsOfUse: null, poweredBy: null, dragObject: null, loadMapObject: function () {
        this.type || (this.type = G_NORMAL_MAP);
        var a, b, c, d = OpenLayers.Layer.Google.cache[this.map.id];
        if (d)a = d.mapObject, b = d.termsOfUse, c = d.poweredBy, ++d.count; else {
            var d = this.map.viewPortDiv, e = document.createElement("div");
            e.id = this.map.id + "_GMap2Container";
            e.style.position = "absolute";
            e.style.width = "100%";
            e.style.height = "100%";
            d.appendChild(e);
            try {
                a = new GMap2(e), b = e.lastChild, d.appendChild(b), b.style.zIndex =
                    "1100", b.style.right = "", b.style.bottom = "", b.className = "olLayerGoogleCopyright", c = e.lastChild, d.appendChild(c), c.style.zIndex = "1100", c.style.right = "", c.style.bottom = "", c.className = "olLayerGooglePoweredBy gmnoprint"
            } catch (f) {
                throw f;
            }
            OpenLayers.Layer.Google.cache[this.map.id] = {mapObject: a, termsOfUse: b, poweredBy: c, count: 1}
        }
        this.mapObject = a;
        this.termsOfUse = b;
        this.poweredBy = c;
        -1 === OpenLayers.Util.indexOf(this.mapObject.getMapTypes(), this.type) && this.mapObject.addMapType(this.type);
        "function" == typeof a.getDragObject ?
            this.dragObject = a.getDragObject() : this.dragPanMapObject = null;
        !1 === this.isBaseLayer && this.setGMapVisibility("none" !== this.div.style.display)
    }, onMapResize: function () {
        if (this.visibility && this.mapObject.isLoaded())this.mapObject.checkResize(); else {
            if (!this._resized)var a = this, b = GEvent.addListener(this.mapObject, "load", function () {
                GEvent.removeListener(b);
                delete a._resized;
                a.mapObject.checkResize();
                a.moveTo(a.map.getCenter(), a.map.getZoom())
            });
            this._resized = !0
        }
    }, setGMapVisibility: function (a) {
        var b = OpenLayers.Layer.Google.cache[this.map.id];
        if (b) {
            var c = this.mapObject.getContainer();
            !0 === a ? (this.mapObject.setMapType(this.type), c.style.display = "", this.termsOfUse.style.left = "", this.termsOfUse.style.display = "", this.poweredBy.style.display = "", b.displayed = this.id) : (b.displayed === this.id && delete b.displayed, b.displayed || (c.style.display = "none", this.termsOfUse.style.display = "none", this.termsOfUse.style.left = "-9999px", this.poweredBy.style.display = "none"))
        }
    }, getMapContainer: function () {
        return this.mapObject.getContainer()
    }, getMapObjectBoundsFromOLBounds: function (a) {
        var b =
            null;
        null != a && (b = this.sphericalMercator ? this.inverseMercator(a.bottom, a.left) : new OpenLayers.LonLat(a.bottom, a.left), a = this.sphericalMercator ? this.inverseMercator(a.top, a.right) : new OpenLayers.LonLat(a.top, a.right), b = new GLatLngBounds(new GLatLng(b.lat, b.lon), new GLatLng(a.lat, a.lon)));
        return b
    }, setMapObjectCenter: function (a, b) {
        this.mapObject.setCenter(a, b)
    }, dragPanMapObject: function (a, b) {
        this.dragObject.moveBy(new GSize(-a, b))
    }, getMapObjectLonLatFromMapObjectPixel: function (a) {
        return this.mapObject.fromContainerPixelToLatLng(a)
    },
    getMapObjectPixelFromMapObjectLonLat: function (a) {
        return this.mapObject.fromLatLngToContainerPixel(a)
    }, getMapObjectZoomFromMapObjectBounds: function (a) {
        return this.mapObject.getBoundsZoomLevel(a)
    }, getMapObjectLonLatFromLonLat: function (a, b) {
        var c;
        this.sphericalMercator ? (c = this.inverseMercator(a, b), c = new GLatLng(c.lat, c.lon)) : c = new GLatLng(b, a);
        return c
    }, getMapObjectPixelFromXY: function (a, b) {
        return new GPoint(a, b)
    }
};
OpenLayers.Layer.Google.v3 = {
    DEFAULTS: {sphericalMercator: !0, projection: "EPSG:900913"}, animationEnabled: !0, loadMapObject: function () {
        this.type || (this.type = google.maps.MapTypeId.ROADMAP);
        var a, b = OpenLayers.Layer.Google.cache[this.map.id];
        b ? (a = b.mapObject, ++b.count) : (b = this.map.viewPortDiv, a = document.createElement("div"), a.id = this.map.id + "_GMapContainer", a.style.position = "absolute", a.style.width = "100%", a.style.height = "100%", b.appendChild(a), b = this.map.getCenter(), a = new google.maps.Map(a, {
            center: b ? new google.maps.LatLng(b.lat,
                b.lon) : new google.maps.LatLng(0, 0),
            zoom: this.map.getZoom() || 0,
            mapTypeId: this.type,
            disableDefaultUI: !0,
            keyboardShortcuts: !1,
            draggable: !1,
            disableDoubleClickZoom: !0,
            scrollwheel: !1,
            streetViewControl: !1
        }), b = {
            mapObject: a,
            count: 1
        }, OpenLayers.Layer.Google.cache[this.map.id] = b, this.repositionListener = google.maps.event.addListenerOnce(a, "center_changed", OpenLayers.Function.bind(this.repositionMapElements, this)));
        this.mapObject = a;
        this.setGMapVisibility(this.visibility)
    }, repositionMapElements: function () {
        google.maps.event.trigger(this.mapObject,
            "resize");
        var a = this.mapObject.getDiv().firstChild;
        if (!a || 3 > a.childNodes.length)return this.repositionTimer = window.setTimeout(OpenLayers.Function.bind(this.repositionMapElements, this), 250), !1;
        for (var b = OpenLayers.Layer.Google.cache[this.map.id], c = this.map.viewPortDiv, d = a.children.length - 1; 0 <= d; --d) {
            if (1000001 == a.children[d].style.zIndex) {
                var e = a.children[d];
                c.appendChild(e);
                e.style.zIndex = "1100";
                e.style.bottom = "";
                e.className = "olLayerGoogleCopyright olLayerGoogleV3";
                e.style.display = "";
                b.termsOfUse =
                    e
            }
            1E6 == a.children[d].style.zIndex && (e = a.children[d], c.appendChild(e), e.style.zIndex = "1100", e.style.bottom = "", e.className = "olLayerGooglePoweredBy olLayerGoogleV3 gmnoprint", e.style.display = "", b.poweredBy = e);
            10000002 == a.children[d].style.zIndex && c.appendChild(a.children[d])
        }
        this.setGMapVisibility(this.visibility)
    }, onMapResize: function () {
        if (this.visibility)google.maps.event.trigger(this.mapObject, "resize"); else {
            var a = OpenLayers.Layer.Google.cache[this.map.id];
            if (!a.resized) {
                var b = this;
                google.maps.event.addListenerOnce(this.mapObject,
                    "tilesloaded", function () {
                        google.maps.event.trigger(b.mapObject, "resize");
                        b.moveTo(b.map.getCenter(), b.map.getZoom());
                        delete a.resized
                    })
            }
            a.resized = !0
        }
    }, setGMapVisibility: function (a) {
        var b = OpenLayers.Layer.Google.cache[this.map.id];
        if (b) {
            for (var c = this.type, d = this.map.layers, e, f = d.length - 1; 0 <= f; --f)if (e = d[f], e instanceof OpenLayers.Layer.Google && !0 === e.visibility && !0 === e.inRange) {
                c = e.type;
                a = !0;
                break
            }
            d = this.mapObject.getDiv();
            !0 === a ? (this.mapObject.setMapTypeId(c), d.style.left = "", b.termsOfUse && b.termsOfUse.style &&
            (b.termsOfUse.style.left = "", b.termsOfUse.style.display = "", b.poweredBy.style.display = ""), b.displayed = this.id) : (delete b.displayed, d.style.left = "-9999px", b.termsOfUse && b.termsOfUse.style && (b.termsOfUse.style.display = "none", b.termsOfUse.style.left = "-9999px", b.poweredBy.style.display = "none"))
        }
    }, getMapContainer: function () {
        return this.mapObject.getDiv()
    }, getMapObjectBoundsFromOLBounds: function (a) {
        var b = null;
        null != a && (b = this.sphericalMercator ? this.inverseMercator(a.bottom, a.left) : new OpenLayers.LonLat(a.bottom,
            a.left), a = this.sphericalMercator ? this.inverseMercator(a.top, a.right) : new OpenLayers.LonLat(a.top, a.right), b = new google.maps.LatLngBounds(new google.maps.LatLng(b.lat, b.lon), new google.maps.LatLng(a.lat, a.lon)));
        return b
    }, getMapObjectLonLatFromMapObjectPixel: function (a) {
        var b = this.map.getSize(), c = this.getLongitudeFromMapObjectLonLat(this.mapObject.center), d = this.getLatitudeFromMapObjectLonLat(this.mapObject.center), e = this.map.getResolution(), a = new OpenLayers.LonLat(c + (a.x - b.w / 2) * e, d - (a.y - b.h / 2) * e);
        this.wrapDateLine && (a = a.wrapDateLine(this.maxExtent));
        return this.getMapObjectLonLatFromLonLat(a.lon, a.lat)
    }, getMapObjectPixelFromMapObjectLonLat: function (a) {
        var b = this.getLongitudeFromMapObjectLonLat(a), a = this.getLatitudeFromMapObjectLonLat(a), c = this.map.getResolution(), d = this.map.getExtent();
        return this.getMapObjectPixelFromXY(1 / c * (b - d.left), 1 / c * (d.top - a))
    }, setMapObjectCenter: function (a, b) {
        if (!1 === this.animationEnabled && b != this.mapObject.zoom) {
            var c = this.getMapContainer();
            google.maps.event.addListenerOnce(this.mapObject,
                "idle", function () {
                    c.style.visibility = ""
                });
            c.style.visibility = "hidden"
        }
        this.mapObject.setOptions({center: a, zoom: b})
    }, getMapObjectZoomFromMapObjectBounds: function (a) {
        return this.mapObject.getBoundsZoomLevel(a)
    }, getMapObjectLonLatFromLonLat: function (a, b) {
        var c;
        this.sphericalMercator ? (c = this.inverseMercator(a, b), c = new google.maps.LatLng(c.lat, c.lon)) : c = new google.maps.LatLng(b, a);
        return c
    }, getMapObjectPixelFromXY: function (a, b) {
        return new google.maps.Point(a, b)
    }, destroy: function () {
        this.repositionListener &&
        google.maps.event.removeListener(this.repositionListener);
        this.repositionTimer && window.clearTimeout(this.repositionTimer);
        OpenLayers.Layer.Google.prototype.destroy.apply(this, arguments)
    }
};
OpenLayers.Layer.HTTPRequest = OpenLayers.Class(OpenLayers.Layer, {
    URL_HASH_FACTOR: (Math.sqrt(5) - 1) / 2, url: null, params: null, reproject: !1, initialize: function (a, b, c, d) {
        OpenLayers.Layer.prototype.initialize.apply(this, [a, d]);
        this.url = b;
        this.params || (this.params = OpenLayers.Util.extend({}, c))
    }, destroy: function () {
        this.params = this.url = null;
        OpenLayers.Layer.prototype.destroy.apply(this, arguments)
    }, clone: function (a) {
        null == a && (a = new OpenLayers.Layer.HTTPRequest(this.name, this.url, this.params, this.getOptions()));
        return OpenLayers.Layer.prototype.clone.apply(this, [a])
    }, setUrl: function (a) {
        this.url = a
    }, mergeNewParams: function (a) {
        this.params = OpenLayers.Util.extend(this.params, a);
        a = this.redraw();
        null != this.map && this.map.events.triggerEvent("changelayer", {layer: this, property: "params"});
        return a
    }, redraw: function (a) {
        return a ? this.mergeNewParams({_olSalt: Math.random()}) : OpenLayers.Layer.prototype.redraw.apply(this, [])
    }, selectUrl: function (a, b) {
        for (var c = 1, d = 0, e = a.length; d < e; d++)c *= a.charCodeAt(d) * this.URL_HASH_FACTOR,
            c -= Math.floor(c);
        return b[Math.floor(c * b.length)]
    }, getFullRequestString: function (a, b) {
        var c = b || this.url, d = OpenLayers.Util.extend({}, this.params), d = OpenLayers.Util.extend(d, a), e = OpenLayers.Util.getParameterString(d);
        OpenLayers.Util.isArray(c) && (c = this.selectUrl(e, c));
        var e = OpenLayers.Util.upperCaseObject(OpenLayers.Util.getParameters(c)), f;
        for (f in d)f.toUpperCase()in e && delete d[f];
        e = OpenLayers.Util.getParameterString(d);
        return OpenLayers.Util.urlAppend(c, e)
    }, CLASS_NAME: "OpenLayers.Layer.HTTPRequest"
});
OpenLayers.Layer.Grid = OpenLayers.Class(OpenLayers.Layer.HTTPRequest, {
    tileSize: null,
    tileOriginCorner: "bl",
    tileOrigin: null,
    tileOptions: null,
    tileClass: OpenLayers.Tile.Image,
    grid: null,
    singleTile: !1,
    ratio: 1.5,
    buffer: 0,
    transitionEffect: null,
    numLoadingTiles: 0,
    tileLoadingDelay: 85,
    serverResolutions: null,
    moveTimerId: null,
    deferMoveGriddedTiles: null,
    tileQueueId: null,
    tileQueue: null,
    loading: !1,
    backBuffer: null,
    gridResolution: null,
    backBufferResolution: null,
    backBufferLonLat: null,
    backBufferTimerId: null,
    removeBackBufferDelay: null,
    className: null,
    initialize: function (a, b, c, d) {
        OpenLayers.Layer.HTTPRequest.prototype.initialize.apply(this, arguments);
        this.grid = [];
        this.tileQueue = [];
        null === this.removeBackBufferDelay && (this.removeBackBufferDelay = this.singleTile ? 0 : 2500);
        null === this.className && (this.className = this.singleTile ? "olLayerGridSingleTile" : "olLayerGrid");
        OpenLayers.Animation.isNative || (this.deferMoveGriddedTiles = OpenLayers.Function.bind(function () {
            this.moveGriddedTiles(!0);
            this.moveTimerId = null
        }, this))
    },
    setMap: function (a) {
        OpenLayers.Layer.HTTPRequest.prototype.setMap.call(this,
            a);
        OpenLayers.Element.addClass(this.div, this.className)
    },
    removeMap: function () {
        null !== this.moveTimerId && (window.clearTimeout(this.moveTimerId), this.moveTimerId = null);
        this.clearTileQueue();
        null !== this.backBufferTimerId && (window.clearTimeout(this.backBufferTimerId), this.backBufferTimerId = null)
    },
    destroy: function () {
        this.removeBackBuffer();
        this.clearGrid();
        this.tileSize = this.grid = null;
        OpenLayers.Layer.HTTPRequest.prototype.destroy.apply(this, arguments)
    },
    clearGrid: function () {
        this.clearTileQueue();
        if (this.grid) {
            for (var a =
                0, b = this.grid.length; a < b; a++)for (var c = this.grid[a], d = 0, e = c.length; d < e; d++)this.destroyTile(c[d]);
            this.grid = [];
            this.gridResolution = null
        }
    },
    clone: function (a) {
        null == a && (a = new OpenLayers.Layer.Grid(this.name, this.url, this.params, this.getOptions()));
        a = OpenLayers.Layer.HTTPRequest.prototype.clone.apply(this, [a]);
        null != this.tileSize && (a.tileSize = this.tileSize.clone());
        a.grid = [];
        a.gridResolution = null;
        a.backBuffer = null;
        a.backBufferTimerId = null;
        a.tileQueue = [];
        a.tileQueueId = null;
        a.loading = !1;
        a.moveTimerId = null;
        return a
    },
    moveTo: function (a, b, c) {
        OpenLayers.Layer.HTTPRequest.prototype.moveTo.apply(this, arguments);
        a = a || this.map.getExtent();
        if (null != a) {
            var d = !this.grid.length || b, e = this.getTilesBounds(), f = this.map.getResolution(), g = this.getServerResolution(f);
            if (this.singleTile) {
                if (d || !c && !e.containsBounds(a))b && "resize" !== this.transitionEffect && this.removeBackBuffer(), (!b || "resize" === this.transitionEffect) && this.applyBackBuffer(g), this.initSingleTile(a)
            } else d = d || !e.intersectsBounds(a, {
                worldBounds: this.map.baseLayer.wrapDateLine &&
                this.map.getMaxExtent()
            }), f !== g ? (a = this.map.calculateBounds(null, g), d && this.transformDiv(g / f)) : (this.div.style.width = "100%", this.div.style.height = "100%", this.div.style.left = "0%", this.div.style.top = "0%"), d ? (b && "resize" === this.transitionEffect && this.applyBackBuffer(g), this.initGriddedTiles(a)) : this.moveGriddedTiles()
        }
    },
    getTileData: function (a) {
        var b = null, c = a.lon, d = a.lat, e = this.grid.length;
        if (this.map && e) {
            var f = this.map.getResolution(), a = this.tileSize.w, g = this.tileSize.h, h = this.grid[0][0].bounds, k = h.left,
                h = h.top;
            if (c < k && this.map.baseLayer.wrapDateLine)var l = this.map.getMaxExtent().getWidth(), m = Math.ceil((k - c) / l), c = c + l * m;
            c = (c - k) / (f * a);
            d = (h - d) / (f * g);
            f = Math.floor(c);
            k = Math.floor(d);
            0 <= k && k < e && (e = this.grid[k][f]) && (b = {
                tile: e,
                i: Math.floor((c - f) * a),
                j: Math.floor((d - k) * g)
            })
        }
        return b
    },
    queueTileDraw: function (a) {
        a = a.object;
        ~OpenLayers.Util.indexOf(this.tileQueue, a) || this.tileQueue.push(a);
        this.tileQueueId || (this.tileQueueId = OpenLayers.Animation.start(OpenLayers.Function.bind(this.drawTileFromQueue, this), null,
            this.div));
        return !1
    },
    drawTileFromQueue: function () {
        0 === this.tileQueue.length ? this.clearTileQueue() : this.tileQueue.shift().draw(!0)
    },
    clearTileQueue: function () {
        OpenLayers.Animation.stop(this.tileQueueId);
        this.tileQueueId = null;
        this.tileQueue = []
    },
    destroyTile: function (a) {
        this.removeTileMonitoringHooks(a);
        a.destroy()
    },
    getServerResolution: function (a) {
        a = a || this.map.getResolution();
        if (this.serverResolutions && -1 === OpenLayers.Util.indexOf(this.serverResolutions, a)) {
            var b, c;
            for (b = this.serverResolutions.length -
            1; 0 <= b; b--)if (c = this.serverResolutions[b], c > a) {
                a = c;
                break
            }
            if (-1 === b)throw"no appropriate resolution in serverResolutions";
        }
        return a
    },
    getServerZoom: function () {
        var a = this.getServerResolution();
        return this.serverResolutions ? OpenLayers.Util.indexOf(this.serverResolutions, a) : this.map.getZoomForResolution(a) + (this.zoomOffset || 0)
    },
    transformDiv: function (a) {
        this.div.style.width = 100 * a + "%";
        this.div.style.height = 100 * a + "%";
        var b = this.map.getSize(), c = parseInt(this.map.layerContainerDiv.style.left, 10), d = (parseInt(this.map.layerContainerDiv.style.top,
                10) - b.h / 2) * (a - 1);
        this.div.style.left = (c - b.w / 2) * (a - 1) + "%";
        this.div.style.top = d + "%"
    },
    getResolutionScale: function () {
        return parseInt(this.div.style.width, 10) / 100
    },
    applyBackBuffer: function (a) {
        null !== this.backBufferTimerId && this.removeBackBuffer();
        var b = this.backBuffer;
        if (!b) {
            b = this.createBackBuffer();
            if (!b)return;
            this.div.insertBefore(b, this.div.firstChild);
            this.backBuffer = b;
            var c = this.grid[0][0].bounds;
            this.backBufferLonLat = {lon: c.left, lat: c.top};
            this.backBufferResolution = this.gridResolution
        }
        var c = b.style,
            d = this.backBufferResolution / a;
        c.width = 100 * d + "%";
        c.height = 100 * d + "%";
        a = this.getViewPortPxFromLonLat(this.backBufferLonLat, a);
        c = parseInt(this.map.layerContainerDiv.style.left, 10);
        d = parseInt(this.map.layerContainerDiv.style.top, 10);
        b.style.left = Math.round(a.x - c) + "%";
        b.style.top = Math.round(a.y - d) + "%"
    },
    createBackBuffer: function () {
        var a;
        if (0 < this.grid.length) {
            a = document.createElement("div");
            a.id = this.div.id + "_bb";
            a.className = "olBackBuffer";
            a.style.position = "absolute";
            a.style.width = "100%";
            a.style.height =
                "100%";
            for (var b = 0, c = this.grid.length; b < c; b++)for (var d = 0, e = this.grid[b].length; d < e; d++) {
                var f = this.grid[b][d].createBackBuffer();
                f && (f.style.top = b * this.tileSize.h + "%", f.style.left = d * this.tileSize.w + "%", a.appendChild(f))
            }
        }
        return a
    },
    removeBackBuffer: function () {
        this.backBuffer && (this.div.removeChild(this.backBuffer), this.backBufferResolution = this.backBuffer = null, null !== this.backBufferTimerId && (window.clearTimeout(this.backBufferTimerId), this.backBufferTimerId = null))
    },
    moveByPx: function () {
        this.singleTile ||
        this.moveGriddedTiles()
    },
    setTileSize: function (a) {
        this.singleTile && (a = this.map.getSize(), a.h = parseInt(a.h * this.ratio), a.w = parseInt(a.w * this.ratio));
        OpenLayers.Layer.HTTPRequest.prototype.setTileSize.apply(this, [a])
    },
    getTilesBounds: function () {
        var a = null, b = this.grid.length;
        if (b)var a = this.grid[b - 1][0].bounds, b = this.grid[0].length * a.getWidth(), c = this.grid.length * a.getHeight(), a = new OpenLayers.Bounds(a.left, a.bottom, a.left + b, a.bottom + c);
        return a
    },
    initSingleTile: function (a) {
        this.clearTileQueue();
        var b =
            a.getCenterLonLat(), c = a.getWidth() * this.ratio, a = a.getHeight() * this.ratio, b = new OpenLayers.Bounds(b.lon - c / 2, b.lat - a / 2, b.lon + c / 2, b.lat + a / 2), c = this.map.getLayerPxFromLonLat({
            lon: b.left,
            lat: b.top
        });
        this.grid.length || (this.grid[0] = []);
        (a = this.grid[0][0]) ? a.moveTo(b, c) : (a = this.addTile(b, c), this.addTileMonitoringHooks(a), a.draw(), this.grid[0][0] = a);
        this.removeExcessTiles(1, 1);
        this.gridResolution = this.getServerResolution()
    },
    calculateGridLayout: function (a, b, c) {
        var d = c * this.tileSize.w, c = c * this.tileSize.h, e =
            a.left - b.lon, f = Math.floor(e / d) - this.buffer, e = -(e / d - f) * this.tileSize.w, f = b.lon + f * d, a = a.top - (b.lat + c), g = Math.ceil(a / c) + this.buffer;
        return {
            tilelon: d,
            tilelat: c,
            tileoffsetlon: f,
            tileoffsetlat: b.lat + g * c,
            tileoffsetx: e,
            tileoffsety: -(g - a / c) * this.tileSize.h
        }
    },
    getTileOrigin: function () {
        var a = this.tileOrigin;
        if (!a)var a = this.getMaxExtent(), b = {
            tl: ["left", "top"],
            tr: ["right", "top"],
            bl: ["left", "bottom"],
            br: ["right", "bottom"]
        }[this.tileOriginCorner], a = new OpenLayers.LonLat(a[b[0]], a[b[1]]);
        return a
    },
    initGriddedTiles: function (a) {
        this.clearTileQueue();
        var b = this.map.getSize(), c = Math.ceil(b.h / this.tileSize.h) + Math.max(1, 2 * this.buffer), b = Math.ceil(b.w / this.tileSize.w) + Math.max(1, 2 * this.buffer), d = this.getTileOrigin(), e = this.getServerResolution(), d = this.calculateGridLayout(a, d, e), e = Math.round(d.tileoffsetx), f = Math.round(d.tileoffsety), g = d.tileoffsetlon, h = d.tileoffsetlat, k = d.tilelon, l = d.tilelat, m = e, n = g, o = 0, p = parseInt(this.map.layerContainerDiv.style.left), r = parseInt(this.map.layerContainerDiv.style.top), d = [], u = this.map.getCenter();
        do {
            var q = this.grid[o++];
            q || (q = [], this.grid.push(q));
            var g = n, e = m, t = 0;
            do {
                var y = new OpenLayers.Bounds(g, h, g + k, h + l), w = e, w = w - p, A = f, A = A - r, A = new OpenLayers.Pixel(w, A);
                (w = q[t++]) ? w.moveTo(y, A, !1) : (w = this.addTile(y, A), this.addTileMonitoringHooks(w), q.push(w));
                y = y.getCenterLonLat();
                d.push({tile: w, distance: Math.pow(y.lon - u.lon, 2) + Math.pow(y.lat - u.lat, 2)});
                g += k;
                e += this.tileSize.w
            } while (g <= a.right + k * this.buffer || t < b);
            h -= l;
            f += this.tileSize.h
        } while (h >= a.bottom - l * this.buffer || o < c);
        this.removeExcessTiles(o, t);
        this.gridResolution = this.getServerResolution();
        d.sort(function (a, b) {
            return a.distance - b.distance
        });
        a = 0;
        for (c = d.length; a < c; ++a)d[a].tile.draw()
    },
    getMaxExtent: function () {
        return this.maxExtent
    },
    addTile: function (a, b) {
        var c = new this.tileClass(this, b, a, null, this.tileSize, this.tileOptions);
        c.events.register("beforedraw", this, this.queueTileDraw);
        return c
    },
    addTileMonitoringHooks: function (a) {
        a.onLoadStart = function () {
            !1 === this.loading && (this.loading = !0, this.events.triggerEvent("loadstart"));
            this.events.triggerEvent("tileloadstart", {tile: a});
            this.numLoadingTiles++
        };
        a.onLoadEnd = function () {
            this.numLoadingTiles--;
            this.events.triggerEvent("tileloaded", {tile: a});
            0 === this.tileQueue.length && 0 === this.numLoadingTiles && (this.loading = !1, this.events.triggerEvent("loadend"), this.backBuffer && (this.backBufferTimerId = window.setTimeout(OpenLayers.Function.bind(this.removeBackBuffer, this), this.removeBackBufferDelay)))
        };
        a.onLoadError = function () {
            this.events.triggerEvent("tileerror", {tile: a})
        };
        a.events.on({
            loadstart: a.onLoadStart, loadend: a.onLoadEnd, unload: a.onLoadEnd, loaderror: a.onLoadError,
            scope: this
        })
    },
    removeTileMonitoringHooks: function (a) {
        a.unload();
        a.events.un({
            loadstart: a.onLoadStart,
            loadend: a.onLoadEnd,
            unload: a.onLoadEnd,
            loaderror: a.onLoadError,
            scope: this
        })
    },
    moveGriddedTiles: function (a) {
        if (!a && !OpenLayers.Animation.isNative)null != this.moveTimerId && window.clearTimeout(this.moveTimerId), this.moveTimerId = window.setTimeout(this.deferMoveGriddedTiles, this.tileLoadingDelay); else for (var a = this.buffer || 1, b = this.getResolutionScale(); ;) {
            var c = this.grid[0][0].position.x * b + parseInt(this.div.style.left,
                    10) + parseInt(this.map.layerContainerDiv.style.left), d = this.grid[0][0].position.y * b + parseInt(this.div.style.top, 10) + parseInt(this.map.layerContainerDiv.style.top), e = this.tileSize.w * b, f = this.tileSize.h * b;
            if (c > -e * (a - 1))this.shiftColumn(!0); else if (c < -e * a)this.shiftColumn(!1); else if (d > -f * (a - 1))this.shiftRow(!0); else if (d < -f * a)this.shiftRow(!1); else break
        }
    },
    shiftRow: function (a) {
        for (var b = this.grid, c = b[a ? 0 : this.grid.length - 1], d = this.getServerResolution(), e = a ? -this.tileSize.h : this.tileSize.h, d = d * -e, f = a ?
            b.pop() : b.shift(), g = 0, h = c.length; g < h; g++) {
            var k = c[g], l = k.bounds.clone(), k = k.position.clone();
            l.bottom += d;
            l.top += d;
            k.y += e;
            f[g].moveTo(l, k)
        }
        a ? b.unshift(f) : b.push(f)
    },
    shiftColumn: function (a) {
        for (var b = a ? -this.tileSize.w : this.tileSize.w, c = this.getServerResolution() * b, d = 0, e = this.grid.length; d < e; d++) {
            var f = this.grid[d], g = f[a ? 0 : f.length - 1], h = g.bounds.clone(), g = g.position.clone();
            h.left += c;
            h.right += c;
            g.x += b;
            var k = a ? this.grid[d].pop() : this.grid[d].shift();
            k.moveTo(h, g);
            a ? f.unshift(k) : f.push(k)
        }
    },
    removeExcessTiles: function (a,
                                 b) {
        for (var c, d; this.grid.length > a;) {
            var e = this.grid.pop();
            for (c = 0, d = e.length; c < d; c++) {
                var f = e[c];
                this.destroyTile(f)
            }
        }
        for (c = 0, d = this.grid.length; c < d; c++)for (; this.grid[c].length > b;)e = this.grid[c], f = e.pop(), this.destroyTile(f)
    },
    onMapResize: function () {
        this.singleTile && (this.clearGrid(), this.setTileSize())
    },
    getTileBounds: function (a) {
        var b = this.maxExtent, c = this.getResolution(), d = c * this.tileSize.w, c = c * this.tileSize.h, e = this.getLonLatFromViewPortPx(a), a = b.left + d * Math.floor((e.lon - b.left) / d), b = b.bottom +
            c * Math.floor((e.lat - b.bottom) / c);
        return new OpenLayers.Bounds(a, b, a + d, b + c)
    },
    CLASS_NAME: "OpenLayers.Layer.Grid"
});
OpenLayers.Layer.MapGuide = OpenLayers.Class(OpenLayers.Layer.Grid, {
    isBaseLayer: !0,
    useHttpTile: !1,
    singleTile: !1,
    useOverlay: !1,
    useAsyncOverlay: !0,
    TILE_PARAMS: {operation: "GETTILEIMAGE", version: "1.2.0"},
    SINGLE_TILE_PARAMS: {operation: "GETMAPIMAGE", format: "PNG", locale: "en", clip: "1", version: "1.0.0"},
    OVERLAY_PARAMS: {operation: "GETDYNAMICMAPOVERLAYIMAGE", format: "PNG", locale: "en", clip: "1", version: "2.0.0"},
    FOLDER_PARAMS: {tileColumnsPerFolder: 30, tileRowsPerFolder: 30, format: "png", querystring: null},
    defaultSize: new OpenLayers.Size(300,
        300),
    tileOriginCorner: "tl",
    initialize: function (a, b, c, d) {
        OpenLayers.Layer.Grid.prototype.initialize.apply(this, arguments);
        if (null == d || null == d.isBaseLayer)this.isBaseLayer = "true" != this.transparent && !0 != this.transparent;
        d && null != d.useOverlay && (this.useOverlay = d.useOverlay);
        this.singleTile ? this.useOverlay ? (OpenLayers.Util.applyDefaults(this.params, this.OVERLAY_PARAMS), this.useAsyncOverlay || (this.params.version = "1.0.0")) : OpenLayers.Util.applyDefaults(this.params, this.SINGLE_TILE_PARAMS) : (this.useHttpTile ?
            OpenLayers.Util.applyDefaults(this.params, this.FOLDER_PARAMS) : OpenLayers.Util.applyDefaults(this.params, this.TILE_PARAMS), this.setTileSize(this.defaultSize))
    },
    clone: function (a) {
        null == a && (a = new OpenLayers.Layer.MapGuide(this.name, this.url, this.params, this.getOptions()));
        return OpenLayers.Layer.Grid.prototype.clone.apply(this, [a])
    },
    getURL: function (a) {
        var b;
        b = a.getCenterLonLat();
        var c = this.map.getSize();
        this.singleTile ? (a = {
            setdisplaydpi: OpenLayers.DOTS_PER_INCH, setdisplayheight: c.h * this.ratio, setdisplaywidth: c.w *
            this.ratio, setviewcenterx: b.lon, setviewcentery: b.lat, setviewscale: this.map.getScale()
        }, this.useOverlay && !this.useAsyncOverlay && (b = {}, b = OpenLayers.Util.extend(b, a), b.operation = "GETVISIBLEMAPEXTENT", b.version = "1.0.0", b.session = this.params.session, b.mapName = this.params.mapName, b.format = "text/xml", b = this.getFullRequestString(b), OpenLayers.Request.GET({
            url: b,
            async: !1
        })), b = this.getFullRequestString(a)) : (c = this.map.getResolution(), b = Math.floor((a.left - this.maxExtent.left) / c), b = Math.round(b / this.tileSize.w),
            a = Math.floor((this.maxExtent.top - a.top) / c), a = Math.round(a / this.tileSize.h), b = this.useHttpTile ? this.getImageFilePath({
            tilecol: b,
            tilerow: a,
            scaleindex: this.resolutions.length - this.map.zoom - 1
        }) : this.getFullRequestString({
            tilecol: b,
            tilerow: a,
            scaleindex: this.resolutions.length - this.map.zoom - 1
        }));
        return b
    },
    getFullRequestString: function (a, b) {
        var c = null == b ? this.url : b;
        "object" == typeof c && (c = c[Math.floor(Math.random() * c.length)]);
        var d = c, e = OpenLayers.Util.extend({}, this.params), e = OpenLayers.Util.extend(e, a),
            f = OpenLayers.Util.upperCaseObject(OpenLayers.Util.getParameters(c)), g;
        for (g in e)g.toUpperCase()in f && delete e[g];
        e = OpenLayers.Util.getParameterString(e);
        e = e.replace(/,/g, "+");
        "" != e && (f = c.charAt(c.length - 1), d = "&" == f || "?" == f ? d + e : -1 == c.indexOf("?") ? d + ("?" + e) : d + ("&" + e));
        return d
    },
    getImageFilePath: function (a, b) {
        var c = null == b ? this.url : b;
        "object" == typeof c && (c = c[Math.floor(Math.random() * c.length)]);
        var d = "", e = "";
        0 > a.tilerow && (d = "-");
        d = 0 == a.tilerow ? d + "0" : d + Math.floor(Math.abs(a.tilerow / this.params.tileRowsPerFolder)) *
        this.params.tileRowsPerFolder;
        0 > a.tilecol && (e = "-");
        e = 0 == a.tilecol ? e + "0" : e + Math.floor(Math.abs(a.tilecol / this.params.tileColumnsPerFolder)) * this.params.tileColumnsPerFolder;
        d = "/S" + Math.floor(a.scaleindex) + "/" + this.params.basemaplayergroupname + "/R" + d + "/C" + e + "/" + a.tilerow % this.params.tileRowsPerFolder + "_" + a.tilecol % this.params.tileColumnsPerFolder + "." + this.params.format;
        this.params.querystring && (d += "?" + this.params.querystring);
        return c + d
    },
    calculateGridLayout: function (a, b, c) {
        var d = c * this.tileSize.w, c =
            c * this.tileSize.h, e = a.left - b.lon, f = Math.floor(e / d) - this.buffer, a = b.lat - a.top + c, g = Math.floor(a / c) - this.buffer;
        return {
            tilelon: d,
            tilelat: c,
            tileoffsetlon: b.lon + f * d,
            tileoffsetlat: b.lat - c * g,
            tileoffsetx: -(e / d - f) * this.tileSize.w,
            tileoffsety: (g - a / c) * this.tileSize.h
        }
    },
    CLASS_NAME: "OpenLayers.Layer.MapGuide"
});
OpenLayers.Layer.MapServer = OpenLayers.Class(OpenLayers.Layer.Grid, {
    DEFAULT_PARAMS: {mode: "map", map_imagetype: "png"}, initialize: function (a, b, c, d) {
        OpenLayers.Layer.Grid.prototype.initialize.apply(this, arguments);
        this.params = OpenLayers.Util.applyDefaults(this.params, this.DEFAULT_PARAMS);
        if (null == d || null == d.isBaseLayer)this.isBaseLayer = "true" != this.params.transparent && !0 != this.params.transparent
    }, clone: function (a) {
        null == a && (a = new OpenLayers.Layer.MapServer(this.name, this.url, this.params, this.getOptions()));
        return OpenLayers.Layer.Grid.prototype.clone.apply(this, [a])
    }, getURL: function (a) {
        var a = this.adjustBounds(a), a = [a.left, a.bottom, a.right, a.top], b = this.getImageSize();
        return this.getFullRequestString({
            mapext: a,
            imgext: a,
            map_size: [b.w, b.h],
            imgx: b.w / 2,
            imgy: b.h / 2,
            imgxy: [b.w, b.h]
        })
    }, getFullRequestString: function (a, b) {
        var c = null == b ? this.url : b, d = OpenLayers.Util.extend({}, this.params), d = OpenLayers.Util.extend(d, a), e = OpenLayers.Util.getParameterString(d);
        OpenLayers.Util.isArray(c) && (c = this.selectUrl(e, c));
        var e =
            OpenLayers.Util.upperCaseObject(OpenLayers.Util.getParameters(c)), f;
        for (f in d)f.toUpperCase()in e && delete d[f];
        e = OpenLayers.Util.getParameterString(d);
        d = c;
        e = e.replace(/,/g, "+");
        "" != e && (f = c.charAt(c.length - 1), d = "&" == f || "?" == f ? d + e : -1 == c.indexOf("?") ? d + ("?" + e) : d + ("&" + e));
        return d
    }, CLASS_NAME: "OpenLayers.Layer.MapServer"
});
OpenLayers.Layer.KaMap = OpenLayers.Class(OpenLayers.Layer.Grid, {
    isBaseLayer: !0, DEFAULT_PARAMS: {i: "jpeg", map: ""}, initialize: function (a, b, c, d) {
        OpenLayers.Layer.Grid.prototype.initialize.apply(this, arguments);
        this.params = OpenLayers.Util.applyDefaults(this.params, this.DEFAULT_PARAMS)
    }, getURL: function (a) {
        var a = this.adjustBounds(a), b = this.map.getResolution(), c = Math.round(1E4 * this.map.getScale()) / 1E4, d = Math.round(a.left / b);
        return this.getFullRequestString({t: -Math.round(a.top / b), l: d, s: c})
    }, calculateGridLayout: function (a,
                                      b, c) {
        var b = c * this.tileSize.w, c = c * this.tileSize.h, d = a.left, e = Math.floor(d / b) - this.buffer, d = -(d / b - e) * this.tileSize.w, e = e * b, a = a.top, f = Math.ceil(a / c) + this.buffer;
        return {
            tilelon: b,
            tilelat: c,
            tileoffsetlon: e,
            tileoffsetlat: f * c,
            tileoffsetx: d,
            tileoffsety: -(f - a / c + 1) * this.tileSize.h
        }
    }, clone: function (a) {
        null == a && (a = new OpenLayers.Layer.KaMap(this.name, this.url, this.params, this.getOptions()));
        a = OpenLayers.Layer.Grid.prototype.clone.apply(this, [a]);
        null != this.tileSize && (a.tileSize = this.tileSize.clone());
        a.grid =
            [];
        return a
    }, getTileBounds: function (a) {
        var b = this.getResolution(), c = b * this.tileSize.w, b = b * this.tileSize.h, d = this.getLonLatFromViewPortPx(a), a = c * Math.floor(d.lon / c), d = b * Math.floor(d.lat / b);
        return new OpenLayers.Bounds(a, d, a + c, d + b)
    }, CLASS_NAME: "OpenLayers.Layer.KaMap"
});
OpenLayers.Layer.KaMapCache = OpenLayers.Class(OpenLayers.Layer.KaMap, {
    IMAGE_EXTENSIONS: {jpeg: "jpg", gif: "gif", png: "png", png8: "png", png24: "png", dithered: "png"},
    DEFAULT_FORMAT: "jpeg",
    initialize: function (a, b, c, d) {
        OpenLayers.Layer.KaMap.prototype.initialize.apply(this, arguments);
        this.extension = this.IMAGE_EXTENSIONS[this.params.i.toLowerCase() || this.DEFAULT_FORMAT]
    },
    getURL: function (a) {
        var a = this.adjustBounds(a), b = this.map.getResolution(), c = Math.round(1E4 * this.map.getScale()) / 1E4, d = Math.round(a.left / b), a =
            -Math.round(a.top / b), b = Math.floor(d / this.tileSize.w / this.params.metaTileSize.w) * this.tileSize.w * this.params.metaTileSize.w, e = Math.floor(a / this.tileSize.h / this.params.metaTileSize.h) * this.tileSize.h * this.params.metaTileSize.h, c = ["/", this.params.map, "/", c, "/", this.params.g.replace(/\s/g, "_"), "/def/t", e, "/l", b, "/t", a, "l", d, ".", this.extension], d = this.url;
        OpenLayers.Util.isArray(d) && (d = this.selectUrl(c.join(""), d));
        return d + c.join("")
    },
    CLASS_NAME: "OpenLayers.Layer.KaMapCache"
});
OpenLayers.Layer.Markers = OpenLayers.Class(OpenLayers.Layer, {
    isBaseLayer: !1, markers: null, drawn: !1, initialize: function (a, b) {
        OpenLayers.Layer.prototype.initialize.apply(this, arguments);
        this.markers = []
    }, destroy: function () {
        this.clearMarkers();
        this.markers = null;
        OpenLayers.Layer.prototype.destroy.apply(this, arguments)
    }, setOpacity: function (a) {
        if (a != this.opacity) {
            this.opacity = a;
            for (var a = 0, b = this.markers.length; a < b; a++)this.markers[a].setOpacity(this.opacity)
        }
    }, moveTo: function (a, b, c) {
        OpenLayers.Layer.prototype.moveTo.apply(this,
            arguments);
        if (b || !this.drawn) {
            for (var d = 0, e = this.markers.length; d < e; d++)this.drawMarker(this.markers[d]);
            this.drawn = !0
        }
    }, addMarker: function (a) {
        this.markers.push(a);
        1 > this.opacity && a.setOpacity(this.opacity);
        this.map && this.map.getExtent() && (a.map = this.map, this.drawMarker(a))
    }, removeMarker: function (a) {
        this.markers && this.markers.length && (OpenLayers.Util.removeItem(this.markers, a), a.erase())
    }, clearMarkers: function () {
        if (null != this.markers)for (; 0 < this.markers.length;)this.removeMarker(this.markers[0])
    },
    drawMarker: function (a) {
        var b = this.map.getLayerPxFromLonLat(a.lonlat);
        null == b ? a.display(!1) : a.isDrawn() ? a.icon && a.icon.moveTo(b) : this.div.appendChild(a.draw(b))
    }, getDataExtent: function () {
        var a = null;
        if (this.markers && 0 < this.markers.length)for (var a = new OpenLayers.Bounds, b = 0, c = this.markers.length; b < c; b++)a.extend(this.markers[b].lonlat);
        return a
    }, CLASS_NAME: "OpenLayers.Layer.Markers"
});
OpenLayers.Layer.Text = OpenLayers.Class(OpenLayers.Layer.Markers, {
    location: null, features: null, formatOptions: null, selectedFeature: null, initialize: function (a, b) {
        OpenLayers.Layer.Markers.prototype.initialize.apply(this, arguments);
        this.features = []
    }, destroy: function () {
        OpenLayers.Layer.Markers.prototype.destroy.apply(this, arguments);
        this.clearFeatures();
        this.features = null
    }, loadText: function () {
        !this.loaded && null != this.location && (this.events.triggerEvent("loadstart"), OpenLayers.Request.GET({
            url: this.location,
            success: this.parseData, failure: function () {
                this.events.triggerEvent("loadend")
            }, scope: this
        }), this.loaded = !0)
    }, moveTo: function (a, b, c) {
        OpenLayers.Layer.Markers.prototype.moveTo.apply(this, arguments);
        this.visibility && !this.loaded && this.loadText()
    }, parseData: function (a) {
        var a = a.responseText, b = {};
        OpenLayers.Util.extend(b, this.formatOptions);
        this.map && !this.projection.equals(this.map.getProjectionObject()) && (b.externalProjection = this.projection, b.internalProjection = this.map.getProjectionObject());
        for (var a =
            (new OpenLayers.Format.Text(b)).read(a), b = 0, c = a.length; b < c; b++) {
            var d = {}, e = a[b], f, g, h;
            f = new OpenLayers.LonLat(e.geometry.x, e.geometry.y);
            e.style.graphicWidth && e.style.graphicHeight && (g = new OpenLayers.Size(e.style.graphicWidth, e.style.graphicHeight));
            void 0 !== e.style.graphicXOffset && void 0 !== e.style.graphicYOffset && (h = new OpenLayers.Pixel(e.style.graphicXOffset, e.style.graphicYOffset));
            null != e.style.externalGraphic ? d.icon = new OpenLayers.Icon(e.style.externalGraphic, g, h) : (d.icon = OpenLayers.Marker.defaultIcon(),
            null != g && d.icon.setSize(g));
            null != e.attributes.title && null != e.attributes.description && (d.popupContentHTML = "<h2>" + e.attributes.title + "</h2><p>" + e.attributes.description + "</p>");
            d.overflow = e.attributes.overflow || "auto";
            d = new OpenLayers.Feature(this, f, d);
            this.features.push(d);
            f = d.createMarker();
            null != e.attributes.title && null != e.attributes.description && f.events.register("click", d, this.markerClick);
            this.addMarker(f)
        }
        this.events.triggerEvent("loadend")
    }, markerClick: function (a) {
        var b = this == this.layer.selectedFeature;
        this.layer.selectedFeature = !b ? this : null;
        for (var c = 0, d = this.layer.map.popups.length; c < d; c++)this.layer.map.removePopup(this.layer.map.popups[c]);
        b || this.layer.map.addPopup(this.createPopup());
        OpenLayers.Event.stop(a)
    }, clearFeatures: function () {
        if (null != this.features)for (; 0 < this.features.length;) {
            var a = this.features[0];
            OpenLayers.Util.removeItem(this.features, a);
            a.destroy()
        }
    }, CLASS_NAME: "OpenLayers.Layer.Text"
});
OpenLayers.Layer.WorldWind = OpenLayers.Class(OpenLayers.Layer.Grid, {
    DEFAULT_PARAMS: {}, isBaseLayer: !0, lzd: null, zoomLevels: null, initialize: function (a, b, c, d, e, f) {
        this.lzd = c;
        this.zoomLevels = d;
        c = [];
        c.push(a, b, e, f);
        OpenLayers.Layer.Grid.prototype.initialize.apply(this, c);
        this.params = OpenLayers.Util.applyDefaults(this.params, this.DEFAULT_PARAMS)
    }, getZoom: function () {
        var a = this.map.getZoom();
        this.map.getMaxExtent();
        return a - Math.log(this.maxResolution / (this.lzd / 512)) / Math.log(2)
    }, getURL: function (a) {
        var a = this.adjustBounds(a),
            b = this.getZoom(), c = this.map.getMaxExtent(), d = this.lzd / Math.pow(2, this.getZoom()), e = Math.floor((a.left - c.left) / d), a = Math.floor((a.bottom - c.bottom) / d);
        return this.map.getResolution() <= this.lzd / 512 && this.getZoom() <= this.zoomLevels ? this.getFullRequestString({
            L: b,
            X: e,
            Y: a
        }) : OpenLayers.Util.getImageLocation("blank.gif")
    }, CLASS_NAME: "OpenLayers.Layer.WorldWind"
});
OpenLayers.Layer.ArcGIS93Rest = OpenLayers.Class(OpenLayers.Layer.Grid, {
    DEFAULT_PARAMS: {format: "png"}, isBaseLayer: !0, initialize: function (a, b, c, d) {
        var e = [], c = OpenLayers.Util.upperCaseObject(c);
        e.push(a, b, c, d);
        OpenLayers.Layer.Grid.prototype.initialize.apply(this, e);
        OpenLayers.Util.applyDefaults(this.params, OpenLayers.Util.upperCaseObject(this.DEFAULT_PARAMS));
        if (this.params.TRANSPARENT && "true" == this.params.TRANSPARENT.toString().toLowerCase()) {
            if (null == d || !d.isBaseLayer)this.isBaseLayer = !1;
            "jpg" == this.params.FORMAT &&
            (this.params.FORMAT = OpenLayers.Util.alphaHack() ? "gif" : "png")
        }
    }, clone: function (a) {
        null == a && (a = new OpenLayers.Layer.ArcGIS93Rest(this.name, this.url, this.params, this.getOptions()));
        return OpenLayers.Layer.Grid.prototype.clone.apply(this, [a])
    }, getURL: function (a) {
        var a = this.adjustBounds(a), b = this.projection.getCode().split(":"), b = b[b.length - 1], c = this.getImageSize(), a = {
            BBOX: a.toBBOX(),
            SIZE: c.w + "," + c.h,
            F: "image",
            BBOXSR: b,
            IMAGESR: b
        };
        if (this.layerDefs) {
            var b = [], d;
            for (d in this.layerDefs)this.layerDefs.hasOwnProperty(d) &&
            this.layerDefs[d] && (b.push(d), b.push(":"), b.push(this.layerDefs[d]), b.push(";"));
            0 < b.length && (a.LAYERDEFS = b.join(""))
        }
        return this.getFullRequestString(a)
    }, setLayerFilter: function (a, b) {
        this.layerDefs || (this.layerDefs = {});
        b ? this.layerDefs[a] = b : delete this.layerDefs[a]
    }, clearLayerFilter: function (a) {
        a ? delete this.layerDefs[a] : delete this.layerDefs
    }, mergeNewParams: function (a) {
        a = [OpenLayers.Util.upperCaseObject(a)];
        return OpenLayers.Layer.Grid.prototype.mergeNewParams.apply(this, a)
    }, CLASS_NAME: "OpenLayers.Layer.ArcGIS93Rest"
});
OpenLayers.Layer.WMS = OpenLayers.Class(OpenLayers.Layer.Grid, {
    DEFAULT_PARAMS: {service: "WMS", version: "1.1.1", request: "GetMap", styles: "", format: "image/jpeg"},
    isBaseLayer: !0,
    encodeBBOX: !1,
    noMagic: !1,
    yx: {},
    initialize: function (a, b, c, d) {
        var e = [], c = OpenLayers.Util.upperCaseObject(c);
        1.3 <= parseFloat(c.VERSION) && !c.EXCEPTIONS && (c.EXCEPTIONS = "INIMAGE");
        e.push(a, b, c, d);
        OpenLayers.Layer.Grid.prototype.initialize.apply(this, e);
        OpenLayers.Util.applyDefaults(this.params, OpenLayers.Util.upperCaseObject(this.DEFAULT_PARAMS));
        if (!this.noMagic && this.params.TRANSPARENT && "true" == this.params.TRANSPARENT.toString().toLowerCase()) {
            if (null == d || !d.isBaseLayer)this.isBaseLayer = !1;
            "image/jpeg" == this.params.FORMAT && (this.params.FORMAT = OpenLayers.Util.alphaHack() ? "image/gif" : "image/png")
        }
    },
    clone: function (a) {
        null == a && (a = new OpenLayers.Layer.WMS(this.name, this.url, this.params, this.getOptions()));
        return OpenLayers.Layer.Grid.prototype.clone.apply(this, [a])
    },
    reverseAxisOrder: function () {
        var a = this.projection.getCode();
        return 1.3 <= parseFloat(this.params.VERSION) && !(!this.yx[a] && !OpenLayers.Projection.defaults[a].yx)
    },
    getURL: function (a) {
        var a = this.adjustBounds(a), b = this.getImageSize(), c = {}, d = this.reverseAxisOrder();
        c.BBOX = this.encodeBBOX ? a.toBBOX(null, d) : a.toArray(d);
        c.WIDTH = b.w;
        c.HEIGHT = b.h;
        return this.getFullRequestString(c)
    },
    mergeNewParams: function (a) {
        a = [OpenLayers.Util.upperCaseObject(a)];
        return OpenLayers.Layer.Grid.prototype.mergeNewParams.apply(this, a)
    },
    getFullRequestString: function (a, b) {
        var c = this.map.getProjectionObject(), c = this.projection && this.projection.equals(c) ?
            this.projection.getCode() : c.getCode(), c = "none" == c ? null : c;
        1.3 <= parseFloat(this.params.VERSION) ? this.params.CRS = c : this.params.SRS = c;
        "boolean" == typeof this.params.TRANSPARENT && (a.TRANSPARENT = this.params.TRANSPARENT ? "TRUE" : "FALSE");
        return OpenLayers.Layer.Grid.prototype.getFullRequestString.apply(this, arguments)
    },
    CLASS_NAME: "OpenLayers.Layer.WMS"
});
OpenLayers.Layer.WMTS = OpenLayers.Class(OpenLayers.Layer.Grid, {
    isBaseLayer: !0,
    version: "1.0.0",
    requestEncoding: "KVP",
    url: null,
    layer: null,
    matrixSet: null,
    style: null,
    format: "image/jpeg",
    tileOrigin: null,
    tileFullExtent: null,
    formatSuffix: null,
    matrixIds: null,
    dimensions: null,
    params: null,
    zoomOffset: 0,
    serverResolutions: null,
    formatSuffixMap: {
        "image/png": "png",
        "image/png8": "png",
        "image/png24": "png",
        "image/png32": "png",
        png: "png",
        "image/jpeg": "jpg",
        "image/jpg": "jpg",
        jpeg: "jpg",
        jpg: "jpg"
    },
    matrix: null,
    initialize: function (a) {
        var b =
        {url: !0, layer: !0, style: !0, matrixSet: !0}, c;
        for (c in b)if (!(c in a))throw Error("Missing property '" + c + "' in layer configuration.");
        a.params = OpenLayers.Util.upperCaseObject(a.params);
        OpenLayers.Layer.Grid.prototype.initialize.apply(this, [a.name, a.url, a.params, a]);
        this.formatSuffix || (this.formatSuffix = this.formatSuffixMap[this.format] || this.format.split("/").pop());
        if (this.matrixIds && (a = this.matrixIds.length) && "string" === typeof this.matrixIds[0]) {
            b = this.matrixIds;
            this.matrixIds = Array(a);
            for (c = 0; c < a; ++c)this.matrixIds[c] =
            {identifier: b[c]}
        }
    },
    setMap: function () {
        OpenLayers.Layer.Grid.prototype.setMap.apply(this, arguments);
        this.updateMatrixProperties()
    },
    updateMatrixProperties: function () {
        if (this.matrix = this.getMatrix())this.matrix.topLeftCorner && (this.tileOrigin = this.matrix.topLeftCorner), this.matrix.tileWidth && this.matrix.tileHeight && (this.tileSize = new OpenLayers.Size(this.matrix.tileWidth, this.matrix.tileHeight)), this.tileOrigin || (this.tileOrigin = new OpenLayers.LonLat(this.maxExtent.left, this.maxExtent.top)), this.tileFullExtent ||
        (this.tileFullExtent = this.maxExtent)
    },
    moveTo: function (a, b, c) {
        (b || !this.matrix) && this.updateMatrixProperties();
        return OpenLayers.Layer.Grid.prototype.moveTo.apply(this, arguments)
    },
    clone: function (a) {
        null == a && (a = new OpenLayers.Layer.WMTS(this.options));
        return OpenLayers.Layer.Grid.prototype.clone.apply(this, [a])
    },
    getIdentifier: function () {
        return this.getServerZoom()
    },
    getMatrix: function () {
        var a;
        if (!this.matrixIds || 0 === this.matrixIds.length)a = {identifier: this.getIdentifier()}; else if ("scaleDenominator"in
            this.matrixIds[0])for (var b = OpenLayers.METERS_PER_INCH * OpenLayers.INCHES_PER_UNIT[this.units] * this.getServerResolution() / 2.8E-4, c = Number.POSITIVE_INFINITY, d, e = 0, f = this.matrixIds.length; e < f; ++e)d = Math.abs(1 - this.matrixIds[e].scaleDenominator / b), d < c && (c = d, a = this.matrixIds[e]); else a = this.matrixIds[this.getIdentifier()];
        return a
    },
    getTileInfo: function (a) {
        var b = this.getServerResolution(), c = (a.lon - this.tileOrigin.lon) / (b * this.tileSize.w), a = (this.tileOrigin.lat - a.lat) / (b * this.tileSize.h), b = Math.floor(c),
            d = Math.floor(a);
        return {col: b, row: d, i: Math.floor((c - b) * this.tileSize.w), j: Math.floor((a - d) * this.tileSize.h)}
    },
    getURL: function (a) {
        var a = this.adjustBounds(a), b = "";
        if (!this.tileFullExtent || this.tileFullExtent.intersectsBounds(a)) {
            var c = this.getTileInfo(a.getCenterLonLat()), a = this.dimensions;
            if ("REST" === this.requestEncoding.toUpperCase())if (b = this.params, "string" === typeof this.url && -1 !== this.url.indexOf("{")) {
                var d = this.url.replace(/\{/g, "${"), c = {
                    style: this.style, Style: this.style, TileMatrixSet: this.matrixSet,
                    TileMatrix: this.matrix.identifier, TileRow: c.row, TileCol: c.col
                };
                if (a) {
                    var e, f;
                    for (f = a.length - 1; 0 <= f; --f)e = a[f], c[e] = b[e.toUpperCase()]
                }
                b = OpenLayers.String.format(d, c)
            } else {
                d = this.version + "/" + this.layer + "/" + this.style + "/";
                if (a)for (f = 0; f < a.length; f++)b[a[f]] && (d = d + b[a[f]] + "/");
                d = d + this.matrixSet + "/" + this.matrix.identifier + "/" + c.row + "/" + c.col + "." + this.formatSuffix;
                b = OpenLayers.Util.isArray(this.url) ? this.selectUrl(d, this.url) : this.url;
                b.match(/\/$/) || (b += "/");
                b += d
            } else"KVP" === this.requestEncoding.toUpperCase() &&
            (b = {
                SERVICE: "WMTS",
                REQUEST: "GetTile",
                VERSION: this.version,
                LAYER: this.layer,
                STYLE: this.style,
                TILEMATRIXSET: this.matrixSet,
                TILEMATRIX: this.matrix.identifier,
                TILEROW: c.row,
                TILECOL: c.col,
                FORMAT: this.format
            }, b = OpenLayers.Layer.Grid.prototype.getFullRequestString.apply(this, [b]))
        }
        return b
    },
    mergeNewParams: function (a) {
        if ("KVP" === this.requestEncoding.toUpperCase())return OpenLayers.Layer.Grid.prototype.mergeNewParams.apply(this, [OpenLayers.Util.upperCaseObject(a)])
    },
    CLASS_NAME: "OpenLayers.Layer.WMTS"
});
OpenLayers.Layer.ArcIMS = OpenLayers.Class(OpenLayers.Layer.Grid, {
    DEFAULT_PARAMS: {ClientVersion: "9.2", ServiceName: ""},
    featureCoordSys: "4326",
    filterCoordSys: "4326",
    layers: null,
    async: !0,
    name: "ArcIMS",
    isBaseLayer: !0,
    DEFAULT_OPTIONS: {
        tileSize: new OpenLayers.Size(512, 512),
        featureCoordSys: "4326",
        filterCoordSys: "4326",
        layers: null,
        isBaseLayer: !0,
        async: !0,
        name: "ArcIMS"
    },
    initialize: function (a, b, c) {
        this.tileSize = new OpenLayers.Size(512, 512);
        this.params = OpenLayers.Util.applyDefaults({ServiceName: c.serviceName},
            this.DEFAULT_PARAMS);
        this.options = OpenLayers.Util.applyDefaults(c, this.DEFAULT_OPTIONS);
        OpenLayers.Layer.Grid.prototype.initialize.apply(this, [a, b, this.params, c]);
        this.transparent && (this.isBaseLayer || (this.isBaseLayer = !1), "image/jpeg" == this.format && (this.format = OpenLayers.Util.alphaHack() ? "image/gif" : "image/png"));
        null === this.options.layers && (this.options.layers = [])
    },
    getURL: function (a) {
        var b = "", a = this.adjustBounds(a), a = new OpenLayers.Format.ArcXML(OpenLayers.Util.extend(this.options, {
            requesttype: "image",
            envelope: a.toArray(), tileSize: this.tileSize
        })), a = new OpenLayers.Request.POST({url: this.getFullRequestString(), data: a.write(), async: !1});
        if (null != a) {
            b = a.responseXML;
            if (!b || !b.documentElement)b = a.responseText;
            b = this.getUrlOrImage((new OpenLayers.Format.ArcXML).read(b).image.output)
        }
        return b
    },
    getURLasync: function (a, b, c) {
        a = this.adjustBounds(a);
        a = new OpenLayers.Format.ArcXML(OpenLayers.Util.extend(this.options, {
            requesttype: "image",
            envelope: a.toArray(),
            tileSize: this.tileSize
        }));
        OpenLayers.Request.POST({
            url: this.getFullRequestString(),
            async: !0, data: a.write(), callback: function (a) {
                var e = a.responseXML;
                if (!e || !e.documentElement)e = a.responseText;
                a = (new OpenLayers.Format.ArcXML).read(e);
                b.call(c, this.getUrlOrImage(a.image.output))
            }, scope: this
        })
    },
    getUrlOrImage: function (a) {
        var b = "";
        a.url ? b = a.url : a.data && (b = "data:image/" + a.type + ";base64," + a.data);
        return b
    },
    setLayerQuery: function (a, b) {
        for (var c = 0; c < this.options.layers.length; c++)if (a == this.options.layers[c].id) {
            this.options.layers[c].query = b;
            return
        }
        this.options.layers.push({
            id: a, visible: !0,
            query: b
        })
    },
    getFeatureInfo: function (a, b, c) {
        var d = c.buffer || 1, e = c.callback || function () {
            }, f = c.scope || window, g = {};
        OpenLayers.Util.extend(g, this.options);
        g.requesttype = "feature";
        a instanceof OpenLayers.LonLat ? (g.polygon = null, g.envelope = [a.lon - d, a.lat - d, a.lon + d, a.lat + d]) : a instanceof OpenLayers.Geometry.Polygon && (g.envelope = null, g.polygon = a);
        var h = new OpenLayers.Format.ArcXML(g);
        OpenLayers.Util.extend(h.request.get_feature, c);
        h.request.get_feature.layer = b.id;
        "number" == typeof b.query.accuracy ? h.request.get_feature.query.accuracy =
            b.query.accuracy : (a = this.map.getCenter(), c = this.map.getViewPortPxFromLonLat(a), c.x++, c = this.map.getLonLatFromPixel(c), h.request.get_feature.query.accuracy = c.lon - a.lon);
        h.request.get_feature.query.where = b.query.where;
        h.request.get_feature.query.spatialfilter.relation = "area_intersection";
        OpenLayers.Request.POST({
            url: this.getFullRequestString({CustomService: "Query"}),
            data: h.write(),
            callback: function (a) {
                a = h.parseResponse(a.responseText);
                h.iserror() ? e.call(f, null) : e.call(f, a.features)
            }
        })
    },
    clone: function (a) {
        null ==
        a && (a = new OpenLayers.Layer.ArcIMS(this.name, this.url, this.getOptions()));
        return OpenLayers.Layer.Grid.prototype.clone.apply(this, [a])
    },
    CLASS_NAME: "OpenLayers.Layer.ArcIMS"
});
OpenLayers.Layer.GeoRSS = OpenLayers.Class(OpenLayers.Layer.Markers, {
    location: null,
    features: null,
    formatOptions: null,
    selectedFeature: null,
    icon: null,
    popupSize: null,
    useFeedTitle: !0,
    initialize: function (a, b, c) {
        OpenLayers.Layer.Markers.prototype.initialize.apply(this, [a, c]);
        this.location = b;
        this.features = []
    },
    destroy: function () {
        OpenLayers.Layer.Markers.prototype.destroy.apply(this, arguments);
        this.clearFeatures();
        this.features = null
    },
    loadRSS: function () {
        this.loaded || (this.events.triggerEvent("loadstart"), OpenLayers.Request.GET({
            url: this.location,
            success: this.parseData, scope: this
        }), this.loaded = !0)
    },
    moveTo: function (a, b, c) {
        OpenLayers.Layer.Markers.prototype.moveTo.apply(this, arguments);
        this.visibility && !this.loaded && this.loadRSS()
    },
    parseData: function (a) {
        var b = a.responseXML;
        if (!b || !b.documentElement)b = OpenLayers.Format.XML.prototype.read(a.responseText);
        if (this.useFeedTitle) {
            a = null;
            try {
                a = b.getElementsByTagNameNS("*", "title")[0].firstChild.nodeValue
            } catch (c) {
                a = b.getElementsByTagName("title")[0].firstChild.nodeValue
            }
            a && this.setName(a)
        }
        a = {};
        OpenLayers.Util.extend(a,
            this.formatOptions);
        this.map && !this.projection.equals(this.map.getProjectionObject()) && (a.externalProjection = this.projection, a.internalProjection = this.map.getProjectionObject());
        for (var b = (new OpenLayers.Format.GeoRSS(a)).read(b), a = 0, d = b.length; a < d; a++) {
            var e = {}, f = b[a];
            if (f.geometry) {
                var g = f.attributes.title ? f.attributes.title : "Untitled", h = f.attributes.description ? f.attributes.description : "No description.", k = f.attributes.link ? f.attributes.link : "", f = f.geometry.getBounds().getCenterLonLat();
                e.icon =
                    null == this.icon ? OpenLayers.Marker.defaultIcon() : this.icon.clone();
                e.popupSize = this.popupSize ? this.popupSize.clone() : new OpenLayers.Size(250, 120);
                if (g || h) {
                    e.title = g;
                    e.description = h;
                    var l = '<div class="olLayerGeoRSSClose">[x]</div>', l = l + '<div class="olLayerGeoRSSTitle">';
                    k && (l += '<a class="link" href="' + k + '" target="_blank">');
                    l += g;
                    k && (l += "</a>");
                    l += "</div>";
                    l += '<div style="" class="olLayerGeoRSSDescription">';
                    l += h;
                    l += "</div>";
                    e.popupContentHTML = l
                }
                f = new OpenLayers.Feature(this, f, e);
                this.features.push(f);
                e = f.createMarker();
                e.events.register("click", f, this.markerClick);
                this.addMarker(e)
            }
        }
        this.events.triggerEvent("loadend")
    },
    markerClick: function (a) {
        var b = this == this.layer.selectedFeature;
        this.layer.selectedFeature = !b ? this : null;
        for (var c = 0, d = this.layer.map.popups.length; c < d; c++)this.layer.map.removePopup(this.layer.map.popups[c]);
        b || (b = this.createPopup(), OpenLayers.Event.observe(b.div, "click", OpenLayers.Function.bind(function () {
                for (var a = 0, b = this.layer.map.popups.length; a < b; a++)this.layer.map.removePopup(this.layer.map.popups[a])
            },
            this)), this.layer.map.addPopup(b));
        OpenLayers.Event.stop(a)
    },
    clearFeatures: function () {
        if (null != this.features)for (; 0 < this.features.length;) {
            var a = this.features[0];
            OpenLayers.Util.removeItem(this.features, a);
            a.destroy()
        }
    },
    CLASS_NAME: "OpenLayers.Layer.GeoRSS"
});
OpenLayers.Layer.Boxes = OpenLayers.Class(OpenLayers.Layer.Markers, {
    drawMarker: function (a) {
        var b = this.map.getLayerPxFromLonLat({
            lon: a.bounds.left,
            lat: a.bounds.top
        }), c = this.map.getLayerPxFromLonLat({lon: a.bounds.right, lat: a.bounds.bottom});
        null == c || null == b ? a.display(!1) : (b = a.draw(b, {
            w: Math.max(1, c.x - b.x),
            h: Math.max(1, c.y - b.y)
        }), a.drawn || (this.div.appendChild(b), a.drawn = !0))
    }, removeMarker: function (a) {
        OpenLayers.Util.removeItem(this.markers, a);
        null != a.div && a.div.parentNode == this.div && this.div.removeChild(a.div)
    },
    CLASS_NAME: "OpenLayers.Layer.Boxes"
});
OpenLayers.Layer.XYZ = OpenLayers.Class(OpenLayers.Layer.Grid, {
    isBaseLayer: !0, sphericalMercator: !1, zoomOffset: 0, serverResolutions: null, initialize: function (a, b, c) {
        if (c && c.sphericalMercator || this.sphericalMercator)c = OpenLayers.Util.extend({
            projection: "EPSG:900913",
            numZoomLevels: 19
        }, c);
        OpenLayers.Layer.Grid.prototype.initialize.apply(this, [a || this.name, b || this.url, {}, c])
    }, clone: function (a) {
        null == a && (a = new OpenLayers.Layer.XYZ(this.name, this.url, this.getOptions()));
        return OpenLayers.Layer.Grid.prototype.clone.apply(this,
            [a])
    }, getURL: function (a) {
        var a = this.getXYZ(a), b = this.url;
        OpenLayers.Util.isArray(b) && (b = this.selectUrl("" + a.x + a.y + a.z, b));
        return OpenLayers.String.format(b, a)
    }, getXYZ: function (a) {
        var b = this.getServerResolution(), c = Math.round((a.left - this.maxExtent.left) / (b * this.tileSize.w)), a = Math.round((this.maxExtent.top - a.top) / (b * this.tileSize.h)), b = this.getServerZoom();
        if (this.wrapDateLine)var d = Math.pow(2, b), c = (c % d + d) % d;
        return {x: c, y: a, z: b}
    }, setMap: function (a) {
        OpenLayers.Layer.Grid.prototype.setMap.apply(this,
            arguments);
        this.tileOrigin || (this.tileOrigin = new OpenLayers.LonLat(this.maxExtent.left, this.maxExtent.bottom))
    }, CLASS_NAME: "OpenLayers.Layer.XYZ"
});
OpenLayers.Layer.UTFGrid = OpenLayers.Class(OpenLayers.Layer.XYZ, {
    isBaseLayer: !1,
    projection: new OpenLayers.Projection("EPSG:900913"),
    useJSONP: !1,
    tileClass: OpenLayers.Tile.UTFGrid,
    initialize: function (a) {
        OpenLayers.Layer.Grid.prototype.initialize.apply(this, [a.name, a.url, {}, a]);
        this.tileOptions = OpenLayers.Util.extend({utfgridResolution: this.utfgridResolution}, this.tileOptions)
    },
    clone: function (a) {
        null == a && (a = new OpenLayers.Layer.UTFGrid(this.getOptions()));
        return OpenLayers.Layer.Grid.prototype.clone.apply(this,
            [a])
    },
    getFeatureInfo: function (a) {
        var b = null, a = this.getTileData(a);
        a.tile && (b = a.tile.getFeatureInfo(a.i, a.j));
        return b
    },
    getFeatureId: function (a) {
        var b = null, a = this.getTileData(a);
        a.tile && (b = a.tile.getFeatureId(a.i, a.j));
        return b
    },
    CLASS_NAME: "OpenLayers.Layer.UTFGrid"
});
OpenLayers.Layer.OSM = OpenLayers.Class(OpenLayers.Layer.XYZ, {
    name: "OpenStreetMap",
    url: ["http://a.tile.openstreetmap.org/${z}/${x}/${y}.png", "http://b.tile.openstreetmap.org/${z}/${x}/${y}.png", "http://c.tile.openstreetmap.org/${z}/${x}/${y}.png"],
    attribution: "Data CC-By-SA by <a href='http://openstreetmap.org/'>OpenStreetMap</a>",
    sphericalMercator: !0,
    wrapDateLine: !0,
    tileOptions: null,
    initialize: function (a, b, c) {
        OpenLayers.Layer.XYZ.prototype.initialize.apply(this, arguments);
        this.tileOptions = OpenLayers.Util.extend({crossOriginKeyword: "anonymous"},
            this.options && this.options.tileOptions)
    },
    clone: function (a) {
        null == a && (a = new OpenLayers.Layer.OSM(this.name, this.url, this.getOptions()));
        return OpenLayers.Layer.XYZ.prototype.clone.apply(this, [a])
    },
    CLASS_NAME: "OpenLayers.Layer.OSM"
});
OpenLayers.Layer.Bing = OpenLayers.Class(OpenLayers.Layer.XYZ, {
    key: null,
    serverResolutions: [156543.03390625, 78271.516953125, 39135.7584765625, 19567.87923828125, 9783.939619140625, 4891.9698095703125, 2445.9849047851562, 1222.9924523925781, 611.4962261962891, 305.74811309814453, 152.87405654907226, 76.43702827453613, 38.218514137268066, 19.109257068634033, 9.554628534317017, 4.777314267158508, 2.388657133579254, 1.194328566789627, 0.5971642833948135, 0.29858214169740677, 0.14929107084870338, 0.07464553542435169],
    attributionTemplate: '<span class="olBingAttribution ${type}"><div><a target="_blank" href="http://www.bing.com/maps/"><img src="${logo}" /></a></div>${copyrights}<a style="white-space: nowrap" target="_blank" href="http://www.microsoft.com/maps/product/terms.html">Terms of Use</a></span>',
    metadata: null,
    type: "Road",
    culture: "en-US",
    metadataParams: null,
    tileOptions: null,
    initialize: function (a) {
        a = OpenLayers.Util.applyDefaults({sphericalMercator: !0}, a);
        OpenLayers.Layer.XYZ.prototype.initialize.apply(this, [a.name || "Bing " + (a.type || this.type), null, a]);
        this.tileOptions = OpenLayers.Util.extend({crossOriginKeyword: "anonymous"}, this.options.tileOptions);
        this.loadMetadata()
    },
    loadMetadata: function () {
        this._callbackId = "_callback_" + this.id.replace(/\./g, "_");
        window[this._callbackId] = OpenLayers.Function.bind(OpenLayers.Layer.Bing.processMetadata,
            this);
        var a = OpenLayers.Util.applyDefaults({
            key: this.key,
            jsonp: this._callbackId,
            include: "ImageryProviders"
        }, this.metadataParams), a = "http://dev.virtualearth.net/REST/v1/Imagery/Metadata/" + this.type + "?" + OpenLayers.Util.getParameterString(a), b = document.createElement("script");
        b.type = "text/javascript";
        b.src = a;
        b.id = this._callbackId;
        document.getElementsByTagName("head")[0].appendChild(b)
    },
    initLayer: function () {
        var a = this.metadata.resourceSets[0].resources[0], b = a.imageUrl.replace("{quadkey}", "${quadkey}"),
            b = b.replace("{culture}", this.culture);
        this.url = [];
        for (var c = 0; c < a.imageUrlSubdomains.length; ++c)this.url.push(b.replace("{subdomain}", a.imageUrlSubdomains[c]));
        this.addOptions({
            maxResolution: Math.min(this.serverResolutions[a.zoomMin], this.maxResolution || Number.POSITIVE_INFINITY),
            numZoomLevels: Math.min(a.zoomMax + 1 - a.zoomMin, this.numZoomLevels)
        }, !0)
    },
    getURL: function (a) {
        if (this.url) {
            for (var b = this.getXYZ(a), a = b.x, c = b.y, b = b.z, d = [], e = b; 0 < e; --e) {
                var f = "0", g = 1 << e - 1;
                0 != (a & g) && f++;
                0 != (c & g) && (f++, f++);
                d.push(f)
            }
            d =
                d.join("");
            a = this.selectUrl("" + a + c + b, this.url);
            return OpenLayers.String.format(a, {quadkey: d})
        }
    },
    updateAttribution: function () {
        var a = this.metadata;
        if (a.resourceSets && this.map && this.map.center) {
            var b = a.resourceSets[0].resources[0], c = this.map.getExtent().transform(this.map.getProjectionObject(), new OpenLayers.Projection("EPSG:4326")), b = b.imageryProviders, d = OpenLayers.Util.indexOf(this.serverResolutions, this.getServerResolution()), e = "", f, g, h, k, l, m, n;
            for (g = 0, h = b.length; g < h; ++g) {
                f = b[g];
                for (k = 0, l = f.coverageAreas.length; k <
                l; ++k)n = f.coverageAreas[k], m = OpenLayers.Bounds.fromArray(n.bbox, !0), c.intersectsBounds(m) && d <= n.zoomMax && d >= n.zoomMin && (e += f.attribution + " ")
            }
            this.attribution = OpenLayers.String.format(this.attributionTemplate, {
                type: this.type.toLowerCase(),
                logo: a.brandLogoUri,
                copyrights: e
            });
            this.map && this.map.events.triggerEvent("changelayer", {layer: this, property: "attribution"})
        }
    },
    setMap: function () {
        OpenLayers.Layer.XYZ.prototype.setMap.apply(this, arguments);
        this.updateAttribution();
        this.map.events.register("moveend",
            this, this.updateAttribution)
    },
    clone: function (a) {
        null == a && (a = new OpenLayers.Layer.Bing(this.options));
        return OpenLayers.Layer.XYZ.prototype.clone.apply(this, [a])
    },
    destroy: function () {
        this.map && this.map.events.unregister("moveend", this, this.updateAttribution);
        OpenLayers.Layer.XYZ.prototype.destroy.apply(this, arguments)
    },
    CLASS_NAME: "OpenLayers.Layer.Bing"
});
OpenLayers.Layer.Bing.processMetadata = function (a) {
    this.metadata = a;
    this.initLayer();
    a = document.getElementById(this._callbackId);
    a.parentNode.removeChild(a);
    window[this._callbackId] = void 0;
    delete this._callbackId
};
OpenLayers.Layer.TMS = OpenLayers.Class(OpenLayers.Layer.Grid, {
    serviceVersion: "1.0.0",
    layername: null,
    type: null,
    isBaseLayer: !0,
    tileOrigin: null,
    serverResolutions: null,
    zoomOffset: 0,
    initialize: function (a, b, c) {
        var d = [];
        d.push(a, b, {}, c);
        OpenLayers.Layer.Grid.prototype.initialize.apply(this, d)
    },
    clone: function (a) {
        null == a && (a = new OpenLayers.Layer.TMS(this.name, this.url, this.getOptions()));
        return OpenLayers.Layer.Grid.prototype.clone.apply(this, [a])
    },
    getURL: function (a) {
        var a = this.adjustBounds(a), b = this.getServerResolution(),
            c = Math.round((a.left - this.tileOrigin.lon) / (b * this.tileSize.w)), a = Math.round((a.bottom - this.tileOrigin.lat) / (b * this.tileSize.h)), c = this.serviceVersion + "/" + this.layername + "/" + this.getServerZoom() + "/" + c + "/" + a + "." + this.type, a = this.url;
        OpenLayers.Util.isArray(a) && (a = this.selectUrl(c, a));
        return a + c
    },
    setMap: function (a) {
        OpenLayers.Layer.Grid.prototype.setMap.apply(this, arguments);
        this.tileOrigin || (this.tileOrigin = new OpenLayers.LonLat(this.map.maxExtent.left, this.map.maxExtent.bottom))
    },
    CLASS_NAME: "OpenLayers.Layer.TMS"
});
OpenLayers.Layer.TileCache = OpenLayers.Class(OpenLayers.Layer.Grid, {
    isBaseLayer: !0, format: "image/png", serverResolutions: null, initialize: function (a, b, c, d) {
        this.layername = c;
        OpenLayers.Layer.Grid.prototype.initialize.apply(this, [a, b, {}, d]);
        this.extension = this.format.split("/")[1].toLowerCase();
        this.extension = "jpg" == this.extension ? "jpeg" : this.extension
    }, clone: function (a) {
        null == a && (a = new OpenLayers.Layer.TileCache(this.name, this.url, this.layername, this.getOptions()));
        return OpenLayers.Layer.Grid.prototype.clone.apply(this,
            [a])
    }, getURL: function (a) {
        function b(a, b) {
            for (var a = "" + a, c = [], d = 0; d < b; ++d)c.push("0");
            return c.join("").substring(0, b - a.length) + a
        }

        var c = this.getServerResolution(), d = this.maxExtent, e = this.tileSize, f = Math.round((a.left - d.left) / (c * e.w)), a = Math.round((a.bottom - d.bottom) / (c * e.h)), c = null != this.serverResolutions ? OpenLayers.Util.indexOf(this.serverResolutions, c) : this.map.getZoom(), f = [this.layername, b(c, 2), b(parseInt(f / 1E6), 3), b(parseInt(f / 1E3) % 1E3, 3), b(parseInt(f) % 1E3, 3), b(parseInt(a / 1E6), 3), b(parseInt(a /
        1E3) % 1E3, 3), b(parseInt(a) % 1E3, 3) + "." + this.extension].join("/"), c = this.url;
        OpenLayers.Util.isArray(c) && (c = this.selectUrl(f, c));
        c = "/" == c.charAt(c.length - 1) ? c : c + "/";
        return c + f
    }, CLASS_NAME: "OpenLayers.Layer.TileCache"
});
OpenLayers.Layer.Zoomify = OpenLayers.Class(OpenLayers.Layer.Grid, {
    size: null,
    isBaseLayer: !0,
    standardTileSize: 256,
    tileOriginCorner: "tl",
    numberOfTiers: 0,
    tileCountUpToTier: null,
    tierSizeInTiles: null,
    tierImageSize: null,
    initialize: function (a, b, c, d) {
        this.initializeZoomify(c);
        OpenLayers.Layer.Grid.prototype.initialize.apply(this, [a, b, c, {}, d])
    },
    initializeZoomify: function (a) {
        var a = a.clone(), b = new OpenLayers.Size(Math.ceil(a.w / this.standardTileSize), Math.ceil(a.h / this.standardTileSize));
        this.tierSizeInTiles = [b];
        for (this.tierImageSize = [a]; a.w > this.standardTileSize || a.h > this.standardTileSize;)a = new OpenLayers.Size(Math.floor(a.w / 2), Math.floor(a.h / 2)), b = new OpenLayers.Size(Math.ceil(a.w / this.standardTileSize), Math.ceil(a.h / this.standardTileSize)), this.tierSizeInTiles.push(b), this.tierImageSize.push(a);
        this.tierSizeInTiles.reverse();
        this.tierImageSize.reverse();
        this.numberOfTiers = this.tierSizeInTiles.length;
        this.tileCountUpToTier = [0];
        for (a = 1; a < this.numberOfTiers; a++)this.tileCountUpToTier.push(this.tierSizeInTiles[a -
        1].w * this.tierSizeInTiles[a - 1].h + this.tileCountUpToTier[a - 1])
    },
    destroy: function () {
        OpenLayers.Layer.Grid.prototype.destroy.apply(this, arguments);
        this.tileCountUpToTier.length = 0;
        this.tierSizeInTiles.length = 0;
        this.tierImageSize.length = 0
    },
    clone: function (a) {
        null == a && (a = new OpenLayers.Layer.Zoomify(this.name, this.url, this.size, this.options));
        return OpenLayers.Layer.Grid.prototype.clone.apply(this, [a])
    },
    getURL: function (a) {
        var a = this.adjustBounds(a), b = this.map.getResolution(), c = Math.round((a.left - this.tileOrigin.lon) /
        (b * this.tileSize.w)), a = Math.round((this.tileOrigin.lat - a.top) / (b * this.tileSize.h)), b = this.map.getZoom(), c = "TileGroup" + Math.floor((c + a * this.tierSizeInTiles[b].w + this.tileCountUpToTier[b]) / 256) + "/" + b + "-" + c + "-" + a + ".jpg", a = this.url;
        OpenLayers.Util.isArray(a) && (a = this.selectUrl(c, a));
        return a + c
    },
    getImageSize: function () {
        if (0 < arguments.length) {
            var a = this.adjustBounds(arguments[0]), b = this.map.getResolution(), c = Math.round((a.left - this.tileOrigin.lon) / (b * this.tileSize.w)), a = Math.round((this.tileOrigin.lat -
            a.top) / (b * this.tileSize.h)), b = this.map.getZoom(), d = this.standardTileSize, e = this.standardTileSize;
            c == this.tierSizeInTiles[b].w - 1 && (d = this.tierImageSize[b].w % this.standardTileSize);
            a == this.tierSizeInTiles[b].h - 1 && (e = this.tierImageSize[b].h % this.standardTileSize);
            return new OpenLayers.Size(d, e)
        }
        return this.tileSize
    },
    setMap: function (a) {
        OpenLayers.Layer.Grid.prototype.setMap.apply(this, arguments);
        this.tileOrigin = new OpenLayers.LonLat(this.map.maxExtent.left, this.map.maxExtent.top)
    },
    calculateGridLayout: function (a,
                                   b, c) {
        var d = c * this.tileSize.w, c = c * this.tileSize.h, e = a.left - b.lon, f = Math.floor(e / d) - this.buffer, a = b.lat - a.top + c, g = Math.floor(a / c) - this.buffer;
        return {
            tilelon: d,
            tilelat: c,
            tileoffsetlon: b.lon + f * d,
            tileoffsetlat: b.lat - c * g,
            tileoffsetx: -(e / d - f) * this.tileSize.w,
            tileoffsety: (g - a / c) * this.tileSize.h
        }
    },
    CLASS_NAME: "OpenLayers.Layer.Zoomify"
});
OpenLayers.Layer.ArcGISCache = OpenLayers.Class(OpenLayers.Layer.XYZ, {
    url: null,
    tileOrigin: null,
    tileSize: new OpenLayers.Size(256, 256),
    useArcGISServer: !0,
    type: "png",
    useScales: !1,
    overrideDPI: !1,
    initialize: function (a, b, c) {
        OpenLayers.Layer.XYZ.prototype.initialize.apply(this, arguments);
        this.resolutions && (this.serverResolutions = this.resolutions, this.maxExtent = this.getMaxExtentForResolution(this.resolutions[0]));
        if (this.layerInfo) {
            var d = this.layerInfo, e = new OpenLayers.Bounds(d.fullExtent.xmin, d.fullExtent.ymin,
                d.fullExtent.xmax, d.fullExtent.ymax);
            this.projection = "EPSG:" + d.spatialReference.wkid;
            this.sphericalMercator = 102100 == d.spatialReference.wkid;
            this.units = "esriFeet" == d.units ? "ft" : "m";
            if (d.tileInfo) {
                this.tileSize = new OpenLayers.Size(d.tileInfo.width || d.tileInfo.cols, d.tileInfo.height || d.tileInfo.rows);
                this.tileOrigin = new OpenLayers.LonLat(d.tileInfo.origin.x, d.tileInfo.origin.y);
                var f = new OpenLayers.Geometry.Point(e.left, e.top), e = new OpenLayers.Geometry.Point(e.right, e.bottom);
                this.useScales ? this.scales =
                    [] : this.resolutions = [];
                this.lods = [];
                for (var g in d.tileInfo.lods)if (d.tileInfo.lods.hasOwnProperty(g)) {
                    var h = d.tileInfo.lods[g];
                    this.useScales ? this.scales.push(h.scale) : this.resolutions.push(h.resolution);
                    var k = this.getContainingTileCoords(f, h.resolution);
                    h.startTileCol = k.x;
                    h.startTileRow = k.y;
                    k = this.getContainingTileCoords(e, h.resolution);
                    h.endTileCol = k.x;
                    h.endTileRow = k.y;
                    this.lods.push(h)
                }
                this.maxExtent = this.calculateMaxExtentWithLOD(this.lods[0]);
                this.serverResolutions = this.resolutions;
                this.overrideDPI &&
                d.tileInfo.dpi && (OpenLayers.DOTS_PER_INCH = d.tileInfo.dpi)
            }
        }
    },
    getContainingTileCoords: function (a, b) {
        return new OpenLayers.Pixel(Math.max(Math.floor((a.x - this.tileOrigin.lon) / (this.tileSize.w * b)), 0), Math.max(Math.floor((this.tileOrigin.lat - a.y) / (this.tileSize.h * b)), 0))
    },
    calculateMaxExtentWithLOD: function (a) {
        var b = this.tileOrigin.lon + a.startTileCol * this.tileSize.w * a.resolution, c = this.tileOrigin.lat - a.startTileRow * this.tileSize.h * a.resolution;
        return new OpenLayers.Bounds(b, c - (a.endTileRow - a.startTileRow +
        1) * this.tileSize.h * a.resolution, b + (a.endTileCol - a.startTileCol + 1) * this.tileSize.w * a.resolution, c)
    },
    calculateMaxExtentWithExtent: function (a, b) {
        var c = new OpenLayers.Geometry.Point(a.left, a.top), d = new OpenLayers.Geometry.Point(a.right, a.bottom), c = this.getContainingTileCoords(c, b), d = this.getContainingTileCoords(d, b);
        return this.calculateMaxExtentWithLOD({
            resolution: b,
            startTileCol: c.x,
            startTileRow: c.y,
            endTileCol: d.x,
            endTileRow: d.y
        })
    },
    getUpperLeftTileCoord: function (a) {
        return this.getContainingTileCoords(new OpenLayers.Geometry.Point(this.maxExtent.left,
            this.maxExtent.top), a)
    },
    getLowerRightTileCoord: function (a) {
        return this.getContainingTileCoords(new OpenLayers.Geometry.Point(this.maxExtent.right, this.maxExtent.bottom), a)
    },
    getMaxExtentForResolution: function (a) {
        var b = this.getUpperLeftTileCoord(a), c = this.getLowerRightTileCoord(a), d = this.tileOrigin.lon + b.x * this.tileSize.w * a, e = this.tileOrigin.lat - b.y * this.tileSize.h * a;
        return new OpenLayers.Bounds(d, e - (c.y - b.y + 1) * this.tileSize.h * a, d + (c.x - b.x + 1) * this.tileSize.w * a, e)
    },
    clone: function (a) {
        null == a && (a = new OpenLayers.Layer.ArcGISCache(this.name,
            this.url, this.options));
        return OpenLayers.Layer.XYZ.prototype.clone.apply(this, [a])
    },
    getMaxExtent: function () {
        return this.maxExtent = this.getMaxExtentForResolution(this.map.getResolution())
    },
    getTileOrigin: function () {
        var a = this.getMaxExtent();
        return new OpenLayers.LonLat(a.left, a.bottom)
    },
    getURL: function (a) {
        var b = this.getResolution(), c = this.tileOrigin.lon + b * this.tileSize.w / 2, d = this.tileOrigin.lat - b * this.tileSize.h / 2, a = a.getCenterLonLat(), c = Math.round(Math.abs((a.lon - c) / (b * this.tileSize.w))), d = Math.round(Math.abs((d -
        a.lat) / (b * this.tileSize.h))), a = this.map.getZoom();
        if (this.lods) {
            if (b = this.lods[this.map.getZoom()], c < b.startTileCol || c > b.endTileCol || d < b.startTileRow || d > b.endTileRow)return null
        } else {
            var e = this.getUpperLeftTileCoord(b), b = this.getLowerRightTileCoord(b);
            if (c < e.x || c >= b.x || d < e.y || d >= b.y)return null
        }
        b = this.url;
        e = "" + c + d + a;
        OpenLayers.Util.isArray(b) && (b = this.selectUrl(e, b));
        this.useArcGISServer ? b += "/tile/${z}/${y}/${x}" : (c = "C" + this.zeroPad(c, 8, 16), d = "R" + this.zeroPad(d, 8, 16), a = "L" + this.zeroPad(a, 2, 16), b =
            b + "/${z}/${y}/${x}." + this.type);
        b = OpenLayers.String.format(b, {x: c, y: d, z: a});
        return OpenLayers.Util.urlAppend(b, OpenLayers.Util.getParameterString(this.params))
    },
    zeroPad: function (a, b, c) {
        for (a = a.toString(c || 10); a.length < b;)a = "0" + a;
        return a
    },
    CLASS_NAME: "OpenLayers.Layer.ArcGISCache"
});
OpenLayers.Popup = OpenLayers.Class(CORNERS = {
    TL: {src: "corners/topl.png", sizing: "scale"},
    TM: {src: "corners/topm.png", sizing: "crop"},
    TR: {src: "corners/topr.png", sizing: "scale"},
    ML: {src: "corners/midl.png", sizing: "crop"},
    MR: {src: "corners/midr.png", sizing: "crop"},
    BL: {src: "corners/botl.png", sizing: "scale"},
    BM: {src: "corners/botm.png", sizing: "crop"},
    BR: {src: "corners/botr.png", sizing: "scale"}
}, OpenLayers.Popup.SlideTimerInterval = 20, OpenLayers.Popup.SlideAnimationTime = 2E3, OpenLayers.Popup.prototype = {
    events: null,
    id: "",
    lonlat: null,
    div: null,
    size: null,
    contentHTML: "",
    opacity: "",
    contentDiv: null,
    padding: 0,
    map: null,
    minHeight: 20,
    initialize: function (a, b, c, d, e) {
        null == a && (a = OpenLayers.Util.createUniqueID(this.CLASS_NAME + "_"));
        this.size = null != d ? d : new OpenLayers.Size(200, 200);
        this.id = a;
        this.map = b;
        this.lonlat = c;
        null != e && (this.contentHTML = e);
        this.div = OpenLayers.Util.createDiv(this.id, null, null, null, null, null);
        this.div.className = "olPopup";
        a = this.div.id + "_contentDiv";
        this.contentDiv = OpenLayers.Util.createDiv(a, null, this.size.clone(),
            null, "static", null);
        this.contentDiv.className = "olPopupContent";
        this.getRenderedDimensions();
        this.insertCorners();
        a = document.createElement("A");
        a.className = "close";
        a.style.position = "absolute";
        a.style.height = "14px";
        a.style.width = "14px";
        a.title = "close popup";
        a.href = "#";
        this.div.appendChild(a);
        (new OpenLayers.Events(this, a)).register("mousedown", this, this.hide);
        this.registerEvents();
        this.updatePosition()
    },
    insertCorners: function () {
        var a = navigator.appVersion.split("MSIE"), a = parseFloat(a[1]), b = OpenLayersEX_ImgLoc;
        this.div.appendChild(OpenLayers.Util.createAlphaImageDiv("", new OpenLayers.Pixel(0, 0), new OpenLayers.Size(38, 28), b + CORNERS.TL.src, "absolute", 0, CORNERS.TL.sizing));
        this.div.appendChild(OpenLayers.Util.createAlphaImageDiv("", new OpenLayers.Pixel(38, 0), new OpenLayers.Size(parseInt(this.size.w - 22), 28), b + CORNERS.TM.src, "absolute", 0, CORNERS.TM.sizing));
        this.div.appendChild(OpenLayers.Util.createAlphaImageDiv("", new OpenLayers.Pixel(parseInt(38 + this.size.w - (7 > a ? 22 : 23)), 0), new OpenLayers.Size(38, 28), b + CORNERS.TR.src,
            "absolute", 0, CORNERS.TR.sizing));
        this.div.appendChild(OpenLayers.Util.createAlphaImageDiv("", new OpenLayers.Pixel(0, 28), new OpenLayers.Size(38, parseInt(this.size.h - 12)), b + CORNERS.ML.src, "absolute", 0, CORNERS.ML.sizing));
        this.contentDiv.style.position = "absolute";
        this.contentDiv.style.backgroundColor = "#ffffff";
        this.contentDiv.style.top = "15px";
        this.contentDiv.style.left = "15px";
        this.contentDiv.style.width = this.size.w + "px";
        this.contentDiv.style.height = this.size.h + "px";
        this.div.appendChild(OpenLayers.Util.createAlphaImageDiv("",
            new OpenLayers.Pixel(parseInt(38 + this.size.w - 22), 28), new OpenLayers.Size(38, parseInt(this.size.h - 13)), b + CORNERS.MR.src, "absolute", 0, CORNERS.MR.sizing));
        var c = 38 + this.size.w + 38;
        this.div.appendChild(OpenLayers.Util.createAlphaImageDiv("", new OpenLayers.Pixel(0, 28 + this.size.h - 12), new OpenLayers.Size(38, 39), b + CORNERS.BL.src, "absolute", 0, CORNERS.BL.sizing));
        this.div.appendChild(OpenLayers.Util.createAlphaImageDiv("", new OpenLayers.Pixel(38, 28 + this.size.h - 13), new OpenLayers.Size(c - 135 - (7 > a ? 21 : 22), 40), b +
        CORNERS.BM.src, "absolute", 0, CORNERS.BM.sizing));
        this.div.appendChild(OpenLayers.Util.createAlphaImageDiv("", new OpenLayers.Pixel(c - 135 + 38 - (7 > a ? 21 : 22), 28 + this.size.h - 13), new OpenLayers.Size(97, 68), b + CORNERS.BR.src, "absolute", 0, CORNERS.BR.sizing));
        this.div.appendChild(this.contentDiv);
        this.size = new OpenLayers.Size(this.size.w + 53, this.size.h + 68)
    },
    getRenderedDimensions: function () {
        this.setContentHTML();
        var a = document.createElement("div");
        a.className = "olPopup";
        a.style.overflow = "";
        a.style.position = "absolute";
        a.style.left = "-9999999999px";
        a.style.width = "20px";
        a.style.height = "20px";
        var b = document.createElement("div");
        b.innerHTML = this.contentHTML;
        b.className = "olPopupContent";
        b.style.overflow = "auto";
        a.appendChild(b);
        document.body.appendChild(a);
        var c = parseInt(b.scrollWidth);
        a.style.width = c + "px";
        b = parseInt(b.scrollHeight);
        b < this.minHeight || this.getMinMapHeight() < this.minHeight ? b = this.minHeight : b > this.getMinMapHeight() && (c += anchoredBubbleSupport.getbarWidth(), b = this.getMinMapHeight());
        this.size = new OpenLayers.Size(c,
            b);
        document.body.removeChild(a)
    },
    getMinMapHeight: function () {
        var a = anchoredBubbleSupport.getPos(this.map.div);
        return a.h - anchoredBubbleSupport.offsetTop - 68 - a.y - anchoredBubbleSupport.offsetBottom
    },
    destroy: function () {
        null != this.map && this.map.removePopup(this);
        this.map = this.div = null
    },
    draw: function (a) {
        null == a && null != this.lonlat && null != this.map && (a = this.map.getLayerPxFromLonLat(this.lonlat));
        this.setSize();
        this.setContentHTML();
        this.moveTo(a);
        return this.div
    },
    updatePosition: function () {
        this.lonlat && this.map &&
        this.anchor && this.moveTo(this.map.getLayerPxFromLonLat(this.lonlat))
    },
    moveTo: function (a) {
        null != a && null != this.div && (this.div.style.left = a.x + "px", this.div.style.top = a.y + "px")
    },
    visible: function () {
        return OpenLayers.Element.visible(this.div)
    },
    toggle: function () {
        OpenLayers.Element.toggle(this.div)
    },
    show: function () {
        OpenLayers.Element.show(this.div)
    },
    hide: function () {
        this.map && this.map.removePopup(this);
        this.div.style.display = "none"
    },
    setSize: function (a) {
        void 0 != a && (this.size = a);
        null != this.div && (this.div.style.width =
            this.size.w + "px", this.div.style.height = this.size.h + "px")
    },
    setOpacity: function (a) {
        void 0 != a && (this.opacity = a);
        null != this.div && (this.div.style.opacity = this.opacity, this.div.style.filter = "alpha(opacity=" + 100 * this.opacity + ")")
    },
    setContentHTML: function (a) {
        null != a && (this.contentHTML = a);
        null != this.contentDiv && (this.contentDiv.innerHTML = this.contentHTML)
    },
    registerEvents: function () {
        this.events = new OpenLayers.Events(this, this.div, null, !0);
        this.events.register("mousedown", this, this.onmousedown);
        this.events.register("mousemove",
            this, this.onmousemove);
        this.events.register("mouseup", this, this.onmouseup);
        this.events.register("click", this, function (a) {
            OpenLayers.Event.stop(a, !0)
        });
        this.events.register("mouseout", this, this.onmouseout);
        this.events.register("dblclick", this, function (a) {
            OpenLayers.Event.stop(a, !0)
        })
    },
    onmousedown: function (a) {
        this.mousedown = !0;
        OpenLayers.Event.stop(a, !0)
    },
    onmousemove: function (a) {
        this.mousedown && OpenLayers.Event.stop(a, !0)
    },
    onmouseup: function (a) {
        this.mousedown && (this.mousedown = !1, OpenLayers.Event.stop(a,
            !0))
    },
    onmouseout: function () {
        this.mousedown = !1
    },
    CLASS_NAME: "OpenLayers.Popup"
});
OpenLayers.Popup.Anchored = OpenLayers.Class(OpenLayers.Popup, {
    relativePosition: "tl",
    anchor: null,
    differenceX: 0,
    differenceY: 0,
    initialize: function (a, b, c, d, e, f, g, h) {
        OpenLayers.Popup.prototype.initialize.apply(this, [a, b, c, d, e, g, h]);
        this.anchor = null != f ? f : {size: new OpenLayers.Size(0, 0), offset: new OpenLayers.Pixel(0, 0)};
        this.registerEvents()
    },
    draw: function (a) {
        null == a && null != this.lonlat && null != this.map && (a = this.map.getLayerPxFromLonLat(this.lonlat));
        this.updatePos();
        return OpenLayers.Popup.prototype.draw.apply(this,
            arguments)
    },
    updatePos: function () {
        var a = anchoredBubbleSupport.offsetWidth, b = anchoredBubbleSupport.offsetTop, c = anchoredBubbleSupport.getPos(this.map.div), d = this.calculateNewPx(this.map.getLayerPxFromLonLat(this.lonlat)), d = this.map.getViewPortPxFromLayerPx(d), e = parseInt(d.x + this.size.w), f = parseInt(d.y + this.size.h);
        d.x < c.x && (this.differenceX = parseInt(d.x - c.x - a));
        e > c.w && (this.differenceX = parseInt(e - c.w + a));
        f > c.h - anchoredBubbleSupport.offsetBottom && (this.differenceY = parseInt(d.y - c.h + anchoredBubbleSupport.offsetBottom +
        this.size.h));
        d.y < c.y && (this.differenceY = parseInt(d.y - c.y - b));
        (0 != this.differenceX || 0 != this.differenceY) && this.map.pan(this.differenceX, this.differenceY)
    },
    moveTo: function (a) {
        a = this.calculateNewPx(a);
        OpenLayers.Popup.prototype.moveTo.apply(this, Array(a))
    },
    setSize: function (a) {
        OpenLayers.Popup.prototype.setSize.apply(this, arguments);
        this.lonlat && this.map && this.moveTo(this.map.getLayerPxFromLonLat(this.lonlat))
    },
    calculateNewPx: function (a) {
        var a = a.offset(this.anchor.offset), b = "t" == this.relativePosition.charAt(0);
        a.y += b ? -this.size.h : this.anchor.size.h;
        b = "l" == this.relativePosition.charAt(1);
        a.x += b ? -this.size.w : this.anchor.size.w;
        a.x += 55;
        a.y -= 15;
        return a
    },
    CLASS_NAME: "OpenLayers.Popup.Anchored"
});
OpenLayers.Popup.AnchoredBubble = OpenLayers.Class(OpenLayers.Popup.Anchored, {
    initialize: function (a, b, c, d, e, f, g, h) {
        OpenLayers.Popup.Anchored.prototype.initialize.apply(this, arguments)
    }, draw: function (a) {
        OpenLayers.Popup.Anchored.prototype.draw.apply(this, arguments);
        this.setContentHTML();
        return this.div
    }, setSize: function (a) {
        OpenLayers.Popup.Anchored.prototype.setSize.apply(this, arguments)
    }, setOpacity: function (a) {
        void 0 != a && (this.opacity = a);
        null != this.div && null != this.contentDiv && OpenLayers.Rico.Corner.changeOpacity(this.contentDiv,
            this.opacity)
    }, CLASS_NAME: "OpenLayers.Popup.AnchoredBubble"
});
var anchoredBubbleSupport = {
    offsetWidth: 60, offsetTop: 10, offsetBottom: 50, scrollbarWidth: null, getbarWidth: function () {
        if (null != this.scrollbarWidth)return this.scrollbarWidth;
        var a = jQuery('<div style="width:50px;height:50px;overflow:hidden;position:absolute;top:-200px;left:-200px;"><div style="height:100px;"></div>');
        jQuery("body").append(a);
        var b = jQuery("div", a).innerWidth();
        a.css("overflow-y", "scroll");
        var c = jQuery("div", a).innerWidth();
        jQuery(a).remove();
        return b - c
    }, viewport: function () {
        return {
            height: document.body.clientHeight ||
            document.documentElement.clientHeight || window.innerHeight || 0,
            width: document.body.clientWidth || document.documentElement.clientWidth || window.innerWidth || 0,
            scrollX: document.body.scrollLeft || document.documentElement.scrollLeft || self.pageXOffset || 0,
            scrollY: document.body.scrollTop || document.documentElement.scrollTop || self.pageYOffset || 0
        }
    }, getPos: function (a) {
        var b = 0, c = 0, d = 0, e = 0;
        if (document.getBoxObjectFor)return a = document.getBoxObjectFor(a), {x: a.x, y: a.y, w: a.width, h: a.height};
        if (a.getBoundingClientRect)return a =
            a.getBoundingClientRect(), {
            x: a.left + anchoredBubbleSupport.viewport().scrollX,
            y: a.top + anchoredBubbleSupport.viewport().scrollY,
            w: a.right - a.left,
            h: a.bottom - a.top
        };
        d = a.offsetWidth;
        e = a.offsetHeight;
        do b += a.offsetLeft || 0, c += a.offsetTop || 0, a = a.offsetParent; while (a);
        return {x: b, y: c, w: d, h: e}
    }, fade: function (a, b, c, d, e) {
        var d = Math.round(d / 100), f = 0;
        if (b > c)for (i = b; i >= c; i--)setTimeout("anchoredBubbleSupport.changeOpac(" + i + ",'" + a + "')", f * d), f++; else if (b < c)for (i = b; i <= c; i++)setTimeout("anchoredBubbleSupport.changeOpac(" +
        i + ",'" + a + "')", f * d), f++;
        b == c && e()
    }, changeOpac: function (a, b) {
        var c = document.getElementById(b).style;
        c.opacity = a / 100;
        c.MozOpacity = a / 100;
        c.KhtmlOpacity = a / 100;
        c.filter = "alpha(opacity=" + a + ")"
    }
};
OpenLayers.Feature = OpenLayers.Class({
    layer: null,
    id: null,
    lonlat: null,
    data: null,
    marker: null,
    popupClass: null,
    popup: null,
    initialize: function (a, b, c) {
        this.layer = a;
        this.lonlat = b;
        this.data = null != c ? c : {};
        this.id = OpenLayers.Util.createUniqueID(this.CLASS_NAME + "_")
    },
    destroy: function () {
        null != this.layer && null != this.layer.map && null != this.popup && this.layer.map.removePopup(this.popup);
        null != this.layer && null != this.marker && this.layer.removeMarker(this.marker);
        this.data = this.lonlat = this.id = this.layer = null;
        null != this.marker &&
        (this.destroyMarker(this.marker), this.marker = null);
        null != this.popup && (this.destroyPopup(this.popup), this.popup = null)
    },
    onScreen: function () {
        var a = !1;
        null != this.layer && null != this.layer.map && (a = this.layer.map.getExtent().containsLonLat(this.lonlat));
        return a
    },
    createMarker: function () {
        null != this.lonlat && (this.marker = new OpenLayers.Marker(this.lonlat, this.data.icon));
        return this.marker
    },
    destroyMarker: function () {
        this.marker.destroy()
    },
    createPopup: function (a) {
        null != this.lonlat && (this.popup || (this.popup = new (this.popupClass ?
            this.popupClass : OpenLayers.Popup.Anchored)(this.id + "_popup", this.lonlat, this.data.popupSize, this.data.popupContentHTML, this.marker ? this.marker.icon : null, a)), null != this.data.overflow && (this.popup.contentDiv.style.overflow = this.data.overflow), this.popup.feature = this);
        return this.popup
    },
    destroyPopup: function () {
        this.popup && (this.popup.feature = null, this.popup.destroy(), this.popup = null)
    },
    CLASS_NAME: "OpenLayers.Feature"
});
OpenLayers.State = {UNKNOWN: "Unknown", INSERT: "Insert", UPDATE: "Update", DELETE: "Delete"};
OpenLayers.Feature.Vector = OpenLayers.Class(OpenLayers.Feature, {
    fid: null,
    geometry: null,
    attributes: null,
    bounds: null,
    state: null,
    style: null,
    url: null,
    renderIntent: "default",
    modified: null,
    initialize: function (a, b, c) {
        OpenLayers.Feature.prototype.initialize.apply(this, [null, null, b]);
        this.lonlat = null;
        this.geometry = a ? a : null;
        this.state = null;
        this.attributes = {};
        b && (this.attributes = OpenLayers.Util.extend(this.attributes, b));
        this.style = c ? c : null
    },
    destroy: function () {
        this.layer && (this.layer.removeFeatures(this), this.layer =
            null);
        this.modified = this.geometry = null;
        OpenLayers.Feature.prototype.destroy.apply(this, arguments)
    },
    clone: function () {
        return new OpenLayers.Feature.Vector(this.geometry ? this.geometry.clone() : null, this.attributes, this.style)
    },
    onScreen: function (a) {
        var b = !1;
        this.layer && this.layer.map && (b = this.layer.map.getExtent(), a ? (a = this.geometry.getBounds(), b = b.intersectsBounds(a)) : b = b.toGeometry().intersects(this.geometry));
        return b
    },
    getVisibility: function () {
        return !(this.style && "none" == this.style.display || !this.layer ||
        this.layer && this.layer.styleMap && "none" == this.layer.styleMap.createSymbolizer(this, this.renderIntent).display || this.layer && !this.layer.getVisibility())
    },
    createMarker: function () {
        return null
    },
    destroyMarker: function () {
    },
    createPopup: function () {
        return null
    },
    atPoint: function (a, b, c) {
        var d = !1;
        this.geometry && (d = this.geometry.atPoint(a, b, c));
        return d
    },
    destroyPopup: function () {
    },
    move: function (a) {
        if (this.layer && this.geometry.move) {
            var a = "OpenLayers.LonLat" == a.CLASS_NAME ? this.layer.getViewPortPxFromLonLat(a) : a,
                b = this.layer.getViewPortPxFromLonLat(this.geometry.getBounds().getCenterLonLat()), c = this.layer.map.getResolution();
            this.geometry.move(c * (a.x - b.x), c * (b.y - a.y));
            this.layer.drawFeature(this);
            return b
        }
    },
    toState: function (a) {
        if (a == OpenLayers.State.UPDATE)switch (this.state) {
            case OpenLayers.State.UNKNOWN:
            case OpenLayers.State.DELETE:
                this.state = a
        } else if (a == OpenLayers.State.INSERT)switch (this.state) {
            case OpenLayers.State.UNKNOWN:
                break;
            default:
                this.state = a
        } else if (a == OpenLayers.State.DELETE)switch (this.state) {
            case OpenLayers.State.UNKNOWN:
            case OpenLayers.State.UPDATE:
                this.state =
                    a
        } else a == OpenLayers.State.UNKNOWN && (this.state = a)
    },
    CLASS_NAME: "OpenLayers.Feature.Vector"
});
OpenLayers.Feature.Vector.style = {
    "default": {
        fillColor: "#ee9900",
        fillOpacity: 0.4,
        hoverFillColor: "white",
        hoverFillOpacity: 0.8,
        strokeColor: "#ee9900",
        strokeOpacity: 1,
        strokeWidth: 1,
        strokeLinecap: "round",
        strokeDashstyle: "solid",
        hoverStrokeColor: "red",
        hoverStrokeOpacity: 1,
        hoverStrokeWidth: 0.2,
        pointRadius: 6,
        hoverPointRadius: 1,
        hoverPointUnit: "%",
        pointerEvents: "visiblePainted",
        cursor: "inherit",
        fontColor: "#000000",
        labelAlign: "cm",
        labelOutlineColor: "white",
        labelOutlineWidth: 3
    }, select: {
        fillColor: "blue",
        fillOpacity: 0.4,
        hoverFillColor: "white",
        hoverFillOpacity: 0.8,
        strokeColor: "blue",
        strokeOpacity: 1,
        strokeWidth: 2,
        strokeLinecap: "round",
        strokeDashstyle: "solid",
        hoverStrokeColor: "red",
        hoverStrokeOpacity: 1,
        hoverStrokeWidth: 0.2,
        pointRadius: 6,
        hoverPointRadius: 1,
        hoverPointUnit: "%",
        pointerEvents: "visiblePainted",
        cursor: "pointer",
        fontColor: "#000000",
        labelAlign: "cm",
        labelOutlineColor: "white",
        labelOutlineWidth: 3
    }, temporary: {
        fillColor: "#66cccc",
        fillOpacity: 0.2,
        hoverFillColor: "white",
        hoverFillOpacity: 0.8,
        strokeColor: "#66cccc",
        strokeOpacity: 1,
        strokeLinecap: "round",
        strokeWidth: 2,
        strokeDashstyle: "solid",
        hoverStrokeColor: "red",
        hoverStrokeOpacity: 1,
        hoverStrokeWidth: 0.2,
        pointRadius: 6,
        hoverPointRadius: 1,
        hoverPointUnit: "%",
        pointerEvents: "visiblePainted",
        cursor: "inherit",
        fontColor: "#000000",
        labelAlign: "cm",
        labelOutlineColor: "white",
        labelOutlineWidth: 3
    }, "delete": {display: "none"}
};
OpenLayers.Handler = OpenLayers.Class({
    id: null, control: null, map: null, keyMask: null, active: !1, evt: null, initialize: function (a, b, c) {
        OpenLayers.Util.extend(this, c);
        this.control = a;
        this.callbacks = b;
        (a = this.map || a.map) && this.setMap(a);
        this.id = OpenLayers.Util.createUniqueID(this.CLASS_NAME + "_")
    }, setMap: function (a) {
        this.map = a
    }, checkModifiers: function (a) {
        return null == this.keyMask ? !0 : ((a.shiftKey ? OpenLayers.Handler.MOD_SHIFT : 0) | (a.ctrlKey ? OpenLayers.Handler.MOD_CTRL : 0) | (a.altKey ? OpenLayers.Handler.MOD_ALT : 0)) ==
        this.keyMask
    }, activate: function () {
        if (this.active)return !1;
        for (var a = OpenLayers.Events.prototype.BROWSER_EVENTS, b = 0, c = a.length; b < c; b++)this[a[b]] && this.register(a[b], this[a[b]]);
        return this.active = !0
    }, deactivate: function () {
        if (!this.active)return !1;
        for (var a = OpenLayers.Events.prototype.BROWSER_EVENTS, b = 0, c = a.length; b < c; b++)this[a[b]] && this.unregister(a[b], this[a[b]]);
        this.active = !1;
        return !0
    }, callback: function (a, b) {
        a && this.callbacks[a] && this.callbacks[a].apply(this.control, b)
    }, register: function (a, b) {
        this.map.events.registerPriority(a,
            this, b);
        this.map.events.registerPriority(a, this, this.setEvent)
    }, unregister: function (a, b) {
        this.map.events.unregister(a, this, b);
        this.map.events.unregister(a, this, this.setEvent)
    }, setEvent: function (a) {
        this.evt = a;
        return !0
    }, destroy: function () {
        this.deactivate();
        this.control = this.map = null
    }, CLASS_NAME: "OpenLayers.Handler"
});
OpenLayers.Handler.MOD_NONE = 0;
OpenLayers.Handler.MOD_SHIFT = 1;
OpenLayers.Handler.MOD_CTRL = 2;
OpenLayers.Handler.MOD_ALT = 4;
OpenLayers.Handler.Click = OpenLayers.Class(OpenLayers.Handler, {
    delay: 300,
    single: !0,
    "double": !1,
    pixelTolerance: 0,
    dblclickTolerance: 13,
    stopSingle: !1,
    stopDouble: !1,
    timerId: null,
    touch: !1,
    down: null,
    last: null,
    first: null,
    rightclickTimerId: null,
    touchstart: function (a) {
        this.touch || (this.unregisterMouseListeners(), this.touch = !0);
        this.down = this.getEventInfo(a);
        this.last = this.getEventInfo(a);
        return !0
    },
    touchmove: function (a) {
        this.last = this.getEventInfo(a);
        return !0
    },
    touchend: function (a) {
        this.down && (a.xy = this.last.xy,
            a.lastTouches = this.last.touches, this.handleSingle(a), this.down = null);
        return !0
    },
    unregisterMouseListeners: function () {
        this.map.events.un({
            mousedown: this.mousedown,
            mouseup: this.mouseup,
            click: this.click,
            dblclick: this.dblclick,
            scope: this
        })
    },
    mousedown: function (a) {
        this.down = this.getEventInfo(a);
        this.last = this.getEventInfo(a);
        return !0
    },
    mouseup: function (a) {
        var b = !0;
        this.checkModifiers(a) && this.control.handleRightClicks && OpenLayers.Event.isRightClick(a) && (b = this.rightclick(a));
        return b
    },
    rightclick: function (a) {
        if (this.passesTolerance(a)) {
            if (null !=
                this.rightclickTimerId)return this.clearTimer(), this.callback("dblrightclick", [a]), !this.stopDouble;
            a = this["double"] ? OpenLayers.Util.extend({}, a) : this.callback("rightclick", [a]);
            a = OpenLayers.Function.bind(this.delayedRightCall, this, a);
            this.rightclickTimerId = window.setTimeout(a, this.delay)
        }
        return !this.stopSingle
    },
    delayedRightCall: function (a) {
        this.rightclickTimerId = null;
        a && this.callback("rightclick", [a])
    },
    click: function (a) {
        this.last || (this.last = this.getEventInfo(a));
        this.handleSingle(a);
        return !this.stopSingle
    },
    dblclick: function (a) {
        this.handleDouble(a);
        return !this.stopDouble
    },
    handleDouble: function (a) {
        this.passesDblclickTolerance(a) && (this["double"] && this.callback("dblclick", [a]), this.clearTimer())
    },
    handleSingle: function (a) {
        this.passesTolerance(a) && (null != this.timerId ? (this.last.touches && 1 === this.last.touches.length && (this["double"] && OpenLayers.Event.stop(a), this.handleDouble(a)), (!this.last.touches || 2 !== this.last.touches.length) && this.clearTimer()) : (this.first = this.getEventInfo(a), this.queuePotentialClick(this.single ?
            OpenLayers.Util.extend({}, a) : null)))
    },
    queuePotentialClick: function (a) {
        this.timerId = window.setTimeout(OpenLayers.Function.bind(this.delayedCall, this, a), this.delay)
    },
    passesTolerance: function (a) {
        var b = !0;
        if (null != this.pixelTolerance && this.down && this.down.xy && (b = this.pixelTolerance >= this.down.xy.distanceTo(a.xy)) && this.touch && this.down.touches.length === this.last.touches.length)for (var a = 0, c = this.down.touches.length; a < c; ++a)if (this.getTouchDistance(this.down.touches[a], this.last.touches[a]) > this.pixelTolerance) {
            b = !1;
            break
        }
        return b
    },
    getTouchDistance: function (a, b) {
        return Math.sqrt(Math.pow(a.clientX - b.clientX, 2) + Math.pow(a.clientY - b.clientY, 2))
    },
    passesDblclickTolerance: function () {
        var a = !0;
        this.down && this.first && (a = this.down.xy.distanceTo(this.first.xy) <= this.dblclickTolerance);
        return a
    },
    clearTimer: function () {
        null != this.timerId && (window.clearTimeout(this.timerId), this.timerId = null);
        null != this.rightclickTimerId && (window.clearTimeout(this.rightclickTimerId), this.rightclickTimerId = null)
    },
    delayedCall: function (a) {
        this.timerId =
            null;
        a && this.callback("click", [a])
    },
    getEventInfo: function (a) {
        var b;
        if (a.touches) {
            var c = a.touches.length;
            b = Array(c);
            for (var d, e = 0; e < c; e++)d = a.touches[e], b[e] = {clientX: d.clientX, clientY: d.clientY}
        }
        return {xy: a.xy, touches: b}
    },
    deactivate: function () {
        var a = !1;
        OpenLayers.Handler.prototype.deactivate.apply(this, arguments) && (this.clearTimer(), this.last = this.first = this.down = null, this.touch = !1, a = !0);
        return a
    },
    CLASS_NAME: "OpenLayers.Handler.Click"
});
OpenLayers.Handler.Hover = OpenLayers.Class(OpenLayers.Handler, {
    delay: 500, pixelTolerance: null, stopMove: !1, px: null, timerId: null, mousemove: function (a) {
        this.passesTolerance(a.xy) && (this.clearTimer(), this.callback("move", [a]), this.px = a.xy, a = OpenLayers.Util.extend({}, a), this.timerId = window.setTimeout(OpenLayers.Function.bind(this.delayedCall, this, a), this.delay));
        return !this.stopMove
    }, mouseout: function (a) {
        OpenLayers.Util.mouseLeft(a, this.map.viewPortDiv) && (this.clearTimer(), this.callback("move", [a]));
        return !0
    },
    passesTolerance: function (a) {
        var b = !0;
        this.pixelTolerance && this.px && Math.sqrt(Math.pow(this.px.x - a.x, 2) + Math.pow(this.px.y - a.y, 2)) < this.pixelTolerance && (b = !1);
        return b
    }, clearTimer: function () {
        null != this.timerId && (window.clearTimeout(this.timerId), this.timerId = null)
    }, delayedCall: function (a) {
        this.callback("pause", [a])
    }, deactivate: function () {
        var a = !1;
        OpenLayers.Handler.prototype.deactivate.apply(this, arguments) && (this.clearTimer(), a = !0);
        return a
    }, CLASS_NAME: "OpenLayers.Handler.Hover"
});
OpenLayers.Handler.Point = OpenLayers.Class(OpenLayers.Handler, {
    point: null,
    layer: null,
    multi: !1,
    citeCompliant: !1,
    mouseDown: !1,
    stoppedDown: null,
    lastDown: null,
    lastUp: null,
    persist: !1,
    stopDown: !1,
    stopUp: !1,
    layerOptions: null,
    pixelTolerance: 5,
    touch: !1,
    lastTouchPx: null,
    initialize: function (a, b, c) {
        if (!c || !c.layerOptions || !c.layerOptions.styleMap)this.style = OpenLayers.Util.extend(OpenLayers.Feature.Vector.style["default"], {});
        OpenLayers.Handler.prototype.initialize.apply(this, arguments)
    },
    activate: function () {
        if (!OpenLayers.Handler.prototype.activate.apply(this,
                arguments))return !1;
        var a = OpenLayers.Util.extend({
            displayInLayerSwitcher: !1,
            calculateInRange: OpenLayers.Function.True,
            wrapDateLine: this.citeCompliant
        }, this.layerOptions);
        this.layer = new OpenLayers.Layer.Vector(this.CLASS_NAME, a);
        this.map.addLayer(this.layer);
        return !0
    },
    createFeature: function (a) {
        a = this.layer.getLonLatFromViewPortPx(a);
        a = new OpenLayers.Geometry.Point(a.lon, a.lat);
        this.point = new OpenLayers.Feature.Vector(a);
        this.callback("create", [this.point.geometry, this.point]);
        this.point.geometry.clearBounds();
        this.layer.addFeatures([this.point], {silent: !0})
    },
    deactivate: function () {
        if (!OpenLayers.Handler.prototype.deactivate.apply(this, arguments))return !1;
        this.cancel();
        null != this.layer.map && (this.destroyFeature(!0), this.layer.destroy(!1));
        this.layer = null;
        this.touch = !1;
        return !0
    },
    destroyFeature: function (a) {
        this.layer && (a || !this.persist) && this.layer.destroyFeatures();
        this.point = null
    },
    destroyPersistedFeature: function () {
        var a = this.layer;
        a && 1 < a.features.length && this.layer.features[0].destroy()
    },
    finalize: function (a) {
        this.mouseDown = !1;
        this.lastTouchPx = this.lastUp = this.lastDown = null;
        this.callback(a ? "cancel" : "done", [this.geometryClone()]);
        this.destroyFeature(a)
    },
    cancel: function () {
        this.finalize(!0)
    },
    click: function (a) {
        OpenLayers.Event.stop(a);
        return !1
    },
    dblclick: function (a) {
        OpenLayers.Event.stop(a);
        return !1
    },
    modifyFeature: function (a) {
        this.point || this.createFeature(a);
        a = this.layer.getLonLatFromViewPortPx(a);
        this.point.geometry.x = a.lon;
        this.point.geometry.y = a.lat;
        this.callback("modify", [this.point.geometry, this.point, !1]);
        this.point.geometry.clearBounds();
        this.drawFeature()
    },
    drawFeature: function () {
        this.layer.drawFeature(this.point, this.style)
    },
    getGeometry: function () {
        var a = this.point && this.point.geometry;
        a && this.multi && (a = new OpenLayers.Geometry.MultiPoint([a]));
        return a
    },
    geometryClone: function () {
        var a = this.getGeometry();
        return a && a.clone()
    },
    mousedown: function (a) {
        return this.down(a)
    },
    touchstart: function (a) {
        this.touch || (this.touch = !0, this.map.events.un({
            mousedown: this.mousedown,
            mouseup: this.mouseup,
            mousemove: this.mousemove,
            click: this.click,
            dblclick: this.dblclick,
            scope: this
        }));
        this.lastTouchPx = a.xy;
        return this.down(a)
    },
    mousemove: function (a) {
        return this.move(a)
    },
    touchmove: function (a) {
        this.lastTouchPx = a.xy;
        return this.move(a)
    },
    mouseup: function (a) {
        return this.up(a)
    },
    touchend: function (a) {
        a.xy = this.lastTouchPx;
        return this.up(a)
    },
    down: function (a) {
        this.mouseDown = !0;
        this.lastDown = a.xy;
        this.touch || this.modifyFeature(a.xy);
        this.stoppedDown = this.stopDown;
        return !this.stopDown
    },
    move: function (a) {
        !this.touch && (!this.mouseDown || this.stoppedDown) && this.modifyFeature(a.xy);
        return !0
    },
    up: function (a) {
        this.mouseDown = !1;
        this.stoppedDown = this.stopDown;
        return this.checkModifiers(a) && (!this.lastUp || !this.lastUp.equals(a.xy)) && this.lastDown && this.passesTolerance(this.lastDown, a.xy, this.pixelTolerance) ? (this.touch && this.modifyFeature(a.xy), this.persist && this.destroyPersistedFeature(), this.lastUp = a.xy, this.finalize(), !this.stopUp) : !0
    },
    mouseout: function (a) {
        OpenLayers.Util.mouseLeft(a, this.map.viewPortDiv) && (this.stoppedDown = this.stopDown, this.mouseDown = !1)
    },
    passesTolerance: function (a,
                               b, c) {
        var d = !0;
        null != c && a && b && a.distanceTo(b) > c && (d = !1);
        return d
    },
    CLASS_NAME: "OpenLayers.Handler.Point"
});
OpenLayers.Handler.Path = OpenLayers.Class(OpenLayers.Handler.Point, {
    line: null,
    maxVertices: null,
    doubleTouchTolerance: 20,
    freehand: !1,
    freehandToggle: "shiftKey",
    timerId: null,
    redoStack: null,
    createFeature: function (a) {
        a = this.layer.getLonLatFromViewPortPx(a);
        a = new OpenLayers.Geometry.Point(a.lon, a.lat);
        this.point = new OpenLayers.Feature.Vector(a);
        this.line = new OpenLayers.Feature.Vector(new OpenLayers.Geometry.LineString([this.point.geometry]));
        this.callback("create", [this.point.geometry, this.getSketch()]);
        this.point.geometry.clearBounds();
        this.layer.addFeatures([this.line, this.point], {silent: !0})
    },
    destroyFeature: function (a) {
        OpenLayers.Handler.Point.prototype.destroyFeature.call(this, a);
        this.line = null
    },
    destroyPersistedFeature: function () {
        var a = this.layer;
        a && 2 < a.features.length && this.layer.features[0].destroy()
    },
    removePoint: function () {
        this.point && this.layer.removeFeatures([this.point])
    },
    addPoint: function (a) {
        this.layer.removeFeatures([this.point]);
        a = this.layer.getLonLatFromViewPortPx(a);
        this.point = new OpenLayers.Feature.Vector(new OpenLayers.Geometry.Point(a.lon,
            a.lat));
        this.line.geometry.addComponent(this.point.geometry, this.line.geometry.components.length);
        this.layer.addFeatures([this.point]);
        this.callback("point", [this.point.geometry, this.getGeometry()]);
        this.callback("modify", [this.point.geometry, this.getSketch()]);
        this.drawFeature();
        delete this.redoStack
    },
    insertXY: function (a, b) {
        this.line.geometry.addComponent(new OpenLayers.Geometry.Point(a, b), this.getCurrentPointIndex());
        this.drawFeature();
        delete this.redoStack
    },
    insertDeltaXY: function (a, b) {
        var c = this.line.geometry.components[this.getCurrentPointIndex() -
        1];
        c && !isNaN(c.x) && !isNaN(c.y) && this.insertXY(c.x + a, c.y + b)
    },
    insertDirectionLength: function (a, b) {
        var a = a * (Math.PI / 180), c = b * Math.cos(a), d = b * Math.sin(a);
        this.insertDeltaXY(c, d)
    },
    insertDeflectionLength: function (a, b) {
        var c = this.getCurrentPointIndex() - 1;
        if (0 < c) {
            var d = this.line.geometry.components[c], c = this.line.geometry.components[c - 1];
            this.insertDirectionLength(180 * Math.atan2(d.y - c.y, d.x - c.x) / Math.PI + a, b)
        }
    },
    getCurrentPointIndex: function () {
        return this.line.geometry.components.length - 1
    },
    undo: function () {
        var a =
            this.line.geometry, b = a.components, c = this.getCurrentPointIndex() - 1, b = b[c];
        if (a = a.removeComponent(b))this.redoStack || (this.redoStack = []), this.redoStack.push(b), this.drawFeature();
        return a
    },
    redo: function () {
        var a = this.redoStack && this.redoStack.pop();
        a && (this.line.geometry.addComponent(a, this.getCurrentPointIndex()), this.drawFeature());
        return !!a
    },
    freehandMode: function (a) {
        return this.freehandToggle && a[this.freehandToggle] ? !this.freehand : this.freehand
    },
    modifyFeature: function (a, b) {
        this.line || this.createFeature(a);
        var c = this.layer.getLonLatFromViewPortPx(a);
        this.point.geometry.x = c.lon;
        this.point.geometry.y = c.lat;
        this.callback("modify", [this.point.geometry, this.getSketch(), b]);
        this.point.geometry.clearBounds();
        this.drawFeature()
    },
    drawFeature: function () {
        this.layer.drawFeature(this.line, this.style);
        this.layer.drawFeature(this.point, this.style)
    },
    getSketch: function () {
        return this.line
    },
    getGeometry: function () {
        var a = this.line && this.line.geometry;
        a && this.multi && (a = new OpenLayers.Geometry.MultiLineString([a]));
        return a
    },
    touchstart: function (a) {
        if (this.timerId && this.passesTolerance(this.lastTouchPx, a.xy, this.doubleTouchTolerance))return this.finishGeometry(), window.clearTimeout(this.timerId), this.timerId = null, !1;
        this.timerId && (window.clearTimeout(this.timerId), this.timerId = null);
        this.timerId = window.setTimeout(OpenLayers.Function.bind(function () {
            this.timerId = null
        }, this), 300);
        return OpenLayers.Handler.Point.prototype.touchstart.call(this, a)
    },
    down: function (a) {
        var b = this.stopDown;
        this.freehandMode(a) && (b = !0, this.touch &&
        (this.modifyFeature(a.xy, !!this.lastUp), OpenLayers.Event.stop(a)));
        !this.touch && (!this.lastDown || !this.passesTolerance(this.lastDown, a.xy, this.pixelTolerance)) && this.modifyFeature(a.xy, !!this.lastUp);
        this.mouseDown = !0;
        this.lastDown = a.xy;
        this.stoppedDown = b;
        return !b
    },
    move: function (a) {
        if (this.stoppedDown && this.freehandMode(a))return this.persist && this.destroyPersistedFeature(), this.maxVertices && this.line && this.line.geometry.components.length === this.maxVertices ? (this.removePoint(), this.finalize()) : this.addPoint(a.xy),
            !1;
        !this.touch && (!this.mouseDown || this.stoppedDown) && this.modifyFeature(a.xy, !!this.lastUp);
        return !0
    },
    up: function (a) {
        if (this.mouseDown && (!this.lastUp || !this.lastUp.equals(a.xy)))this.stoppedDown && this.freehandMode(a) ? (this.persist && this.destroyPersistedFeature(), this.removePoint(), this.finalize()) : this.passesTolerance(this.lastDown, a.xy, this.pixelTolerance) && (this.touch && this.modifyFeature(a.xy), null == this.lastUp && this.persist && this.destroyPersistedFeature(), this.addPoint(a.xy), this.lastUp = a.xy, this.line.geometry.components.length ===
        this.maxVertices + 1 && this.finishGeometry());
        this.stoppedDown = this.stopDown;
        this.mouseDown = !1;
        return !this.stopUp
    },
    finishGeometry: function () {
        this.line.geometry.removeComponent(this.line.geometry.components[this.line.geometry.components.length - 1]);
        this.removePoint();
        this.finalize()
    },
    dblclick: function (a) {
        this.freehandMode(a) || this.finishGeometry();
        return !1
    },
    CLASS_NAME: "OpenLayers.Handler.Path"
});
OpenLayers.Handler.Polygon = OpenLayers.Class(OpenLayers.Handler.Path, {
    holeModifier: null, drawingHole: !1, polygon: null, createFeature: function (a) {
        a = this.layer.getLonLatFromViewPortPx(a);
        a = new OpenLayers.Geometry.Point(a.lon, a.lat);
        this.point = new OpenLayers.Feature.Vector(a);
        this.line = new OpenLayers.Feature.Vector(new OpenLayers.Geometry.LinearRing([this.point.geometry]));
        this.polygon = new OpenLayers.Feature.Vector(new OpenLayers.Geometry.Polygon([this.line.geometry]));
        this.callback("create", [this.point.geometry,
            this.getSketch()]);
        this.point.geometry.clearBounds();
        this.layer.addFeatures([this.polygon, this.point], {silent: !0})
    }, addPoint: function (a) {
        if (!this.drawingHole && this.holeModifier && this.evt && this.evt[this.holeModifier])for (var b = this.point.geometry, c = this.control.layer.features, d, e = c.length - 1; 0 <= e; --e)if (d = c[e].geometry, (d instanceof OpenLayers.Geometry.Polygon || d instanceof OpenLayers.Geometry.MultiPolygon) && d.intersects(b)) {
            b = c[e];
            this.control.layer.removeFeatures([b], {silent: !0});
            this.control.layer.events.registerPriority("sketchcomplete",
                this, this.finalizeInteriorRing);
            this.control.layer.events.registerPriority("sketchmodified", this, this.enforceTopology);
            b.geometry.addComponent(this.line.geometry);
            this.polygon = b;
            this.drawingHole = !0;
            break
        }
        OpenLayers.Handler.Path.prototype.addPoint.apply(this, arguments)
    }, getCurrentPointIndex: function () {
        return this.line.geometry.components.length - 2
    }, enforceTopology: function (a) {
        var a = a.vertex, b = this.line.geometry.components;
        this.polygon.geometry.intersects(a) || (b = b[b.length - 3], a.x = b.x, a.y = b.y)
    }, finishGeometry: function () {
        this.line.geometry.removeComponent(this.line.geometry.components[this.line.geometry.components.length -
        2]);
        this.removePoint();
        this.finalize()
    }, finalizeInteriorRing: function () {
        var a = this.line.geometry, b = 0 !== a.getArea();
        if (b) {
            for (var c = this.polygon.geometry.components, d = c.length - 2; 0 <= d; --d)if (a.intersects(c[d])) {
                b = !1;
                break
            }
            if (b) {
                d = c.length - 2;
                a:for (; 0 < d; --d)for (var e = c[d].components, f = 0, g = e.length; f < g; ++f)if (a.containsPoint(e[f])) {
                    b = !1;
                    break a
                }
            }
        }
        b ? this.polygon.state !== OpenLayers.State.INSERT && (this.polygon.state = OpenLayers.State.UPDATE) : this.polygon.geometry.removeComponent(a);
        this.restoreFeature();
        return !1
    },
    cancel: function () {
        this.drawingHole && (this.polygon.geometry.removeComponent(this.line.geometry), this.restoreFeature(!0));
        return OpenLayers.Handler.Path.prototype.cancel.apply(this, arguments)
    }, restoreFeature: function (a) {
        this.control.layer.events.unregister("sketchcomplete", this, this.finalizeInteriorRing);
        this.control.layer.events.unregister("sketchmodified", this, this.enforceTopology);
        this.layer.removeFeatures([this.polygon], {silent: !0});
        this.control.layer.addFeatures([this.polygon], {silent: !0});
        this.drawingHole = !1;
        a || this.control.layer.events.triggerEvent("sketchcomplete", {feature: this.polygon})
    }, destroyFeature: function (a) {
        OpenLayers.Handler.Path.prototype.destroyFeature.call(this, a);
        this.polygon = null
    }, drawFeature: function () {
        this.layer.drawFeature(this.polygon, this.style);
        this.layer.drawFeature(this.point, this.style)
    }, getSketch: function () {
        return this.polygon
    }, getGeometry: function () {
        var a = this.polygon && this.polygon.geometry;
        a && this.multi && (a = new OpenLayers.Geometry.MultiPolygon([a]));
        return a
    }, CLASS_NAME: "OpenLayers.Handler.Polygon"
});
OpenLayers.Handler.Feature = OpenLayers.Class(OpenLayers.Handler, {
    EVENTMAP: {
        click: {"in": "click", out: "clickout"},
        mousemove: {"in": "over", out: "out"},
        dblclick: {"in": "dblclick", out: null},
        mousedown: {"in": null, out: null},
        mouseup: {"in": null, out: null},
        touchstart: {"in": "click", out: "clickout"}
    },
    feature: null,
    lastFeature: null,
    down: null,
    up: null,
    touch: !1,
    clickTolerance: 4,
    geometryTypes: null,
    stopClick: !0,
    stopDown: !0,
    stopUp: !1,
    initialize: function (a, b, c, d) {
        OpenLayers.Handler.prototype.initialize.apply(this, [a, c, d]);
        this.layer =
            b
    },
    touchstart: function (a) {
        this.touch || (this.touch = !0, this.map.events.un({
            mousedown: this.mousedown,
            mouseup: this.mouseup,
            mousemove: this.mousemove,
            click: this.click,
            dblclick: this.dblclick,
            scope: this
        }));
        return OpenLayers.Event.isMultiTouch(a) ? !0 : this.mousedown(a)
    },
    touchmove: function (a) {
        OpenLayers.Event.stop(a)
    },
    mousedown: function (a) {
        if (OpenLayers.Event.isLeftClick(a) || OpenLayers.Event.isSingleTouch(a))this.down = a.xy;
        return this.handle(a) ? !this.stopDown : !0
    },
    mouseup: function (a) {
        this.up = a.xy;
        return this.handle(a) ?
            !this.stopUp : !0
    },
    click: function (a) {
        return this.handle(a) ? !this.stopClick : !0
    },
    mousemove: function (a) {
        if (!this.callbacks.over && !this.callbacks.out)return !0;
        this.handle(a);
        return !0
    },
    dblclick: function (a) {
        return !this.handle(a)
    },
    geometryTypeMatches: function (a) {
        return null == this.geometryTypes || -1 < OpenLayers.Util.indexOf(this.geometryTypes, a.geometry.CLASS_NAME)
    },
    handle: function (a) {
        this.feature && !this.feature.layer && (this.feature = null);
        var b = a.type, c = !1, d = !!this.feature, e = "click" == b || "dblclick" == b || "touchstart" ==
            b;
        if ((this.feature = this.layer.getFeatureFromEvent(a)) && !this.feature.layer)this.feature = null;
        this.lastFeature && !this.lastFeature.layer && (this.lastFeature = null);
        this.feature ? ("touchstart" === b && OpenLayers.Event.stop(a), a = this.feature != this.lastFeature, this.geometryTypeMatches(this.feature) ? (d && a ? (this.lastFeature && this.triggerCallback(b, "out", [this.lastFeature]), this.triggerCallback(b, "in", [this.feature])) : (!d || e) && this.triggerCallback(b, "in", [this.feature]), this.lastFeature = this.feature, c = !0) : (this.lastFeature &&
        (d && a || e) && this.triggerCallback(b, "out", [this.lastFeature]), this.feature = null)) : this.lastFeature && (d || e) && this.triggerCallback(b, "out", [this.lastFeature]);
        return c
    },
    triggerCallback: function (a, b, c) {
        (b = this.EVENTMAP[a][b]) && ("click" == a && this.up && this.down ? Math.sqrt(Math.pow(this.up.x - this.down.x, 2) + Math.pow(this.up.y - this.down.y, 2)) <= this.clickTolerance && this.callback(b, c) : this.callback(b, c))
    },
    activate: function () {
        var a = !1;
        OpenLayers.Handler.prototype.activate.apply(this, arguments) && (this.moveLayerToTop(),
            this.map.events.on({
                removelayer: this.handleMapEvents,
                changelayer: this.handleMapEvents,
                scope: this
            }), a = !0);
        return a
    },
    deactivate: function () {
        var a = !1;
        OpenLayers.Handler.prototype.deactivate.apply(this, arguments) && (this.moveLayerBack(), this.up = this.down = this.lastFeature = this.feature = null, this.touch = !1, this.map.events.un({
            removelayer: this.handleMapEvents,
            changelayer: this.handleMapEvents,
            scope: this
        }), a = !0);
        return a
    },
    handleMapEvents: function (a) {
        ("removelayer" == a.type || "order" == a.property) && this.moveLayerToTop()
    },
    moveLayerToTop: function () {
        this.layer.setZIndex(Math.max(this.map.Z_INDEX_BASE.Feature - 1, this.layer.getZIndex()) + 1)
    },
    moveLayerBack: function () {
        var a = this.layer.getZIndex() - 1;
        a >= this.map.Z_INDEX_BASE.Feature ? this.layer.setZIndex(a) : this.map.setLayerZIndex(this.layer, this.map.getLayerIndex(this.layer))
    },
    CLASS_NAME: "OpenLayers.Handler.Feature"
});
OpenLayers.Handler.Drag = OpenLayers.Class(OpenLayers.Handler, {
    started: !1,
    stopDown: !0,
    dragging: !1,
    touch: !1,
    last: null,
    start: null,
    lastMoveEvt: null,
    oldOnselectstart: null,
    interval: 0,
    timeoutId: null,
    documentDrag: !1,
    documentEvents: null,
    initialize: function (a, b, c) {
        OpenLayers.Handler.prototype.initialize.apply(this, arguments);
        if (!0 === this.documentDrag) {
            var d = this;
            this._docMove = function (a) {
                d.mousemove({xy: {x: a.clientX, y: a.clientY}, element: document})
            };
            this._docUp = function (a) {
                d.mouseup({xy: {x: a.clientX, y: a.clientY}})
            }
        }
    },
    dragstart: function (a) {
        var b = !0;
        this.dragging = !1;
        this.checkModifiers(a) && (OpenLayers.Event.isLeftClick(a) || OpenLayers.Event.isSingleTouch(a)) ? (this.started = !0, this.last = this.start = a.xy, OpenLayers.Element.addClass(this.map.viewPortDiv, "olDragDown"), this.down(a), this.callback("down", [a.xy]), OpenLayers.Event.stop(a), this.oldOnselectstart || (this.oldOnselectstart = document.onselectstart ? document.onselectstart : OpenLayers.Function.True), document.onselectstart = OpenLayers.Function.False, b = !this.stopDown) : (this.started = !1, this.last = this.start = null);
        return b
    },
    dragmove: function (a) {
        this.lastMoveEvt = a;
        if (this.started && !this.timeoutId && (a.xy.x != this.last.x || a.xy.y != this.last.y))!0 === this.documentDrag && this.documentEvents && (a.element === document ? (this.adjustXY(a), this.setEvent(a)) : this.removeDocumentEvents()), 0 < this.interval && (this.timeoutId = setTimeout(OpenLayers.Function.bind(this.removeTimeout, this), this.interval)), this.dragging = !0, this.move(a), this.callback("move", [a.xy]), this.oldOnselectstart || (this.oldOnselectstart =
            document.onselectstart, document.onselectstart = OpenLayers.Function.False), this.last = a.xy;
        return !0
    },
    dragend: function (a) {
        if (this.started) {
            !0 === this.documentDrag && this.documentEvents && (this.adjustXY(a), this.removeDocumentEvents());
            var b = this.start != this.last;
            this.dragging = this.started = !1;
            OpenLayers.Element.removeClass(this.map.viewPortDiv, "olDragDown");
            this.up(a);
            this.callback("up", [a.xy]);
            b && this.callback("done", [a.xy]);
            document.onselectstart = this.oldOnselectstart
        }
        return !0
    },
    down: function () {
    },
    move: function () {
    },
    up: function () {
    },
    out: function () {
    },
    mousedown: function (a) {
        return this.dragstart(a)
    },
    touchstart: function (a) {
        this.touch || (this.touch = !0, this.map.events.un({
            mousedown: this.mousedown,
            mouseup: this.mouseup,
            mousemove: this.mousemove,
            click: this.click,
            scope: this
        }));
        return this.dragstart(a)
    },
    mousemove: function (a) {
        return this.dragmove(a)
    },
    touchmove: function (a) {
        return this.dragmove(a)
    },
    removeTimeout: function () {
        this.timeoutId = null;
        this.dragging && this.mousemove(this.lastMoveEvt)
    },
    mouseup: function (a) {
        return this.dragend(a)
    },
    touchend: function (a) {
        a.xy = this.last;
        return this.dragend(a)
    },
    mouseout: function (a) {
        if (this.started && OpenLayers.Util.mouseLeft(a, this.map.viewPortDiv))if (!0 === this.documentDrag)this.addDocumentEvents(); else {
            var b = this.start != this.last;
            this.dragging = this.started = !1;
            OpenLayers.Element.removeClass(this.map.viewPortDiv, "olDragDown");
            this.out(a);
            this.callback("out", []);
            b && this.callback("done", [a.xy]);
            document.onselectstart && (document.onselectstart = this.oldOnselectstart)
        }
        return !0
    },
    click: function () {
        return this.start ==
            this.last
    },
    activate: function () {
        var a = !1;
        OpenLayers.Handler.prototype.activate.apply(this, arguments) && (this.dragging = !1, a = !0);
        return a
    },
    deactivate: function () {
        var a = !1;
        OpenLayers.Handler.prototype.deactivate.apply(this, arguments) && (this.dragging = this.started = this.touch = !1, this.last = this.start = null, a = !0, OpenLayers.Element.removeClass(this.map.viewPortDiv, "olDragDown"));
        return a
    },
    adjustXY: function (a) {
        var b = OpenLayers.Util.pagePosition(this.map.viewPortDiv);
        a.xy.x -= b[0];
        a.xy.y -= b[1]
    },
    addDocumentEvents: function () {
        OpenLayers.Element.addClass(document.body,
            "olDragDown");
        this.documentEvents = !0;
        OpenLayers.Event.observe(document, "mousemove", this._docMove);
        OpenLayers.Event.observe(document, "mouseup", this._docUp)
    },
    removeDocumentEvents: function () {
        OpenLayers.Element.removeClass(document.body, "olDragDown");
        this.documentEvents = !1;
        OpenLayers.Event.stopObserving(document, "mousemove", this._docMove);
        OpenLayers.Event.stopObserving(document, "mouseup", this._docUp)
    },
    CLASS_NAME: "OpenLayers.Handler.Drag"
});
OpenLayers.Handler.Pinch = OpenLayers.Class(OpenLayers.Handler, {
    started: !1, stopDown: !1, pinching: !1, last: null, start: null, touchstart: function (a) {
        var b = !0;
        this.pinching = !1;
        OpenLayers.Event.isMultiTouch(a) ? (this.started = !0, this.last = this.start = {
            distance: this.getDistance(a.touches),
            delta: 0,
            scale: 1
        }, this.callback("start", [a, this.start]), b = !this.stopDown) : (this.started = !1, this.last = this.start = null);
        OpenLayers.Event.stop(a);
        return b
    }, touchmove: function (a) {
        if (this.started && OpenLayers.Event.isMultiTouch(a)) {
            this.pinching = !0;
            var b = this.getPinchData(a);
            this.callback("move", [a, b]);
            this.last = b;
            OpenLayers.Event.stop(a)
        }
        return !0
    }, touchend: function (a) {
        this.started && (this.pinching = this.started = !1, this.callback("done", [a, this.start, this.last]), this.last = this.start = null);
        return !0
    }, activate: function () {
        var a = !1;
        OpenLayers.Handler.prototype.activate.apply(this, arguments) && (this.pinching = !1, a = !0);
        return a
    }, deactivate: function () {
        var a = !1;
        OpenLayers.Handler.prototype.deactivate.apply(this, arguments) && (this.pinching = this.started = !1, this.last = this.start = null, a = !0);
        return a
    }, getDistance: function (a) {
        var b = a[0], a = a[1];
        return Math.sqrt(Math.pow(b.clientX - a.clientX, 2) + Math.pow(b.clientY - a.clientY, 2))
    }, getPinchData: function (a) {
        a = this.getDistance(a.touches);
        return {distance: a, delta: this.last.distance - a, scale: a / this.start.distance}
    }, CLASS_NAME: "OpenLayers.Handler.Pinch"
});
OpenLayers.Handler.RegularPolygon = OpenLayers.Class(OpenLayers.Handler.Drag, {
    sides: 4,
    radius: null,
    snapAngle: null,
    snapToggle: "shiftKey",
    layerOptions: null,
    persist: !1,
    irregular: !1,
    citeCompliant: !1,
    angle: null,
    fixedRadius: !1,
    feature: null,
    layer: null,
    origin: null,
    initialize: function (a, b, c) {
        if (!c || !c.layerOptions || !c.layerOptions.styleMap)this.style = OpenLayers.Util.extend(OpenLayers.Feature.Vector.style["default"], {});
        OpenLayers.Handler.Drag.prototype.initialize.apply(this, [a, b, c]);
        this.options = c ? c : {}
    },
    setOptions: function (a) {
        OpenLayers.Util.extend(this.options,
            a);
        OpenLayers.Util.extend(this, a)
    },
    activate: function () {
        var a = !1;
        OpenLayers.Handler.Drag.prototype.activate.apply(this, arguments) && (a = OpenLayers.Util.extend({
            displayInLayerSwitcher: !1,
            calculateInRange: OpenLayers.Function.True,
            wrapDateLine: this.citeCompliant
        }, this.layerOptions), this.layer = new OpenLayers.Layer.Vector(this.CLASS_NAME, a), this.map.addLayer(this.layer), a = !0);
        return a
    },
    deactivate: function () {
        var a = !1;
        OpenLayers.Handler.Drag.prototype.deactivate.apply(this, arguments) && (this.dragging && this.cancel(),
        null != this.layer.map && (this.layer.destroy(!1), this.feature && this.feature.destroy()), this.feature = this.layer = null, a = !0);
        return a
    },
    down: function (a) {
        this.fixedRadius = !!this.radius;
        a = this.layer.getLonLatFromViewPortPx(a.xy);
        this.origin = new OpenLayers.Geometry.Point(a.lon, a.lat);
        if (!this.fixedRadius || this.irregular)this.radius = this.map.getResolution();
        this.persist && this.clear();
        this.feature = new OpenLayers.Feature.Vector;
        this.createGeometry();
        this.callback("create", [this.origin, this.feature]);
        this.layer.addFeatures([this.feature],
            {silent: !0});
        this.layer.drawFeature(this.feature, this.style)
    },
    move: function (a) {
        var b = this.layer.getLonLatFromViewPortPx(a.xy), b = new OpenLayers.Geometry.Point(b.lon, b.lat);
        this.irregular ? (a = Math.sqrt(2) * Math.abs(b.y - this.origin.y) / 2, this.radius = Math.max(this.map.getResolution() / 2, a)) : this.fixedRadius ? this.origin = b : (this.calculateAngle(b, a), this.radius = Math.max(this.map.getResolution() / 2, b.distanceTo(this.origin)));
        this.modifyGeometry();
        this.irregular && (a = b.x - this.origin.x, b = b.y - this.origin.y, this.feature.geometry.resize(1,
            this.origin, 0 == b ? a / (this.radius * Math.sqrt(2)) : a / b), this.feature.geometry.move(a / 2, b / 2));
        this.layer.drawFeature(this.feature, this.style)
    },
    up: function (a) {
        this.finalize();
        this.start == this.last && this.callback("done", [a.xy])
    },
    out: function () {
        this.finalize()
    },
    createGeometry: function () {
        this.angle = Math.PI * (1 / this.sides - 0.5);
        this.snapAngle && (this.angle += this.snapAngle * (Math.PI / 180));
        this.feature.geometry = OpenLayers.Geometry.Polygon.createRegularPolygon(this.origin, this.radius, this.sides, this.snapAngle)
    },
    modifyGeometry: function () {
        var a,
            b, c = this.feature.geometry.components[0];
        c.components.length != this.sides + 1 && (this.createGeometry(), c = this.feature.geometry.components[0]);
        for (var d = 0; d < this.sides; ++d)b = c.components[d], a = this.angle + 2 * d * Math.PI / this.sides, b.x = this.origin.x + this.radius * Math.cos(a), b.y = this.origin.y + this.radius * Math.sin(a), b.clearBounds()
    },
    calculateAngle: function (a, b) {
        var c = Math.atan2(a.y - this.origin.y, a.x - this.origin.x);
        if (this.snapAngle && this.snapToggle && !b[this.snapToggle]) {
            var d = Math.PI / 180 * this.snapAngle;
            this.angle =
                Math.round(c / d) * d
        } else this.angle = c
    },
    cancel: function () {
        this.callback("cancel", null);
        this.finalize()
    },
    finalize: function () {
        this.origin = null;
        this.radius = this.options.radius
    },
    clear: function () {
        this.layer && (this.layer.renderer.clear(), this.layer.destroyFeatures())
    },
    callback: function (a) {
        this.callbacks[a] && this.callbacks[a].apply(this.control, [this.feature.geometry.clone()]);
        !this.persist && ("done" == a || "cancel" == a) && this.clear()
    },
    CLASS_NAME: "OpenLayers.Handler.RegularPolygon"
});
OpenLayers.Handler.Box = OpenLayers.Class(OpenLayers.Handler, {
    dragHandler: null, boxDivClassName: "olHandlerBoxZoomBox", boxOffsets: null, initialize: function (a, b, c) {
        OpenLayers.Handler.prototype.initialize.apply(this, arguments);
        this.dragHandler = new OpenLayers.Handler.Drag(this, {
            down: this.startBox,
            move: this.moveBox,
            out: this.removeBox,
            up: this.endBox
        }, {keyMask: this.keyMask})
    }, destroy: function () {
        OpenLayers.Handler.prototype.destroy.apply(this, arguments);
        this.dragHandler && (this.dragHandler.destroy(), this.dragHandler =
            null)
    }, setMap: function (a) {
        OpenLayers.Handler.prototype.setMap.apply(this, arguments);
        this.dragHandler && this.dragHandler.setMap(a)
    }, startBox: function () {
        this.callback("start", []);
        this.zoomBox = OpenLayers.Util.createDiv("zoomBox", {x: -9999, y: -9999});
        this.zoomBox.className = this.boxDivClassName;
        this.zoomBox.style.zIndex = this.map.Z_INDEX_BASE.Popup - 1;
        this.map.viewPortDiv.appendChild(this.zoomBox);
        OpenLayers.Element.addClass(this.map.viewPortDiv, "olDrawBox")
    }, moveBox: function (a) {
        var b = this.dragHandler.start.x,
            c = this.dragHandler.start.y, d = Math.abs(b - a.x), e = Math.abs(c - a.y), f = this.getBoxOffsets();
        this.zoomBox.style.width = d + f.width + 1 + "px";
        this.zoomBox.style.height = e + f.height + 1 + "px";
        this.zoomBox.style.left = (a.x < b ? b - d - f.left : b - f.left) + "px";
        this.zoomBox.style.top = (a.y < c ? c - e - f.top : c - f.top) + "px"
    }, endBox: function (a) {
        var b;
        if (5 < Math.abs(this.dragHandler.start.x - a.x) || 5 < Math.abs(this.dragHandler.start.y - a.y)) {
            var c = this.dragHandler.start;
            b = Math.min(c.y, a.y);
            var d = Math.max(c.y, a.y), e = Math.min(c.x, a.x), a = Math.max(c.x,
                a.x);
            b = new OpenLayers.Bounds(e, d, a, b)
        } else b = this.dragHandler.start.clone();
        this.removeBox();
        this.callback("done", [b])
    }, removeBox: function () {
        this.map.viewPortDiv.removeChild(this.zoomBox);
        this.boxOffsets = this.zoomBox = null;
        OpenLayers.Element.removeClass(this.map.viewPortDiv, "olDrawBox")
    }, activate: function () {
        return OpenLayers.Handler.prototype.activate.apply(this, arguments) ? (this.dragHandler.activate(), !0) : !1
    }, deactivate: function () {
        return OpenLayers.Handler.prototype.deactivate.apply(this, arguments) ?
            (this.dragHandler.deactivate() && this.zoomBox && this.removeBox(), !0) : !1
    }, getBoxOffsets: function () {
        if (!this.boxOffsets) {
            var a = document.createElement("div");
            a.style.position = "absolute";
            a.style.border = "1px solid black";
            a.style.width = "3px";
            document.body.appendChild(a);
            var b = 3 == a.clientWidth;
            document.body.removeChild(a);
            var a = parseInt(OpenLayers.Element.getStyle(this.zoomBox, "border-left-width")), c = parseInt(OpenLayers.Element.getStyle(this.zoomBox, "border-right-width")), d = parseInt(OpenLayers.Element.getStyle(this.zoomBox,
                "border-top-width")), e = parseInt(OpenLayers.Element.getStyle(this.zoomBox, "border-bottom-width"));
            this.boxOffsets = {
                left: a,
                right: c,
                top: d,
                bottom: e,
                width: !1 === b ? a + c : 0,
                height: !1 === b ? d + e : 0
            }
        }
        return this.boxOffsets
    }, CLASS_NAME: "OpenLayers.Handler.Box"
});
OpenLayers.Handler.MouseWheel = OpenLayers.Class(OpenLayers.Handler, {
    wheelListener: null, mousePosition: null, interval: 0, delta: 0, cumulative: !0, initialize: function (a, b, c) {
        OpenLayers.Handler.prototype.initialize.apply(this, arguments);
        this.wheelListener = OpenLayers.Function.bindAsEventListener(this.onWheelEvent, this)
    }, destroy: function () {
        OpenLayers.Handler.prototype.destroy.apply(this, arguments);
        this.wheelListener = null
    }, onWheelEvent: function (a) {
        if (this.map && this.checkModifiers(a)) {
            for (var b = !1, c = !1, d = !1, e =
                OpenLayers.Event.element(a); null != e && !d && !b;) {
                if (!b)try {
                    var f = e.currentStyle ? e.currentStyle.overflow : document.defaultView.getComputedStyle(e, null).getPropertyValue("overflow"), b = f && "auto" == f || "scroll" == f
                } catch (g) {
                }
                if (!c)for (var d = 0, h = this.map.layers.length; d < h; d++)if (e == this.map.layers[d].div || e == this.map.layers[d].pane) {
                    c = !0;
                    break
                }
                d = e == this.map.div;
                e = e.parentNode
            }
            !b && d && (c && (b = 0, a || (a = window.event), a.wheelDelta ? (b = a.wheelDelta / 120, window.opera && 9.2 > window.opera.version() && (b = -b)) : a.detail && (b = -a.detail /
            3), this.delta += b, this.interval ? (window.clearTimeout(this._timeoutId), this._timeoutId = window.setTimeout(OpenLayers.Function.bind(function () {
                this.wheelZoom(a)
            }, this), this.interval)) : this.wheelZoom(a)), OpenLayers.Event.stop(a))
        }
    }, wheelZoom: function (a) {
        var b = this.delta;
        this.delta = 0;
        b && (this.mousePosition && (a.xy = this.mousePosition), a.xy || (a.xy = this.map.getPixelFromLonLat(this.map.getCenter())), 0 > b ? this.callback("down", [a, this.cumulative ? b : -1]) : this.callback("up", [a, this.cumulative ? b : 1]))
    }, mousemove: function (a) {
        this.mousePosition =
            a.xy
    }, activate: function (a) {
        if (OpenLayers.Handler.prototype.activate.apply(this, arguments)) {
            var b = this.wheelListener;
            OpenLayers.Event.observe(window, "DOMMouseScroll", b);
            OpenLayers.Event.observe(window, "mousewheel", b);
            OpenLayers.Event.observe(document, "mousewheel", b);
            return !0
        }
        return !1
    }, deactivate: function (a) {
        if (OpenLayers.Handler.prototype.deactivate.apply(this, arguments)) {
            var b = this.wheelListener;
            OpenLayers.Event.stopObserving(window, "DOMMouseScroll", b);
            OpenLayers.Event.stopObserving(window, "mousewheel",
                b);
            OpenLayers.Event.stopObserving(document, "mousewheel", b);
            return !0
        }
        return !1
    }, CLASS_NAME: "OpenLayers.Handler.MouseWheel"
});
OpenLayers.Handler.Keyboard = OpenLayers.Class(OpenLayers.Handler, {
    KEY_EVENTS: ["keydown", "keyup"], eventListener: null, observeElement: null, initialize: function (a, b, c) {
        OpenLayers.Handler.prototype.initialize.apply(this, arguments);
        this.eventListener = OpenLayers.Function.bindAsEventListener(this.handleKeyEvent, this)
    }, destroy: function () {
        this.deactivate();
        this.eventListener = null;
        OpenLayers.Handler.prototype.destroy.apply(this, arguments)
    }, activate: function () {
        if (OpenLayers.Handler.prototype.activate.apply(this,
                arguments)) {
            this.observeElement = this.observeElement || document;
            for (var a = 0, b = this.KEY_EVENTS.length; a < b; a++)OpenLayers.Event.observe(this.observeElement, this.KEY_EVENTS[a], this.eventListener);
            return !0
        }
        return !1
    }, deactivate: function () {
        var a = !1;
        if (OpenLayers.Handler.prototype.deactivate.apply(this, arguments)) {
            for (var a = 0, b = this.KEY_EVENTS.length; a < b; a++)OpenLayers.Event.stopObserving(this.observeElement, this.KEY_EVENTS[a], this.eventListener);
            a = !0
        }
        return a
    }, handleKeyEvent: function (a) {
        this.checkModifiers(a) &&
        this.callback(a.type, [a])
    }, CLASS_NAME: "OpenLayers.Handler.Keyboard"
});
OpenLayers.Control = OpenLayers.Class({
    id: null,
    map: null,
    div: null,
    type: null,
    allowSelection: !1,
    displayClass: "",
    title: "",
    autoActivate: !1,
    active: null,
    handler: null,
    eventListeners: null,
    events: null,
    initialize: function (a) {
        this.displayClass = this.CLASS_NAME.replace("OpenLayers.", "ol").replace(/\./g, "");
        OpenLayers.Util.extend(this, a);
        this.events = new OpenLayers.Events(this);
        if (this.eventListeners instanceof Object)this.events.on(this.eventListeners);
        null == this.id && (this.id = OpenLayers.Util.createUniqueID(this.CLASS_NAME +
        "_"))
    },
    destroy: function () {
        this.events && (this.eventListeners && this.events.un(this.eventListeners), this.events.destroy(), this.events = null);
        this.eventListeners = null;
        this.handler && (this.handler.destroy(), this.handler = null);
        if (this.handlers) {
            for (var a in this.handlers)this.handlers.hasOwnProperty(a) && "function" == typeof this.handlers[a].destroy && this.handlers[a].destroy();
            this.handlers = null
        }
        this.map && (this.map.removeControl(this), this.map = null);
        this.div = null
    },
    setMap: function (a) {
        this.map = a;
        this.handler &&
        this.handler.setMap(a)
    },
    draw: function (a) {
        null == this.div && (this.div = OpenLayers.Util.createDiv(this.id), this.div.className = this.displayClass, this.allowSelection || (this.div.className += " olControlNoSelect", this.div.setAttribute("unselectable", "on", 0), this.div.onselectstart = OpenLayers.Function.False), "" != this.title && (this.div.title = this.title));
        null != a && (this.position = a.clone());
        this.moveTo(this.position);
        return this.div
    },
    moveTo: function (a) {
        null != a && null != this.div && (this.div.style.left = a.x + "px", this.div.style.top =
            a.y + "px")
    },
    activate: function () {
        if (this.active)return !1;
        this.handler && this.handler.activate();
        this.active = !0;
        this.map && OpenLayers.Element.addClass(this.map.viewPortDiv, this.displayClass.replace(/ /g, "") + "Active");
        this.events.triggerEvent("activate");
        return !0
    },
    deactivate: function () {
        return this.active ? (this.handler && this.handler.deactivate(), this.active = !1, this.map && OpenLayers.Element.removeClass(this.map.viewPortDiv, this.displayClass.replace(/ /g, "") + "Active"), this.events.triggerEvent("deactivate"),
            !0) : !1
    },
    CLASS_NAME: "OpenLayers.Control"
});
OpenLayers.Control.TYPE_BUTTON = 1;
OpenLayers.Control.TYPE_TOGGLE = 2;
OpenLayers.Control.TYPE_TOOL = 3;
OpenLayers.Control.Attribution = OpenLayers.Class(OpenLayers.Control, {
    separator: ", ", template: "${layers}", destroy: function () {
        this.map.events.un({
            removelayer: this.updateAttribution,
            addlayer: this.updateAttribution,
            changelayer: this.updateAttribution,
            changebaselayer: this.updateAttribution,
            scope: this
        });
        OpenLayers.Control.prototype.destroy.apply(this, arguments)
    }, draw: function () {
        OpenLayers.Control.prototype.draw.apply(this, arguments);
        this.map.events.on({
            changebaselayer: this.updateAttribution, changelayer: this.updateAttribution,
            addlayer: this.updateAttribution, removelayer: this.updateAttribution, scope: this
        });
        this.updateAttribution();
        return this.div
    }, updateAttribution: function () {
        var a = [];
        if (this.map && this.map.layers) {
            for (var b = 0, c = this.map.layers.length; b < c; b++) {
                var d = this.map.layers[b];
                d.attribution && d.getVisibility() && -1 === OpenLayers.Util.indexOf(a, d.attribution) && a.push(d.attribution)
            }
            this.div.innerHTML = OpenLayers.String.format(this.template, {layers: a.join(this.separator)})
        }
    }, CLASS_NAME: "OpenLayers.Control.Attribution"
});
OpenLayers.Control.Button = OpenLayers.Class(OpenLayers.Control, {
    type: OpenLayers.Control.TYPE_BUTTON,
    trigger: function () {
    },
    CLASS_NAME: "OpenLayers.Control.Button"
});
OpenLayers.Control.CacheRead = OpenLayers.Class(OpenLayers.Control, {
    fetchEvent: "tileloadstart", layers: null, autoActivate: !0, setMap: function (a) {
        OpenLayers.Control.prototype.setMap.apply(this, arguments);
        var b, c = this.layers || a.layers;
        for (b = c.length - 1; 0 <= b; --b)this.addLayer({layer: c[b]});
        if (!this.layers)a.events.on({addlayer: this.addLayer, removeLayer: this.removeLayer, scope: this})
    }, addLayer: function (a) {
        a.layer.events.register(this.fetchEvent, this, this.fetch)
    }, removeLayer: function (a) {
        a.layer.events.unregister(this.fetchEvent,
            this, this.fetch)
    }, fetch: function (a) {
        if (this.active && window.localStorage && a.tile instanceof OpenLayers.Tile.Image) {
            var b = a.tile, c = b.url;
            !b.layer.crossOriginKeyword && OpenLayers.ProxyHost && 0 === c.indexOf(OpenLayers.ProxyHost) && (c = OpenLayers.Control.CacheWrite.urlMap[c]);
            if (c = window.localStorage.getItem("olCache_" + c))b.url = c, "tileerror" === a.type && b.setImgSrc(c)
        }
    }, destroy: function () {
        if (this.layers || this.map) {
            var a, b = this.layers || this.map.layers;
            for (a = b.length - 1; 0 <= a; --a)this.removeLayer({layer: b[a]})
        }
        this.map &&
        this.map.events.un({addlayer: this.addLayer, removeLayer: this.removeLayer, scope: this});
        OpenLayers.Control.prototype.destroy.apply(this, arguments)
    }, CLASS_NAME: "OpenLayers.Control.CacheRead"
});
OpenLayers.Control.CacheWrite = OpenLayers.Class(OpenLayers.Control, {
    layers: null, imageFormat: "image/png", quotaRegEx: /quota/i, setMap: function (a) {
        OpenLayers.Control.prototype.setMap.apply(this, arguments);
        var b, c = this.layers || a.layers;
        for (b = c.length - 1; 0 <= b; --b)this.addLayer({layer: c[b]});
        if (!this.layers)a.events.on({addlayer: this.addLayer, removeLayer: this.removeLayer, scope: this})
    }, addLayer: function (a) {
        a.layer.events.on({tileloadstart: this.makeSameOrigin, tileloaded: this.cache, scope: this})
    }, removeLayer: function (a) {
        a.layer.events.un({
            tileloadstart: this.makeSameOrigin,
            tileloaded: this.cache, scope: this
        })
    }, makeSameOrigin: function (a) {
        if (this.active && (a = a.tile, a instanceof OpenLayers.Tile.Image && !a.crossOriginKeyword && "data:" !== a.url.substr(0, 5))) {
            var b = OpenLayers.Request.makeSameOrigin(a.url, OpenLayers.ProxyHost);
            OpenLayers.Control.CacheWrite.urlMap[b] = a.url;
            a.url = b
        }
    }, cache: function (a) {
        if (this.active && window.localStorage && (a = a.tile, a instanceof OpenLayers.Tile.Image && "data:" !== a.url.substr(0, 5)))try {
            var b = a.getCanvasContext();
            if (b) {
                var c = OpenLayers.Control.CacheWrite.urlMap;
                window.localStorage.setItem("olCache_" + (c[a.url] || a.url), b.canvas.toDataURL(this.imageFormat));
                delete c[a.url]
            }
        } catch (d) {
            (b = d.name || d.message) && this.quotaRegEx.test(b) ? this.events.triggerEvent("cachefull", {tile: a}) : OpenLayers.Console.error(d.toString())
        }
    }, destroy: function () {
        if (this.layers || this.map) {
            var a, b = this.layers || this.map.layers;
            for (a = b.length - 1; 0 <= a; --a)this.removeLayer({layer: b[a]})
        }
        this.map && this.map.events.un({addlayer: this.addLayer, removeLayer: this.removeLayer, scope: this});
        OpenLayers.Control.prototype.destroy.apply(this,
            arguments)
    }, CLASS_NAME: "OpenLayers.Control.CacheWrite"
});
OpenLayers.Control.CacheWrite.clearCache = function () {
    if (window.localStorage) {
        var a, b;
        for (a = window.localStorage.length - 1; 0 <= a; --a)b = window.localStorage.key(a), "olCache_" === b.substr(0, 8) && window.localStorage.removeItem(b)
    }
};
OpenLayers.Control.CacheWrite.urlMap = {};
OpenLayers.Control.ZoomBox = OpenLayers.Class(OpenLayers.Control, {
    type: OpenLayers.Control.TYPE_TOOL, out: !1, keyMask: null, alwaysZoom: !1, draw: function () {
        this.handler = new OpenLayers.Handler.Box(this, {done: this.zoomBox}, {keyMask: this.keyMask})
    }, zoomBox: function (a) {
        if (a instanceof OpenLayers.Bounds) {
            var b;
            if (this.out) {
                b = Math.abs(a.right - a.left);
                var c = Math.abs(a.top - a.bottom);
                b = Math.min(this.map.size.h / c, this.map.size.w / b);
                var c = this.map.getExtent(), d = this.map.getLonLatFromPixel(a.getCenterPixel()), a = d.lon -
                    c.getWidth() / 2 * b, e = d.lon + c.getWidth() / 2 * b, f = d.lat - c.getHeight() / 2 * b;
                b = d.lat + c.getHeight() / 2 * b;
                b = new OpenLayers.Bounds(a, f, e, b)
            } else b = this.map.getLonLatFromPixel({
                x: a.left,
                y: a.bottom
            }), c = this.map.getLonLatFromPixel({
                x: a.right,
                y: a.top
            }), b = new OpenLayers.Bounds(b.lon, b.lat, c.lon, c.lat);
            c = this.map.getZoom();
            this.map.zoomToExtent(b);
            c == this.map.getZoom() && !0 == this.alwaysZoom && this.map.zoomTo(c + (this.out ? -1 : 1))
        } else this.out ? this.map.setCenter(this.map.getLonLatFromPixel(a), this.map.getZoom() - 1) : this.map.setCenter(this.map.getLonLatFromPixel(a),
            this.map.getZoom() + 1)
    }, CLASS_NAME: "OpenLayers.Control.ZoomBox"
});
OpenLayers.Control.ZoomToMaxExtent = OpenLayers.Class(OpenLayers.Control, {
    type: OpenLayers.Control.TYPE_BUTTON,
    trigger: function () {
        this.map && this.map.zoomToMaxExtent()
    },
    CLASS_NAME: "OpenLayers.Control.ZoomToMaxExtent"
});
OpenLayers.Control.DragPan = OpenLayers.Class(OpenLayers.Control, {
    type: OpenLayers.Control.TYPE_TOOL,
    panned: !1,
    interval: 1,
    documentDrag: !1,
    kinetic: null,
    enableKinetic: !1,
    kineticInterval: 10,
    draw: function () {
        if (this.enableKinetic) {
            var a = {interval: this.kineticInterval};
            "object" === typeof this.enableKinetic && (a = OpenLayers.Util.extend(a, this.enableKinetic));
            this.kinetic = new OpenLayers.Kinetic(a)
        }
        this.handler = new OpenLayers.Handler.Drag(this, {
            move: this.panMap,
            done: this.panMapDone,
            down: this.panMapStart
        }, {
            interval: this.interval,
            documentDrag: this.documentDrag
        })
    },
    panMapStart: function () {
        this.kinetic && this.kinetic.begin()
    },
    panMap: function (a) {
        this.kinetic && this.kinetic.update(a);
        this.panned = !0;
        this.map.pan(this.handler.last.x - a.x, this.handler.last.y - a.y, {dragging: !0, animate: !1})
    },
    panMapDone: function (a) {
        if (this.panned) {
            var b = null;
            this.kinetic && (b = this.kinetic.end(a));
            this.map.pan(this.handler.last.x - a.x, this.handler.last.y - a.y, {dragging: !!b, animate: !1});
            if (b) {
                var c = this;
                this.kinetic.move(b, function (a, b, f) {
                    c.map.pan(a, b, {
                        dragging: !f,
                        animate: !1
                    })
                })
            }
            this.panned = !1
        }
    },
    CLASS_NAME: "OpenLayers.Control.DragPan"
});
OpenLayers.Control.Navigation = OpenLayers.Class(OpenLayers.Control, {
    dragPan: null,
    dragPanOptions: null,
    pinchZoom: null,
    pinchZoomOptions: null,
    documentDrag: !1,
    zoomBox: null,
    zoomBoxEnabled: !0,
    zoomWheelEnabled: !0,
    mouseWheelOptions: null,
    handleRightClicks: !1,
    zoomBoxKeyMask: OpenLayers.Handler.MOD_SHIFT,
    autoActivate: !0,
    initialize: function (a) {
        this.handlers = {};
        OpenLayers.Control.prototype.initialize.apply(this, arguments)
    },
    destroy: function () {
        this.deactivate();
        this.dragPan && this.dragPan.destroy();
        this.dragPan = null;
        this.zoomBox && this.zoomBox.destroy();
        this.zoomBox = null;
        this.pinchZoom && this.pinchZoom.destroy();
        this.pinchZoom = null;
        OpenLayers.Control.prototype.destroy.apply(this, arguments)
    },
    activate: function () {
        this.dragPan.activate();
        this.zoomWheelEnabled && this.handlers.wheel.activate();
        this.handlers.click.activate();
        this.zoomBoxEnabled && this.zoomBox.activate();
        this.pinchZoom && this.pinchZoom.activate();
        return OpenLayers.Control.prototype.activate.apply(this, arguments)
    },
    deactivate: function () {
        this.pinchZoom && this.pinchZoom.deactivate();
        this.zoomBox.deactivate();
        this.dragPan.deactivate();
        this.handlers.click.deactivate();
        this.handlers.wheel.deactivate();
        return OpenLayers.Control.prototype.deactivate.apply(this, arguments)
    },
    draw: function () {
        this.handleRightClicks && (this.map.viewPortDiv.oncontextmenu = OpenLayers.Function.False);
        this.handlers.click = new OpenLayers.Handler.Click(this, {
            click: this.defaultClick,
            dblclick: this.defaultDblClick,
            dblrightclick: this.defaultDblRightClick
        }, {"double": !0, stopDouble: !0});
        this.dragPan = new OpenLayers.Control.DragPan(OpenLayers.Util.extend({
            map: this.map,
            documentDrag: this.documentDrag
        }, this.dragPanOptions));
        this.zoomBox = new OpenLayers.Control.ZoomBox({map: this.map, keyMask: this.zoomBoxKeyMask});
        this.dragPan.draw();
        this.zoomBox.draw();
        this.handlers.wheel = new OpenLayers.Handler.MouseWheel(this, {
            up: this.wheelUp,
            down: this.wheelDown
        }, this.mouseWheelOptions);
        OpenLayers.Control.PinchZoom && (this.pinchZoom = new OpenLayers.Control.PinchZoom(OpenLayers.Util.extend({map: this.map}, this.pinchZoomOptions)))
    },
    defaultClick: function (a) {
        a.lastTouches && 2 == a.lastTouches.length &&
        this.map.zoomOut()
    },
    defaultDblClick: function (a) {
        this.map.setCenter(this.map.getLonLatFromViewPortPx(a.xy), this.map.zoom + 1)
    },
    defaultDblRightClick: function (a) {
        this.map.setCenter(this.map.getLonLatFromViewPortPx(a.xy), this.map.zoom - 1)
    },
    wheelChange: function (a, b) {
        var c = this.map.getZoom(), d = this.map.getZoom() + Math.round(b), d = Math.max(d, 0), d = Math.min(d, this.map.getNumZoomLevels());
        if (d !== c) {
            var e = this.map.getSize(), c = e.w / 2 - a.xy.x, e = a.xy.y - e.h / 2, f = this.map.baseLayer.getResolutionForZoom(d), g = this.map.getLonLatFromPixel(a.xy);
            this.map.setCenter(new OpenLayers.LonLat(g.lon + c * f, g.lat + e * f), d)
        }
    },
    wheelUp: function (a, b) {
        this.wheelChange(a, b || 1)
    },
    wheelDown: function (a, b) {
        this.wheelChange(a, b || -1)
    },
    disableZoomBox: function () {
        this.zoomBoxEnabled = !1;
        this.zoomBox.deactivate()
    },
    enableZoomBox: function () {
        this.zoomBoxEnabled = !0;
        this.active && this.zoomBox.activate()
    },
    disableZoomWheel: function () {
        this.zoomWheelEnabled = !1;
        this.handlers.wheel.deactivate()
    },
    enableZoomWheel: function () {
        this.zoomWheelEnabled = !0;
        this.active && this.handlers.wheel.activate()
    },
    CLASS_NAME: "OpenLayers.Control.Navigation"
});
OpenLayers.Control.PinchZoom = OpenLayers.Class(OpenLayers.Control, {
    type: OpenLayers.Control.TYPE_TOOL,
    containerCenter: null,
    pinchOrigin: null,
    currentCenter: null,
    autoActivate: !0,
    initialize: function (a) {
        OpenLayers.Control.prototype.initialize.apply(this, arguments);
        this.handler = new OpenLayers.Handler.Pinch(this, {
            start: this.pinchStart,
            move: this.pinchMove,
            done: this.pinchDone
        }, this.handlerOptions)
    },
    activate: function () {
        var a = OpenLayers.Control.prototype.activate.apply(this, arguments);
        a && (this.map.events.on({
            moveend: this.updateContainerCenter,
            scope: this
        }), this.updateContainerCenter());
        return a
    },
    deactivate: function () {
        var a = OpenLayers.Control.prototype.deactivate.apply(this, arguments);
        this.map && this.map.events && this.map.events.un({moveend: this.updateContainerCenter, scope: this});
        return a
    },
    updateContainerCenter: function () {
        var a = this.map.layerContainerDiv;
        this.containerCenter = {x: parseInt(a.style.left, 10) + 50, y: parseInt(a.style.top, 10) + 50}
    },
    pinchStart: function (a) {
        this.currentCenter = this.pinchOrigin = a.xy
    },
    pinchMove: function (a, b) {
        var c = b.scale,
            d = this.containerCenter, e = this.pinchOrigin, f = a.xy, g = Math.round(f.x - e.x + (c - 1) * (d.x - e.x)), d = Math.round(f.y - e.y + (c - 1) * (d.y - e.y));
        this.applyTransform("translate(" + g + "px, " + d + "px) scale(" + c + ")");
        this.currentCenter = f
    },
    applyTransform: function (a) {
        var b = this.map.layerContainerDiv.style;
        b["-webkit-transform"] = a;
        b["-moz-transform"] = a
    },
    pinchDone: function (a, b, c) {
        this.applyTransform("");
        a = this.map.getZoomForResolution(this.map.getResolution() / c.scale, !0);
        if (a !== this.map.getZoom() || !this.currentCenter.equals(this.pinchOrigin)) {
            var b =
                this.map.getResolutionForZoom(a), c = this.map.getLonLatFromPixel(this.pinchOrigin), d = this.currentCenter, e = this.map.getSize();
            c.lon += b * (e.w / 2 - d.x);
            c.lat -= b * (e.h / 2 - d.y);
            this.map.div.clientWidth = this.map.div.clientWidth;
            this.map.setCenter(c, a)
        }
    },
    CLASS_NAME: "OpenLayers.Control.PinchZoom"
});
OpenLayers.Control.TouchNavigation = OpenLayers.Class(OpenLayers.Control, {
    dragPan: null,
    dragPanOptions: null,
    pinchZoom: null,
    pinchZoomOptions: null,
    clickHandlerOptions: null,
    documentDrag: !1,
    autoActivate: !0,
    initialize: function (a) {
        this.handlers = {};
        OpenLayers.Control.prototype.initialize.apply(this, arguments)
    },
    destroy: function () {
        this.deactivate();
        this.dragPan && this.dragPan.destroy();
        this.dragPan = null;
        this.pinchZoom && (this.pinchZoom.destroy(), delete this.pinchZoom);
        OpenLayers.Control.prototype.destroy.apply(this,
            arguments)
    },
    activate: function () {
        return OpenLayers.Control.prototype.activate.apply(this, arguments) ? (this.dragPan.activate(), this.handlers.click.activate(), this.pinchZoom.activate(), !0) : !1
    },
    deactivate: function () {
        return OpenLayers.Control.prototype.deactivate.apply(this, arguments) ? (this.dragPan.deactivate(), this.handlers.click.deactivate(), this.pinchZoom.deactivate(), !0) : !1
    },
    draw: function () {
        var a = {click: this.defaultClick, dblclick: this.defaultDblClick}, b = OpenLayers.Util.extend({
            "double": !0, stopDouble: !0,
            pixelTolerance: 2
        }, this.clickHandlerOptions);
        this.handlers.click = new OpenLayers.Handler.Click(this, a, b);
        this.dragPan = new OpenLayers.Control.DragPan(OpenLayers.Util.extend({
            map: this.map,
            documentDrag: this.documentDrag
        }, this.dragPanOptions));
        this.dragPan.draw();
        this.pinchZoom = new OpenLayers.Control.PinchZoom(OpenLayers.Util.extend({map: this.map}, this.pinchZoomOptions))
    },
    defaultClick: function (a) {
        a.lastTouches && 2 == a.lastTouches.length && this.map.zoomOut()
    },
    defaultDblClick: function (a) {
        this.map.setCenter(this.map.getLonLatFromViewPortPx(a.xy),
            this.map.zoom + 1)
    },
    CLASS_NAME: "OpenLayers.Control.TouchNavigation"
});
OpenLayers.Control.MousePosition = OpenLayers.Class(OpenLayers.Control, {
    autoActivate: !0,
    element: null,
    prefix: "",
    separator: ", ",
    suffix: "",
    numDigits: 5,
    granularity: 10,
    emptyString: null,
    lastXy: null,
    displayProjection: null,
    destroy: function () {
        this.deactivate();
        OpenLayers.Control.prototype.destroy.apply(this, arguments)
    },
    activate: function () {
        return OpenLayers.Control.prototype.activate.apply(this, arguments) ? (this.map.events.register("mousemove", this, this.redraw), this.map.events.register("mouseout", this, this.reset),
            this.redraw(), !0) : !1
    },
    deactivate: function () {
        return OpenLayers.Control.prototype.deactivate.apply(this, arguments) ? (this.map.events.unregister("mousemove", this, this.redraw), this.map.events.unregister("mouseout", this, this.reset), this.element.innerHTML = "", !0) : !1
    },
    draw: function () {
        OpenLayers.Control.prototype.draw.apply(this, arguments);
        this.element || (this.div.left = "", this.div.top = "", this.element = this.div);
        return this.div
    },
    redraw: function (a) {
        var b;
        if (null == a)this.reset(); else if (null == this.lastXy || Math.abs(a.xy.x -
            this.lastXy.x) > this.granularity || Math.abs(a.xy.y - this.lastXy.y) > this.granularity)this.lastXy = a.xy; else if (b = this.map.getLonLatFromPixel(a.xy))this.displayProjection && b.transform(this.map.getProjectionObject(), this.displayProjection), this.lastXy = a.xy, a = this.formatOutput(b), a != this.element.innerHTML && (this.element.innerHTML = a)
    },
    reset: function () {
        null != this.emptyString && (this.element.innerHTML = this.emptyString)
    },
    formatOutput: function (a) {
        var b = parseInt(this.numDigits);
        return this.prefix + a.lon.toFixed(b) +
            this.separator + a.lat.toFixed(b) + this.suffix
    },
    CLASS_NAME: "OpenLayers.Control.MousePosition"
});
OpenLayers.Control.OverviewMap = OpenLayers.Class(OpenLayers.Control, {
    element: null,
    ovmap: null,
    size: {w: 180, h: 90},
    layers: null,
    minRectSize: 15,
    minRectDisplayClass: "RectReplacement",
    minRatio: 8,
    maxRatio: 32,
    mapOptions: null,
    autoPan: !1,
    handlers: null,
    resolutionFactor: 1,
    maximized: !1,
    initialize: function (a) {
        this.layers = [];
        this.handlers = {};
        OpenLayers.Control.prototype.initialize.apply(this, [a])
    },
    destroy: function () {
        this.mapDiv && (this.handlers.click && this.handlers.click.destroy(), this.handlers.drag && this.handlers.drag.destroy(),
        this.ovmap && this.ovmap.viewPortDiv.removeChild(this.extentRectangle), this.extentRectangle = null, this.rectEvents && (this.rectEvents.destroy(), this.rectEvents = null), this.ovmap && (this.ovmap.destroy(), this.ovmap = null), this.element.removeChild(this.mapDiv), this.mapDiv = null, this.div.removeChild(this.element), this.element = null, this.maximizeDiv && (this.div.removeChild(this.maximizeDiv), this.maximizeDiv = null), this.minimizeDiv && (this.div.removeChild(this.minimizeDiv), this.minimizeDiv = null), this.map.events.un({
            buttonclick: this.onButtonClick,
            moveend: this.update, changebaselayer: this.baseLayerDraw, scope: this
        }), OpenLayers.Control.prototype.destroy.apply(this, arguments))
    },
    draw: function () {
        OpenLayers.Control.prototype.draw.apply(this, arguments);
        if (0 === this.layers.length)if (this.map.baseLayer)this.layers = [this.map.baseLayer.clone()]; else return this.map.events.register("changebaselayer", this, this.baseLayerDraw), this.div;
        this.element = document.createElement("div");
        this.element.className = this.displayClass + "Element";
        this.element.style.display = "none";
        this.mapDiv = document.createElement("div");
        this.mapDiv.style.width = this.size.w + "px";
        this.mapDiv.style.height = this.size.h + "px";
        this.mapDiv.style.position = "relative";
        this.mapDiv.style.overflow = "hidden";
        this.mapDiv.id = OpenLayers.Util.createUniqueID("overviewMap");
        this.extentRectangle = document.createElement("div");
        this.extentRectangle.style.position = "absolute";
        this.extentRectangle.style.zIndex = 1E3;
        this.extentRectangle.className = this.displayClass + "ExtentRectangle";
        this.element.appendChild(this.mapDiv);
        this.div.appendChild(this.element);
        if (this.outsideViewport)this.element.style.display = ""; else {
            this.div.className += " " + this.displayClass + "Container";
            var a = OpenLayers.Util.getImageLocation("layer-switcher-maximize.png");
            this.maximizeDiv = OpenLayers.Util.createAlphaImageDiv(this.displayClass + "MaximizeButton", null, null, a, "absolute");
            this.maximizeDiv.style.display = "none";
            this.maximizeDiv.className = this.displayClass + "MaximizeButton olButton";
            this.div.appendChild(this.maximizeDiv);
            a = OpenLayers.Util.getImageLocation("layer-switcher-minimize.png");
            this.minimizeDiv = OpenLayers.Util.createAlphaImageDiv("OpenLayers_Control_minimizeDiv", null, null, a, "absolute");
            this.minimizeDiv.style.display = "none";
            this.minimizeDiv.className = this.displayClass + "MinimizeButton olButton";
            this.div.appendChild(this.minimizeDiv);
            this.minimizeControl()
        }
        this.map.getExtent() && this.update();
        this.map.events.on({buttonclick: this.onButtonClick, moveend: this.update, scope: this});
        this.maximized && this.maximizeControl();
        return this.div
    },
    baseLayerDraw: function () {
        this.draw();
        this.map.events.unregister("changebaselayer",
            this, this.baseLayerDraw)
    },
    rectDrag: function (a) {
        var b = this.handlers.drag.last.x - a.x, c = this.handlers.drag.last.y - a.y;
        if (0 != b || 0 != c) {
            var d = this.rectPxBounds.top, e = this.rectPxBounds.left, a = Math.abs(this.rectPxBounds.getHeight()), f = this.rectPxBounds.getWidth(), c = Math.max(0, d - c), c = Math.min(c, this.ovmap.size.h - this.hComp - a), b = Math.max(0, e - b), b = Math.min(b, this.ovmap.size.w - this.wComp - f);
            this.setRectPxBounds(new OpenLayers.Bounds(b, c + a, b + f, c))
        }
    },
    mapDivClick: function (a) {
        var b = this.rectPxBounds.getCenterPixel(),
            c = a.xy.x - b.x, d = a.xy.y - b.y, e = this.rectPxBounds.top, f = this.rectPxBounds.left, a = Math.abs(this.rectPxBounds.getHeight()), b = this.rectPxBounds.getWidth(), d = Math.max(0, e + d), d = Math.min(d, this.ovmap.size.h - a), c = Math.max(0, f + c), c = Math.min(c, this.ovmap.size.w - b);
        this.setRectPxBounds(new OpenLayers.Bounds(c, d + a, c + b, d));
        this.updateMapToRect()
    },
    onButtonClick: function (a) {
        a.buttonElement === this.minimizeDiv ? this.minimizeControl() : a.buttonElement === this.maximizeDiv && this.maximizeControl()
    },
    maximizeControl: function (a) {
        this.element.style.display =
            "";
        this.showToggle(!1);
        null != a && OpenLayers.Event.stop(a)
    },
    minimizeControl: function (a) {
        this.element.style.display = "none";
        this.showToggle(!0);
        null != a && OpenLayers.Event.stop(a)
    },
    showToggle: function (a) {
        this.maximizeDiv.style.display = a ? "" : "none";
        this.minimizeDiv.style.display = a ? "none" : ""
    },
    update: function () {
        null == this.ovmap && this.createMap();
        (this.autoPan || !this.isSuitableOverview()) && this.updateOverview();
        this.updateRectToMap()
    },
    isSuitableOverview: function () {
        var a = this.map.getExtent(), b = this.map.maxExtent,
            a = new OpenLayers.Bounds(Math.max(a.left, b.left), Math.max(a.bottom, b.bottom), Math.min(a.right, b.right), Math.min(a.top, b.top));
        this.ovmap.getProjection() != this.map.getProjection() && (a = a.transform(this.map.getProjectionObject(), this.ovmap.getProjectionObject()));
        b = this.ovmap.getResolution() / this.map.getResolution();
        return b > this.minRatio && b <= this.maxRatio && this.ovmap.getExtent().containsBounds(a)
    },
    updateOverview: function () {
        var a = this.map.getResolution(), b = this.ovmap.getResolution(), c = b / a;
        c > this.maxRatio ?
            b = this.minRatio * a : c <= this.minRatio && (b = this.maxRatio * a);
        this.ovmap.getProjection() != this.map.getProjection() ? (a = this.map.center.clone(), a.transform(this.map.getProjectionObject(), this.ovmap.getProjectionObject())) : a = this.map.center;
        this.ovmap.setCenter(a, this.ovmap.getZoomForResolution(b * this.resolutionFactor));
        this.updateRectToMap()
    },
    createMap: function () {
        var a = OpenLayers.Util.extend({controls: [], maxResolution: "auto", fallThrough: !1}, this.mapOptions);
        this.ovmap = new OpenLayers.Map(this.mapDiv, a);
        this.ovmap.viewPortDiv.appendChild(this.extentRectangle);
        OpenLayers.Event.stopObserving(window, "unload", this.ovmap.unloadDestroy);
        this.ovmap.addLayers(this.layers);
        this.ovmap.zoomToMaxExtent();
        this.wComp = (this.wComp = parseInt(OpenLayers.Element.getStyle(this.extentRectangle, "border-left-width")) + parseInt(OpenLayers.Element.getStyle(this.extentRectangle, "border-right-width"))) ? this.wComp : 2;
        this.hComp = (this.hComp = parseInt(OpenLayers.Element.getStyle(this.extentRectangle, "border-top-width")) + parseInt(OpenLayers.Element.getStyle(this.extentRectangle, "border-bottom-width"))) ?
            this.hComp : 2;
        this.handlers.drag = new OpenLayers.Handler.Drag(this, {
            move: this.rectDrag,
            done: this.updateMapToRect
        }, {map: this.ovmap});
        this.handlers.click = new OpenLayers.Handler.Click(this, {click: this.mapDivClick}, {
            single: !0,
            "double": !1,
            stopSingle: !0,
            stopDouble: !0,
            pixelTolerance: 1,
            map: this.ovmap
        });
        this.handlers.click.activate();
        this.rectEvents = new OpenLayers.Events(this, this.extentRectangle, null, !0);
        this.rectEvents.register("mouseover", this, function () {
            !this.handlers.drag.active && !this.map.dragging && this.handlers.drag.activate()
        });
        this.rectEvents.register("mouseout", this, function () {
            this.handlers.drag.dragging || this.handlers.drag.deactivate()
        });
        if (this.ovmap.getProjection() != this.map.getProjection()) {
            var a = this.map.getProjectionObject().getUnits() || this.map.units || this.map.baseLayer.units, b = this.ovmap.getProjectionObject().getUnits() || this.ovmap.units || this.ovmap.baseLayer.units;
            this.resolutionFactor = a && b ? OpenLayers.INCHES_PER_UNIT[a] / OpenLayers.INCHES_PER_UNIT[b] : 1
        }
    },
    updateRectToMap: function () {
        var a = this.getRectBoundsFromMapBounds(this.ovmap.getProjection() !=
        this.map.getProjection() ? this.map.getExtent().transform(this.map.getProjectionObject(), this.ovmap.getProjectionObject()) : this.map.getExtent());
        a && this.setRectPxBounds(a)
    },
    updateMapToRect: function () {
        var a = this.getMapBoundsFromRectBounds(this.rectPxBounds);
        this.ovmap.getProjection() != this.map.getProjection() && (a = a.transform(this.ovmap.getProjectionObject(), this.map.getProjectionObject()));
        this.map.panTo(a.getCenterLonLat())
    },
    setRectPxBounds: function (a) {
        var b = Math.max(a.top, 0), c = Math.max(a.left, 0), d =
            Math.min(a.top + Math.abs(a.getHeight()), this.ovmap.size.h - this.hComp), a = Math.min(a.left + a.getWidth(), this.ovmap.size.w - this.wComp), e = Math.max(a - c, 0), f = Math.max(d - b, 0);
        e < this.minRectSize || f < this.minRectSize ? (this.extentRectangle.className = this.displayClass + this.minRectDisplayClass, e = c + e / 2 - this.minRectSize / 2, this.extentRectangle.style.top = Math.round(b + f / 2 - this.minRectSize / 2) + "px", this.extentRectangle.style.left = Math.round(e) + "px", this.extentRectangle.style.height = this.minRectSize + "px", this.extentRectangle.style.width =
            this.minRectSize + "px") : (this.extentRectangle.className = this.displayClass + "ExtentRectangle", this.extentRectangle.style.top = Math.round(b) + "px", this.extentRectangle.style.left = Math.round(c) + "px", this.extentRectangle.style.height = Math.round(f) + "px", this.extentRectangle.style.width = Math.round(e) + "px");
        this.rectPxBounds = new OpenLayers.Bounds(Math.round(c), Math.round(d), Math.round(a), Math.round(b))
    },
    getRectBoundsFromMapBounds: function (a) {
        var b = this.getOverviewPxFromLonLat({lon: a.left, lat: a.bottom}), a = this.getOverviewPxFromLonLat({
            lon: a.right,
            lat: a.top
        }), c = null;
        b && a && (c = new OpenLayers.Bounds(b.x, b.y, a.x, a.y));
        return c
    },
    getMapBoundsFromRectBounds: function (a) {
        var b = this.getLonLatFromOverviewPx({x: a.left, y: a.bottom}), a = this.getLonLatFromOverviewPx({
            x: a.right,
            y: a.top
        });
        return new OpenLayers.Bounds(b.lon, b.lat, a.lon, a.lat)
    },
    getLonLatFromOverviewPx: function (a) {
        var b = this.ovmap.size, c = this.ovmap.getResolution(), d = this.ovmap.getExtent().getCenterLonLat();
        return {lon: d.lon + (a.x - b.w / 2) * c, lat: d.lat - (a.y - b.h / 2) * c}
    },
    getOverviewPxFromLonLat: function (a) {
        var b =
            this.ovmap.getResolution(), c = this.ovmap.getExtent();
        if (c)return {x: Math.round(1 / b * (a.lon - c.left)), y: Math.round(1 / b * (c.top - a.lat))}
    },
    CLASS_NAME: "OpenLayers.Control.OverviewMap"
});
OpenLayers.Control.KeyboardDefaults = OpenLayers.Class(OpenLayers.Control, {
    autoActivate: !0, slideFactor: 75, observeElement: null, draw: function () {
        this.handler = new OpenLayers.Handler.Keyboard(this, {keydown: this.defaultKeyPress}, {observeElement: this.observeElement || document})
    }, defaultKeyPress: function (a) {
        var b, c = !0;
        switch (a.keyCode) {
            case OpenLayers.Event.KEY_LEFT:
                this.map.pan(-this.slideFactor, 0);
                break;
            case OpenLayers.Event.KEY_RIGHT:
                this.map.pan(this.slideFactor, 0);
                break;
            case OpenLayers.Event.KEY_UP:
                this.map.pan(0,
                    -this.slideFactor);
                break;
            case OpenLayers.Event.KEY_DOWN:
                this.map.pan(0, this.slideFactor);
                break;
            case 33:
                b = this.map.getSize();
                this.map.pan(0, -0.75 * b.h);
                break;
            case 34:
                b = this.map.getSize();
                this.map.pan(0, 0.75 * b.h);
                break;
            case 35:
                b = this.map.getSize();
                this.map.pan(0.75 * b.w, 0);
                break;
            case 36:
                b = this.map.getSize();
                this.map.pan(-0.75 * b.w, 0);
                break;
            case 43:
            case 61:
            case 187:
            case 107:
                this.map.zoomIn();
                break;
            case 45:
            case 109:
            case 189:
            case 95:
                this.map.zoomOut();
                break;
            default:
                c = !1
        }
        c && OpenLayers.Event.stop(a)
    }, CLASS_NAME: "OpenLayers.Control.KeyboardDefaults"
});
OpenLayers.Control.PanZoom = OpenLayers.Class(OpenLayers.Control, {
    slideFactor: 50, slideRatio: null, buttons: null, position: null, initialize: function (a) {
        this.position = new OpenLayers.Pixel(OpenLayers.Control.PanZoom.X, OpenLayers.Control.PanZoom.Y);
        OpenLayers.Control.prototype.initialize.apply(this, arguments)
    }, destroy: function () {
        this.map && this.map.events.unregister("buttonclick", this, this.onButtonClick);
        this.removeButtons();
        this.position = this.buttons = null;
        OpenLayers.Control.prototype.destroy.apply(this, arguments)
    },
    setMap: function (a) {
        OpenLayers.Control.prototype.setMap.apply(this, arguments);
        this.map.events.register("buttonclick", this, this.onButtonClick)
    }, draw: function (a) {
        OpenLayers.Control.prototype.draw.apply(this, arguments);
        a = this.position;
        this.buttons = [];
        var b = {w: 18, h: 18}, c = new OpenLayers.Pixel(a.x + b.w / 2, a.y);
        this._addButton("panup", "north-mini.png", c, b);
        a.y = c.y + b.h;
        this._addButton("panleft", "west-mini.png", a, b);
        this._addButton("panright", "east-mini.png", a.add(b.w, 0), b);
        this._addButton("pandown", "south-mini.png",
            c.add(0, 2 * b.h), b);
        this._addButton("zoomin", "zoom-plus-mini.png", c.add(0, 3 * b.h + 5), b);
        this._addButton("zoomout", "zoom-minus-mini.png", c.add(0, 4 * b.h + 5), b);
        return this.div
    }, _addButton: function (a, b, c, d) {
        b = OpenLayers.Util.getImageLocation(b);
        c = OpenLayers.Util.createAlphaImageDiv(this.id + "_" + a, c, d, b, "absolute");
        c.style.cursor = "pointer";
        this.div.appendChild(c);
        c.action = a;
        c.className = "olButton";
        this.buttons.push(c);
        return c
    }, _removeButton: function (a) {
        this.div.removeChild(a);
        OpenLayers.Util.removeItem(this.buttons,
            a)
    }, removeButtons: function () {
        for (var a = this.buttons.length - 1; 0 <= a; --a)this._removeButton(this.buttons[a])
    }, onButtonClick: function (a) {
        switch (a.buttonElement.action) {
            case "panup":
                this.map.pan(0, -this.getSlideFactor("h"));
                break;
            case "pandown":
                this.map.pan(0, this.getSlideFactor("h"));
                break;
            case "panleft":
                this.map.pan(-this.getSlideFactor("w"), 0);
                break;
            case "panright":
                this.map.pan(this.getSlideFactor("w"), 0);
                break;
            case "zoomin":
                this.map.zoomIn();
                break;
            case "zoomout":
                this.map.zoomOut();
                break;
            case "zoomworld":
                this.map.zoomToMaxExtent()
        }
    },
    getSlideFactor: function (a) {
        return this.slideRatio ? this.map.getSize()[a] * this.slideRatio : this.slideFactor
    }, CLASS_NAME: "OpenLayers.Control.PanZoom"
});
OpenLayers.Control.PanZoom.X = 4;
OpenLayers.Control.PanZoom.Y = 4;
OpenLayers.Control.PanZoomBar = OpenLayers.Class(OpenLayers.Control.PanZoom, {
    zoomStopWidth: 18,
    zoomStopHeight: 11,
    slider: null,
    sliderEvents: null,
    zoombarDiv: null,
    zoomWorldIcon: !1,
    panIcons: !0,
    forceFixedZoomLevel: !1,
    mouseDragStart: null,
    deltaY: null,
    zoomStart: null,
    destroy: function () {
        this._removeZoomBar();
        this.map.events.un({changebaselayer: this.redraw, scope: this});
        OpenLayers.Control.PanZoom.prototype.destroy.apply(this, arguments);
        delete this.mouseDragStart;
        delete this.zoomStart
    },
    setMap: function (a) {
        OpenLayers.Control.PanZoom.prototype.setMap.apply(this,
            arguments);
        this.map.events.register("changebaselayer", this, this.redraw)
    },
    redraw: function () {
        null != this.div && (this.removeButtons(), this._removeZoomBar());
        this.draw()
    },
    draw: function (a) {
        OpenLayers.Control.prototype.draw.apply(this, arguments);
        a = this.position.clone();
        this.buttons = [];
        var b = {w: 18, h: 18};
        if (this.panIcons) {
            var c = new OpenLayers.Pixel(a.x + b.w / 2, a.y), d = b.w;
            this.zoomWorldIcon && (c = new OpenLayers.Pixel(a.x + b.w, a.y));
            this._addButton("panup", "north-mini.png", c, b);
            a.y = c.y + b.h;
            this._addButton("panleft",
                "west-mini.png", a, b);
            this.zoomWorldIcon && (this._addButton("zoomworld", "zoom-world-mini.png", a.add(b.w, 0), b), d *= 2);
            this._addButton("panright", "east-mini.png", a.add(d, 0), b);
            this._addButton("pandown", "south-mini.png", c.add(0, 2 * b.h), b);
            this._addButton("zoomin", "zoom-plus-mini.png", c.add(0, 3 * b.h + 5), b);
            c = this._addZoomBar(c.add(0, 4 * b.h + 5));
            this._addButton("zoomout", "zoom-minus-mini.png", c, b)
        } else this._addButton("zoomin", "zoom-plus-mini.png", a, b), c = this._addZoomBar(a.add(0, b.h)), this._addButton("zoomout",
            "zoom-minus-mini.png", c, b), this.zoomWorldIcon && (c = c.add(0, b.h + 3), this._addButton("zoomworld", "zoom-world-mini.png", c, b));
        return this.div
    },
    _addZoomBar: function (a) {
        var b = OpenLayers.Util.getImageLocation("slider.png"), c = this.id + "_" + this.map.id, d = this.map.getNumZoomLevels() - 1 - this.map.getZoom(), d = OpenLayers.Util.createAlphaImageDiv(c, a.add(-1, d * this.zoomStopHeight), {
            w: 20,
            h: 9
        }, b, "absolute");
        d.style.cursor = "move";
        this.slider = d;
        this.sliderEvents = new OpenLayers.Events(this, d, null, !0, {includeXY: !0});
        this.sliderEvents.on({
            touchstart: this.zoomBarDown,
            touchmove: this.zoomBarDrag,
            touchend: this.zoomBarUp,
            mousedown: this.zoomBarDown,
            mousemove: this.zoomBarDrag,
            mouseup: this.zoomBarUp
        });
        var e = {
            w: this.zoomStopWidth,
            h: this.zoomStopHeight * this.map.getNumZoomLevels()
        }, b = OpenLayers.Util.getImageLocation("zoombar.png"), c = null;
        OpenLayers.Util.alphaHack() ? (c = this.id + "_" + this.map.id, c = OpenLayers.Util.createAlphaImageDiv(c, a, {
            w: e.w,
            h: this.zoomStopHeight
        }, b, "absolute", null, "crop"), c.style.height = e.h + "px") : c = OpenLayers.Util.createDiv("OpenLayers_Control_PanZoomBar_Zoombar" +
        this.map.id, a, e, b);
        c.style.cursor = "pointer";
        c.className = "olButton";
        this.zoombarDiv = c;
        this.div.appendChild(c);
        this.startTop = parseInt(c.style.top);
        this.div.appendChild(d);
        this.map.events.register("zoomend", this, this.moveZoomBar);
        return a.add(0, this.zoomStopHeight * this.map.getNumZoomLevels())
    },
    _removeZoomBar: function () {
        this.sliderEvents.un({
            touchstart: this.zoomBarDown,
            touchmove: this.zoomBarDrag,
            touchend: this.zoomBarUp,
            mousedown: this.zoomBarDown,
            mousemove: this.zoomBarDrag,
            mouseup: this.zoomBarUp
        });
        this.sliderEvents.destroy();
        this.div.removeChild(this.zoombarDiv);
        this.zoombarDiv = null;
        this.div.removeChild(this.slider);
        this.slider = null;
        this.map.events.unregister("zoomend", this, this.moveZoomBar)
    },
    onButtonClick: function (a) {
        OpenLayers.Control.PanZoom.prototype.onButtonClick.apply(this, arguments);
        if (a.buttonElement === this.zoombarDiv) {
            var b = a.buttonXY.y / this.zoomStopHeight;
            if (this.forceFixedZoomLevel || !this.map.fractionalZoom)b = Math.floor(b);
            b = this.map.getNumZoomLevels() - 1 - b;
            b = Math.min(Math.max(b, 0), this.map.getNumZoomLevels() -
            1);
            this.map.zoomTo(b)
        }
    },
    passEventToSlider: function (a) {
        this.sliderEvents.handleBrowserEvent(a)
    },
    zoomBarDown: function (a) {
        if (OpenLayers.Event.isLeftClick(a) || OpenLayers.Event.isSingleTouch(a))this.map.events.on({
            touchmove: this.passEventToSlider,
            mousemove: this.passEventToSlider,
            mouseup: this.passEventToSlider,
            scope: this
        }), this.mouseDragStart = a.xy.clone(), this.zoomStart = a.xy.clone(), this.div.style.cursor = "move", this.zoombarDiv.offsets = null, OpenLayers.Event.stop(a)
    },
    zoomBarDrag: function (a) {
        if (null != this.mouseDragStart) {
            var b =
                this.mouseDragStart.y - a.xy.y, c = OpenLayers.Util.pagePosition(this.zoombarDiv);
            0 < a.clientY - c[1] && a.clientY - c[1] < parseInt(this.zoombarDiv.style.height) - 2 && (this.slider.style.top = parseInt(this.slider.style.top) - b + "px", this.mouseDragStart = a.xy.clone());
            this.deltaY = this.zoomStart.y - a.xy.y;
            OpenLayers.Event.stop(a)
        }
    },
    zoomBarUp: function (a) {
        if ((OpenLayers.Event.isLeftClick(a) || "touchend" === a.type) && this.mouseDragStart) {
            this.div.style.cursor = "";
            this.map.events.un({
                touchmove: this.passEventToSlider, mouseup: this.passEventToSlider,
                mousemove: this.passEventToSlider, scope: this
            });
            var b = this.map.zoom;
            !this.forceFixedZoomLevel && this.map.fractionalZoom ? (b += this.deltaY / this.zoomStopHeight, b = Math.min(Math.max(b, 0), this.map.getNumZoomLevels() - 1)) : (b += this.deltaY / this.zoomStopHeight, b = Math.max(Math.round(b), 0));
            this.map.zoomTo(b);
            this.zoomStart = this.mouseDragStart = null;
            this.deltaY = 0;
            OpenLayers.Event.stop(a)
        }
    },
    moveZoomBar: function () {
        this.slider.style.top = (this.map.getNumZoomLevels() - 1 - this.map.getZoom()) * this.zoomStopHeight + this.startTop +
        1 + "px"
    },
    CLASS_NAME: "OpenLayers.Control.PanZoomBar"
});
OpenLayers.Control.ArgParser = OpenLayers.Class(OpenLayers.Control, {
    center: null, zoom: null, layers: null, displayProjection: null, getParameters: function (a) {
        var a = a || window.location.href, b = OpenLayers.Util.getParameters(a), c = a.indexOf("#");
        0 < c && (a = "?" + a.substring(c + 1, a.length), OpenLayers.Util.extend(b, OpenLayers.Util.getParameters(a)));
        return b
    }, setMap: function (a) {
        OpenLayers.Control.prototype.setMap.apply(this, arguments);
        for (var b = 0, c = this.map.controls.length; b < c; b++) {
            var d = this.map.controls[b];
            if (d != this &&
                "OpenLayers.Control.ArgParser" == d.CLASS_NAME) {
                d.displayProjection != this.displayProjection && (this.displayProjection = d.displayProjection);
                break
            }
        }
        b == this.map.controls.length && (b = this.getParameters(), b.layers && (this.layers = b.layers, this.map.events.register("addlayer", this, this.configureLayers), this.configureLayers()), b.lat && b.lon && (this.center = new OpenLayers.LonLat(parseFloat(b.lon), parseFloat(b.lat)), b.zoom && (this.zoom = parseFloat(b.zoom)), this.map.events.register("changebaselayer", this, this.setCenter),
            this.setCenter()))
    }, setCenter: function () {
        this.map.baseLayer && (this.map.events.unregister("changebaselayer", this, this.setCenter), this.displayProjection && this.center.transform(this.displayProjection, this.map.getProjectionObject()), this.map.setCenter(this.center, this.zoom))
    }, configureLayers: function () {
        if (this.layers.length == this.map.layers.length) {
            this.map.events.unregister("addlayer", this, this.configureLayers);
            for (var a = 0, b = this.layers.length; a < b; a++) {
                var c = this.map.layers[a], d = this.layers.charAt(a);
                "B" == d ? this.map.setBaseLayer(c) : ("T" == d || "F" == d) && c.setVisibility("T" == d)
            }
        }
    }, CLASS_NAME: "OpenLayers.Control.ArgParser"
});
OpenLayers.Control.Permalink = OpenLayers.Class(OpenLayers.Control, {
    argParserClass: OpenLayers.Control.ArgParser,
    element: null,
    anchor: !1,
    base: "",
    displayProjection: null,
    initialize: function (a, b, c) {
        null !== a && "object" == typeof a && !OpenLayers.Util.isElement(a) ? (this.base = document.location.href, OpenLayers.Control.prototype.initialize.apply(this, [a]), null != this.element && (this.element = OpenLayers.Util.getElement(this.element))) : (OpenLayers.Control.prototype.initialize.apply(this, [c]), this.element = OpenLayers.Util.getElement(a),
            this.base = b || document.location.href)
    },
    destroy: function () {
        this.element && this.element.parentNode == this.div && (this.div.removeChild(this.element), this.element = null);
        this.map && this.map.events.unregister("moveend", this, this.updateLink);
        OpenLayers.Control.prototype.destroy.apply(this, arguments)
    },
    setMap: function (a) {
        OpenLayers.Control.prototype.setMap.apply(this, arguments);
        for (var b = 0, c = this.map.controls.length; b < c; b++) {
            var d = this.map.controls[b];
            if (d.CLASS_NAME == this.argParserClass.CLASS_NAME) {
                d.displayProjection !=
                this.displayProjection && (this.displayProjection = d.displayProjection);
                break
            }
        }
        b == this.map.controls.length && this.map.addControl(new this.argParserClass({displayProjection: this.displayProjection}))
    },
    draw: function () {
        OpenLayers.Control.prototype.draw.apply(this, arguments);
        !this.element && !this.anchor && (this.element = document.createElement("a"), this.element.innerHTML = OpenLayers.i18n("Permalink"), this.element.href = "", this.div.appendChild(this.element));
        this.map.events.on({
            moveend: this.updateLink, changelayer: this.updateLink,
            changebaselayer: this.updateLink, scope: this
        });
        this.updateLink();
        return this.div
    },
    updateLink: function () {
        var a = this.anchor ? "#" : "?", b = this.base;
        -1 != b.indexOf(a) && (b = b.substring(0, b.indexOf(a)));
        b += a + OpenLayers.Util.getParameterString(this.createParams());
        this.anchor && !this.element ? window.location.href = b : this.element.href = b
    },
    createParams: function (a, b, c) {
        var a = a || this.map.getCenter(), d = OpenLayers.Util.getParameters(this.base);
        if (a) {
            d.zoom = b || this.map.getZoom();
            b = a.lat;
            a = a.lon;
            this.displayProjection && (b =
                OpenLayers.Projection.transform({
                    x: a,
                    y: b
                }, this.map.getProjectionObject(), this.displayProjection), a = b.x, b = b.y);
            d.lat = Math.round(1E5 * b) / 1E5;
            d.lon = Math.round(1E5 * a) / 1E5;
            c = c || this.map.layers;
            d.layers = "";
            a = 0;
            for (b = c.length; a < b; a++) {
                var e = c[a];
                d.layers = e.isBaseLayer ? d.layers + (e == this.map.baseLayer ? "B" : "0") : d.layers + (e.getVisibility() ? "T" : "F")
            }
        }
        return d
    },
    CLASS_NAME: "OpenLayers.Control.Permalink"
});
OpenLayers.Control.Scale = OpenLayers.Class(OpenLayers.Control, {
    element: null, geodesic: !1, initialize: function (a, b) {
        OpenLayers.Control.prototype.initialize.apply(this, [b]);
        this.element = OpenLayers.Util.getElement(a)
    }, draw: function () {
        OpenLayers.Control.prototype.draw.apply(this, arguments);
        this.element || (this.element = document.createElement("div"), this.div.appendChild(this.element));
        this.map.events.register("moveend", this, this.updateScale);
        this.updateScale();
        return this.div
    }, updateScale: function () {
        var a;
        if (!0 === this.geodesic) {
            if (!this.map.getUnits())return;
            a = OpenLayers.INCHES_PER_UNIT;
            a = (this.map.getGeodesicPixelSize().w || 1.0E-6) * a.km * OpenLayers.DOTS_PER_INCH
        } else a = this.map.getScale();
        a && (a = 9500 <= a && 95E4 >= a ? Math.round(a / 1E3) + "K" : 95E4 <= a ? Math.round(a / 1E6) + "M" : Math.round(a), this.element.innerHTML = OpenLayers.i18n("Scale = 1 : ${scaleDenom}", {scaleDenom: a}))
    }, CLASS_NAME: "OpenLayers.Control.Scale"
});
OpenLayers.Control.ScaleLine = OpenLayers.Class(OpenLayers.Control, {
    maxWidth: 100,
    topOutUnits: "km",
    topInUnits: "m",
    bottomOutUnits: "mi",
    bottomInUnits: "ft",
    eTop: null,
    eBottom: null,
    geodesic: !1,
    draw: function () {
        OpenLayers.Control.prototype.draw.apply(this, arguments);
        this.eTop || (this.eTop = document.createElement("div"), this.eTop.className = this.displayClass + "Top", this.div.appendChild(this.eTop), this.eTop.style.visibility = "" == this.topOutUnits || "" == this.topInUnits ? "hidden" : "visible", this.eBottom = document.createElement("div"),
            this.eBottom.className = this.displayClass + "Bottom", this.div.appendChild(this.eBottom), this.eBottom.style.visibility = "" == this.bottomOutUnits || "" == this.bottomInUnits ? "hidden" : "visible");
        this.map.events.register("moveend", this, this.update);
        this.update();
        return this.div
    },
    getBarLen: function (a) {
        var b = parseInt(Math.log(a) / Math.log(10)), b = Math.pow(10, b), a = parseInt(a / b);
        return (5 < a ? 5 : 2 < a ? 2 : 1) * b
    },
    update: function () {
        var a = this.map.getResolution();
        if (a) {
            var b = this.map.getUnits(), c = OpenLayers.INCHES_PER_UNIT, d = this.maxWidth *
                a * c[b], e = 1;
            !0 === this.geodesic && (e = (this.map.getGeodesicPixelSize().w || 1.0E-6) * this.maxWidth / (d / c.km), d *= e);
            var f, g;
            1E5 < d ? (f = this.topOutUnits, g = this.bottomOutUnits) : (f = this.topInUnits, g = this.bottomInUnits);
            var h = d / c[f], k = d / c[g], d = this.getBarLen(h), l = this.getBarLen(k), h = d / c[b] * c[f], k = l / c[b] * c[g], b = h / a / e;
            "visible" == this.eBottom.style.visibility && (this.eBottom.style.width = Math.round(k / a / e) + "px", this.eBottom.innerHTML = l + " " + g);
            "visible" == this.eTop.style.visibility && (this.eTop.style.width = Math.round(b) +
            "px", this.eTop.innerHTML = d + " " + f)
        }
    },
    CLASS_NAME: "OpenLayers.Control.ScaleLine"
});
OpenLayers.Control.Snapping = OpenLayers.Class(OpenLayers.Control, {
    DEFAULTS: {tolerance: 10, node: !0, edge: !0, vertex: !0},
    greedy: !0,
    precedence: ["node", "vertex", "edge"],
    resolution: null,
    geoToleranceCache: null,
    layer: null,
    feature: null,
    point: null,
    initialize: function (a) {
        OpenLayers.Control.prototype.initialize.apply(this, [a]);
        this.options = a || {};
        this.options.layer && this.setLayer(this.options.layer);
        a = OpenLayers.Util.extend({}, this.options.defaults);
        this.defaults = OpenLayers.Util.applyDefaults(a, this.DEFAULTS);
        this.setTargets(this.options.targets);
        0 === this.targets.length && this.layer && this.addTargetLayer(this.layer);
        this.geoToleranceCache = {}
    },
    setLayer: function (a) {
        this.active ? (this.deactivate(), this.layer = a, this.activate()) : this.layer = a
    },
    setTargets: function (a) {
        this.targets = [];
        if (a && a.length)for (var b, c = 0, d = a.length; c < d; ++c)b = a[c], b instanceof OpenLayers.Layer.Vector ? this.addTargetLayer(b) : this.addTarget(b)
    },
    addTargetLayer: function (a) {
        this.addTarget({layer: a})
    },
    addTarget: function (a) {
        a = OpenLayers.Util.applyDefaults(a, this.defaults);
        a.nodeTolerance =
            a.nodeTolerance || a.tolerance;
        a.vertexTolerance = a.vertexTolerance || a.tolerance;
        a.edgeTolerance = a.edgeTolerance || a.tolerance;
        this.targets.push(a)
    },
    removeTargetLayer: function (a) {
        for (var b, c = this.targets.length - 1; 0 <= c; --c)b = this.targets[c], b.layer === a && this.removeTarget(b)
    },
    removeTarget: function (a) {
        return OpenLayers.Util.removeItem(this.targets, a)
    },
    activate: function () {
        var a = OpenLayers.Control.prototype.activate.call(this);
        if (a && this.layer && this.layer.events)this.layer.events.on({
            sketchstarted: this.onSketchModified,
            sketchmodified: this.onSketchModified, vertexmodified: this.onVertexModified, scope: this
        });
        return a
    },
    deactivate: function () {
        var a = OpenLayers.Control.prototype.deactivate.call(this);
        a && this.layer && this.layer.events && this.layer.events.un({
            sketchstarted: this.onSketchModified,
            sketchmodified: this.onSketchModified,
            vertexmodified: this.onVertexModified,
            scope: this
        });
        this.point = this.feature = null;
        return a
    },
    onSketchModified: function (a) {
        this.feature = a.feature;
        this.considerSnapping(a.vertex, a.vertex)
    },
    onVertexModified: function (a) {
        this.feature =
            a.feature;
        var b = this.layer.map.getLonLatFromViewPortPx(a.pixel);
        this.considerSnapping(a.vertex, new OpenLayers.Geometry.Point(b.lon, b.lat))
    },
    considerSnapping: function (a, b) {
        for (var c = {
            rank: Number.POSITIVE_INFINITY,
            dist: Number.POSITIVE_INFINITY,
            x: null,
            y: null
        }, d = !1, e, f, g = 0, h = this.targets.length; g < h; ++g)if (f = this.targets[g], e = this.testTarget(f, b))if (this.greedy) {
            c = e;
            c.target = f;
            d = !0;
            break
        } else if (e.rank < c.rank || e.rank === c.rank && e.dist < c.dist)c = e, c.target = f, d = !0;
        d && (!1 !== this.events.triggerEvent("beforesnap",
            {
                point: a,
                x: c.x,
                y: c.y,
                distance: c.dist,
                layer: c.target.layer,
                snapType: this.precedence[c.rank]
            }) ? (a.x = c.x, a.y = c.y, this.point = a, this.events.triggerEvent("snap", {
            point: a,
            snapType: this.precedence[c.rank],
            layer: c.target.layer,
            distance: c.dist
        })) : d = !1);
        this.point && !d && (a.x = b.x, a.y = b.y, this.point = null, this.events.triggerEvent("unsnap", {point: a}))
    },
    testTarget: function (a, b) {
        var c = this.layer.map.getResolution();
        if ("minResolution"in a && c < a.minResolution || "maxResolution"in a && c >= a.maxResolution)return null;
        for (var c =
        {
            node: this.getGeoTolerance(a.nodeTolerance, c),
            vertex: this.getGeoTolerance(a.vertexTolerance, c),
            edge: this.getGeoTolerance(a.edgeTolerance, c)
        }, d = Math.max(c.node, c.vertex, c.edge), e = {
            rank: Number.POSITIVE_INFINITY,
            dist: Number.POSITIVE_INFINITY
        }, f = !1, g = a.layer.features, h, k, l, m, n, o, p = this.precedence.length, r = new OpenLayers.LonLat(b.x, b.y), u = 0, q = g.length; u < q; ++u)if (h = g[u], h !== this.feature && !h._sketch && h.state !== OpenLayers.State.DELETE && (!a.filter || a.filter.evaluate(h)) && h.atPoint(r, d, d))for (var t = 0, y = Math.min(e.rank +
        1, p); t < y; ++t)if (k = this.precedence[t], a[k])if ("edge" === k) {
            if (l = h.geometry.distanceTo(b, {details: !0}), n = l.distance, n <= c[k] && n < e.dist) {
                e = {rank: t, dist: n, x: l.x0, y: l.y0};
                f = !0;
                break
            }
        } else {
            l = h.geometry.getVertices("node" === k);
            o = !1;
            for (var w = 0, A = l.length; w < A; ++w)if (m = l[w], n = m.distanceTo(b), n <= c[k] && (t < e.rank || t === e.rank && n < e.dist))e = {
                rank: t,
                dist: n,
                x: m.x,
                y: m.y
            }, o = f = !0;
            if (o)break
        }
        return f ? e : null
    },
    getGeoTolerance: function (a, b) {
        b !== this.resolution && (this.resolution = b, this.geoToleranceCache = {});
        var c = this.geoToleranceCache[a];
        void 0 === c && (c = a * b, this.geoToleranceCache[a] = c);
        return c
    },
    destroy: function () {
        this.active && this.deactivate();
        delete this.layer;
        delete this.targets;
        OpenLayers.Control.prototype.destroy.call(this)
    },
    CLASS_NAME: "OpenLayers.Control.Snapping"
});
OpenLayers.Control.Split = OpenLayers.Class(OpenLayers.Control, {
    layer: null,
    source: null,
    sourceOptions: null,
    tolerance: null,
    edge: !0,
    deferDelete: !1,
    mutual: !0,
    targetFilter: null,
    sourceFilter: null,
    handler: null,
    initialize: function (a) {
        OpenLayers.Control.prototype.initialize.apply(this, [a]);
        this.options = a || {};
        this.options.source && this.setSource(this.options.source)
    },
    setSource: function (a) {
        this.active ? (this.deactivate(), this.handler && (this.handler.destroy(), delete this.handler), this.source = a, this.activate()) : this.source =
            a
    },
    activate: function () {
        var a = OpenLayers.Control.prototype.activate.call(this);
        if (a)if (this.source) {
            if (this.source.events)this.source.events.on({
                sketchcomplete: this.onSketchComplete,
                afterfeaturemodified: this.afterFeatureModified,
                scope: this
            })
        } else this.handler || (this.handler = new OpenLayers.Handler.Path(this, {
            done: function (a) {
                this.onSketchComplete({feature: new OpenLayers.Feature.Vector(a)})
            }
        }, {layerOptions: this.sourceOptions})), this.handler.activate();
        return a
    },
    deactivate: function () {
        var a = OpenLayers.Control.prototype.deactivate.call(this);
        a && this.source && this.source.events && this.layer.events.un({
            sketchcomplete: this.onSketchComplete,
            afterfeaturemodified: this.afterFeatureModified,
            scope: this
        });
        return a
    },
    onSketchComplete: function (a) {
        this.feature = null;
        return !this.considerSplit(a.feature)
    },
    afterFeatureModified: function (a) {
        a.modified && "function" === typeof a.feature.geometry.split && (this.feature = a.feature, this.considerSplit(a.feature))
    },
    removeByGeometry: function (a, b) {
        for (var c = 0, d = a.length; c < d; ++c)if (a[c].geometry === b) {
            a.splice(c, 1);
            break
        }
    },
    isEligible: function (a) {
        return a.geometry ? a.state !== OpenLayers.State.DELETE && "function" === typeof a.geometry.split && this.feature !== a && (!this.targetFilter || this.targetFilter.evaluate(a.attributes)) : !1
    },
    considerSplit: function (a) {
        var b = !1, c = !1;
        if (!this.sourceFilter || this.sourceFilter.evaluate(a.attributes)) {
            for (var d = this.layer && this.layer.features || [], e, f, g = [], h = [], k = this.layer === this.source && this.mutual, l = {
                edge: this.edge,
                tolerance: this.tolerance,
                mutual: k
            }, m = [a.geometry], n, o, p, r = 0, u = d.length; r < u; ++r)if (n =
                    d[r], this.isEligible(n)) {
                o = [n.geometry];
                for (var q = 0; q < m.length; ++q) {
                    p = m[q];
                    for (var t = 0; t < o.length; ++t)if (e = o[t], p.getBounds().intersectsBounds(e.getBounds()) && (e = p.split(e, l)))f = this.events.triggerEvent("beforesplit", {
                        source: a,
                        target: n
                    }), !1 !== f && (k && (f = e[0], 1 < f.length && (f.unshift(q, 1), Array.prototype.splice.apply(m, f), q += f.length - 3), e = e[1]), 1 < e.length && (e.unshift(t, 1), Array.prototype.splice.apply(o, e), t += e.length - 3))
                }
                o && 1 < o.length && (this.geomsToFeatures(n, o), this.events.triggerEvent("split", {
                    original: n,
                    features: o
                }), Array.prototype.push.apply(g, o), h.push(n), c = !0)
            }
            m && 1 < m.length && (this.geomsToFeatures(a, m), this.events.triggerEvent("split", {
                original: a,
                features: m
            }), Array.prototype.push.apply(g, m), h.push(a), b = !0);
            if (b || c) {
                if (this.deferDelete) {
                    d = [];
                    r = 0;
                    for (u = h.length; r < u; ++r)c = h[r], c.state === OpenLayers.State.INSERT ? d.push(c) : (c.state = OpenLayers.State.DELETE, this.layer.drawFeature(c));
                    this.layer.destroyFeatures(d, {silent: !0});
                    r = 0;
                    for (u = g.length; r < u; ++r)g[r].state = OpenLayers.State.INSERT
                } else this.layer.destroyFeatures(h,
                    {silent: !0});
                this.layer.addFeatures(g, {silent: !0});
                this.events.triggerEvent("aftersplit", {source: a, features: g})
            }
        }
        return b
    },
    geomsToFeatures: function (a, b) {
        var c = a.clone();
        delete c.geometry;
        for (var d, e = 0, f = b.length; e < f; ++e)d = c.clone(), d.geometry = b[e], d.state = OpenLayers.State.INSERT, b[e] = d
    },
    destroy: function () {
        this.active && this.deactivate();
        OpenLayers.Control.prototype.destroy.call(this)
    },
    CLASS_NAME: "OpenLayers.Control.Split"
});
OpenLayers.Control.LayerSwitcher = OpenLayers.Class(OpenLayers.Control, {
    roundedCorner: !1,
    roundedCornerColor: "darkblue",
    layerStates: null,
    layersDiv: null,
    baseLayersDiv: null,
    baseLayers: null,
    dataLbl: null,
    dataLayersDiv: null,
    dataLayers: null,
    minimizeDiv: null,
    maximizeDiv: null,
    ascending: !0,
    initialize: function (a) {
        OpenLayers.Control.prototype.initialize.apply(this, arguments);
        this.layerStates = [];
        this.roundedCorner && OpenLayers.Console.warn("roundedCorner option is deprecated")
    },
    destroy: function () {
        this.clearLayersArray("base");
        this.clearLayersArray("data");
        this.map.events.un({
            buttonclick: this.onButtonClick,
            addlayer: this.redraw,
            changelayer: this.redraw,
            removelayer: this.redraw,
            changebaselayer: this.redraw,
            scope: this
        });
        this.events.unregister("buttonclick", this, this.onButtonClick);
        OpenLayers.Control.prototype.destroy.apply(this, arguments)
    },
    setMap: function (a) {
        OpenLayers.Control.prototype.setMap.apply(this, arguments);
        this.map.events.on({
            addlayer: this.redraw, changelayer: this.redraw, removelayer: this.redraw, changebaselayer: this.redraw,
            scope: this
        });
        this.outsideViewport ? (this.events.attachToElement(this.div), this.events.register("buttonclick", this, this.onButtonClick)) : this.map.events.register("buttonclick", this, this.onButtonClick)
    },
    draw: function () {
        OpenLayers.Control.prototype.draw.apply(this);
        this.loadContents();
        this.outsideViewport || this.minimizeControl();
        this.redraw();
        return this.div
    },
    onButtonClick: function (a) {
        a = a.buttonElement;
        a === this.minimizeDiv ? this.minimizeControl() : a === this.maximizeDiv ? this.maximizeControl() : a._layerSwitcher ===
        this.id && (a["for"] && (a = document.getElementById(a["for"])), a.disabled || ("radio" == a.type ? (a.checked = !0, this.map.setBaseLayer(this.map.getLayer(a._layer))) : (a.checked = !a.checked, this.updateMap())))
    },
    clearLayersArray: function (a) {
        this[a + "LayersDiv"].innerHTML = "";
        this[a + "Layers"] = []
    },
    checkRedraw: function () {
        var a = !1;
        if (!this.layerStates.length || this.map.layers.length != this.layerStates.length)a = !0; else for (var b = 0, c = this.layerStates.length; b < c; b++) {
            var d = this.layerStates[b], e = this.map.layers[b];
            if (d.name !=
                e.name || d.inRange != e.inRange || d.id != e.id || d.visibility != e.visibility) {
                a = !0;
                break
            }
        }
        return a
    },
    redraw: function () {
        if (!this.checkRedraw())return this.div;
        this.clearLayersArray("base");
        this.clearLayersArray("data");
        var a = !1, b = !1, c = this.map.layers.length;
        this.layerStates = Array(c);
        for (var d = 0; d < c; d++) {
            var e = this.map.layers[d];
            this.layerStates[d] = {name: e.name, visibility: e.visibility, inRange: e.inRange, id: e.id}
        }
        var f = this.map.layers.slice();
        this.ascending || f.reverse();
        d = 0;
        for (c = f.length; d < c; d++) {
            var e = f[d],
                g = e.isBaseLayer;
            if (e.displayInLayerSwitcher) {
                g ? b = !0 : a = !0;
                var h = g ? e == this.map.baseLayer : e.getVisibility(), k = document.createElement("input");
                k.id = this.id + "_input_" + e.name;
                k.name = g ? this.id + "_baseLayers" : e.name;
                k.type = g ? "radio" : "checkbox";
                k.value = e.name;
                k.checked = h;
                k.defaultChecked = h;
                k.className = "olButton";
                k._layer = e.id;
                k._layerSwitcher = this.id;
                !g && !e.inRange && (k.disabled = !0);
                h = document.createElement("label");
                h["for"] = k.id;
                OpenLayers.Element.addClass(h, "labelSpan olButton");
                h._layer = e.id;
                h._layerSwitcher =
                    this.id;
                !g && !e.inRange && (h.style.color = "gray");
                h.innerHTML = e.name;
                h.style.verticalAlign = g ? "bottom" : "baseline";
                var l = document.createElement("br");
                (g ? this.baseLayers : this.dataLayers).push({layer: e, inputElem: k, labelSpan: h});
                e = g ? this.baseLayersDiv : this.dataLayersDiv;
                e.appendChild(k);
                e.appendChild(h);
                e.appendChild(l)
            }
        }
        this.dataLbl.style.display = a ? "" : "none";
        this.baseLbl.style.display = b ? "" : "none";
        return this.div
    },
    updateMap: function () {
        for (var a = 0, b = this.baseLayers.length; a < b; a++) {
            var c = this.baseLayers[a];
            c.inputElem.checked && this.map.setBaseLayer(c.layer, !1)
        }
        a = 0;
        for (b = this.dataLayers.length; a < b; a++)c = this.dataLayers[a], c.layer.setVisibility(c.inputElem.checked)
    },
    maximizeControl: function (a) {
        this.div.style.width = "";
        this.div.style.height = "";
        this.showControls(!1);
        null != a && OpenLayers.Event.stop(a)
    },
    minimizeControl: function (a) {
        this.div.style.width = "0px";
        this.div.style.height = "0px";
        this.showControls(!0);
        null != a && OpenLayers.Event.stop(a)
    },
    showControls: function (a) {
        this.maximizeDiv.style.display = a ? "" : "none";
        this.minimizeDiv.style.display = a ? "none" : "";
        this.layersDiv.style.display = a ? "none" : ""
    },
    loadContents: function () {
        this.layersDiv = document.createElement("div");
        this.layersDiv.id = this.id + "_layersDiv";
        OpenLayers.Element.addClass(this.layersDiv, "layersDiv");
        this.baseLbl = document.createElement("div");
        this.baseLbl.innerHTML = OpenLayers.i18n("Base Layer");
        OpenLayers.Element.addClass(this.baseLbl, "baseLbl");
        this.baseLayersDiv = document.createElement("div");
        OpenLayers.Element.addClass(this.baseLayersDiv, "baseLayersDiv");
        this.dataLbl = document.createElement("div");
        this.dataLbl.innerHTML = OpenLayers.i18n("Overlays");
        OpenLayers.Element.addClass(this.dataLbl, "dataLbl");
        this.dataLayersDiv = document.createElement("div");
        OpenLayers.Element.addClass(this.dataLayersDiv, "dataLayersDiv");
        this.ascending ? (this.layersDiv.appendChild(this.baseLbl), this.layersDiv.appendChild(this.baseLayersDiv), this.layersDiv.appendChild(this.dataLbl), this.layersDiv.appendChild(this.dataLayersDiv)) : (this.layersDiv.appendChild(this.dataLbl), this.layersDiv.appendChild(this.dataLayersDiv),
            this.layersDiv.appendChild(this.baseLbl), this.layersDiv.appendChild(this.baseLayersDiv));
        this.div.appendChild(this.layersDiv);
        this.roundedCorner && (OpenLayers.Rico.Corner.round(this.div, {
            corners: "tl bl",
            bgColor: "transparent",
            color: this.roundedCornerColor,
            blend: !1
        }), OpenLayers.Rico.Corner.changeOpacity(this.layersDiv, 0.75));
        var a = OpenLayers.Util.getImageLocation("layer-switcher-maximize.png");
        this.maximizeDiv = OpenLayers.Util.createAlphaImageDiv("OpenLayers_Control_MaximizeDiv", null, null, a, "absolute");
        OpenLayers.Element.addClass(this.maximizeDiv, "maximizeDiv olButton");
        this.maximizeDiv.style.display = "none";
        this.div.appendChild(this.maximizeDiv);
        a = OpenLayers.Util.getImageLocation("layer-switcher-minimize.png");
        this.minimizeDiv = OpenLayers.Util.createAlphaImageDiv("OpenLayers_Control_MinimizeDiv", null, null, a, "absolute");
        OpenLayers.Element.addClass(this.minimizeDiv, "minimizeDiv olButton");
        this.minimizeDiv.style.display = "none";
        this.div.appendChild(this.minimizeDiv)
    },
    CLASS_NAME: "OpenLayers.Control.LayerSwitcher"
});
OpenLayers.Control.DrawFeature = OpenLayers.Class(OpenLayers.Control, {
    layer: null, callbacks: null, multi: !1, featureAdded: function () {
    }, handlerOptions: null, initialize: function (a, b, c) {
        OpenLayers.Control.prototype.initialize.apply(this, [c]);
        this.callbacks = OpenLayers.Util.extend({
            done: this.drawFeature, modify: function (a, b) {
                this.layer.events.triggerEvent("sketchmodified", {vertex: a, feature: b})
            }, create: function (a, b) {
                this.layer.events.triggerEvent("sketchstarted", {vertex: a, feature: b})
            }
        }, this.callbacks);
        this.layer =
            a;
        this.handlerOptions = this.handlerOptions || {};
        this.handlerOptions.layerOptions = OpenLayers.Util.applyDefaults(this.handlerOptions.layerOptions, {
            renderers: a.renderers,
            rendererOptions: a.rendererOptions
        });
        "multi"in this.handlerOptions || (this.handlerOptions.multi = this.multi);
        if (a = this.layer.styleMap && this.layer.styleMap.styles.temporary)this.handlerOptions.layerOptions = OpenLayers.Util.applyDefaults(this.handlerOptions.layerOptions, {styleMap: new OpenLayers.StyleMap({"default": a})});
        this.handler = new b(this,
            this.callbacks, this.handlerOptions)
    }, drawFeature: function (a) {
        a = new OpenLayers.Feature.Vector(a);
        !1 !== this.layer.events.triggerEvent("sketchcomplete", {feature: a}) && (a.state = OpenLayers.State.INSERT, this.layer.addFeatures([a]), this.featureAdded(a), this.events.triggerEvent("featureadded", {feature: a}))
    }, insertXY: function (a, b) {
        this.handler && this.handler.line && this.handler.insertXY(a, b)
    }, insertDeltaXY: function (a, b) {
        this.handler && this.handler.line && this.handler.insertDeltaXY(a, b)
    }, insertDirectionLength: function (a,
                                        b) {
        this.handler && this.handler.line && this.handler.insertDirectionLength(a, b)
    }, insertDeflectionLength: function (a, b) {
        this.handler && this.handler.line && this.handler.insertDeflectionLength(a, b)
    }, undo: function () {
        return this.handler.undo && this.handler.undo()
    }, redo: function () {
        return this.handler.redo && this.handler.redo()
    }, finishSketch: function () {
        this.handler.finishGeometry()
    }, cancel: function () {
        this.handler.cancel()
    }, CLASS_NAME: "OpenLayers.Control.DrawFeature"
});
OpenLayers.Control.DragFeature = OpenLayers.Class(OpenLayers.Control, {
    geometryTypes: null,
    onStart: function () {
    },
    onDrag: function () {
    },
    onComplete: function () {
    },
    onEnter: function () {
    },
    onLeave: function () {
    },
    documentDrag: !1,
    layer: null,
    feature: null,
    dragCallbacks: {},
    featureCallbacks: {},
    lastPixel: null,
    initialize: function (a, b) {
        OpenLayers.Control.prototype.initialize.apply(this, [b]);
        this.layer = a;
        this.handlers = {
            drag: new OpenLayers.Handler.Drag(this, OpenLayers.Util.extend({
                down: this.downFeature, move: this.moveFeature,
                up: this.upFeature, out: this.cancel, done: this.doneDragging
            }, this.dragCallbacks), {documentDrag: this.documentDrag}),
            feature: new OpenLayers.Handler.Feature(this, this.layer, OpenLayers.Util.extend({
                click: this.clickFeature,
                clickout: this.clickoutFeature,
                over: this.overFeature,
                out: this.outFeature
            }, this.featureCallbacks), {geometryTypes: this.geometryTypes})
        }
    },
    clickFeature: function (a) {
        this.handlers.feature.touch && !this.over && this.overFeature(a) && (this.handlers.drag.dragstart(this.handlers.feature.evt), this.handlers.drag.stopDown = !1)
    },
    clickoutFeature: function (a) {
        this.handlers.feature.touch && this.over && (this.outFeature(a), this.handlers.drag.stopDown = !0)
    },
    destroy: function () {
        this.layer = null;
        OpenLayers.Control.prototype.destroy.apply(this, [])
    },
    activate: function () {
        return this.handlers.feature.activate() && OpenLayers.Control.prototype.activate.apply(this, arguments)
    },
    deactivate: function () {
        this.handlers.drag.deactivate();
        this.handlers.feature.deactivate();
        this.feature = null;
        this.dragging = !1;
        this.lastPixel = null;
        OpenLayers.Element.removeClass(this.map.viewPortDiv,
            this.displayClass + "Over");
        return OpenLayers.Control.prototype.deactivate.apply(this, arguments)
    },
    overFeature: function (a) {
        var b = !1;
        this.handlers.drag.dragging ? this.over = this.feature.id == a.id ? !0 : !1 : (this.feature = a, this.handlers.drag.activate(), this.over = b = !0, OpenLayers.Element.addClass(this.map.viewPortDiv, this.displayClass + "Over"), this.onEnter(a));
        return b
    },
    downFeature: function (a) {
        this.lastPixel = a;
        this.onStart(this.feature, a)
    },
    moveFeature: function (a) {
        var b = this.map.getResolution();
        this.feature.geometry.move(b *
        (a.x - this.lastPixel.x), b * (this.lastPixel.y - a.y));
        this.layer.drawFeature(this.feature);
        this.lastPixel = a;
        this.onDrag(this.feature, a)
    },
    upFeature: function () {
        this.over || this.handlers.drag.deactivate()
    },
    doneDragging: function (a) {
        this.onComplete(this.feature, a)
    },
    outFeature: function (a) {
        this.handlers.drag.dragging ? this.feature.id == a.id && (this.over = !1) : (this.over = !1, this.handlers.drag.deactivate(), OpenLayers.Element.removeClass(this.map.viewPortDiv, this.displayClass + "Over"), this.onLeave(a), this.feature = null)
    },
    cancel: function () {
        this.handlers.drag.deactivate();
        this.over = !1
    },
    setMap: function (a) {
        this.handlers.drag.setMap(a);
        this.handlers.feature.setMap(a);
        OpenLayers.Control.prototype.setMap.apply(this, arguments)
    },
    CLASS_NAME: "OpenLayers.Control.DragFeature"
});
OpenLayers.Control.ModifyFeature = OpenLayers.Class(OpenLayers.Control, {
    geometryTypes: null,
    clickout: !0,
    toggle: !0,
    standalone: !1,
    layer: null,
    feature: null,
    vertices: null,
    virtualVertices: null,
    selectControl: null,
    dragControl: null,
    handlers: null,
    deleteCodes: null,
    virtualStyle: null,
    vertexRenderIntent: null,
    mode: null,
    createVertices: !0,
    modified: !1,
    radiusHandle: null,
    dragHandle: null,
    onModificationStart: function () {
    },
    onModification: function () {
    },
    onModificationEnd: function () {
    },
    initialize: function (a, b) {
        b = b || {};
        this.layer =
            a;
        this.vertices = [];
        this.virtualVertices = [];
        this.virtualStyle = OpenLayers.Util.extend({}, this.layer.style || this.layer.styleMap.createSymbolizer(null, b.vertexRenderIntent));
        this.virtualStyle.fillOpacity = 0.3;
        this.virtualStyle.strokeOpacity = 0.3;
        this.deleteCodes = [46, 68];
        this.mode = OpenLayers.Control.ModifyFeature.RESHAPE;
        OpenLayers.Control.prototype.initialize.apply(this, [b]);
        OpenLayers.Util.isArray(this.deleteCodes) || (this.deleteCodes = [this.deleteCodes]);
        var c = this, d = {
            geometryTypes: this.geometryTypes,
            clickout: this.clickout,
            toggle: this.toggle,
            onBeforeSelect: this.beforeSelectFeature,
            onSelect: this.selectFeature,
            onUnselect: this.unselectFeature,
            scope: this
        };
        !1 === this.standalone && (this.selectControl = new OpenLayers.Control.SelectFeature(a, d));
        this.dragControl = new OpenLayers.Control.DragFeature(a, {
            geometryTypes: ["OpenLayers.Geometry.Point"], onStart: function (a, b) {
                c.dragStart.apply(c, [a, b])
            }, onDrag: function (a, b) {
                c.dragVertex.apply(c, [a, b])
            }, onComplete: function (a) {
                c.dragComplete.apply(c, [a])
            }, featureCallbacks: {
                over: function (a) {
                    (!0 !==
                    c.standalone || a._sketch || c.feature === a) && c.dragControl.overFeature.apply(c.dragControl, [a])
                }
            }
        });
        this.handlers = {keyboard: new OpenLayers.Handler.Keyboard(this, {keydown: this.handleKeypress})}
    },
    destroy: function () {
        this.layer = null;
        this.standalone || this.selectControl.destroy();
        this.dragControl.destroy();
        OpenLayers.Control.prototype.destroy.apply(this, [])
    },
    activate: function () {
        return (this.standalone || this.selectControl.activate()) && this.handlers.keyboard.activate() && OpenLayers.Control.prototype.activate.apply(this,
                arguments)
    },
    deactivate: function () {
        var a = !1;
        if (OpenLayers.Control.prototype.deactivate.apply(this, arguments)) {
            this.layer.removeFeatures(this.vertices, {silent: !0});
            this.layer.removeFeatures(this.virtualVertices, {silent: !0});
            this.vertices = [];
            this.dragControl.deactivate();
            var b = (a = this.feature) && a.geometry && a.layer;
            !1 === this.standalone ? (b && this.selectControl.unselect.apply(this.selectControl, [a]), this.selectControl.deactivate()) : b && this.unselectFeature(a);
            this.handlers.keyboard.deactivate();
            a = !0
        }
        return a
    },
    beforeSelectFeature: function (a) {
        return this.layer.events.triggerEvent("beforefeaturemodified", {feature: a})
    },
    selectFeature: function (a) {
        if (!this.standalone || !1 !== this.beforeSelectFeature(a))this.feature = a, this.modified = !1, this.resetVertices(), this.dragControl.activate(), this.onModificationStart(this.feature);
        var b = a.modified;
        if (a.geometry && (!b || !b.geometry))this._originalGeometry = a.geometry.clone()
    },
    unselectFeature: function (a) {
        this.layer.removeFeatures(this.vertices, {silent: !0});
        this.vertices = [];
        this.layer.destroyFeatures(this.virtualVertices,
            {silent: !0});
        this.virtualVertices = [];
        this.dragHandle && (this.layer.destroyFeatures([this.dragHandle], {silent: !0}), delete this.dragHandle);
        this.radiusHandle && (this.layer.destroyFeatures([this.radiusHandle], {silent: !0}), delete this.radiusHandle);
        this.feature = null;
        this.dragControl.deactivate();
        this.onModificationEnd(a);
        this.layer.events.triggerEvent("afterfeaturemodified", {feature: a, modified: this.modified});
        this.modified = !1
    },
    dragStart: function (a, b) {
        if (a != this.feature && !a.geometry.parent && a != this.dragHandle &&
            a != this.radiusHandle && (!1 === this.standalone && this.feature && this.selectControl.clickFeature.apply(this.selectControl, [this.feature]), null == this.geometryTypes || -1 != OpenLayers.Util.indexOf(this.geometryTypes, a.geometry.CLASS_NAME)))this.standalone || this.selectControl.clickFeature.apply(this.selectControl, [a]), this.dragControl.overFeature.apply(this.dragControl, [a]), this.dragControl.lastPixel = b, this.dragControl.handlers.drag.started = !0, this.dragControl.handlers.drag.start = b, this.dragControl.handlers.drag.last =
            b
    },
    dragVertex: function (a, b) {
        this.modified = !0;
        "OpenLayers.Geometry.Point" == this.feature.geometry.CLASS_NAME ? (this.feature != a && (this.feature = a), this.layer.events.triggerEvent("vertexmodified", {
            vertex: a.geometry,
            feature: this.feature,
            pixel: b
        })) : (a._index ? (a.geometry.parent.addComponent(a.geometry, a._index), delete a._index, OpenLayers.Util.removeItem(this.virtualVertices, a), this.vertices.push(a)) : a == this.dragHandle ? (this.layer.removeFeatures(this.vertices, {silent: !0}), this.vertices = [], this.radiusHandle &&
        (this.layer.destroyFeatures([this.radiusHandle], {silent: !0}), this.radiusHandle = null)) : a !== this.radiusHandle && this.layer.events.triggerEvent("vertexmodified", {
            vertex: a.geometry,
            feature: this.feature,
            pixel: b
        }), 0 < this.virtualVertices.length && (this.layer.destroyFeatures(this.virtualVertices, {silent: !0}), this.virtualVertices = []), this.layer.drawFeature(this.feature, this.standalone ? void 0 : this.selectControl.renderIntent));
        this.layer.drawFeature(a)
    },
    dragComplete: function () {
        this.resetVertices();
        this.setFeatureState();
        this.onModification(this.feature);
        this.layer.events.triggerEvent("featuremodified", {feature: this.feature})
    },
    setFeatureState: function () {
        if (this.feature.state != OpenLayers.State.INSERT && this.feature.state != OpenLayers.State.DELETE && (this.feature.state = OpenLayers.State.UPDATE, this.modified && this._originalGeometry)) {
            var a = this.feature;
            a.modified = OpenLayers.Util.extend(a.modified, {geometry: this._originalGeometry});
            delete this._originalGeometry
        }
    },
    resetVertices: function () {
        this.dragControl.feature && this.dragControl.outFeature(this.dragControl.feature);
        0 < this.vertices.length && (this.layer.removeFeatures(this.vertices, {silent: !0}), this.vertices = []);
        0 < this.virtualVertices.length && (this.layer.removeFeatures(this.virtualVertices, {silent: !0}), this.virtualVertices = []);
        this.dragHandle && (this.layer.destroyFeatures([this.dragHandle], {silent: !0}), this.dragHandle = null);
        this.radiusHandle && (this.layer.destroyFeatures([this.radiusHandle], {silent: !0}), this.radiusHandle = null);
        this.feature && "OpenLayers.Geometry.Point" != this.feature.geometry.CLASS_NAME && (this.mode &
        OpenLayers.Control.ModifyFeature.DRAG && this.collectDragHandle(), this.mode & (OpenLayers.Control.ModifyFeature.ROTATE | OpenLayers.Control.ModifyFeature.RESIZE) && this.collectRadiusHandle(), this.mode & OpenLayers.Control.ModifyFeature.RESHAPE && (this.mode & OpenLayers.Control.ModifyFeature.RESIZE || this.collectVertices()))
    },
    handleKeypress: function (a) {
        var b = a.keyCode;
        if (this.feature && -1 != OpenLayers.Util.indexOf(this.deleteCodes, b) && (b = this.dragControl.feature) && -1 != OpenLayers.Util.indexOf(this.vertices, b) && !this.dragControl.handlers.drag.dragging &&
            b.geometry.parent)b.geometry.parent.removeComponent(b.geometry), this.layer.events.triggerEvent("vertexremoved", {
            vertex: b.geometry,
            feature: this.feature,
            pixel: a.xy
        }), this.layer.drawFeature(this.feature, this.standalone ? void 0 : this.selectControl.renderIntent), this.modified = !0, this.resetVertices(), this.setFeatureState(), this.onModification(this.feature), this.layer.events.triggerEvent("featuremodified", {feature: this.feature})
    },
    collectVertices: function () {
        function a(c) {
            var d, e, f;
            if ("OpenLayers.Geometry.Point" ==
                c.CLASS_NAME)e = new OpenLayers.Feature.Vector(c), e._sketch = !0, e.renderIntent = b.vertexRenderIntent, b.vertices.push(e); else {
                f = c.components.length;
                "OpenLayers.Geometry.LinearRing" == c.CLASS_NAME && (f -= 1);
                for (d = 0; d < f; ++d)e = c.components[d], "OpenLayers.Geometry.Point" == e.CLASS_NAME ? (e = new OpenLayers.Feature.Vector(e), e._sketch = !0, e.renderIntent = b.vertexRenderIntent, b.vertices.push(e)) : a(e);
                if (b.createVertices && "OpenLayers.Geometry.MultiPoint" != c.CLASS_NAME)for (d = 0, f = c.components.length; d < f - 1; ++d) {
                    e = c.components[d];
                    var g = c.components[d + 1];
                    "OpenLayers.Geometry.Point" == e.CLASS_NAME && "OpenLayers.Geometry.Point" == g.CLASS_NAME && (e = new OpenLayers.Feature.Vector(new OpenLayers.Geometry.Point((e.x + g.x) / 2, (e.y + g.y) / 2), null, b.virtualStyle), e.geometry.parent = c, e._index = d + 1, e._sketch = !0, b.virtualVertices.push(e))
                }
            }
        }

        this.vertices = [];
        this.virtualVertices = [];
        var b = this;
        a.call(this, this.feature.geometry);
        this.layer.addFeatures(this.virtualVertices, {silent: !0});
        this.layer.addFeatures(this.vertices, {silent: !0})
    },
    collectDragHandle: function () {
        var a =
            this.feature.geometry, b = a.getBounds().getCenterLonLat(), b = new OpenLayers.Geometry.Point(b.lon, b.lat), c = new OpenLayers.Feature.Vector(b);
        b.move = function (b, c) {
            OpenLayers.Geometry.Point.prototype.move.call(this, b, c);
            a.move(b, c)
        };
        c._sketch = !0;
        this.dragHandle = c;
        this.dragHandle.renderIntent = this.vertexRenderIntent;
        this.layer.addFeatures([this.dragHandle], {silent: !0})
    },
    collectRadiusHandle: function () {
        var a = this.feature.geometry, b = a.getBounds(), c = b.getCenterLonLat(), d = new OpenLayers.Geometry.Point(c.lon, c.lat),
            b = new OpenLayers.Geometry.Point(b.right, b.bottom), c = new OpenLayers.Feature.Vector(b), e = this.mode & OpenLayers.Control.ModifyFeature.RESIZE, f = this.mode & OpenLayers.Control.ModifyFeature.RESHAPE, g = this.mode & OpenLayers.Control.ModifyFeature.ROTATE;
        b.move = function (b, c) {
            OpenLayers.Geometry.Point.prototype.move.call(this, b, c);
            var l = this.x - d.x, m = this.y - d.y, n = l - b, o = m - c;
            if (g) {
                var p = Math.atan2(o, n), p = Math.atan2(m, l) - p, p = p * (180 / Math.PI);
                a.rotate(p, d)
            }
            if (e) {
                var r;
                f ? (m /= o, r = l / n / m) : (n = Math.sqrt(n * n + o * o), m = Math.sqrt(l *
                l + m * m) / n);
                a.resize(m, d, r)
            }
        };
        c._sketch = !0;
        this.radiusHandle = c;
        this.radiusHandle.renderIntent = this.vertexRenderIntent;
        this.layer.addFeatures([this.radiusHandle], {silent: !0})
    },
    setMap: function (a) {
        this.standalone || this.selectControl.setMap(a);
        this.dragControl.setMap(a);
        OpenLayers.Control.prototype.setMap.apply(this, arguments)
    },
    CLASS_NAME: "OpenLayers.Control.ModifyFeature"
});
OpenLayers.Control.ModifyFeature.RESHAPE = 1;
OpenLayers.Control.ModifyFeature.RESIZE = 2;
OpenLayers.Control.ModifyFeature.ROTATE = 4;
OpenLayers.Control.ModifyFeature.DRAG = 8;
OpenLayers.Control.Panel = OpenLayers.Class(OpenLayers.Control, {
    controls: null,
    autoActivate: !0,
    defaultControl: null,
    saveState: !1,
    allowDepress: !1,
    activeState: null,
    initialize: function (a) {
        OpenLayers.Control.prototype.initialize.apply(this, [a]);
        this.controls = [];
        this.activeState = {}
    },
    destroy: function () {
        this.map && this.map.events.unregister("buttonclick", this, this.onButtonClick);
        OpenLayers.Control.prototype.destroy.apply(this, arguments);
        for (var a, b = this.controls.length - 1; 0 <= b; b--)a = this.controls[b], a.events &&
        a.events.un({activate: this.iconOn, deactivate: this.iconOff}), a.panel_div = null;
        this.activeState = null
    },
    activate: function () {
        if (OpenLayers.Control.prototype.activate.apply(this, arguments)) {
            for (var a, b = 0, c = this.controls.length; b < c; b++)a = this.controls[b], (a === this.defaultControl || this.saveState && this.activeState[a.id]) && a.activate();
            !0 === this.saveState && (this.defaultControl = null);
            this.redraw();
            return !0
        }
        return !1
    },
    deactivate: function () {
        if (OpenLayers.Control.prototype.deactivate.apply(this, arguments)) {
            for (var a,
                     b = 0, c = this.controls.length; b < c; b++)a = this.controls[b], this.activeState[a.id] = a.deactivate();
            this.redraw();
            return !0
        }
        return !1
    },
    draw: function () {
        OpenLayers.Control.prototype.draw.apply(this, arguments);
        this.outsideViewport ? (this.events.attachToElement(this.div), this.events.register("buttonclick", this, this.onButtonClick)) : this.map.events.register("buttonclick", this, this.onButtonClick);
        this.addControlsToMap(this.controls);
        return this.div
    },
    redraw: function () {
        for (var a = this.div.childNodes.length - 1; 0 <= a; a--)this.div.removeChild(this.div.childNodes[a]);
        this.div.innerHTML = "";
        if (this.active)for (var a = 0, b = this.controls.length; a < b; a++)this.div.appendChild(this.controls[a].panel_div)
    },
    activateControl: function (a) {
        if (!this.active)return !1;
        if (a.type == OpenLayers.Control.TYPE_BUTTON)a.trigger(); else if (a.type == OpenLayers.Control.TYPE_TOGGLE)a.active ? a.deactivate() : a.activate(); else if (this.allowDepress && a.active)a.deactivate(); else {
            for (var b, c = 0, d = this.controls.length; c < d; c++)b = this.controls[c], b != a && (b.type === OpenLayers.Control.TYPE_TOOL || null == b.type) &&
            b.deactivate();
            a.activate()
        }
    },
    addControls: function (a) {
        OpenLayers.Util.isArray(a) || (a = [a]);
        this.controls = this.controls.concat(a);
        for (var b = 0, c = a.length; b < c; b++) {
            var d = a[b], e = this.createControlMarkup(d);
            OpenLayers.Element.addClass(e, d.displayClass + "ItemInactive");
            OpenLayers.Element.addClass(e, "olButton");
            "" != d.title && !e.title && (e.title = d.title);
            d.panel_div = e
        }
        this.map && (this.addControlsToMap(a), this.redraw())
    },
    createControlMarkup: function () {
        return document.createElement("div")
    },
    addControlsToMap: function (a) {
        for (var b,
                 c = 0, d = a.length; c < d; c++)b = a[c], !0 === b.autoActivate ? (b.autoActivate = !1, this.map.addControl(b), b.autoActivate = !0) : (this.map.addControl(b), b.deactivate()), b.events.on({
            activate: this.iconOn,
            deactivate: this.iconOff
        })
    },
    iconOn: function () {
        var a = this.panel_div;
        a.className = a.className.replace(RegExp("\\b(" + this.displayClass + "Item)Inactive\\b"), "$1Active")
    },
    iconOff: function () {
        var a = this.panel_div;
        a.className = a.className.replace(RegExp("\\b(" + this.displayClass + "Item)Active\\b"), "$1Inactive")
    },
    onButtonClick: function (a) {
        for (var b =
            this.controls, a = a.buttonElement, c = b.length - 1; 0 <= c; --c)if (b[c].panel_div === a) {
            this.activateControl(b[c]);
            break
        }
    },
    getControlsBy: function (a, b) {
        var c = "function" == typeof b.test;
        return OpenLayers.Array.filter(this.controls, function (d) {
            return d[a] == b || c && b.test(d[a])
        })
    },
    getControlsByName: function (a) {
        return this.getControlsBy("name", a)
    },
    getControlsByClass: function (a) {
        return this.getControlsBy("CLASS_NAME", a)
    },
    CLASS_NAME: "OpenLayers.Control.Panel"
});
OpenLayers.Control.SelectFeature = OpenLayers.Class(OpenLayers.Control, {
    multipleKey: null,
    toggleKey: null,
    multiple: !1,
    clickout: !0,
    toggle: !1,
    hover: !1,
    highlightOnly: !1,
    box: !1,
    onBeforeSelect: function () {
    },
    onSelect: function () {
    },
    onUnselect: function () {
    },
    scope: null,
    geometryTypes: null,
    layer: null,
    layers: null,
    callbacks: null,
    selectStyle: null,
    renderIntent: "select",
    handlers: null,
    initialize: function (a, b) {
        OpenLayers.Control.prototype.initialize.apply(this, [b]);
        null === this.scope && (this.scope = this);
        this.initLayer(a);
        var c =
        {click: this.clickFeature, clickout: this.clickoutFeature};
        this.hover && (c.over = this.overFeature, c.out = this.outFeature);
        this.callbacks = OpenLayers.Util.extend(c, this.callbacks);
        this.handlers = {feature: new OpenLayers.Handler.Feature(this, this.layer, this.callbacks, {geometryTypes: this.geometryTypes})};
        this.box && (this.handlers.box = new OpenLayers.Handler.Box(this, {done: this.selectBox}, {boxDivClassName: "olHandlerBoxSelectFeature"}))
    },
    initLayer: function (a) {
        OpenLayers.Util.isArray(a) ? (this.layers = a, this.layer =
            new OpenLayers.Layer.Vector.RootContainer(this.id + "_container", {layers: a})) : this.layer = a
    },
    destroy: function () {
        this.active && this.layers && this.map.removeLayer(this.layer);
        OpenLayers.Control.prototype.destroy.apply(this, arguments);
        this.layers && this.layer.destroy()
    },
    activate: function () {
        this.active || (this.layers && this.map.addLayer(this.layer), this.handlers.feature.activate(), this.box && this.handlers.box && this.handlers.box.activate());
        return OpenLayers.Control.prototype.activate.apply(this, arguments)
    },
    deactivate: function () {
        this.active &&
        (this.handlers.feature.deactivate(), this.handlers.box && this.handlers.box.deactivate(), this.layers && this.map.removeLayer(this.layer));
        return OpenLayers.Control.prototype.deactivate.apply(this, arguments)
    },
    unselectAll: function (a) {
        for (var b = this.layers || [this.layer], c, d, e = 0; e < b.length; ++e) {
            c = b[e];
            for (var f = c.selectedFeatures.length - 1; 0 <= f; --f)d = c.selectedFeatures[f], (!a || a.except != d) && this.unselect(d)
        }
    },
    clickFeature: function (a) {
        this.hover || (-1 < OpenLayers.Util.indexOf(a.layer.selectedFeatures, a) ? this.toggleSelect() ?
            this.unselect(a) : this.multipleSelect() || this.unselectAll({except: a}) : (this.multipleSelect() || this.unselectAll({except: a}), this.select(a)))
    },
    multipleSelect: function () {
        return this.multiple || this.handlers.feature.evt && this.handlers.feature.evt[this.multipleKey]
    },
    toggleSelect: function () {
        return this.toggle || this.handlers.feature.evt && this.handlers.feature.evt[this.toggleKey]
    },
    clickoutFeature: function () {
        !this.hover && this.clickout && this.unselectAll()
    },
    overFeature: function (a) {
        var b = a.layer;
        this.hover && (this.highlightOnly ?
            this.highlight(a) : -1 == OpenLayers.Util.indexOf(b.selectedFeatures, a) && this.select(a))
    },
    outFeature: function (a) {
        if (this.hover)if (this.highlightOnly) {
            if (a._lastHighlighter == this.id)if (a._prevHighlighter && a._prevHighlighter != this.id) {
                delete a._lastHighlighter;
                var b = this.map.getControl(a._prevHighlighter);
                b && b.highlight(a)
            } else this.unhighlight(a)
        } else this.unselect(a)
    },
    highlight: function (a) {
        var b = a.layer;
        !1 !== this.events.triggerEvent("beforefeaturehighlighted", {feature: a}) && (a._prevHighlighter = a._lastHighlighter,
            a._lastHighlighter = this.id, b.drawFeature(a, this.selectStyle || this.renderIntent), this.events.triggerEvent("featurehighlighted", {feature: a}))
    },
    unhighlight: function (a) {
        var b = a.layer;
        void 0 == a._prevHighlighter ? delete a._lastHighlighter : (a._prevHighlighter != this.id && (a._lastHighlighter = a._prevHighlighter), delete a._prevHighlighter);
        b.drawFeature(a, a.style || a.layer.style || "default");
        this.events.triggerEvent("featureunhighlighted", {feature: a})
    },
    select: function (a) {
        var b = this.onBeforeSelect.call(this.scope,
            a), c = a.layer;
        !1 !== b && (b = c.events.triggerEvent("beforefeatureselected", {feature: a}), !1 !== b && (c.selectedFeatures.push(a), this.highlight(a), this.handlers.feature.lastFeature || (this.handlers.feature.lastFeature = c.selectedFeatures[0]), c.events.triggerEvent("featureselected", {feature: a}), this.onSelect.call(this.scope, a)))
    },
    unselect: function (a) {
        var b = a.layer;
        this.unhighlight(a);
        OpenLayers.Util.removeItem(b.selectedFeatures, a);
        b.events.triggerEvent("featureunselected", {feature: a});
        this.onUnselect.call(this.scope,
            a)
    },
    selectBox: function (a) {
        if (a instanceof OpenLayers.Bounds) {
            var b = this.map.getLonLatFromPixel({x: a.left, y: a.bottom}), a = this.map.getLonLatFromPixel({
                x: a.right,
                y: a.top
            }), b = new OpenLayers.Bounds(b.lon, b.lat, a.lon, a.lat);
            this.multipleSelect() || this.unselectAll();
            a = this.multiple;
            this.multiple = !0;
            var c = this.layers || [this.layer];
            this.events.triggerEvent("boxselectionstart", {layers: c});
            for (var d, e = 0; e < c.length; ++e) {
                d = c[e];
                for (var f = 0, g = d.features.length; f < g; ++f) {
                    var h = d.features[f];
                    h.getVisibility() && (null ==
                    this.geometryTypes || -1 < OpenLayers.Util.indexOf(this.geometryTypes, h.geometry.CLASS_NAME)) && b.toGeometry().intersects(h.geometry) && -1 == OpenLayers.Util.indexOf(d.selectedFeatures, h) && this.select(h)
                }
            }
            this.multiple = a;
            this.events.triggerEvent("boxselectionend", {layers: c})
        }
    },
    setMap: function (a) {
        this.handlers.feature.setMap(a);
        this.box && this.handlers.box.setMap(a);
        OpenLayers.Control.prototype.setMap.apply(this, arguments)
    },
    setLayer: function (a) {
        var b = this.active;
        this.unselectAll();
        this.deactivate();
        this.layers &&
        (this.layer.destroy(), this.layers = null);
        this.initLayer(a);
        this.handlers.feature.layer = this.layer;
        b && this.activate()
    },
    CLASS_NAME: "OpenLayers.Control.SelectFeature"
});
OpenLayers.Control.NavigationHistory = OpenLayers.Class(OpenLayers.Control, {
    type: OpenLayers.Control.TYPE_TOGGLE,
    previous: null,
    previousOptions: null,
    next: null,
    nextOptions: null,
    limit: 50,
    autoActivate: !0,
    clearOnDeactivate: !1,
    registry: null,
    nextStack: null,
    previousStack: null,
    listeners: null,
    restoring: !1,
    initialize: function (a) {
        OpenLayers.Control.prototype.initialize.apply(this, [a]);
        this.registry = OpenLayers.Util.extend({moveend: this.getState}, this.registry);
        a = {
            trigger: OpenLayers.Function.bind(this.previousTrigger,
                this), displayClass: this.displayClass + " " + this.displayClass + "Previous"
        };
        OpenLayers.Util.extend(a, this.previousOptions);
        this.previous = new OpenLayers.Control.Button(a);
        a = {
            trigger: OpenLayers.Function.bind(this.nextTrigger, this),
            displayClass: this.displayClass + " " + this.displayClass + "Next"
        };
        OpenLayers.Util.extend(a, this.nextOptions);
        this.next = new OpenLayers.Control.Button(a);
        this.clear()
    },
    onPreviousChange: function (a) {
        a && !this.previous.active ? this.previous.activate() : !a && this.previous.active && this.previous.deactivate()
    },
    onNextChange: function (a) {
        a && !this.next.active ? this.next.activate() : !a && this.next.active && this.next.deactivate()
    },
    destroy: function () {
        OpenLayers.Control.prototype.destroy.apply(this);
        this.previous.destroy();
        this.next.destroy();
        this.deactivate();
        for (var a in this)this[a] = null
    },
    setMap: function (a) {
        this.map = a;
        this.next.setMap(a);
        this.previous.setMap(a)
    },
    draw: function () {
        OpenLayers.Control.prototype.draw.apply(this, arguments);
        this.next.draw();
        this.previous.draw()
    },
    previousTrigger: function () {
        var a = this.previousStack.shift(),
            b = this.previousStack.shift();
        void 0 != b ? (this.nextStack.unshift(a), this.previousStack.unshift(b), this.restoring = !0, this.restore(b), this.restoring = !1, this.onNextChange(this.nextStack[0], this.nextStack.length), this.onPreviousChange(this.previousStack[1], this.previousStack.length - 1)) : this.previousStack.unshift(a);
        return b
    },
    nextTrigger: function () {
        var a = this.nextStack.shift();
        void 0 != a && (this.previousStack.unshift(a), this.restoring = !0, this.restore(a), this.restoring = !1, this.onNextChange(this.nextStack[0],
            this.nextStack.length), this.onPreviousChange(this.previousStack[1], this.previousStack.length - 1));
        return a
    },
    clear: function () {
        this.previousStack = [];
        this.previous.deactivate();
        this.nextStack = [];
        this.next.deactivate()
    },
    getState: function () {
        return {
            center: this.map.getCenter(),
            resolution: this.map.getResolution(),
            projection: this.map.getProjectionObject(),
            units: this.map.getProjectionObject().getUnits() || this.map.units || this.map.baseLayer.units
        }
    },
    restore: function (a) {
        var b, c;
        if (this.map.getProjectionObject() ==
            a.projection)c = this.map.getZoomForResolution(a.resolution), b = a.center; else {
            b = a.center.clone();
            b.transform(a.projection, this.map.getProjectionObject());
            c = a.units;
            var d = this.map.getProjectionObject().getUnits() || this.map.units || this.map.baseLayer.units;
            c = this.map.getZoomForResolution((c && d ? OpenLayers.INCHES_PER_UNIT[c] / OpenLayers.INCHES_PER_UNIT[d] : 1) * a.resolution)
        }
        this.map.setCenter(b, c)
    },
    setListeners: function () {
        this.listeners = {};
        for (var a in this.registry)this.listeners[a] = OpenLayers.Function.bind(function () {
            if (!this.restoring) {
                this.previousStack.unshift(this.registry[a].apply(this,
                    arguments));
                if (1 < this.previousStack.length)this.onPreviousChange(this.previousStack[1], this.previousStack.length - 1);
                this.previousStack.length > this.limit + 1 && this.previousStack.pop();
                0 < this.nextStack.length && (this.nextStack = [], this.onNextChange(null, 0))
            }
            return !0
        }, this)
    },
    activate: function () {
        var a = !1;
        if (this.map && OpenLayers.Control.prototype.activate.apply(this)) {
            null == this.listeners && this.setListeners();
            for (var b in this.listeners)this.map.events.register(b, this, this.listeners[b]);
            a = !0;
            0 == this.previousStack.length &&
            this.initStack()
        }
        return a
    },
    initStack: function () {
        this.map.getCenter() && this.listeners.moveend()
    },
    deactivate: function () {
        var a = !1;
        if (this.map && OpenLayers.Control.prototype.deactivate.apply(this)) {
            for (var b in this.listeners)this.map.events.unregister(b, this, this.listeners[b]);
            this.clearOnDeactivate && this.clear();
            a = !0
        }
        return a
    },
    CLASS_NAME: "OpenLayers.Control.NavigationHistory"
});
OpenLayers.Control.Measure = OpenLayers.Class(OpenLayers.Control, {
    handlerOptions: null,
    callbacks: null,
    displaySystem: "metric",
    geodesic: !1,
    displaySystemUnits: {geographic: ["dd"], english: ["mi", "ft", "in"], metric: ["km", "m"]},
    partialDelay: 300,
    delayedTrigger: null,
    persist: !1,
    immediate: !1,
    initialize: function (a, b) {
        OpenLayers.Control.prototype.initialize.apply(this, [b]);
        var c = {done: this.measureComplete, point: this.measurePartial};
        this.immediate && (c.modify = this.measureImmediate);
        this.callbacks = OpenLayers.Util.extend(c,
            this.callbacks);
        this.handlerOptions = OpenLayers.Util.extend({persist: this.persist}, this.handlerOptions);
        this.handler = new a(this, this.callbacks, this.handlerOptions)
    },
    deactivate: function () {
        this.cancelDelay();
        return OpenLayers.Control.prototype.deactivate.apply(this, arguments)
    },
    cancel: function () {
        this.cancelDelay();
        this.handler.cancel()
    },
    setImmediate: function (a) {
        (this.immediate = a) ? this.callbacks.modify = this.measureImmediate : delete this.callbacks.modify
    },
    updateHandler: function (a, b) {
        var c = this.active;
        c &&
        this.deactivate();
        this.handler = new a(this, this.callbacks, b);
        c && this.activate()
    },
    measureComplete: function (a) {
        this.cancelDelay();
        this.measure(a, "measure")
    },
    measurePartial: function (a, b) {
        this.cancelDelay();
        b = b.clone();
        this.handler.freehandMode(this.handler.evt) ? this.measure(b, "measurepartial") : this.delayedTrigger = window.setTimeout(OpenLayers.Function.bind(function () {
            this.delayedTrigger = null;
            this.measure(b, "measurepartial")
        }, this), this.partialDelay)
    },
    measureImmediate: function (a, b, c) {
        c && !this.handler.freehandMode(this.handler.evt) &&
        (this.cancelDelay(), this.measure(b.geometry, "measurepartial"))
    },
    cancelDelay: function () {
        null !== this.delayedTrigger && (window.clearTimeout(this.delayedTrigger), this.delayedTrigger = null)
    },
    measure: function (a, b) {
        var c, d;
        -1 < a.CLASS_NAME.indexOf("LineString") ? (c = this.getBestLength(a), d = 1) : (c = this.getBestArea(a), d = 2);
        this.events.triggerEvent(b, {measure: c[0], units: c[1], order: d, geometry: a})
    },
    getBestArea: function (a) {
        for (var b = this.displaySystemUnits[this.displaySystem], c, d, e = 0, f = b.length; e < f && !(c = b[e], d = this.getArea(a,
            c), 1 < d); ++e);
        return [d, c]
    },
    getArea: function (a, b) {
        var c, d;
        this.geodesic ? (c = a.getGeodesicArea(this.map.getProjectionObject()), d = "m") : (c = a.getArea(), d = this.map.getUnits());
        var e = OpenLayers.INCHES_PER_UNIT[b];
        e && (c *= Math.pow(OpenLayers.INCHES_PER_UNIT[d] / e, 2));
        return c
    },
    getBestLength: function (a) {
        for (var b = this.displaySystemUnits[this.displaySystem], c, d, e = 0, f = b.length; e < f && !(c = b[e], d = this.getLength(a, c), 1 < d); ++e);
        return [d, c]
    },
    getLength: function (a, b) {
        var c, d;
        this.geodesic ? (c = a.getGeodesicLength(this.map.getProjectionObject()),
            d = "m") : (c = a.getLength(), d = this.map.getUnits());
        var e = OpenLayers.INCHES_PER_UNIT[b];
        e && (c *= OpenLayers.INCHES_PER_UNIT[d] / e);
        return c
    },
    CLASS_NAME: "OpenLayers.Control.Measure"
});
OpenLayers.Control.WMSGetFeatureInfo = OpenLayers.Class(OpenLayers.Control, {
    hover: !1,
    drillDown: !1,
    maxFeatures: 10,
    clickCallback: "click",
    output: "features",
    layers: null,
    queryVisible: !1,
    url: null,
    layerUrls: null,
    infoFormat: "text/html",
    vendorParams: {},
    format: null,
    formatOptions: null,
    handlerOptions: null,
    handler: null,
    hoverRequest: null,
    initialize: function (a) {
        a = a || {};
        a.handlerOptions = a.handlerOptions || {};
        OpenLayers.Control.prototype.initialize.apply(this, [a]);
        this.format || (this.format = new OpenLayers.Format.WMSGetFeatureInfo(a.formatOptions));
        !0 === this.drillDown && (this.hover = !1);
        this.hover ? this.handler = new OpenLayers.Handler.Hover(this, {
            move: this.cancelHover,
            pause: this.getInfoForHover
        }, OpenLayers.Util.extend(this.handlerOptions.hover || {}, {delay: 250})) : (a = {}, a[this.clickCallback] = this.getInfoForClick, this.handler = new OpenLayers.Handler.Click(this, a, this.handlerOptions.click || {}))
    },
    getInfoForClick: function (a) {
        this.events.triggerEvent("beforegetfeatureinfo", {xy: a.xy});
        OpenLayers.Element.addClass(this.map.viewPortDiv, "olCursorWait");
        this.request(a.xy,
            {})
    },
    getInfoForHover: function (a) {
        this.events.triggerEvent("beforegetfeatureinfo", {xy: a.xy});
        this.request(a.xy, {hover: !0})
    },
    cancelHover: function () {
        this.hoverRequest && (this.hoverRequest.abort(), this.hoverRequest = null)
    },
    findLayers: function () {
        for (var a = this.layers || this.map.layers, b = [], c, d, e = a.length - 1; 0 <= e; --e)if (c = a[e], c instanceof OpenLayers.Layer.WMS && (!this.queryVisible || c.getVisibility()))d = OpenLayers.Util.isArray(c.url) ? c.url[0] : c.url, !1 === this.drillDown && !this.url && (this.url = d), (!0 === this.drillDown ||
        this.urlMatches(d)) && b.push(c);
        return b
    },
    urlMatches: function (a) {
        var b = OpenLayers.Util.isEquivalentUrl(this.url, a);
        if (!b && this.layerUrls)for (var c = 0, d = this.layerUrls.length; c < d; ++c)if (OpenLayers.Util.isEquivalentUrl(this.layerUrls[c], a)) {
            b = !0;
            break
        }
        return b
    },
    buildWMSOptions: function (a, b, c, d) {
        for (var e = [], f = [], g = 0, h = b.length; g < h; g++)null != b[g].params.LAYERS && (e = e.concat(b[g].params.LAYERS), f = f.concat(this.getStyleNames(b[g])));
        b = b[0];
        g = this.map.getProjection();
        (h = b.projection) && h.equals(this.map.getProjectionObject()) &&
        (g = h.getCode());
        d = OpenLayers.Util.extend({
            service: "WMS",
            version: b.params.VERSION,
            request: "GetFeatureInfo",
            exceptions: b.params.EXCEPTIONS,
            bbox: this.map.getExtent().toBBOX(null, b.reverseAxisOrder()),
            feature_count: this.maxFeatures,
            height: this.map.getSize().h,
            width: this.map.getSize().w,
            format: d,
            info_format: b.params.INFO_FORMAT || this.infoFormat
        }, 1.3 <= parseFloat(b.params.VERSION) ? {crs: g, i: parseInt(c.x), j: parseInt(c.y)} : {
            srs: g,
            x: parseInt(c.x),
            y: parseInt(c.y)
        });
        0 != e.length && (d = OpenLayers.Util.extend({
            layers: e,
            query_layers: e, styles: f
        }, d));
        OpenLayers.Util.applyDefaults(d, this.vendorParams);
        return {
            url: a, params: OpenLayers.Util.upperCaseObject(d), callback: function (b) {
                this.handleResponse(c, b, a)
            }, scope: this
        }
    },
    getStyleNames: function (a) {
        return a.params.STYLES ? a.params.STYLES : OpenLayers.Util.isArray(a.params.LAYERS) ? Array(a.params.LAYERS.length) : a.params.LAYERS.replace(/[^,]/g, "")
    },
    request: function (a, b) {
        var c = this.findLayers();
        if (0 == c.length)this.events.triggerEvent("nogetfeatureinfo"), OpenLayers.Element.removeClass(this.map.viewPortDiv,
            "olCursorWait"); else if (b = b || {}, !1 === this.drillDown) {
            var c = this.buildWMSOptions(this.url, c, a, c[0].params.FORMAT), d = OpenLayers.Request.GET(c);
            !0 === b.hover && (this.hoverRequest = d)
        } else {
            this._numRequests = this._requestCount = 0;
            this.features = [];
            for (var d = {}, e, f = 0, g = c.length; f < g; f++) {
                var h = c[f];
                e = OpenLayers.Util.isArray(h.url) ? h.url[0] : h.url;
                e in d ? d[e].push(h) : (this._numRequests++, d[e] = [h])
            }
            for (e in d)c = d[e], c = this.buildWMSOptions(e, c, a, c[0].params.FORMAT), OpenLayers.Request.GET(c)
        }
    },
    triggerGetFeatureInfo: function (a,
                                     b, c) {
        this.events.triggerEvent("getfeatureinfo", {text: a.responseText, features: c, request: a, xy: b});
        OpenLayers.Element.removeClass(this.map.viewPortDiv, "olCursorWait")
    },
    handleResponse: function (a, b, c) {
        var d = b.responseXML;
        if (!d || !d.documentElement)d = b.responseText;
        d = this.format.read(d);
        !1 === this.drillDown ? this.triggerGetFeatureInfo(b, a, d) : (this._requestCount++, this._features = "object" === this.output ? (this._features || []).concat({
            url: c,
            features: d
        }) : (this._features || []).concat(d), this._requestCount === this._numRequests &&
        (this.triggerGetFeatureInfo(b, a, this._features.concat()), delete this._features, delete this._requestCount, delete this._numRequests))
    },
    CLASS_NAME: "OpenLayers.Control.WMSGetFeatureInfo"
});
OpenLayers.Control.WMTSGetFeatureInfo = OpenLayers.Class(OpenLayers.Control, {
    hover: !1,
    requestEncoding: "KVP",
    drillDown: !1,
    maxFeatures: 10,
    clickCallback: "click",
    layers: null,
    queryVisible: !0,
    infoFormat: "text/html",
    vendorParams: {},
    format: null,
    formatOptions: null,
    handlerOptions: null,
    handler: null,
    hoverRequest: null,
    pending: 0,
    initialize: function (a) {
        a = a || {};
        a.handlerOptions = a.handlerOptions || {};
        OpenLayers.Control.prototype.initialize.apply(this, [a]);
        this.format || (this.format = new OpenLayers.Format.WMSGetFeatureInfo(a.formatOptions));
        !0 === this.drillDown && (this.hover = !1);
        this.hover ? this.handler = new OpenLayers.Handler.Hover(this, {
            move: this.cancelHover,
            pause: this.getInfoForHover
        }, OpenLayers.Util.extend(this.handlerOptions.hover || {}, {delay: 250})) : (a = {}, a[this.clickCallback] = this.getInfoForClick, this.handler = new OpenLayers.Handler.Click(this, a, this.handlerOptions.click || {}))
    },
    getInfoForClick: function (a) {
        this.request(a.xy, {})
    },
    getInfoForHover: function (a) {
        this.request(a.xy, {hover: !0})
    },
    cancelHover: function () {
        this.hoverRequest && (--this.pending,
        0 >= this.pending && (OpenLayers.Element.removeClass(this.map.viewPortDiv, "olCursorWait"), this.pending = 0), this.hoverRequest.abort(), this.hoverRequest = null)
    },
    findLayers: function () {
        for (var a = this.layers || this.map.layers, b = [], c, d = a.length - 1; 0 <= d; --d)if (c = a[d], c instanceof OpenLayers.Layer.WMTS && c.requestEncoding === this.requestEncoding && (!this.queryVisible || c.getVisibility()))if (b.push(c), !this.drillDown || this.hover)break;
        return b
    },
    buildRequestOptions: function (a, b) {
        var c = this.map.getLonLatFromPixel(b), d =
            a.getURL(new OpenLayers.Bounds(c.lon, c.lat, c.lon, c.lat)), d = OpenLayers.Util.getParameters(d), c = a.getTileInfo(c);
        OpenLayers.Util.extend(d, {
            service: "WMTS",
            version: a.version,
            request: "GetFeatureInfo",
            infoFormat: this.infoFormat,
            i: c.i,
            j: c.j
        });
        OpenLayers.Util.applyDefaults(d, this.vendorParams);
        return {
            url: OpenLayers.Util.isArray(a.url) ? a.url[0] : a.url,
            params: OpenLayers.Util.upperCaseObject(d),
            callback: function (c) {
                this.handleResponse(b, c, a)
            },
            scope: this
        }
    },
    request: function (a, b) {
        var b = b || {}, c = this.findLayers();
        if (0 < c.length) {
            for (var d, e, f = 0, g = c.length; f < g; f++)e = c[f], d = this.events.triggerEvent("beforegetfeatureinfo", {
                xy: a,
                layer: e
            }), !1 !== d && (++this.pending, d = this.buildRequestOptions(e, a), d = OpenLayers.Request.GET(d), !0 === b.hover && (this.hoverRequest = d));
            0 < this.pending && OpenLayers.Element.addClass(this.map.viewPortDiv, "olCursorWait")
        }
    },
    handleResponse: function (a, b, c) {
        --this.pending;
        0 >= this.pending && (OpenLayers.Element.removeClass(this.map.viewPortDiv, "olCursorWait"), this.pending = 0);
        if (b.status && (200 > b.status ||
            300 <= b.status))this.events.triggerEvent("exception", {xy: a, request: b, layer: c}); else {
            var d = b.responseXML;
            if (!d || !d.documentElement)d = b.responseText;
            var e, f;
            try {
                e = this.format.read(d)
            } catch (g) {
                f = !0, this.events.triggerEvent("exception", {xy: a, request: b, error: g, layer: c})
            }
            f || this.events.triggerEvent("getfeatureinfo", {
                text: b.responseText,
                features: e,
                request: b,
                xy: a,
                layer: c
            })
        }
    },
    CLASS_NAME: "OpenLayers.Control.WMTSGetFeatureInfo"
});
OpenLayers.Control.Graticule = OpenLayers.Class(OpenLayers.Control, {
    autoActivate: !0,
    intervals: [45, 30, 20, 10, 5, 2, 1, 0.5, 0.2, 0.1, 0.05, 0.01, 0.005, 0.002, 0.001],
    displayInLayerSwitcher: !0,
    visible: !0,
    numPoints: 50,
    targetSize: 200,
    layerName: null,
    labelled: !0,
    labelFormat: "dm",
    lineSymbolizer: {strokeColor: "#333", strokeWidth: 1, strokeOpacity: 0.5},
    labelSymbolizer: {},
    gratLayer: null,
    initialize: function (a) {
        a = a || {};
        a.layerName = a.layerName || OpenLayers.i18n("Graticule");
        OpenLayers.Control.prototype.initialize.apply(this, [a]);
        this.labelSymbolizer.stroke = !1;
        this.labelSymbolizer.fill = !1;
        this.labelSymbolizer.label = "${label}";
        this.labelSymbolizer.labelAlign = "${labelAlign}";
        this.labelSymbolizer.labelXOffset = "${xOffset}";
        this.labelSymbolizer.labelYOffset = "${yOffset}"
    },
    destroy: function () {
        this.deactivate();
        OpenLayers.Control.prototype.destroy.apply(this, arguments);
        this.gratLayer && (this.gratLayer.destroy(), this.gratLayer = null)
    },
    draw: function () {
        OpenLayers.Control.prototype.draw.apply(this, arguments);
        if (!this.gratLayer) {
            var a = new OpenLayers.Style({},
                {rules: [new OpenLayers.Rule({symbolizer: {Point: this.labelSymbolizer, Line: this.lineSymbolizer}})]});
            this.gratLayer = new OpenLayers.Layer.Vector(this.layerName, {
                styleMap: new OpenLayers.StyleMap({"default": a}),
                visibility: this.visible,
                displayInLayerSwitcher: this.displayInLayerSwitcher
            })
        }
        return this.div
    },
    activate: function () {
        return OpenLayers.Control.prototype.activate.apply(this, arguments) ? (this.map.addLayer(this.gratLayer), this.map.events.register("moveend", this, this.update), this.update(), !0) : !1
    },
    deactivate: function () {
        return OpenLayers.Control.prototype.deactivate.apply(this,
            arguments) ? (this.map.events.unregister("moveend", this, this.update), this.map.removeLayer(this.gratLayer), !0) : !1
    },
    update: function () {
        var a = this.map.getExtent();
        if (a) {
            this.gratLayer.destroyFeatures();
            var b = new OpenLayers.Projection("EPSG:4326"), c = this.map.getProjectionObject(), d = this.map.getResolution();
            c.proj && "longlat" == c.proj.projName && (this.numPoints = 1);
            var e = this.map.getCenter(), f = new OpenLayers.Pixel(e.lon, e.lat);
            OpenLayers.Projection.transform(f, c, b);
            for (var e = this.targetSize * d, e = e * e, g, d = 0; d < this.intervals.length; ++d) {
                g =
                    this.intervals[d];
                var h = g / 2, k = f.offset({x: -h, y: -h}), h = f.offset({x: h, y: h});
                OpenLayers.Projection.transform(k, b, c);
                OpenLayers.Projection.transform(h, b, c);
                if ((k.x - h.x) * (k.x - h.x) + (k.y - h.y) * (k.y - h.y) <= e)break
            }
            f.x = Math.floor(f.x / g) * g;
            f.y = Math.floor(f.y / g) * g;
            var d = 0, e = [f.clone()], h = f.clone(), l;
            do h = h.offset({
                x: 0,
                y: g
            }), l = OpenLayers.Projection.transform(h.clone(), b, c), e.unshift(h); while (a.containsPixel(l) && 1E3 > ++d);
            h = f.clone();
            do h = h.offset({x: 0, y: -g}), l = OpenLayers.Projection.transform(h.clone(), b, c), e.push(h);
            while (a.containsPixel(l) && 1E3 > ++d);
            d = 0;
            k = [f.clone()];
            h = f.clone();
            do h = h.offset({
                x: -g,
                y: 0
            }), l = OpenLayers.Projection.transform(h.clone(), b, c), k.unshift(h); while (a.containsPixel(l) && 1E3 > ++d);
            h = f.clone();
            do h = h.offset({
                x: g,
                y: 0
            }), l = OpenLayers.Projection.transform(h.clone(), b, c), k.push(h); while (a.containsPixel(l) && 1E3 > ++d);
            g = [];
            for (d = 0; d < k.length; ++d) {
                l = k[d].x;
                for (var f = [], m = null, n = Math.min(e[0].y, 90), h = Math.max(e[e.length - 1].y, -90), o = (n - h) / this.numPoints, n = h, h = 0; h <= this.numPoints; ++h) {
                    var p = new OpenLayers.Geometry.Point(l,
                        n);
                    p.transform(b, c);
                    f.push(p);
                    n += o;
                    p.y >= a.bottom && !m && (m = p)
                }
                this.labelled && (m = new OpenLayers.Geometry.Point(m.x, a.bottom), l = {
                    value: l,
                    label: this.labelled ? OpenLayers.Util.getFormattedLonLat(l, "lon", this.labelFormat) : "",
                    labelAlign: "cb",
                    xOffset: 0,
                    yOffset: 2
                }, this.gratLayer.addFeatures(new OpenLayers.Feature.Vector(m, l)));
                f = new OpenLayers.Geometry.LineString(f);
                g.push(new OpenLayers.Feature.Vector(f))
            }
            for (h = 0; h < e.length; ++h)if (n = e[h].y, !(-90 > n || 90 < n)) {
                f = [];
                d = k[0].x;
                o = (k[k.length - 1].x - d) / this.numPoints;
                l = d;
                m = null;
                for (d = 0; d <= this.numPoints; ++d)p = new OpenLayers.Geometry.Point(l, n), p.transform(b, c), f.push(p), l += o, p.x < a.right && (m = p);
                this.labelled && (m = new OpenLayers.Geometry.Point(a.right, m.y), l = {
                    value: n,
                    label: this.labelled ? OpenLayers.Util.getFormattedLonLat(n, "lat", this.labelFormat) : "",
                    labelAlign: "rb",
                    xOffset: -2,
                    yOffset: 2
                }, this.gratLayer.addFeatures(new OpenLayers.Feature.Vector(m, l)));
                f = new OpenLayers.Geometry.LineString(f);
                g.push(new OpenLayers.Feature.Vector(f))
            }
            this.gratLayer.addFeatures(g)
        }
    },
    CLASS_NAME: "OpenLayers.Control.Graticule"
});
OpenLayers.Control.TransformFeature = OpenLayers.Class(OpenLayers.Control, {
    geometryTypes: null,
    layer: null,
    preserveAspectRatio: !1,
    rotate: !0,
    feature: null,
    renderIntent: "temporary",
    rotationHandleSymbolizer: null,
    box: null,
    center: null,
    scale: 1,
    ratio: 1,
    rotation: 0,
    handles: null,
    rotationHandles: null,
    dragControl: null,
    irregular: !1,
    initialize: function (a, b) {
        OpenLayers.Control.prototype.initialize.apply(this, [b]);
        this.layer = a;
        this.rotationHandleSymbolizer || (this.rotationHandleSymbolizer = {
            stroke: !1, pointRadius: 10, fillOpacity: 0,
            cursor: "pointer"
        });
        this.createBox();
        this.createControl()
    },
    activate: function () {
        var a = !1;
        OpenLayers.Control.prototype.activate.apply(this, arguments) && (this.dragControl.activate(), this.layer.addFeatures([this.box]), this.rotate && this.layer.addFeatures(this.rotationHandles), this.layer.addFeatures(this.handles), a = !0);
        return a
    },
    deactivate: function () {
        var a = !1;
        OpenLayers.Control.prototype.deactivate.apply(this, arguments) && (this.layer.removeFeatures(this.handles), this.rotate && this.layer.removeFeatures(this.rotationHandles),
            this.layer.removeFeatures([this.box]), this.dragControl.deactivate(), a = !0);
        return a
    },
    setMap: function (a) {
        this.dragControl.setMap(a);
        OpenLayers.Control.prototype.setMap.apply(this, arguments)
    },
    setFeature: function (a, b) {
        var b = OpenLayers.Util.applyDefaults(b, {rotation: 0, scale: 1, ratio: 1}), c = this.rotation, d = this.center;
        OpenLayers.Util.extend(this, b);
        if (!1 !== this.events.triggerEvent("beforesetfeature", {feature: a})) {
            this.feature = a;
            this.activate();
            this._setfeature = !0;
            var e = this.feature.geometry.getBounds();
            this.box.move(e.getCenterLonLat());
            this.box.geometry.rotate(-c, d);
            this._angle = 0;
            this.rotation ? (c = a.geometry.clone(), c.rotate(-this.rotation, this.center), c = new OpenLayers.Feature.Vector(c.getBounds().toGeometry()), c.geometry.rotate(this.rotation, this.center), this.box.geometry.rotate(this.rotation, this.center), this.box.move(c.geometry.getBounds().getCenterLonLat()), c = c.geometry.components[0].components[0].getBounds().getCenterLonLat()) : c = new OpenLayers.LonLat(e.left, e.bottom);
            this.handles[0].move(c);
            delete this._setfeature;
            this.events.triggerEvent("setfeature",
                {feature: a})
        }
    },
    unsetFeature: function () {
        this.active ? this.deactivate() : (this.feature = null, this.rotation = 0, this.ratio = this.scale = 1)
    },
    createBox: function () {
        var a = this;
        this.center = new OpenLayers.Geometry.Point(0, 0);
        this.box = new OpenLayers.Feature.Vector(new OpenLayers.Geometry.LineString([new OpenLayers.Geometry.Point(-1, -1), new OpenLayers.Geometry.Point(0, -1), new OpenLayers.Geometry.Point(1, -1), new OpenLayers.Geometry.Point(1, 0), new OpenLayers.Geometry.Point(1, 1), new OpenLayers.Geometry.Point(0, 1), new OpenLayers.Geometry.Point(-1,
            1), new OpenLayers.Geometry.Point(-1, 0), new OpenLayers.Geometry.Point(-1, -1)]), null, "string" == typeof this.renderIntent ? null : this.renderIntent);
        this.box.geometry.move = function (b, c) {
            a._moving = !0;
            OpenLayers.Geometry.LineString.prototype.move.apply(this, arguments);
            a.center.move(b, c);
            delete a._moving
        };
        for (var b = function (a, b) {
            OpenLayers.Geometry.Point.prototype.move.apply(this, arguments);
            this._rotationHandle && this._rotationHandle.geometry.move(a, b);
            this._handle.geometry.move(a, b)
        }, c = function (a, b, c) {
            OpenLayers.Geometry.Point.prototype.resize.apply(this,
                arguments);
            this._rotationHandle && this._rotationHandle.geometry.resize(a, b, c);
            this._handle.geometry.resize(a, b, c)
        }, d = function (a, b) {
            OpenLayers.Geometry.Point.prototype.rotate.apply(this, arguments);
            this._rotationHandle && this._rotationHandle.geometry.rotate(a, b);
            this._handle.geometry.rotate(a, b)
        }, e = function (b, c) {
            var d = this.x, e = this.y;
            OpenLayers.Geometry.Point.prototype.move.call(this, b, c);
            if (!a._moving) {
                var f = a.dragControl.handlers.drag.evt, g = !(!a._setfeature && a.preserveAspectRatio) && !(f && f.shiftKey),
                    h = new OpenLayers.Geometry.Point(d, e), f = a.center;
                this.rotate(-a.rotation, f);
                h.rotate(-a.rotation, f);
                var k = this.x - f.x, l = this.y - f.y, m = k - (this.x - h.x), n = l - (this.y - h.y);
                a.irregular && !a._setfeature && (k -= (this.x - h.x) / 2, l -= (this.y - h.y) / 2);
                this.x = d;
                this.y = e;
                h = 1;
                g ? (l = 1.0E-5 > Math.abs(n) ? 1 : l / n, h = (1.0E-5 > Math.abs(m) ? 1 : k / m) / l) : (m = Math.sqrt(m * m + n * n), l = Math.sqrt(k * k + l * l) / m);
                a._moving = !0;
                a.box.geometry.rotate(-a.rotation, f);
                delete a._moving;
                a.box.geometry.resize(l, f, h);
                a.box.geometry.rotate(a.rotation, f);
                a.transformFeature({
                    scale: l,
                    ratio: h
                });
                a.irregular && !a._setfeature && (k = f.clone(), k.x += 1.0E-5 > Math.abs(d - f.x) ? 0 : this.x - d, k.y += 1.0E-5 > Math.abs(e - f.y) ? 0 : this.y - e, a.box.geometry.move(this.x - d, this.y - e), a.transformFeature({center: k}))
            }
        }, f = function (b, c) {
            var d = this.x, e = this.y;
            OpenLayers.Geometry.Point.prototype.move.call(this, b, c);
            if (!a._moving) {
                var f = a.dragControl.handlers.drag.evt, f = f && f.shiftKey ? 45 : 1, g = a.center, h = this.x - g.x, k = this.y - g.y;
                this.x = d;
                this.y = e;
                d = Math.atan2(k - c, h - b);
                d = Math.atan2(k, h) - d;
                d *= 180 / Math.PI;
                a._angle = (a._angle +
                d) % 360;
                d = a.rotation % f;
                if (Math.abs(a._angle) >= f || 0 !== d)d = Math.round(a._angle / f) * f - d, a._angle = 0, a.box.geometry.rotate(d, g), a.transformFeature({rotation: d})
            }
        }, g = Array(8), h = Array(4), k, l, m, n = "sw,s,se,e,ne,n,nw,w".split(","), o = 0; 8 > o; ++o)k = this.box.geometry.components[o], l = new OpenLayers.Feature.Vector(k.clone(), {role: n[o] + "-resize"}, "string" == typeof this.renderIntent ? null : this.renderIntent), 0 == o % 2 && (m = new OpenLayers.Feature.Vector(k.clone(), {role: n[o] + "-rotate"}, "string" == typeof this.rotationHandleSymbolizer ?
            null : this.rotationHandleSymbolizer), m.geometry.move = f, k._rotationHandle = m, h[o / 2] = m), k.move = b, k.resize = c, k.rotate = d, l.geometry.move = e, k._handle = l, g[o] = l;
        this.rotationHandles = h;
        this.handles = g
    },
    createControl: function () {
        var a = this;
        this.dragControl = new OpenLayers.Control.DragFeature(this.layer, {
            documentDrag: !0, moveFeature: function (b) {
                this.feature === a.feature && (this.feature = a.box);
                OpenLayers.Control.DragFeature.prototype.moveFeature.apply(this, arguments)
            }, onDrag: function (b) {
                b === a.box && a.transformFeature({center: a.center})
            },
            onStart: function (b) {
                var c = !a.geometryTypes || -1 !== OpenLayers.Util.indexOf(a.geometryTypes, b.geometry.CLASS_NAME), d = OpenLayers.Util.indexOf(a.handles, b), d = d + OpenLayers.Util.indexOf(a.rotationHandles, b);
                b !== a.feature && b !== a.box && -2 == d && c && a.setFeature(b)
            }, onComplete: function () {
                a.events.triggerEvent("transformcomplete", {feature: a.feature})
            }
        })
    },
    drawHandles: function () {
        for (var a = this.layer, b = 0; 8 > b; ++b)this.rotate && 0 === b % 2 && a.drawFeature(this.rotationHandles[b / 2], this.rotationHandleSymbolizer), a.drawFeature(this.handles[b],
            this.renderIntent)
    },
    transformFeature: function (a) {
        if (!this._setfeature) {
            this.scale *= a.scale || 1;
            this.ratio *= a.ratio || 1;
            var b = this.rotation;
            this.rotation = (this.rotation + (a.rotation || 0)) % 360;
            if (!1 !== this.events.triggerEvent("beforetransform", a)) {
                var c = this.feature, d = c.geometry, e = this.center;
                d.rotate(-b, e);
                a.scale || a.ratio ? d.resize(a.scale, e, a.ratio) : a.center && c.move(a.center.getBounds().getCenterLonLat());
                d.rotate(this.rotation, e);
                this.layer.drawFeature(c);
                c.toState(OpenLayers.State.UPDATE);
                this.events.triggerEvent("transform",
                    a)
            }
        }
        this.layer.drawFeature(this.box, this.renderIntent);
        this.drawHandles()
    },
    destroy: function () {
        for (var a, b = 0; 8 > b; ++b)a = this.box.geometry.components[b], a._handle.destroy(), a._handle = null, a._rotationHandle && a._rotationHandle.destroy(), a._rotationHandle = null;
        this.rotationHandles = this.rotationHandleSymbolizer = this.handles = this.feature = this.center = null;
        this.box.destroy();
        this.layer = this.box = null;
        this.dragControl.destroy();
        this.dragControl = null;
        OpenLayers.Control.prototype.destroy.apply(this, arguments)
    },
    CLASS_NAME: "OpenLayers.Control.TransformFeature"
});
OpenLayers.Control.UTFGrid = OpenLayers.Class(OpenLayers.Control, {
    autoActivate: !0,
    layers: null,
    defaultHandlerOptions: {
        delay: 300,
        pixelTolerance: 4,
        stopMove: !1,
        single: !0,
        "double": !1,
        stopSingle: !1,
        stopDouble: !1
    },
    handlerMode: "click",
    setHandler: function (a) {
        this.handlerMode = a;
        this.resetHandler()
    },
    resetHandler: function () {
        this.handler && (this.handler.deactivate(), this.handler.destroy(), this.handler = null);
        "hover" == this.handlerMode ? this.handler = new OpenLayers.Handler.Hover(this, {
                pause: this.handleEvent,
                move: this.reset
            },
            this.handlerOptions) : "click" == this.handlerMode ? this.handler = new OpenLayers.Handler.Click(this, {click: this.handleEvent}, this.handlerOptions) : "move" == this.handlerMode && (this.handler = new OpenLayers.Handler.Hover(this, {
            pause: this.handleEvent,
            move: this.handleEvent
        }, this.handlerOptions));
        return this.handler ? !0 : !1
    },
    initialize: function (a) {
        a = a || {};
        a.handlerOptions = a.handlerOptions || this.defaultHandlerOptions;
        OpenLayers.Control.prototype.initialize.apply(this, [a]);
        this.resetHandler()
    },
    handleEvent: function (a) {
        if (null ==
            a)this.reset(); else {
            var b = this.map.getLonLatFromPixel(a.xy);
            if (b) {
                var c = this.findLayers();
                if (0 < c.length) {
                    for (var d = {}, e, f, g = 0, h = c.length; g < h; g++)e = c[g], f = OpenLayers.Util.indexOf(this.map.layers, e), d[f] = e.getFeatureInfo(b);
                    this.callback(d, b, a.xy)
                }
            }
        }
    },
    callback: function () {
    },
    reset: function () {
        this.callback(null)
    },
    findLayers: function () {
        for (var a = this.layers || this.map.layers, b = [], c, d = a.length - 1; 0 <= d; --d)c = a[d], c instanceof OpenLayers.Layer.UTFGrid && b.push(c);
        return b
    },
    CLASS_NAME: "OpenLayers.Control.UTFGrid"
});
OpenLayers.Control.SLDSelect = OpenLayers.Class(OpenLayers.Control, {
    clearOnDeactivate: !1,
    layers: null,
    callbacks: null,
    selectionSymbolizer: {
        Polygon: {fillColor: "#FF0000", stroke: !1},
        Line: {strokeColor: "#FF0000", strokeWidth: 2},
        Point: {graphicName: "square", fillColor: "#FF0000", pointRadius: 5}
    },
    layerOptions: null,
    handlerOptions: null,
    sketchStyle: null,
    wfsCache: {},
    layerCache: {},
    initialize: function (a, b) {
        OpenLayers.Control.prototype.initialize.apply(this, [b]);
        this.callbacks = OpenLayers.Util.extend({done: this.select, click: this.select},
            this.callbacks);
        this.handlerOptions = this.handlerOptions || {};
        this.layerOptions = OpenLayers.Util.applyDefaults(this.layerOptions, {
            displayInLayerSwitcher: !1,
            tileOptions: {maxGetUrlLength: 2048}
        });
        this.sketchStyle && (this.handlerOptions.layerOptions = OpenLayers.Util.applyDefaults(this.handlerOptions.layerOptions, {styleMap: new OpenLayers.StyleMap({"default": this.sketchStyle})}));
        this.handler = new a(this, this.callbacks, this.handlerOptions)
    },
    destroy: function () {
        for (var a in this.layerCache)delete this.layerCache[a];
        for (a in this.wfsCache)delete this.wfsCache[a];
        OpenLayers.Control.prototype.destroy.apply(this, arguments)
    },
    coupleLayerVisiblity: function (a) {
        this.setVisibility(a.object.getVisibility())
    },
    createSelectionLayer: function (a) {
        var b;
        if (this.layerCache[a.id])b = this.layerCache[a.id]; else {
            b = new OpenLayers.Layer.WMS(a.name, a.url, a.params, OpenLayers.Util.applyDefaults(this.layerOptions, a.getOptions()));
            this.layerCache[a.id] = b;
            if (!1 === this.layerOptions.displayInLayerSwitcher)a.events.on({
                visibilitychanged: this.coupleLayerVisiblity,
                scope: b
            });
            this.map.addLayer(b)
        }
        return b
    },
    createSLD: function (a, b, c) {
        for (var d = {
            version: "1.0.0",
            namedLayers: {}
        }, e = ("" + a.params.LAYERS).split(","), f = 0, g = e.length; f < g; f++) {
            var h = e[f];
            d.namedLayers[h] = {name: h, userStyles: []};
            var k = this.selectionSymbolizer, l = c[f];
            0 <= l.type.indexOf("Polygon") ? k = {Polygon: this.selectionSymbolizer.Polygon} : 0 <= l.type.indexOf("LineString") ? k = {Line: this.selectionSymbolizer.Line} : 0 <= l.type.indexOf("Point") && (k = {Point: this.selectionSymbolizer.Point});
            d.namedLayers[h].userStyles.push({
                name: "default",
                rules: [new OpenLayers.Rule({symbolizer: k, filter: b[f], maxScaleDenominator: a.options.minScale})]
            })
        }
        return (new OpenLayers.Format.SLD({srsName: this.map.getProjection()})).write(d)
    },
    parseDescribeLayer: function (a) {
        var b = new OpenLayers.Format.WMSDescribeLayer, c = a.responseXML;
        if (!c || !c.documentElement)c = a.responseText;
        for (var a = b.read(c), b = [], c = null, d = 0, e = a.length; d < e; d++)"WFS" == a[d].owsType && (b.push(a[d].typeName), c = a[d].owsURL);
        OpenLayers.Request.GET({
            url: c, params: {
                SERVICE: "WFS", TYPENAME: b.toString(), REQUEST: "DescribeFeatureType",
                VERSION: "1.0.0"
            }, callback: function (a) {
                var b = new OpenLayers.Format.WFSDescribeFeatureType, c = a.responseXML;
                if (!c || !c.documentElement)c = a.responseText;
                this.control.wfsCache[this.layer.id] = b.read(c);
                this.control._queue && this.control.applySelection()
            }, scope: this
        })
    },
    getGeometryAttributes: function (a) {
        for (var b = [], a = this.wfsCache[a.id], c = 0, d = a.featureTypes.length; c < d; c++)for (var e = a.featureTypes[c].properties, f = 0, g = e.length; f < g; f++) {
            var h = e[f], k = h.type;
            (0 <= k.indexOf("LineString") || 0 <= k.indexOf("GeometryAssociationType") ||
            0 <= k.indexOf("GeometryPropertyType") || 0 <= k.indexOf("Point") || 0 <= k.indexOf("Polygon")) && b.push(h)
        }
        return b
    },
    activate: function () {
        var a = OpenLayers.Control.prototype.activate.call(this);
        if (a)for (var b = 0, c = this.layers.length; b < c; b++) {
            var d = this.layers[b];
            d && !this.wfsCache[d.id] && OpenLayers.Request.GET({
                url: d.url,
                params: {SERVICE: "WMS", VERSION: d.params.VERSION, LAYERS: d.params.LAYERS, REQUEST: "DescribeLayer"},
                callback: this.parseDescribeLayer,
                scope: {layer: d, control: this}
            })
        }
        return a
    },
    deactivate: function () {
        var a =
            OpenLayers.Control.prototype.deactivate.call(this);
        if (a)for (var b = 0, c = this.layers.length; b < c; b++) {
            var d = this.layers[b];
            if (d && !0 === this.clearOnDeactivate) {
                var e = this.layerCache, f = e[d.id];
                f && (d.events.un({
                    visibilitychanged: this.coupleLayerVisiblity,
                    scope: f
                }), f.destroy(), delete e[d.id])
            }
        }
        return a
    },
    setLayers: function (a) {
        this.active ? (this.deactivate(), this.layers = a, this.activate()) : this.layers = a
    },
    createFilter: function (a, b) {
        var c = null;
        this.handler instanceof OpenLayers.Handler.RegularPolygon ? c = !0 === this.handler.irregular ?
            new OpenLayers.Filter.Spatial({
                type: OpenLayers.Filter.Spatial.BBOX,
                property: a.name,
                value: b.getBounds()
            }) : new OpenLayers.Filter.Spatial({
            type: OpenLayers.Filter.Spatial.INTERSECTS,
            property: a.name,
            value: b
        }) : this.handler instanceof OpenLayers.Handler.Polygon ? c = new OpenLayers.Filter.Spatial({
            type: OpenLayers.Filter.Spatial.INTERSECTS,
            property: a.name,
            value: b
        }) : this.handler instanceof OpenLayers.Handler.Path ? c = 0 <= a.type.indexOf("Point") ? new OpenLayers.Filter.Spatial({
            type: OpenLayers.Filter.Spatial.DWITHIN,
            property: a.name,
            distance: 0.01 * this.map.getExtent().getWidth(),
            distanceUnits: this.map.getUnits(),
            value: b
        }) : new OpenLayers.Filter.Spatial({
            type: OpenLayers.Filter.Spatial.INTERSECTS,
            property: a.name,
            value: b
        }) : this.handler instanceof OpenLayers.Handler.Click && (c = 0 <= a.type.indexOf("Polygon") ? new OpenLayers.Filter.Spatial({
            type: OpenLayers.Filter.Spatial.INTERSECTS,
            property: a.name,
            value: b
        }) : new OpenLayers.Filter.Spatial({
            type: OpenLayers.Filter.Spatial.DWITHIN, property: a.name, distance: 0.01 * this.map.getExtent().getWidth(),
            distanceUnits: this.map.getUnits(), value: b
        }));
        return c
    },
    select: function (a) {
        this._queue = function () {
            for (var b = 0, c = this.layers.length; b < c; b++) {
                for (var d = this.layers[b], e = this.getGeometryAttributes(d), f = [], g = 0, h = e.length; g < h; g++) {
                    var k = e[g];
                    if (null !== k) {
                        if (!(a instanceof OpenLayers.Geometry)) {
                            var l = this.map.getLonLatFromPixel(a.xy);
                            a = new OpenLayers.Geometry.Point(l.lon, l.lat)
                        }
                        k = this.createFilter(k, a);
                        null !== k && f.push(k)
                    }
                }
                g = this.createSelectionLayer(d);
                e = this.createSLD(d, f, e);
                this.events.triggerEvent("selected",
                    {layer: d, filters: f});
                g.mergeNewParams({SLD_BODY: e});
                delete this._queue
            }
        };
        this.applySelection()
    },
    applySelection: function () {
        for (var a = !0, b = 0, c = this.layers.length; b < c; b++)if (!this.wfsCache[this.layers[b].id]) {
            a = !1;
            break
        }
        a && this._queue.call(this)
    },
    CLASS_NAME: "OpenLayers.Control.SLDSelect"
});
OpenLayers.Control.Zoom = OpenLayers.Class(OpenLayers.Control, {
    zoomInText: "+", zoomInId: "olZoomInLink", zoomOutText: "-", zoomOutId: "olZoomOutLink", draw: function () {
        var a = OpenLayers.Control.prototype.draw.apply(this), b = this.getOrCreateLinks(a), c = b.zoomIn, b = b.zoomOut, d = this.map.events;
        b.parentNode !== a && (d = this.events, d.attachToElement(b.parentNode));
        d.register("buttonclick", this, this.onZoomClick);
        this.zoomInLink = c;
        this.zoomOutLink = b;
        return a
    }, getOrCreateLinks: function (a) {
        var b = document.getElementById(this.zoomInId),
            c = document.getElementById(this.zoomOutId);
        b || (b = document.createElement("a"), b.href = "#zoomIn", b.appendChild(document.createTextNode(this.zoomInText)), b.className = "olControlZoomIn", a.appendChild(b));
        OpenLayers.Element.addClass(b, "olButton");
        c || (c = document.createElement("a"), c.href = "#zoomOut", c.appendChild(document.createTextNode(this.zoomOutText)), c.className = "olControlZoomOut", a.appendChild(c));
        OpenLayers.Element.addClass(c, "olButton");
        return {zoomIn: b, zoomOut: c}
    }, onZoomClick: function (a) {
        a = a.buttonElement;
        a === this.zoomInLink ? this.map.zoomIn() : a === this.zoomOutLink && this.map.zoomOut()
    }, destroy: function () {
        this.map && this.map.events.unregister("buttonclick", this, this.onZoomClick);
        delete this.zoomInLink;
        delete this.zoomOutLink;
        OpenLayers.Control.prototype.destroy.apply(this)
    }, CLASS_NAME: "OpenLayers.Control.Zoom"
});
OpenLayers.Geometry = OpenLayers.Class({
    id: null, parent: null, bounds: null, initialize: function () {
        this.id = OpenLayers.Util.createUniqueID(this.CLASS_NAME + "_")
    }, destroy: function () {
        this.bounds = this.id = null
    }, clone: function () {
        return new OpenLayers.Geometry
    }, setBounds: function (a) {
        a && (this.bounds = a.clone())
    }, clearBounds: function () {
        this.bounds = null;
        this.parent && this.parent.clearBounds()
    }, extendBounds: function (a) {
        this.getBounds() ? this.bounds.extend(a) : this.setBounds(a)
    }, getBounds: function () {
        null == this.bounds && this.calculateBounds();
        return this.bounds
    }, calculateBounds: function () {
    }, distanceTo: function () {
    }, getVertices: function () {
    }, atPoint: function (a, b, c) {
        var d = !1;
        null != this.getBounds() && null != a && (b = null != b ? b : 0, c = null != c ? c : 0, d = (new OpenLayers.Bounds(this.bounds.left - b, this.bounds.bottom - c, this.bounds.right + b, this.bounds.top + c)).containsLonLat(a));
        return d
    }, getLength: function () {
        return 0
    }, getArea: function () {
        return 0
    }, getCentroid: function () {
        return null
    }, toString: function () {
        return OpenLayers.Format && OpenLayers.Format.WKT ? OpenLayers.Format.WKT.prototype.write(new OpenLayers.Feature.Vector(this)) :
            Object.prototype.toString.call(this)
    }, CLASS_NAME: "OpenLayers.Geometry"
});
OpenLayers.Geometry.fromWKT = function (a) {
    var b;
    if (OpenLayers.Format && OpenLayers.Format.WKT) {
        var c = OpenLayers.Geometry.fromWKT.format;
        c || (c = new OpenLayers.Format.WKT, OpenLayers.Geometry.fromWKT.format = c);
        a = c.read(a);
        if (a instanceof OpenLayers.Feature.Vector)b = a.geometry; else if (OpenLayers.Util.isArray(a)) {
            b = a.length;
            for (var c = Array(b), d = 0; d < b; ++d)c[d] = a[d].geometry;
            b = new OpenLayers.Geometry.Collection(c)
        }
    }
    return b
};
OpenLayers.Geometry.segmentsIntersect = function (a, b, c) {
    var d = c && c.point, c = c && c.tolerance, e = !1, f = a.x1 - b.x1, g = a.y1 - b.y1, h = a.x2 - a.x1, k = a.y2 - a.y1, l = b.y2 - b.y1, m = b.x2 - b.x1, n = l * h - m * k, l = m * g - l * f, g = h * g - k * f;
    0 == n ? 0 == l && 0 == g && (e = !0) : (f = l / n, n = g / n, 0 <= f && 1 >= f && 0 <= n && 1 >= n && (d ? (h = a.x1 + f * h, n = a.y1 + f * k, e = new OpenLayers.Geometry.Point(h, n)) : e = !0));
    if (c)if (e) {
        if (d) {
            a = [a, b];
            b = 0;
            a:for (; 2 > b; ++b) {
                f = a[b];
                for (k = 1; 3 > k; ++k)if (h = f["x" + k], n = f["y" + k], d = Math.sqrt(Math.pow(h - e.x, 2) + Math.pow(n - e.y, 2)), d < c) {
                    e.x = h;
                    e.y = n;
                    break a
                }
            }
        }
    } else {
        a =
            [a, b];
        b = 0;
        a:for (; 2 > b; ++b) {
            h = a[b];
            n = a[(b + 1) % 2];
            for (k = 1; 3 > k; ++k)if (f = {
                    x: h["x" + k],
                    y: h["y" + k]
                }, g = OpenLayers.Geometry.distanceToSegment(f, n), g.distance < c) {
                e = d ? new OpenLayers.Geometry.Point(f.x, f.y) : !0;
                break a
            }
        }
    }
    return e
};
OpenLayers.Geometry.distanceToSegment = function (a, b) {
    var c = a.x, d = a.y, e = b.x1, f = b.y1, g = b.x2, h = b.y2, k = g - e, l = h - f, m = (k * (c - e) + l * (d - f)) / (Math.pow(k, 2) + Math.pow(l, 2));
    0 >= m || (1 <= m ? (e = g, f = h) : (e += m * k, f += m * l));
    return {distance: Math.sqrt(Math.pow(e - c, 2) + Math.pow(f - d, 2)), x: e, y: f}
};
OpenLayers.Geometry.Collection = OpenLayers.Class(OpenLayers.Geometry, {
    components: null, componentTypes: null, initialize: function (a) {
        OpenLayers.Geometry.prototype.initialize.apply(this, arguments);
        this.components = [];
        null != a && this.addComponents(a)
    }, destroy: function () {
        this.components.length = 0;
        this.components = null;
        OpenLayers.Geometry.prototype.destroy.apply(this, arguments)
    }, clone: function () {
        for (var a = eval("new " + this.CLASS_NAME + "()"), b = 0, c = this.components.length; b < c; b++)a.addComponent(this.components[b].clone());
        OpenLayers.Util.applyDefaults(a, this);
        return a
    }, getComponentsString: function () {
        for (var a = [], b = 0, c = this.components.length; b < c; b++)a.push(this.components[b].toShortString());
        return a.join(",")
    }, calculateBounds: function () {
        this.bounds = null;
        var a = new OpenLayers.Bounds, b = this.components;
        if (b)for (var c = 0, d = b.length; c < d; c++)a.extend(b[c].getBounds());
        null != a.left && null != a.bottom && null != a.right && null != a.top && this.setBounds(a)
    }, addComponents: function (a) {
        OpenLayers.Util.isArray(a) || (a = [a]);
        for (var b = 0, c = a.length; b <
        c; b++)this.addComponent(a[b])
    }, addComponent: function (a, b) {
        var c = !1;
        if (a && (null == this.componentTypes || -1 < OpenLayers.Util.indexOf(this.componentTypes, a.CLASS_NAME))) {
            if (null != b && b < this.components.length) {
                var c = this.components.slice(0, b), d = this.components.slice(b, this.components.length);
                c.push(a);
                this.components = c.concat(d)
            } else this.components.push(a);
            a.parent = this;
            this.clearBounds();
            c = !0
        }
        return c
    }, removeComponents: function (a) {
        var b = !1;
        OpenLayers.Util.isArray(a) || (a = [a]);
        for (var c = a.length - 1; 0 <= c; --c)b =
            this.removeComponent(a[c]) || b;
        return b
    }, removeComponent: function (a) {
        OpenLayers.Util.removeItem(this.components, a);
        this.clearBounds();
        return !0
    }, getLength: function () {
        for (var a = 0, b = 0, c = this.components.length; b < c; b++)a += this.components[b].getLength();
        return a
    }, getArea: function () {
        for (var a = 0, b = 0, c = this.components.length; b < c; b++)a += this.components[b].getArea();
        return a
    }, getGeodesicArea: function (a) {
        for (var b = 0, c = 0, d = this.components.length; c < d; c++)b += this.components[c].getGeodesicArea(a);
        return b
    }, getCentroid: function (a) {
        if (!a)return this.components.length &&
            this.components[0].getCentroid();
        a = this.components.length;
        if (!a)return !1;
        for (var b = [], c = [], d = 0, e = Number.MAX_VALUE, f, g = 0; g < a; ++g) {
            f = this.components[g];
            var h = f.getArea();
            f = f.getCentroid(!0);
            !isNaN(h) && !isNaN(f.x) && !isNaN(f.y) && (b.push(h), d += h, e = h < e && 0 < h ? h : e, c.push(f))
        }
        a = b.length;
        if (0 === d) {
            for (g = 0; g < a; ++g)b[g] = 1;
            d = b.length
        } else {
            for (g = 0; g < a; ++g)b[g] /= e;
            d /= e
        }
        for (var k = e = 0, g = 0; g < a; ++g)f = c[g], h = b[g], e += f.x * h, k += f.y * h;
        return new OpenLayers.Geometry.Point(e / d, k / d)
    }, getGeodesicLength: function (a) {
        for (var b =
            0, c = 0, d = this.components.length; c < d; c++)b += this.components[c].getGeodesicLength(a);
        return b
    }, move: function (a, b) {
        for (var c = 0, d = this.components.length; c < d; c++)this.components[c].move(a, b)
    }, rotate: function (a, b) {
        for (var c = 0, d = this.components.length; c < d; ++c)this.components[c].rotate(a, b)
    }, resize: function (a, b, c) {
        for (var d = 0; d < this.components.length; ++d)this.components[d].resize(a, b, c);
        return this
    }, distanceTo: function (a, b) {
        for (var c = !(b && !1 === b.edge) && b && b.details, d, e, f, g = Number.POSITIVE_INFINITY, h = 0, k = this.components.length; h <
        k && !(d = this.components[h].distanceTo(a, b), f = c ? d.distance : d, f < g && (g = f, e = d, 0 == g)); ++h);
        return e
    }, equals: function (a) {
        var b = !0;
        if (!a || !a.CLASS_NAME || this.CLASS_NAME != a.CLASS_NAME)b = !1; else if (!OpenLayers.Util.isArray(a.components) || a.components.length != this.components.length)b = !1; else for (var c = 0, d = this.components.length; c < d; ++c)if (!this.components[c].equals(a.components[c])) {
            b = !1;
            break
        }
        return b
    }, transform: function (a, b) {
        if (a && b) {
            for (var c = 0, d = this.components.length; c < d; c++)this.components[c].transform(a,
                b);
            this.bounds = null
        }
        return this
    }, intersects: function (a) {
        for (var b = !1, c = 0, d = this.components.length; c < d && !(b = a.intersects(this.components[c])); ++c);
        return b
    }, getVertices: function (a) {
        for (var b = [], c = 0, d = this.components.length; c < d; ++c)Array.prototype.push.apply(b, this.components[c].getVertices(a));
        return b
    }, CLASS_NAME: "OpenLayers.Geometry.Collection"
});
OpenLayers.Geometry.Point = OpenLayers.Class(OpenLayers.Geometry, {
    x: null, y: null, initialize: function (a, b) {
        OpenLayers.Geometry.prototype.initialize.apply(this, arguments);
        this.x = parseFloat(a);
        this.y = parseFloat(b)
    }, clone: function (a) {
        null == a && (a = new OpenLayers.Geometry.Point(this.x, this.y));
        OpenLayers.Util.applyDefaults(a, this);
        return a
    }, calculateBounds: function () {
        this.bounds = new OpenLayers.Bounds(this.x, this.y, this.x, this.y)
    }, distanceTo: function (a, b) {
        var c = !(b && !1 === b.edge) && b && b.details, d, e, f, g, h;
        a instanceof
        OpenLayers.Geometry.Point ? (e = this.x, f = this.y, g = a.x, h = a.y, d = Math.sqrt(Math.pow(e - g, 2) + Math.pow(f - h, 2)), d = !c ? d : {
            x0: e,
            y0: f,
            x1: g,
            y1: h,
            distance: d
        }) : (d = a.distanceTo(this, b), c && (d = {x0: d.x1, y0: d.y1, x1: d.x0, y1: d.y0, distance: d.distance}));
        return d
    }, equals: function (a) {
        var b = !1;
        null != a && (b = this.x == a.x && this.y == a.y || isNaN(this.x) && isNaN(this.y) && isNaN(a.x) && isNaN(a.y));
        return b
    }, toShortString: function () {
        return this.x + ", " + this.y
    }, move: function (a, b) {
        this.x += a;
        this.y += b;
        this.clearBounds()
    }, rotate: function (a, b) {
        var a =
            a * (Math.PI / 180), c = this.distanceTo(b), d = a + Math.atan2(this.y - b.y, this.x - b.x);
        this.x = b.x + c * Math.cos(d);
        this.y = b.y + c * Math.sin(d);
        this.clearBounds()
    }, getCentroid: function () {
        return new OpenLayers.Geometry.Point(this.x, this.y)
    }, resize: function (a, b, c) {
        this.x = b.x + a * (void 0 == c ? 1 : c) * (this.x - b.x);
        this.y = b.y + a * (this.y - b.y);
        this.clearBounds();
        return this
    }, intersects: function (a) {
        return "OpenLayers.Geometry.Point" == a.CLASS_NAME ? this.equals(a) : a.intersects(this)
    }, transform: function (a, b) {
        a && b && (OpenLayers.Projection.transform(this,
            a, b), this.bounds = null);
        return this
    }, getVertices: function () {
        return [this]
    }, CLASS_NAME: "OpenLayers.Geometry.Point"
});
OpenLayers.Geometry.MultiPoint = OpenLayers.Class(OpenLayers.Geometry.Collection, {
    componentTypes: ["OpenLayers.Geometry.Point"],
    addPoint: function (a, b) {
        this.addComponent(a, b)
    },
    removePoint: function (a) {
        this.removeComponent(a)
    },
    CLASS_NAME: "OpenLayers.Geometry.MultiPoint"
});
OpenLayers.Geometry.Curve = OpenLayers.Class(OpenLayers.Geometry.MultiPoint, {
    componentTypes: ["OpenLayers.Geometry.Point"], getLength: function () {
        var a = 0;
        if (this.components && 1 < this.components.length)for (var b = 1, c = this.components.length; b < c; b++)a += this.components[b - 1].distanceTo(this.components[b]);
        return a
    }, getGeodesicLength: function (a) {
        var b = this;
        if (a) {
            var c = new OpenLayers.Projection("EPSG:4326");
            c.equals(a) || (b = this.clone().transform(a, c))
        }
        a = 0;
        if (b.components && 1 < b.components.length)for (var d, e = 1, f = b.components.length; e <
        f; e++)c = b.components[e - 1], d = b.components[e], a += OpenLayers.Util.distVincenty({
            lon: c.x,
            lat: c.y
        }, {lon: d.x, lat: d.y});
        return 1E3 * a
    }, CLASS_NAME: "OpenLayers.Geometry.Curve"
});
OpenLayers.Geometry.LineString = OpenLayers.Class(OpenLayers.Geometry.Curve, {
    removeComponent: function (a) {
        var b = this.components && 2 < this.components.length;
        b && OpenLayers.Geometry.Collection.prototype.removeComponent.apply(this, arguments);
        return b
    }, intersects: function (a) {
        var b = !1, c = a.CLASS_NAME;
        if ("OpenLayers.Geometry.LineString" == c || "OpenLayers.Geometry.LinearRing" == c || "OpenLayers.Geometry.Point" == c) {
            var d = this.getSortedSegments(), a = "OpenLayers.Geometry.Point" == c ? [{
                    x1: a.x,
                    y1: a.y,
                    x2: a.x,
                    y2: a.y
                }] : a.getSortedSegments(),
                e, f, g, h, k, l, m, n = 0, o = d.length;
            a:for (; n < o; ++n) {
                c = d[n];
                e = c.x1;
                f = c.x2;
                g = c.y1;
                h = c.y2;
                for (var p = 0, r = a.length; p < r; ++p) {
                    k = a[p];
                    if (k.x1 > f)break;
                    if (!(k.x2 < e) && (l = k.y1, m = k.y2, !(Math.min(l, m) > Math.max(g, h)) && !(Math.max(l, m) < Math.min(g, h)) && OpenLayers.Geometry.segmentsIntersect(c, k))) {
                        b = !0;
                        break a
                    }
                }
            }
        } else b = a.intersects(this);
        return b
    }, getSortedSegments: function () {
        for (var a = this.components.length - 1, b = Array(a), c, d, e = 0; e < a; ++e)c = this.components[e], d = this.components[e + 1], b[e] = c.x < d.x ? {
            x1: c.x,
            y1: c.y,
            x2: d.x,
            y2: d.y
        } :
        {x1: d.x, y1: d.y, x2: c.x, y2: c.y};
        return b.sort(function (a, b) {
            return a.x1 - b.x1
        })
    }, splitWithSegment: function (a, b) {
        for (var c = !(b && !1 === b.edge), d = b && b.tolerance, e = [], f = this.getVertices(), g = [], h = [], k = !1, l, m, n = {
            point: !0,
            tolerance: d
        }, o = null, p = 0, r = f.length - 2; p <= r; ++p)if (d = f[p], g.push(d.clone()), l = f[p + 1], m = {
                x1: d.x,
                y1: d.y,
                x2: l.x,
                y2: l.y
            }, m = OpenLayers.Geometry.segmentsIntersect(a, m, n), m instanceof OpenLayers.Geometry.Point && ((m.x === a.x1 && m.y === a.y1 || m.x === a.x2 && m.y === a.y2 || m.equals(d) || m.equals(l) ? !0 : !1) || c))m.equals(h[h.length -
        1]) || h.push(m.clone()), !(0 === p && m.equals(d)) && !m.equals(l) && (k = !0, m.equals(d) || g.push(m), e.push(new OpenLayers.Geometry.LineString(g)), g = [m.clone()]);
        k && (g.push(l.clone()), e.push(new OpenLayers.Geometry.LineString(g)));
        if (0 < h.length)var u = a.x1 < a.x2 ? 1 : -1, q = a.y1 < a.y2 ? 1 : -1, o = {
            lines: e,
            points: h.sort(function (a, b) {
                return u * a.x - u * b.x || q * a.y - q * b.y
            })
        };
        return o
    }, split: function (a, b) {
        var c = null, d = b && b.mutual, e, f, g, h;
        if (a instanceof OpenLayers.Geometry.LineString) {
            var k = this.getVertices(), l, m, n, o, p, r = [];
            g = [];
            for (var u = 0, q = k.length - 2; u <= q; ++u) {
                l = k[u];
                m = k[u + 1];
                n = {x1: l.x, y1: l.y, x2: m.x, y2: m.y};
                h = h || [a];
                d && r.push(l.clone());
                for (var t = 0; t < h.length; ++t)if (o = h[t].splitWithSegment(n, b))if (p = o.lines, 0 < p.length && (p.unshift(t, 1), Array.prototype.splice.apply(h, p), t += p.length - 2), d)for (var y = 0, w = o.points.length; y < w; ++y)p = o.points[y], p.equals(l) || (r.push(p), g.push(new OpenLayers.Geometry.LineString(r)), r = p.equals(m) ? [] : [p.clone()])
            }
            d && 0 < g.length && 0 < r.length && (r.push(m.clone()), g.push(new OpenLayers.Geometry.LineString(r)))
        } else c =
            a.splitWith(this, b);
        h && 1 < h.length ? f = !0 : h = [];
        g && 1 < g.length ? e = !0 : g = [];
        if (f || e)c = d ? [g, h] : h;
        return c
    }, splitWith: function (a, b) {
        return a.split(this, b)
    }, getVertices: function (a) {
        return !0 === a ? [this.components[0], this.components[this.components.length - 1]] : !1 === a ? this.components.slice(1, this.components.length - 1) : this.components.slice()
    }, distanceTo: function (a, b) {
        var c = !(b && !1 === b.edge) && b && b.details, d, e = {}, f = Number.POSITIVE_INFINITY;
        if (a instanceof OpenLayers.Geometry.Point) {
            for (var g = this.getSortedSegments(),
                     h = a.x, k = a.y, l, m = 0, n = g.length; m < n; ++m)if (l = g[m], d = OpenLayers.Geometry.distanceToSegment(a, l), d.distance < f) {
                if (f = d.distance, e = d, 0 === f)break
            } else if (l.x2 > h && (k > l.y1 && k < l.y2 || k < l.y1 && k > l.y2))break;
            e = c ? {distance: e.distance, x0: e.x, y0: e.y, x1: h, y1: k} : e.distance
        } else if (a instanceof OpenLayers.Geometry.LineString) {
            var g = this.getSortedSegments(), h = a.getSortedSegments(), o, p, r = h.length, u = {point: !0}, m = 0, n = g.length;
            a:for (; m < n; ++m) {
                k = g[m];
                l = k.x1;
                p = k.y1;
                for (var q = 0; q < r; ++q)if (d = h[q], o = OpenLayers.Geometry.segmentsIntersect(k,
                        d, u)) {
                    f = 0;
                    e = {distance: 0, x0: o.x, y0: o.y, x1: o.x, y1: o.y};
                    break a
                } else d = OpenLayers.Geometry.distanceToSegment({
                    x: l,
                    y: p
                }, d), d.distance < f && (f = d.distance, e = {distance: f, x0: l, y0: p, x1: d.x, y1: d.y})
            }
            c || (e = e.distance);
            0 !== f && k && (d = a.distanceTo(new OpenLayers.Geometry.Point(k.x2, k.y2), b), m = c ? d.distance : d, m < f && (e = c ? {
                distance: f,
                x0: d.x1,
                y0: d.y1,
                x1: d.x0,
                y1: d.y0
            } : m))
        } else e = a.distanceTo(this, b), c && (e = {distance: e.distance, x0: e.x1, y0: e.y1, x1: e.x0, y1: e.y0});
        return e
    }, simplify: function (a) {
        if (this && null !== this) {
            var b = this.getVertices();
            if (3 > b.length)return this;
            var c = function (a, b, d, k) {
                for (var l = 0, m = 0, n = b, o; n < d; n++) {
                    o = a[b];
                    var p = a[d], r = a[n], r = Math.abs(0.5 * (o.x * p.y + p.x * r.y + r.x * o.y - p.x * o.y - r.x * p.y - o.x * r.y));
                    o = Math.sqrt(Math.pow(o.x - p.x, 2) + Math.pow(o.y - p.y, 2));
                    o = 2 * (r / o);
                    o > l && (l = o, m = n)
                }
                l > k && m != b && (e.push(m), c(a, b, m, k), c(a, m, d, k))
            }, d = b.length - 1, e = [];
            e.push(0);
            for (e.push(d); b[0].equals(b[d]);)d--, e.push(d);
            c(b, 0, d, a);
            a = [];
            e.sort(function (a, b) {
                return a - b
            });
            for (d = 0; d < e.length; d++)a.push(b[e[d]]);
            return new OpenLayers.Geometry.LineString(a)
        }
        return this
    },
    CLASS_NAME: "OpenLayers.Geometry.LineString"
});
OpenLayers.Geometry.LinearRing = OpenLayers.Class(OpenLayers.Geometry.LineString, {
    componentTypes: ["OpenLayers.Geometry.Point"], addComponent: function (a, b) {
        var c = !1, d = this.components.pop();
        if (null != b || !a.equals(d))c = OpenLayers.Geometry.Collection.prototype.addComponent.apply(this, arguments);
        OpenLayers.Geometry.Collection.prototype.addComponent.apply(this, [this.components[0]]);
        return c
    }, removeComponent: function (a) {
        var b = this.components && 3 < this.components.length;
        b && (this.components.pop(), OpenLayers.Geometry.Collection.prototype.removeComponent.apply(this,
            arguments), OpenLayers.Geometry.Collection.prototype.addComponent.apply(this, [this.components[0]]));
        return b
    }, move: function (a, b) {
        for (var c = 0, d = this.components.length; c < d - 1; c++)this.components[c].move(a, b)
    }, rotate: function (a, b) {
        for (var c = 0, d = this.components.length; c < d - 1; ++c)this.components[c].rotate(a, b)
    }, resize: function (a, b, c) {
        for (var d = 0, e = this.components.length; d < e - 1; ++d)this.components[d].resize(a, b, c);
        return this
    }, transform: function (a, b) {
        if (a && b) {
            for (var c = 0, d = this.components.length; c < d - 1; c++)this.components[c].transform(a,
                b);
            this.bounds = null
        }
        return this
    }, getCentroid: function () {
        if (this.components && 2 < this.components.length) {
            for (var a = 0, b = 0, c = 0; c < this.components.length - 1; c++)var d = this.components[c], e = this.components[c + 1], a = a + (d.x + e.x) * (d.x * e.y - e.x * d.y), b = b + (d.y + e.y) * (d.x * e.y - e.x * d.y);
            c = -1 * this.getArea();
            return new OpenLayers.Geometry.Point(a / (6 * c), b / (6 * c))
        }
        return null
    }, getArea: function () {
        var a = 0;
        if (this.components && 2 < this.components.length) {
            for (var b = a = 0, c = this.components.length; b < c - 1; b++)var d = this.components[b], e =
                this.components[b + 1], a = a + (d.x + e.x) * (e.y - d.y);
            a = -a / 2
        }
        return a
    }, getGeodesicArea: function (a) {
        var b = this;
        if (a) {
            var c = new OpenLayers.Projection("EPSG:4326");
            c.equals(a) || (b = this.clone().transform(a, c))
        }
        a = 0;
        c = b.components && b.components.length;
        if (2 < c) {
            for (var d, e, f = 0; f < c - 1; f++)d = b.components[f], e = b.components[f + 1], a += OpenLayers.Util.rad(e.x - d.x) * (2 + Math.sin(OpenLayers.Util.rad(d.y)) + Math.sin(OpenLayers.Util.rad(e.y)));
            a = 40680631590769 * a / 2
        }
        return a
    }, containsPoint: function (a) {
        for (var b = OpenLayers.Number.limitSigDigs,
                 c = b(a.x, 14), a = b(a.y, 14), d = this.components.length - 1, e, f, g, h, k, l = 0, m = 0; m < d; ++m)if (e = this.components[m], g = b(e.x, 14), e = b(e.y, 14), f = this.components[m + 1], h = b(f.x, 14), f = b(f.y, 14), e == f) {
            if (a == e && (g <= h && c >= g && c <= h || g >= h && c <= g && c >= h)) {
                l = -1;
                break
            }
        } else {
            k = b((a - f) * ((h - g) / (f - e)) + h, 14);
            if (k == c && (e < f && a >= e && a <= f || e > f && a <= e && a >= f)) {
                l = -1;
                break
            }
            k <= c || g != h && (k < Math.min(g, h) || k > Math.max(g, h)) || (e < f && a >= e && a < f || e > f && a < e && a >= f) && ++l
        }
        return -1 == l ? 1 : !!(l & 1)
    }, intersects: function (a) {
        var b = !1;
        if ("OpenLayers.Geometry.Point" ==
            a.CLASS_NAME)b = this.containsPoint(a); else if ("OpenLayers.Geometry.LineString" == a.CLASS_NAME)b = a.intersects(this); else if ("OpenLayers.Geometry.LinearRing" == a.CLASS_NAME)b = OpenLayers.Geometry.LineString.prototype.intersects.apply(this, [a]); else for (var c = 0, d = a.components.length; c < d && !(b = a.components[c].intersects(this)); ++c);
        return b
    }, getVertices: function (a) {
        return !0 === a ? [] : this.components.slice(0, this.components.length - 1)
    }, CLASS_NAME: "OpenLayers.Geometry.LinearRing"
});
OpenLayers.Geometry.Polygon = OpenLayers.Class(OpenLayers.Geometry.Collection, {
    componentTypes: ["OpenLayers.Geometry.LinearRing"], getArea: function () {
        var a = 0;
        if (this.components && 0 < this.components.length)for (var a = a + Math.abs(this.components[0].getArea()), b = 1, c = this.components.length; b < c; b++)a -= Math.abs(this.components[b].getArea());
        return a
    }, getGeodesicArea: function (a) {
        var b = 0;
        if (this.components && 0 < this.components.length)for (var b = b + Math.abs(this.components[0].getGeodesicArea(a)), c = 1, d = this.components.length; c <
        d; c++)b -= Math.abs(this.components[c].getGeodesicArea(a));
        return b
    }, containsPoint: function (a) {
        var b = this.components.length, c = !1;
        if (0 < b && (c = this.components[0].containsPoint(a), 1 !== c && c && 1 < b))for (var d, e = 1; e < b; ++e)if (d = this.components[e].containsPoint(a)) {
            c = 1 === d ? 1 : !1;
            break
        }
        return c
    }, intersects: function (a) {
        var b = !1, c, d;
        if ("OpenLayers.Geometry.Point" == a.CLASS_NAME)b = this.containsPoint(a); else if ("OpenLayers.Geometry.LineString" == a.CLASS_NAME || "OpenLayers.Geometry.LinearRing" == a.CLASS_NAME) {
            for (c = 0, d =
                this.components.length; c < d && !(b = a.intersects(this.components[c])); ++c);
            if (!b)for (c = 0, d = a.components.length; c < d && !(b = this.containsPoint(a.components[c])); ++c);
        } else for (c = 0, d = a.components.length; c < d && !(b = this.intersects(a.components[c])); ++c);
        if (!b && "OpenLayers.Geometry.Polygon" == a.CLASS_NAME) {
            var e = this.components[0];
            for (c = 0, d = e.components.length; c < d && !(b = a.containsPoint(e.components[c])); ++c);
        }
        return b
    }, distanceTo: function (a, b) {
        return b && !1 === b.edge && this.intersects(a) ? 0 : OpenLayers.Geometry.Collection.prototype.distanceTo.apply(this,
            [a, b])
    }, CLASS_NAME: "OpenLayers.Geometry.Polygon"
});
OpenLayers.Geometry.Polygon.createRegularPolygon = function (a, b, c, d) {
    var e = Math.PI * (1 / c - 0.5);
    d && (e += d / 180 * Math.PI);
    for (var f, g = [], h = 0; h < c; ++h)f = e + 2 * h * Math.PI / c, d = a.x + b * Math.cos(f), f = a.y + b * Math.sin(f), g.push(new OpenLayers.Geometry.Point(d, f));
    a = new OpenLayers.Geometry.LinearRing(g);
    return new OpenLayers.Geometry.Polygon([a])
};
OpenLayers.Geometry.MultiLineString = OpenLayers.Class(OpenLayers.Geometry.Collection, {
    componentTypes: ["OpenLayers.Geometry.LineString"], split: function (a, b) {
        for (var c = null, d = b && b.mutual, e, f, g, h, k = [], l = [a], m = 0, n = this.components.length; m < n; ++m) {
            f = this.components[m];
            g = !1;
            for (var o = 0; o < l.length; ++o)if (e = f.split(l[o], b)) {
                if (d) {
                    g = e[0];
                    for (var p = 0, r = g.length; p < r; ++p)0 === p && k.length ? k[k.length - 1].addComponent(g[p]) : k.push(new OpenLayers.Geometry.MultiLineString([g[p]]));
                    g = !0;
                    e = e[1]
                }
                if (e.length) {
                    e.unshift(o,
                        1);
                    Array.prototype.splice.apply(l, e);
                    break
                }
            }
            g || (k.length ? k[k.length - 1].addComponent(f.clone()) : k = [new OpenLayers.Geometry.MultiLineString(f.clone())])
        }
        k && 1 < k.length ? g = !0 : k = [];
        l && 1 < l.length ? h = !0 : l = [];
        if (g || h)c = d ? [k, l] : l;
        return c
    }, splitWith: function (a, b) {
        var c = null, d = b && b.mutual, e, f, g, h, k, l;
        if (a instanceof OpenLayers.Geometry.LineString) {
            l = [];
            k = [a];
            for (var m = 0, n = this.components.length; m < n; ++m) {
                g = !1;
                f = this.components[m];
                for (var o = 0; o < k.length; ++o)if (e = k[o].split(f, b)) {
                    d && (g = e[0], g.length && (g.unshift(o,
                        1), Array.prototype.splice.apply(k, g), o += g.length - 2), e = e[1], 0 === e.length && (e = [f.clone()]));
                    g = 0;
                    for (var p = e.length; g < p; ++g)0 === g && l.length ? l[l.length - 1].addComponent(e[g]) : l.push(new OpenLayers.Geometry.MultiLineString([e[g]]));
                    g = !0
                }
                g || (l.length ? l[l.length - 1].addComponent(f.clone()) : l = [new OpenLayers.Geometry.MultiLineString([f.clone()])])
            }
        } else c = a.split(this);
        k && 1 < k.length ? h = !0 : k = [];
        l && 1 < l.length ? g = !0 : l = [];
        if (h || g)c = d ? [k, l] : l;
        return c
    }, CLASS_NAME: "OpenLayers.Geometry.MultiLineString"
});
OpenLayers.Geometry.MultiPolygon = OpenLayers.Class(OpenLayers.Geometry.Collection, {
    componentTypes: ["OpenLayers.Geometry.Polygon"],
    CLASS_NAME: "OpenLayers.Geometry.MultiPolygon"
});
OpenLayers.Renderer = OpenLayers.Class({
    container: null,
    root: null,
    extent: null,
    locked: !1,
    size: null,
    resolution: null,
    map: null,
    featureDx: 0,
    initialize: function (a, b) {
        this.container = OpenLayers.Util.getElement(a);
        OpenLayers.Util.extend(this, b)
    },
    destroy: function () {
        this.map = this.resolution = this.size = this.extent = this.container = null
    },
    supported: function () {
        return !1
    },
    setExtent: function (a, b) {
        this.extent = a.clone();
        if (this.map.baseLayer && this.map.baseLayer.wrapDateLine) {
            var c = a.getWidth() / this.map.getExtent().getWidth(),
                a = a.scale(1 / c);
            this.extent = a.wrapDateLine(this.map.getMaxExtent()).scale(c)
        }
        b && (this.resolution = null);
        return !0
    },
    setSize: function (a) {
        this.size = a.clone();
        this.resolution = null
    },
    getResolution: function () {
        return this.resolution = this.resolution || this.map.getResolution()
    },
    drawFeature: function (a, b) {
        null == b && (b = a.style);
        if (a.geometry) {
            var c = a.geometry.getBounds();
            if (c) {
                var d;
                this.map.baseLayer && this.map.baseLayer.wrapDateLine && (d = this.map.getMaxExtent());
                c.intersectsBounds(this.extent, {worldBounds: d}) ? this.calculateFeatureDx(c,
                    d) : b = {display: "none"};
                c = this.drawGeometry(a.geometry, b, a.id);
                if ("none" != b.display && b.label && !1 !== c) {
                    d = a.geometry.getCentroid();
                    if (b.labelXOffset || b.labelYOffset) {
                        var e = isNaN(b.labelXOffset) ? 0 : b.labelXOffset, f = isNaN(b.labelYOffset) ? 0 : b.labelYOffset, g = this.getResolution();
                        d.move(e * g, f * g)
                    }
                    this.drawText(a.id, b, d)
                } else this.removeText(a.id);
                return c
            }
        }
    },
    calculateFeatureDx: function (a, b) {
        this.featureDx = 0;
        if (b) {
            var c = b.getWidth();
            this.featureDx = Math.round(((a.left + a.right) / 2 - (this.extent.left + this.extent.right) /
            2) / c) * c
        }
    },
    drawGeometry: function () {
    },
    drawText: function () {
    },
    removeText: function () {
    },
    clear: function () {
    },
    getFeatureIdFromEvent: function () {
    },
    eraseFeatures: function (a) {
        OpenLayers.Util.isArray(a) || (a = [a]);
        for (var b = 0, c = a.length; b < c; ++b) {
            var d = a[b];
            this.eraseGeometry(d.geometry, d.id);
            this.removeText(d.id)
        }
    },
    eraseGeometry: function () {
    },
    moveRoot: function () {
    },
    getRenderLayerId: function () {
        return this.container.id
    },
    applyDefaultSymbolizer: function (a) {
        var b = OpenLayers.Util.extend({}, OpenLayers.Renderer.defaultSymbolizer);
        !1 === a.stroke && (delete b.strokeWidth, delete b.strokeColor);
        !1 === a.fill && delete b.fillColor;
        OpenLayers.Util.extend(b, a);
        return b
    },
    CLASS_NAME: "OpenLayers.Renderer"
});
OpenLayers.Renderer.defaultSymbolizer = {
    fillColor: "#000000",
    strokeColor: "#000000",
    strokeWidth: 2,
    fillOpacity: 1,
    strokeOpacity: 1,
    pointRadius: 0,
    labelAlign: "cm"
};
OpenLayers.Renderer.symbol = {
    star: [350, 75, 379, 161, 469, 161, 397, 215, 423, 301, 350, 250, 277, 301, 303, 215, 231, 161, 321, 161, 350, 75],
    cross: [4, 0, 6, 0, 6, 4, 10, 4, 10, 6, 6, 6, 6, 10, 4, 10, 4, 6, 0, 6, 0, 4, 4, 4, 4, 0],
    x: [0, 0, 25, 0, 50, 35, 75, 0, 100, 0, 65, 50, 100, 100, 75, 100, 50, 65, 25, 100, 0, 100, 35, 50, 0, 0],
    square: [0, 0, 0, 1, 1, 1, 1, 0, 0, 0],
    triangle: [0, 10, 10, 10, 5, 0, 0, 10]
};
OpenLayers.ElementsIndexer = OpenLayers.Class({
    maxZIndex: null, order: null, indices: null, compare: null, initialize: function (a) {
        this.compare = a ? OpenLayers.ElementsIndexer.IndexingMethods.Z_ORDER_Y_ORDER : OpenLayers.ElementsIndexer.IndexingMethods.Z_ORDER_DRAWING_ORDER;
        this.clear()
    }, insert: function (a) {
        this.exists(a) && this.remove(a);
        var b = a.id;
        this.determineZIndex(a);
        for (var c = -1, d = this.order.length, e; 1 < d - c;)e = parseInt((c + d) / 2), 0 < this.compare(this, a, OpenLayers.Util.getElement(this.order[e])) ? c = e : d = e;
        this.order.splice(d,
            0, b);
        this.indices[b] = this.getZIndex(a);
        return this.getNextElement(d)
    }, remove: function (a) {
        var a = a.id, b = OpenLayers.Util.indexOf(this.order, a);
        0 <= b && (this.order.splice(b, 1), delete this.indices[a], this.maxZIndex = 0 < this.order.length ? this.indices[this.order[this.order.length - 1]] : 0)
    }, clear: function () {
        this.order = [];
        this.indices = {};
        this.maxZIndex = 0
    }, exists: function (a) {
        return null != this.indices[a.id]
    }, getZIndex: function (a) {
        return a._style.graphicZIndex
    }, determineZIndex: function (a) {
        var b = a._style.graphicZIndex;
        null == b ? (b = this.maxZIndex, a._style.graphicZIndex = b) : b > this.maxZIndex && (this.maxZIndex = b)
    }, getNextElement: function (a) {
        a += 1;
        if (a < this.order.length) {
            var b = OpenLayers.Util.getElement(this.order[a]);
            void 0 == b && (b = this.getNextElement(a));
            return b
        }
        return null
    }, CLASS_NAME: "OpenLayers.ElementsIndexer"
});
OpenLayers.ElementsIndexer.IndexingMethods = {
    Z_ORDER: function (a, b, c) {
        var b = a.getZIndex(b), d = 0;
        c && (a = a.getZIndex(c), d = b - a);
        return d
    }, Z_ORDER_DRAWING_ORDER: function (a, b, c) {
        a = OpenLayers.ElementsIndexer.IndexingMethods.Z_ORDER(a, b, c);
        c && 0 == a && (a = 1);
        return a
    }, Z_ORDER_Y_ORDER: function (a, b, c) {
        a = OpenLayers.ElementsIndexer.IndexingMethods.Z_ORDER(a, b, c);
        c && 0 === a && (b = c._boundsBottom - b._boundsBottom, a = 0 === b ? 1 : b);
        return a
    }
};
OpenLayers.Renderer.Elements = OpenLayers.Class(OpenLayers.Renderer, {
    rendererRoot: null,
    root: null,
    vectorRoot: null,
    textRoot: null,
    xmlns: null,
    xOffset: 0,
    indexer: null,
    BACKGROUND_ID_SUFFIX: "_background",
    LABEL_ID_SUFFIX: "_label",
    LABEL_OUTLINE_SUFFIX: "_outline",
    initialize: function (a, b) {
        OpenLayers.Renderer.prototype.initialize.apply(this, arguments);
        this.rendererRoot = this.createRenderRoot();
        this.root = this.createRoot("_root");
        this.vectorRoot = this.createRoot("_vroot");
        this.textRoot = this.createRoot("_troot");
        this.root.appendChild(this.vectorRoot);
        this.root.appendChild(this.textRoot);
        this.rendererRoot.appendChild(this.root);
        this.container.appendChild(this.rendererRoot);
        if (b && (b.zIndexing || b.yOrdering))this.indexer = new OpenLayers.ElementsIndexer(b.yOrdering)
    },
    destroy: function () {
        this.clear();
        this.xmlns = this.root = this.rendererRoot = null;
        OpenLayers.Renderer.prototype.destroy.apply(this, arguments)
    },
    clear: function () {
        var a, b = this.vectorRoot;
        if (b)for (; a = b.firstChild;)b.removeChild(a);
        if (b = this.textRoot)for (; a = b.firstChild;)b.removeChild(a);
        this.indexer &&
        this.indexer.clear()
    },
    setExtent: function (a, b) {
        var c = OpenLayers.Renderer.prototype.setExtent.apply(this, arguments), d = this.getResolution();
        if (this.map.baseLayer && this.map.baseLayer.wrapDateLine) {
            var e, f = a.getWidth() / this.map.getExtent().getWidth(), a = a.scale(1 / f), f = this.map.getMaxExtent();
            f.right > a.left && f.right < a.right ? e = !0 : f.left > a.left && f.left < a.right && (e = !1);
            if (e !== this.rightOfDateLine || b)c = !1, this.xOffset = !0 === e ? f.getWidth() / d : 0;
            this.rightOfDateLine = e
        }
        return c
    },
    getNodeType: function () {
    },
    drawGeometry: function (a,
                            b, c) {
        var d = a.CLASS_NAME, e = !0;
        if ("OpenLayers.Geometry.Collection" == d || "OpenLayers.Geometry.MultiPoint" == d || "OpenLayers.Geometry.MultiLineString" == d || "OpenLayers.Geometry.MultiPolygon" == d) {
            for (var d = 0, f = a.components.length; d < f; d++)e = this.drawGeometry(a.components[d], b, c) && e;
            return e
        }
        d = e = !1;
        "none" != b.display && (b.backgroundGraphic ? this.redrawBackgroundNode(a.id, a, b, c) : d = !0, e = this.redrawNode(a.id, a, b, c));
        if (!1 == e && (b = document.getElementById(a.id)))b._style.backgroundGraphic && (d = !0), b.parentNode.removeChild(b);
        d && (b = document.getElementById(a.id + this.BACKGROUND_ID_SUFFIX)) && b.parentNode.removeChild(b);
        return e
    },
    redrawNode: function (a, b, c, d) {
        c = this.applyDefaultSymbolizer(c);
        a = this.nodeFactory(a, this.getNodeType(b, c));
        a._featureId = d;
        a._boundsBottom = b.getBounds().bottom;
        a._geometryClass = b.CLASS_NAME;
        a._style = c;
        b = this.drawGeometryNode(a, b, c);
        if (!1 === b)return !1;
        a = b.node;
        this.indexer ? (c = this.indexer.insert(a)) ? this.vectorRoot.insertBefore(a, c) : this.vectorRoot.appendChild(a) : a.parentNode !== this.vectorRoot && this.vectorRoot.appendChild(a);
        this.postDraw(a);
        return b.complete
    },
    redrawBackgroundNode: function (a, b, c) {
        c = OpenLayers.Util.extend({}, c);
        c.externalGraphic = c.backgroundGraphic;
        c.graphicXOffset = c.backgroundXOffset;
        c.graphicYOffset = c.backgroundYOffset;
        c.graphicZIndex = c.backgroundGraphicZIndex;
        c.graphicWidth = c.backgroundWidth || c.graphicWidth;
        c.graphicHeight = c.backgroundHeight || c.graphicHeight;
        c.backgroundGraphic = null;
        c.backgroundXOffset = null;
        c.backgroundYOffset = null;
        c.backgroundGraphicZIndex = null;
        return this.redrawNode(a + this.BACKGROUND_ID_SUFFIX,
            b, c, null)
    },
    drawGeometryNode: function (a, b, c) {
        var c = c || a._style, d = {
            isFilled: void 0 === c.fill ? !0 : c.fill,
            isStroked: void 0 === c.stroke ? !!c.strokeWidth : c.stroke
        }, e;
        switch (b.CLASS_NAME) {
            case "OpenLayers.Geometry.Point":
                !1 === c.graphic && (d.isFilled = !1, d.isStroked = !1);
                e = this.drawPoint(a, b);
                break;
            case "OpenLayers.Geometry.LineString":
                d.isFilled = !1;
                e = this.drawLineString(a, b);
                break;
            case "OpenLayers.Geometry.LinearRing":
                e = this.drawLinearRing(a, b);
                break;
            case "OpenLayers.Geometry.Polygon":
                e = this.drawPolygon(a, b);
                break;
            case "OpenLayers.Geometry.Rectangle":
                e = this.drawRectangle(a, b)
        }
        a._options = d;
        return !1 != e ? {node: this.setStyle(a, c, d, b), complete: e} : !1
    },
    postDraw: function () {
    },
    drawPoint: function () {
    },
    drawLineString: function () {
    },
    drawLinearRing: function () {
    },
    drawPolygon: function () {
    },
    drawRectangle: function () {
    },
    drawCircle: function () {
    },
    removeText: function (a) {
        var b = document.getElementById(a + this.LABEL_ID_SUFFIX);
        b && this.textRoot.removeChild(b);
        (a = document.getElementById(a + this.LABEL_OUTLINE_SUFFIX)) && this.textRoot.removeChild(a)
    },
    getFeatureIdFromEvent: function (a) {
        var b = a.target, c = b && b.correspondingUseElement;
        return (c ? c : b || a.srcElement)._featureId
    },
    eraseGeometry: function (a, b) {
        if ("OpenLayers.Geometry.MultiPoint" == a.CLASS_NAME || "OpenLayers.Geometry.MultiLineString" == a.CLASS_NAME || "OpenLayers.Geometry.MultiPolygon" == a.CLASS_NAME || "OpenLayers.Geometry.Collection" == a.CLASS_NAME)for (var c = 0, d = a.components.length; c < d; c++)this.eraseGeometry(a.components[c], b); else if ((c = OpenLayers.Util.getElement(a.id)) && c.parentNode)c.geometry && (c.geometry.destroy(),
            c.geometry = null), c.parentNode.removeChild(c), this.indexer && this.indexer.remove(c), c._style.backgroundGraphic && (c = OpenLayers.Util.getElement(a.id + this.BACKGROUND_ID_SUFFIX)) && c.parentNode && c.parentNode.removeChild(c)
    },
    nodeFactory: function (a, b) {
        var c = OpenLayers.Util.getElement(a);
        c ? this.nodeTypeCompare(c, b) || (c.parentNode.removeChild(c), c = this.nodeFactory(a, b)) : c = this.createNode(b, a);
        return c
    },
    nodeTypeCompare: function () {
    },
    createNode: function () {
    },
    moveRoot: function (a) {
        var b = this.root;
        a.root.parentNode ==
        this.rendererRoot && (b = a.root);
        b.parentNode.removeChild(b);
        a.rendererRoot.appendChild(b)
    },
    getRenderLayerId: function () {
        return this.root.parentNode.parentNode.id
    },
    isComplexSymbol: function (a) {
        return "circle" != a && !!a
    },
    CLASS_NAME: "OpenLayers.Renderer.Elements"
});
OpenLayers.Renderer.SVG = OpenLayers.Class(OpenLayers.Renderer.Elements, {
    xmlns: "http://www.w3.org/2000/svg",
    xlinkns: "http://www.w3.org/1999/xlink",
    MAX_PIXEL: 15E3,
    translationParameters: null,
    symbolMetrics: null,
    initialize: function (a) {
        this.supported() && (OpenLayers.Renderer.Elements.prototype.initialize.apply(this, arguments), this.translationParameters = {
            x: 0,
            y: 0
        }, this.symbolMetrics = {})
    },
    supported: function () {
        return document.implementation && (document.implementation.hasFeature("org.w3c.svg", "1.0") || document.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#SVG",
                "1.1") || document.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1"))
    },
    inValidRange: function (a, b, c) {
        a += c ? 0 : this.translationParameters.x;
        b += c ? 0 : this.translationParameters.y;
        return a >= -this.MAX_PIXEL && a <= this.MAX_PIXEL && b >= -this.MAX_PIXEL && b <= this.MAX_PIXEL
    },
    setExtent: function (a, b) {
        var c = OpenLayers.Renderer.Elements.prototype.setExtent.apply(this, arguments), d = this.getResolution(), e = -a.left / d, d = a.top / d;
        if (b)return this.left = e, this.top = d, this.rendererRoot.setAttributeNS(null,
            "viewBox", "0 0 " + this.size.w + " " + this.size.h), this.translate(this.xOffset, 0), !0;
        (e = this.translate(e - this.left + this.xOffset, d - this.top)) || this.setExtent(a, !0);
        return c && e
    },
    translate: function (a, b) {
        if (this.inValidRange(a, b, !0)) {
            var c = "";
            if (a || b)c = "translate(" + a + "," + b + ")";
            this.root.setAttributeNS(null, "transform", c);
            this.translationParameters = {x: a, y: b};
            return !0
        }
        return !1
    },
    setSize: function (a) {
        OpenLayers.Renderer.prototype.setSize.apply(this, arguments);
        this.rendererRoot.setAttributeNS(null, "width", this.size.w);
        this.rendererRoot.setAttributeNS(null, "height", this.size.h)
    },
    getNodeType: function (a, b) {
        var c = null;
        switch (a.CLASS_NAME) {
            case "OpenLayers.Geometry.Point":
                c = b.externalGraphic ? "image" : this.isComplexSymbol(b.graphicName) ? "svg" : "circle";
                break;
            case "OpenLayers.Geometry.Rectangle":
                c = "rect";
                break;
            case "OpenLayers.Geometry.LineString":
                c = "polyline";
                break;
            case "OpenLayers.Geometry.LinearRing":
                c = "polygon";
                break;
            case "OpenLayers.Geometry.Polygon":
            case "OpenLayers.Geometry.Curve":
                c = "path"
        }
        return c
    },
    setStyle: function (a,
                        b, c) {
        var b = b || a._style, c = c || a._options, d = parseFloat(a.getAttributeNS(null, "r")), e = 1, f;
        if ("OpenLayers.Geometry.Point" == a._geometryClass && d) {
            a.style.visibility = "";
            if (!1 === b.graphic)a.style.visibility = "hidden"; else if (b.externalGraphic) {
                f = this.getPosition(a);
                b.graphicTitle && (a.setAttributeNS(null, "title", b.graphicTitle), d = a.getElementsByTagName("title"), 0 < d.length ? d[0].firstChild.textContent = b.graphicTitle : (d = this.nodeFactory(null, "title"), d.textContent = b.graphicTitle, a.appendChild(d)));
                b.graphicWidth &&
                b.graphicHeight && a.setAttributeNS(null, "preserveAspectRatio", "none");
                var d = b.graphicWidth || b.graphicHeight, g = b.graphicHeight || b.graphicWidth, d = d ? d : 2 * b.pointRadius, g = g ? g : 2 * b.pointRadius, h = void 0 != b.graphicYOffset ? b.graphicYOffset : -(0.5 * g), k = b.graphicOpacity || b.fillOpacity;
                a.setAttributeNS(null, "x", (f.x + (void 0 != b.graphicXOffset ? b.graphicXOffset : -(0.5 * d))).toFixed());
                a.setAttributeNS(null, "y", (f.y + h).toFixed());
                a.setAttributeNS(null, "width", d);
                a.setAttributeNS(null, "height", g);
                a.setAttributeNS(this.xlinkns,
                    "href", b.externalGraphic);
                a.setAttributeNS(null, "style", "opacity: " + k);
                a.onclick = OpenLayers.Renderer.SVG.preventDefault
            } else if (this.isComplexSymbol(b.graphicName)) {
                var d = 3 * b.pointRadius, g = 2 * d, l = this.importSymbol(b.graphicName);
                f = this.getPosition(a);
                e = 3 * this.symbolMetrics[l.id][0] / g;
                h = a.parentNode;
                k = a.nextSibling;
                h && h.removeChild(a);
                a.firstChild && a.removeChild(a.firstChild);
                a.appendChild(l.firstChild.cloneNode(!0));
                a.setAttributeNS(null, "viewBox", l.getAttributeNS(null, "viewBox"));
                a.setAttributeNS(null,
                    "width", g);
                a.setAttributeNS(null, "height", g);
                a.setAttributeNS(null, "x", f.x - d);
                a.setAttributeNS(null, "y", f.y - d);
                k ? h.insertBefore(a, k) : h && h.appendChild(a)
            } else a.setAttributeNS(null, "r", b.pointRadius);
            d = b.rotation;
            if ((void 0 !== d || void 0 !== a._rotation) && f)a._rotation = d, d |= 0, "svg" !== a.nodeName ? a.setAttributeNS(null, "transform", "rotate(" + d + " " + f.x + " " + f.y + ")") : (f = this.symbolMetrics[l.id], a.firstChild.setAttributeNS(null, "transform", "rotate(" + d + " " + f[1] + " " + f[2] + ")"))
        }
        c.isFilled ? (a.setAttributeNS(null,
            "fill", b.fillColor), a.setAttributeNS(null, "fill-opacity", b.fillOpacity)) : a.setAttributeNS(null, "fill", "none");
        c.isStroked ? (a.setAttributeNS(null, "stroke", b.strokeColor), a.setAttributeNS(null, "stroke-opacity", b.strokeOpacity), a.setAttributeNS(null, "stroke-width", b.strokeWidth * e), a.setAttributeNS(null, "stroke-linecap", b.strokeLinecap || "round"), a.setAttributeNS(null, "stroke-linejoin", "round"), b.strokeDashstyle && a.setAttributeNS(null, "stroke-dasharray", this.dashStyle(b, e))) : a.setAttributeNS(null, "stroke",
            "none");
        b.pointerEvents && a.setAttributeNS(null, "pointer-events", b.pointerEvents);
        null != b.cursor && a.setAttributeNS(null, "cursor", b.cursor);
        return a
    },
    dashStyle: function (a, b) {
        var c = a.strokeWidth * b, d = a.strokeDashstyle;
        switch (d) {
            case "solid":
                return "none";
            case "dot":
                return [1, 4 * c].join();
            case "dash":
                return [4 * c, 4 * c].join();
            case "dashdot":
                return [4 * c, 4 * c, 1, 4 * c].join();
            case "longdash":
                return [8 * c, 4 * c].join();
            case "longdashdot":
                return [8 * c, 4 * c, 1, 4 * c].join();
            default:
                return OpenLayers.String.trim(d).replace(/\s+/g,
                    ",")
        }
    },
    createNode: function (a, b) {
        var c = document.createElementNS(this.xmlns, a);
        b && c.setAttributeNS(null, "id", b);
        return c
    },
    nodeTypeCompare: function (a, b) {
        return b == a.nodeName
    },
    createRenderRoot: function () {
        var a = this.nodeFactory(this.container.id + "_svgRoot", "svg");
        a.style.display = "block";
        return a
    },
    createRoot: function (a) {
        return this.nodeFactory(this.container.id + a, "g")
    },
    createDefs: function () {
        var a = this.nodeFactory(this.container.id + "_defs", "defs");
        this.rendererRoot.appendChild(a);
        return a
    },
    drawPoint: function (a,
                         b) {
        return this.drawCircle(a, b, 1)
    },
    drawCircle: function (a, b, c) {
        var d = this.getResolution(), e = (b.x - this.featureDx) / d + this.left, b = this.top - b.y / d;
        return this.inValidRange(e, b) ? (a.setAttributeNS(null, "cx", e), a.setAttributeNS(null, "cy", b), a.setAttributeNS(null, "r", c), a) : !1
    },
    drawLineString: function (a, b) {
        var c = this.getComponentsString(b.components);
        return c.path ? (a.setAttributeNS(null, "points", c.path), c.complete ? a : null) : !1
    },
    drawLinearRing: function (a, b) {
        var c = this.getComponentsString(b.components);
        return c.path ?
            (a.setAttributeNS(null, "points", c.path), c.complete ? a : null) : !1
    },
    drawPolygon: function (a, b) {
        for (var c = "", d = !0, e = !0, f, g, h = 0, k = b.components.length; h < k; h++)c += " M", f = this.getComponentsString(b.components[h].components, " "), (g = f.path) ? (c += " " + g, e = f.complete && e) : d = !1;
        return d ? (a.setAttributeNS(null, "d", c + " z"), a.setAttributeNS(null, "fill-rule", "evenodd"), e ? a : null) : !1
    },
    drawRectangle: function (a, b) {
        var c = this.getResolution(), d = (b.x - this.featureDx) / c + this.left, e = this.top - b.y / c;
        return this.inValidRange(d, e) ? (a.setAttributeNS(null,
            "x", d), a.setAttributeNS(null, "y", e), a.setAttributeNS(null, "width", b.width / c), a.setAttributeNS(null, "height", b.height / c), a) : !1
    },
    drawText: function (a, b, c) {
        var d = !!b.labelOutlineWidth;
        if (d) {
            var e = OpenLayers.Util.extend({}, b);
            e.fontColor = e.labelOutlineColor;
            e.fontStrokeColor = e.labelOutlineColor;
            e.fontStrokeWidth = b.labelOutlineWidth;
            delete e.labelOutlineWidth;
            this.drawText(a, e, c)
        }
        var f = this.getResolution(), e = (c.x - this.featureDx) / f + this.left, g = c.y / f - this.top, d = d ? this.LABEL_OUTLINE_SUFFIX : this.LABEL_ID_SUFFIX,
            f = this.nodeFactory(a + d, "text");
        f.setAttributeNS(null, "x", e);
        f.setAttributeNS(null, "y", -g);
        b.fontColor && f.setAttributeNS(null, "fill", b.fontColor);
        b.fontStrokeColor && f.setAttributeNS(null, "stroke", b.fontStrokeColor);
        b.fontStrokeWidth && f.setAttributeNS(null, "stroke-width", b.fontStrokeWidth);
        b.fontOpacity && f.setAttributeNS(null, "opacity", b.fontOpacity);
        b.fontFamily && f.setAttributeNS(null, "font-family", b.fontFamily);
        b.fontSize && f.setAttributeNS(null, "font-size", b.fontSize);
        b.fontWeight && f.setAttributeNS(null,
            "font-weight", b.fontWeight);
        b.fontStyle && f.setAttributeNS(null, "font-style", b.fontStyle);
        !0 === b.labelSelect ? (f.setAttributeNS(null, "pointer-events", "visible"), f._featureId = a) : f.setAttributeNS(null, "pointer-events", "none");
        g = b.labelAlign || OpenLayers.Renderer.defaultSymbolizer.labelAlign;
        f.setAttributeNS(null, "text-anchor", OpenLayers.Renderer.SVG.LABEL_ALIGN[g[0]] || "middle");
        !0 === OpenLayers.IS_GECKO && f.setAttributeNS(null, "dominant-baseline", OpenLayers.Renderer.SVG.LABEL_ALIGN[g[1]] || "central");
        for (var h =
            b.label.split("\n"), k = h.length; f.childNodes.length > k;)f.removeChild(f.lastChild);
        for (var l = 0; l < k; l++) {
            var m = this.nodeFactory(a + d + "_tspan_" + l, "tspan");
            !0 === b.labelSelect && (m._featureId = a, m._geometry = c, m._geometryClass = c.CLASS_NAME);
            !1 === OpenLayers.IS_GECKO && m.setAttributeNS(null, "baseline-shift", OpenLayers.Renderer.SVG.LABEL_VSHIFT[g[1]] || "-35%");
            m.setAttribute("x", e);
            if (0 == l) {
                var n = OpenLayers.Renderer.SVG.LABEL_VFACTOR[g[1]];
                null == n && (n = -0.5);
                m.setAttribute("dy", n * (k - 1) + "em")
            } else m.setAttribute("dy",
                "1em");
            m.textContent = "" === h[l] ? " " : h[l];
            m.parentNode || f.appendChild(m)
        }
        f.parentNode || this.textRoot.appendChild(f)
    },
    getComponentsString: function (a, b) {
        for (var c = [], d = !0, e = a.length, f = [], g, h = 0; h < e; h++)g = a[h], c.push(g), (g = this.getShortString(g)) ? f.push(g) : (0 < h && this.getShortString(a[h - 1]) && f.push(this.clipLine(a[h], a[h - 1])), h < e - 1 && this.getShortString(a[h + 1]) && f.push(this.clipLine(a[h], a[h + 1])), d = !1);
        return {path: f.join(b || ","), complete: d}
    },
    clipLine: function (a, b) {
        if (b.equals(a))return "";
        var c = this.getResolution(),
            d = this.MAX_PIXEL - this.translationParameters.x, e = this.MAX_PIXEL - this.translationParameters.y, f = (b.x - this.featureDx) / c + this.left, g = this.top - b.y / c, h = (a.x - this.featureDx) / c + this.left, c = this.top - a.y / c, k;
        if (h < -d || h > d)k = (c - g) / (h - f), h = 0 > h ? -d : d, c = g + (h - f) * k;
        if (c < -e || c > e)k = (h - f) / (c - g), c = 0 > c ? -e : e, h = f + (c - g) * k;
        return h + "," + c
    },
    getShortString: function (a) {
        var b = this.getResolution(), c = (a.x - this.featureDx) / b + this.left, a = this.top - a.y / b;
        return this.inValidRange(c, a) ? c + "," + a : !1
    },
    getPosition: function (a) {
        return {
            x: parseFloat(a.getAttributeNS(null,
                "cx")), y: parseFloat(a.getAttributeNS(null, "cy"))
        }
    },
    importSymbol: function (a) {
        this.defs || (this.defs = this.createDefs());
        var b = this.container.id + "-" + a, c = document.getElementById(b);
        if (null != c)return c;
        var d = OpenLayers.Renderer.symbol[a];
        if (!d)throw Error(a + " is not a valid symbol name");
        var a = this.nodeFactory(b, "symbol"), e = this.nodeFactory(null, "polygon");
        a.appendChild(e);
        for (var c = new OpenLayers.Bounds(Number.MAX_VALUE, Number.MAX_VALUE, 0, 0), f = [], g, h, k = 0; k < d.length; k += 2)g = d[k], h = d[k + 1], c.left = Math.min(c.left,
            g), c.bottom = Math.min(c.bottom, h), c.right = Math.max(c.right, g), c.top = Math.max(c.top, h), f.push(g, ",", h);
        e.setAttributeNS(null, "points", f.join(" "));
        d = c.getWidth();
        e = c.getHeight();
        a.setAttributeNS(null, "viewBox", [c.left - d, c.bottom - e, 3 * d, 3 * e].join(" "));
        this.symbolMetrics[b] = [Math.max(d, e), c.getCenterLonLat().lon, c.getCenterLonLat().lat];
        this.defs.appendChild(a);
        return a
    },
    getFeatureIdFromEvent: function (a) {
        var b = OpenLayers.Renderer.Elements.prototype.getFeatureIdFromEvent.apply(this, arguments);
        b || (b = a.target,
            b = b.parentNode && b != this.rendererRoot ? b.parentNode._featureId : void 0);
        return b
    },
    CLASS_NAME: "OpenLayers.Renderer.SVG"
});
OpenLayers.Renderer.SVG.LABEL_ALIGN = {l: "start", r: "end", b: "bottom", t: "hanging"};
OpenLayers.Renderer.SVG.LABEL_VSHIFT = {t: "-70%", b: "0"};
OpenLayers.Renderer.SVG.LABEL_VFACTOR = {t: 0, b: -1};
OpenLayers.Renderer.SVG.preventDefault = function (a) {
    a.preventDefault && a.preventDefault()
};
OpenLayers.Renderer.Canvas = OpenLayers.Class(OpenLayers.Renderer, {
    hitDetection: !0,
    hitOverflow: 0,
    canvas: null,
    features: null,
    pendingRedraw: !1,
    cachedSymbolBounds: {},
    initialize: function (a, b) {
        OpenLayers.Renderer.prototype.initialize.apply(this, arguments);
        this.root = document.createElement("canvas");
        this.container.appendChild(this.root);
        this.canvas = this.root.getContext("2d");
        this.features = {};
        this.hitDetection && (this.hitCanvas = document.createElement("canvas"), this.hitContext = this.hitCanvas.getContext("2d"))
    },
    setExtent: function () {
        OpenLayers.Renderer.prototype.setExtent.apply(this, arguments);
        return !1
    },
    eraseGeometry: function (a, b) {
        this.eraseFeatures(this.features[b][0])
    },
    supported: function () {
        return OpenLayers.CANVAS_SUPPORTED
    },
    setSize: function (a) {
        this.size = a.clone();
        var b = this.root;
        b.style.width = a.w + "px";
        b.style.height = a.h + "px";
        b.width = a.w;
        b.height = a.h;
        this.resolution = null;
        this.hitDetection && (b = this.hitCanvas, b.style.width = a.w + "px", b.style.height = a.h + "px", b.width = a.w, b.height = a.h)
    },
    drawFeature: function (a,
                           b) {
        var c;
        if (a.geometry) {
            b = this.applyDefaultSymbolizer(b || a.style);
            c = a.geometry.getBounds();
            var d;
            this.map.baseLayer && this.map.baseLayer.wrapDateLine && (d = this.map.getMaxExtent());
            d = c && c.intersectsBounds(this.extent, {worldBounds: d});
            (c = "none" !== b.display && !!c && d) ? this.features[a.id] = [a, b] : delete this.features[a.id];
            this.pendingRedraw = !0
        }
        this.pendingRedraw && !this.locked && (this.redraw(), this.pendingRedraw = !1);
        return c
    },
    drawGeometry: function (a, b, c) {
        var d = a.CLASS_NAME;
        if ("OpenLayers.Geometry.Collection" ==
            d || "OpenLayers.Geometry.MultiPoint" == d || "OpenLayers.Geometry.MultiLineString" == d || "OpenLayers.Geometry.MultiPolygon" == d)for (d = 0; d < a.components.length; d++)this.drawGeometry(a.components[d], b, c); else switch (a.CLASS_NAME) {
            case "OpenLayers.Geometry.Point":
                this.drawPoint(a, b, c);
                break;
            case "OpenLayers.Geometry.LineString":
                this.drawLineString(a, b, c);
                break;
            case "OpenLayers.Geometry.LinearRing":
                this.drawLinearRing(a, b, c);
                break;
            case "OpenLayers.Geometry.Polygon":
                this.drawPolygon(a, b, c)
        }
    },
    drawExternalGraphic: function (a,
                                   b, c) {
        var d = new Image;
        b.graphicTitle && (d.title = b.graphicTitle);
        var e = b.graphicWidth || b.graphicHeight, f = b.graphicHeight || b.graphicWidth, e = e ? e : 2 * b.pointRadius, f = f ? f : 2 * b.pointRadius, g = void 0 != b.graphicXOffset ? b.graphicXOffset : -(0.5 * e), h = void 0 != b.graphicYOffset ? b.graphicYOffset : -(0.5 * f), k = b.graphicOpacity || b.fillOpacity;
        d.onload = OpenLayers.Function.bind(function () {
            if (this.features[c]) {
                var b = this.getLocalXY(a), m = b[0], b = b[1];
                if (!isNaN(m) && !isNaN(b)) {
                    var m = m + g | 0, b = b + h | 0, n = this.canvas;
                    n.globalAlpha = k;
                    var o =
                        OpenLayers.Renderer.Canvas.drawImageScaleFactor || (OpenLayers.Renderer.Canvas.drawImageScaleFactor = /android 2.1/.test(navigator.userAgent.toLowerCase()) ? 320 / window.screen.width : 1);
                    n.drawImage(d, m * o, b * o, e * o, f * o);
                    this.hitDetection && (this.setHitContextStyle("fill", c), this.hitContext.fillRect(m, b, e, f))
                }
            }
        }, this);
        d.src = b.externalGraphic
    },
    drawNamedSymbol: function (a, b, c) {
        var d, e, f, g;
        f = Math.PI / 180;
        var h = OpenLayers.Renderer.symbol[b.graphicName];
        if (!h)throw Error(b.graphicName + " is not a valid symbol name");
        if (h.length && !(2 > h.length) && (a = this.getLocalXY(a), e = a[0], g = a[1], !isNaN(e) && !isNaN(g))) {
            this.canvas.lineCap = "round";
            this.canvas.lineJoin = "round";
            this.hitDetection && (this.hitContext.lineCap = "round", this.hitContext.lineJoin = "round");
            if (b.graphicName in this.cachedSymbolBounds)d = this.cachedSymbolBounds[b.graphicName]; else {
                d = new OpenLayers.Bounds;
                for (a = 0; a < h.length; a += 2)d.extend(new OpenLayers.LonLat(h[a], h[a + 1]));
                this.cachedSymbolBounds[b.graphicName] = d
            }
            this.canvas.save();
            this.hitDetection && this.hitContext.save();
            this.canvas.translate(e, g);
            this.hitDetection && this.hitContext.translate(e, g);
            a = f * b.rotation;
            isNaN(a) || (this.canvas.rotate(a), this.hitDetection && this.hitContext.rotate(a));
            f = 2 * b.pointRadius / Math.max(d.getWidth(), d.getHeight());
            this.canvas.scale(f, f);
            this.hitDetection && this.hitContext.scale(f, f);
            a = d.getCenterLonLat().lon;
            d = d.getCenterLonLat().lat;
            this.canvas.translate(-a, -d);
            this.hitDetection && this.hitContext.translate(-a, -d);
            g = b.strokeWidth;
            b.strokeWidth = g / f;
            if (!1 !== b.fill) {
                this.setCanvasStyle("fill",
                    b);
                this.canvas.beginPath();
                for (a = 0; a < h.length; a += 2)d = h[a], e = h[a + 1], 0 == a && this.canvas.moveTo(d, e), this.canvas.lineTo(d, e);
                this.canvas.closePath();
                this.canvas.fill();
                if (this.hitDetection) {
                    this.setHitContextStyle("fill", c, b);
                    this.hitContext.beginPath();
                    for (a = 0; a < h.length; a += 2)d = h[a], e = h[a + 1], 0 == a && this.canvas.moveTo(d, e), this.hitContext.lineTo(d, e);
                    this.hitContext.closePath();
                    this.hitContext.fill()
                }
            }
            if (!1 !== b.stroke) {
                this.setCanvasStyle("stroke", b);
                this.canvas.beginPath();
                for (a = 0; a < h.length; a += 2)d = h[a],
                    e = h[a + 1], 0 == a && this.canvas.moveTo(d, e), this.canvas.lineTo(d, e);
                this.canvas.closePath();
                this.canvas.stroke();
                if (this.hitDetection) {
                    this.setHitContextStyle("stroke", c, b, f);
                    this.hitContext.beginPath();
                    for (a = 0; a < h.length; a += 2)d = h[a], e = h[a + 1], 0 == a && this.hitContext.moveTo(d, e), this.hitContext.lineTo(d, e);
                    this.hitContext.closePath();
                    this.hitContext.stroke()
                }
            }
            b.strokeWidth = g;
            this.canvas.restore();
            this.hitDetection && this.hitContext.restore();
            this.setCanvasStyle("reset")
        }
    },
    setCanvasStyle: function (a, b) {
        "fill" ===
        a ? (this.canvas.globalAlpha = b.fillOpacity, this.canvas.fillStyle = b.fillColor) : "stroke" === a ? (this.canvas.globalAlpha = b.strokeOpacity, this.canvas.strokeStyle = b.strokeColor, this.canvas.lineWidth = b.strokeWidth) : (this.canvas.globalAlpha = 0, this.canvas.lineWidth = 1)
    },
    featureIdToHex: function (a) {
        a = Number(a.split("_").pop()) + 1;
        16777216 <= a && (this.hitOverflow = a - 16777215, a = a % 16777216 + 1);
        var a = "000000" + a.toString(16), b = a.length;
        return "#" + a.substring(b - 6, b)
    },
    setHitContextStyle: function (a, b, c, d) {
        b = this.featureIdToHex(b);
        "fill" == a ? (this.hitContext.globalAlpha = 1, this.hitContext.fillStyle = b) : "stroke" == a ? (this.hitContext.globalAlpha = 1, this.hitContext.strokeStyle = b, "undefined" === typeof d ? this.hitContext.lineWidth = c.strokeWidth + 2 : isNaN(d) || (this.hitContext.lineWidth = c.strokeWidth + 2 / d)) : (this.hitContext.globalAlpha = 0, this.hitContext.lineWidth = 1)
    },
    drawPoint: function (a, b, c) {
        if (!1 !== b.graphic)if (b.externalGraphic)this.drawExternalGraphic(a, b, c); else if (b.graphicName && "circle" != b.graphicName)this.drawNamedSymbol(a, b, c); else {
            var d =
                this.getLocalXY(a), a = d[0], d = d[1];
            if (!isNaN(a) && !isNaN(d)) {
                var e = 2 * Math.PI, f = b.pointRadius;
                !1 !== b.fill && (this.setCanvasStyle("fill", b), this.canvas.beginPath(), this.canvas.arc(a, d, f, 0, e, !0), this.canvas.fill(), this.hitDetection && (this.setHitContextStyle("fill", c, b), this.hitContext.beginPath(), this.hitContext.arc(a, d, f, 0, e, !0), this.hitContext.fill()));
                !1 !== b.stroke && (this.setCanvasStyle("stroke", b), this.canvas.beginPath(), this.canvas.arc(a, d, f, 0, e, !0), this.canvas.stroke(), this.hitDetection && (this.setHitContextStyle("stroke",
                    c, b), this.hitContext.beginPath(), this.hitContext.arc(a, d, f, 0, e, !0), this.hitContext.stroke()), this.setCanvasStyle("reset"))
            }
        }
    },
    drawLineString: function (a, b, c) {
        b = OpenLayers.Util.applyDefaults({fill: !1}, b);
        this.drawLinearRing(a, b, c)
    },
    drawLinearRing: function (a, b, c) {
        !1 !== b.fill && (this.setCanvasStyle("fill", b), this.renderPath(this.canvas, a, b, c, "fill"), this.hitDetection && (this.setHitContextStyle("fill", c, b), this.renderPath(this.hitContext, a, b, c, "fill")));
        !1 !== b.stroke && (this.setCanvasStyle("stroke", b), this.renderPath(this.canvas,
            a, b, c, "stroke"), this.hitDetection && (this.setHitContextStyle("stroke", c, b), this.renderPath(this.hitContext, a, b, c, "stroke")));
        this.setCanvasStyle("reset")
    },
    renderPath: function (a, b, c, d, e) {
        b = b.components;
        c = b.length;
        a.beginPath();
        var d = this.getLocalXY(b[0]), f = d[1];
        if (!isNaN(d[0]) && !isNaN(f)) {
            a.moveTo(d[0], d[1]);
            for (d = 1; d < c; ++d)f = this.getLocalXY(b[d]), a.lineTo(f[0], f[1]);
            "fill" === e ? a.fill() : a.stroke()
        }
    },
    drawPolygon: function (a, b, c) {
        var a = a.components, d = a.length;
        this.drawLinearRing(a[0], b, c);
        for (var e = 1; e <
        d; ++e)this.canvas.globalCompositeOperation = "destination-out", this.hitDetection && (this.hitContext.globalCompositeOperation = "destination-out"), this.drawLinearRing(a[e], OpenLayers.Util.applyDefaults({
            stroke: !1,
            fillOpacity: 1
        }, b), c), this.canvas.globalCompositeOperation = "source-over", this.hitDetection && (this.hitContext.globalCompositeOperation = "source-over"), this.drawLinearRing(a[e], OpenLayers.Util.applyDefaults({fill: !1}, b), c)
    },
    drawText: function (a, b) {
        var c = this.getLocalXY(a);
        this.setCanvasStyle("reset");
        this.canvas.fillStyle = b.fontColor;
        this.canvas.globalAlpha = b.fontOpacity || 1;
        var d = [b.fontStyle ? b.fontStyle : "normal", "normal", b.fontWeight ? b.fontWeight : "normal", b.fontSize ? b.fontSize : "1em", b.fontFamily ? b.fontFamily : "sans-serif"].join(" "), e = b.label.split("\n"), f = e.length;
        if (this.canvas.fillText) {
            this.canvas.font = d;
            this.canvas.textAlign = OpenLayers.Renderer.Canvas.LABEL_ALIGN[b.labelAlign[0]] || "center";
            this.canvas.textBaseline = OpenLayers.Renderer.Canvas.LABEL_ALIGN[b.labelAlign[1]] || "middle";
            var g = OpenLayers.Renderer.Canvas.LABEL_FACTOR[b.labelAlign[1]];
            null == g && (g = -0.5);
            d = this.canvas.measureText("Mg").height || this.canvas.measureText("xx").width;
            c[1] += d * g * (f - 1);
            for (g = 0; g < f; g++)b.labelOutlineWidth && (this.canvas.save(), this.canvas.strokeStyle = b.labelOutlineColor, this.canvas.lineWidth = b.labelOutlineWidth, this.canvas.strokeText(e[g], c[0], c[1] + d * g + 1), this.canvas.restore()), this.canvas.fillText(e[g], c[0], c[1] + d * g)
        } else if (this.canvas.mozDrawText) {
            this.canvas.mozTextStyle = d;
            var h = OpenLayers.Renderer.Canvas.LABEL_FACTOR[b.labelAlign[0]];
            null == h && (h = -0.5);
            g = OpenLayers.Renderer.Canvas.LABEL_FACTOR[b.labelAlign[1]];
            null == g && (g = -0.5);
            d = this.canvas.mozMeasureText("xx");
            c[1] += d * (1 + g * f);
            for (g = 0; g < f; g++) {
                var k = c[0] + h * this.canvas.mozMeasureText(e[g]), l = c[1] + g * d;
                this.canvas.translate(k, l);
                this.canvas.mozDrawText(e[g]);
                this.canvas.translate(-k, -l)
            }
        }
        this.setCanvasStyle("reset")
    },
    getLocalXY: function (a) {
        var b = this.getResolution(), c = this.extent;
        return [(a.x - this.featureDx) / b + -c.left / b, c.top / b - a.y / b]
    },
    clear: function () {
        var a = this.root.height, b = this.root.width;
        this.canvas.clearRect(0,
            0, b, a);
        this.features = {};
        this.hitDetection && this.hitContext.clearRect(0, 0, b, a)
    },
    getFeatureIdFromEvent: function (a) {
        var b;
        if (this.hitDetection && "none" !== this.root.style.display && !this.map.dragging && (a = a.xy, a = this.hitContext.getImageData(a.x | 0, a.y | 0, 1, 1).data, 255 === a[3] && (a = a[2] + 256 * (a[1] + 256 * a[0])))) {
            a = "OpenLayers.Feature.Vector_" + (a - 1 + this.hitOverflow);
            try {
                b = this.features[a][0]
            } catch (c) {
            }
        }
        return b
    },
    eraseFeatures: function (a) {
        OpenLayers.Util.isArray(a) || (a = [a]);
        for (var b = 0; b < a.length; ++b)delete this.features[a[b].id];
        this.redraw()
    },
    redraw: function () {
        if (!this.locked) {
            var a = this.root.height, b = this.root.width;
            this.canvas.clearRect(0, 0, b, a);
            this.hitDetection && this.hitContext.clearRect(0, 0, b, a);
            var a = [], c, d, e = this.map.baseLayer && this.map.baseLayer.wrapDateLine && this.map.getMaxExtent(), f;
            for (f in this.features)this.features.hasOwnProperty(f) && (b = this.features[f][0], c = b.geometry, this.calculateFeatureDx(c.getBounds(), e), d = this.features[f][1], this.drawGeometry(c, d, b.id), d.label && a.push([b, d]));
            b = 0;
            for (c = a.length; b < c; ++b)f =
                a[b], this.drawText(f[0].geometry.getCentroid(), f[1])
        }
    },
    CLASS_NAME: "OpenLayers.Renderer.Canvas"
});
OpenLayers.Renderer.Canvas.LABEL_ALIGN = {l: "left", r: "right", t: "top", b: "bottom"};
OpenLayers.Renderer.Canvas.LABEL_FACTOR = {l: 0, r: -1, t: 0, b: -1};
OpenLayers.Renderer.Canvas.drawImageScaleFactor = null;
OpenLayers.Renderer.VML = OpenLayers.Class(OpenLayers.Renderer.Elements, {
    xmlns: "urn:schemas-microsoft-com:vml", symbolCache: {}, offset: null, initialize: function (a) {
        if (this.supported()) {
            if (!document.namespaces.olv) {
                document.namespaces.add("olv", this.xmlns);
                for (var b = document.createStyleSheet(), c = "shape,rect,oval,fill,stroke,imagedata,group,textbox".split(","), d = 0, e = c.length; d < e; d++)b.addRule("olv\\:" + c[d], "behavior: url(#default#VML); position: absolute; display: inline-block;")
            }
            OpenLayers.Renderer.Elements.prototype.initialize.apply(this,
                arguments)
        }
    }, supported: function () {
        return !!document.namespaces
    }, setExtent: function (a, b) {
        var c = OpenLayers.Renderer.Elements.prototype.setExtent.apply(this, arguments), d = this.getResolution(), e = a.left / d | 0, d = a.top / d - this.size.h | 0;
        b || !this.offset ? (this.offset = {x: e, y: d}, d = e = 0) : (e -= this.offset.x, d -= this.offset.y);
        this.root.coordorigin = e - this.xOffset + " " + d;
        for (var e = [this.root, this.vectorRoot, this.textRoot], f = 0, g = e.length; f < g; ++f)d = e[f], d.coordsize = this.size.w + " " + this.size.h;
        this.root.style.flip = "y";
        return c
    },
    setSize: function (a) {
        OpenLayers.Renderer.prototype.setSize.apply(this, arguments);
        for (var b = [this.rendererRoot, this.root, this.vectorRoot, this.textRoot], c = this.size.w + "px", d = this.size.h + "px", e, f = 0, g = b.length; f < g; ++f)e = b[f], e.style.width = c, e.style.height = d
    }, getNodeType: function (a, b) {
        var c = null;
        switch (a.CLASS_NAME) {
            case "OpenLayers.Geometry.Point":
                c = b.externalGraphic ? "olv:rect" : this.isComplexSymbol(b.graphicName) ? "olv:shape" : "olv:oval";
                break;
            case "OpenLayers.Geometry.Rectangle":
                c = "olv:rect";
                break;
            case "OpenLayers.Geometry.LineString":
            case "OpenLayers.Geometry.LinearRing":
            case "OpenLayers.Geometry.Polygon":
            case "OpenLayers.Geometry.Curve":
                c =
                    "olv:shape"
        }
        return c
    }, setStyle: function (a, b, c, d) {
        var b = b || a._style, c = c || a._options, e = b.fillColor;
        if ("OpenLayers.Geometry.Point" === a._geometryClass)if (b.externalGraphic) {
            c.isFilled = !0;
            b.graphicTitle && (a.title = b.graphicTitle);
            var e = b.graphicWidth || b.graphicHeight, f = b.graphicHeight || b.graphicWidth, e = e ? e : 2 * b.pointRadius, f = f ? f : 2 * b.pointRadius, g = this.getResolution(), h = void 0 != b.graphicXOffset ? b.graphicXOffset : -(0.5 * e), k = void 0 != b.graphicYOffset ? b.graphicYOffset : -(0.5 * f);
            a.style.left = ((d.x - this.featureDx) /
            g - this.offset.x + h | 0) + "px";
            a.style.top = (d.y / g - this.offset.y - (k + f) | 0) + "px";
            a.style.width = e + "px";
            a.style.height = f + "px";
            a.style.flip = "y";
            e = "none";
            c.isStroked = !1
        } else this.isComplexSymbol(b.graphicName) ? (f = this.importSymbol(b.graphicName), a.path = f.path, a.coordorigin = f.left + "," + f.bottom, f = f.size, a.coordsize = f + "," + f, this.drawCircle(a, d, b.pointRadius), a.style.flip = "y") : this.drawCircle(a, d, b.pointRadius);
        c.isFilled ? a.fillcolor = e : a.filled = "false";
        d = a.getElementsByTagName("fill");
        d = 0 == d.length ? null : d[0];
        if (c.isFilled) {
            d ||
            (d = this.createNode("olv:fill", a.id + "_fill"));
            d.opacity = b.fillOpacity;
            if ("OpenLayers.Geometry.Point" === a._geometryClass && b.externalGraphic && (b.graphicOpacity && (d.opacity = b.graphicOpacity), d.src = b.externalGraphic, d.type = "frame", !b.graphicWidth || !b.graphicHeight))d.aspect = "atmost";
            d.parentNode != a && a.appendChild(d)
        } else d && a.removeChild(d);
        e = b.rotation;
        if (void 0 !== e || void 0 !== a._rotation)a._rotation = e, b.externalGraphic ? (this.graphicRotate(a, h, k, b), d.opacity = 0) : "OpenLayers.Geometry.Point" === a._geometryClass &&
        (a.style.rotation = e || 0);
        h = a.getElementsByTagName("stroke");
        h = 0 == h.length ? null : h[0];
        c.isStroked ? (h || (h = this.createNode("olv:stroke", a.id + "_stroke"), a.appendChild(h)), h.on = !0, h.color = b.strokeColor, h.weight = b.strokeWidth + "px", h.opacity = b.strokeOpacity, h.endcap = "butt" == b.strokeLinecap ? "flat" : b.strokeLinecap || "round", b.strokeDashstyle && (h.dashstyle = this.dashStyle(b))) : (a.stroked = !1, h && (h.on = !1));
        "inherit" != b.cursor && null != b.cursor && (a.style.cursor = b.cursor);
        return a
    }, graphicRotate: function (a, b, c, d) {
        var d =
            d || a._style, e = d.rotation || 0, f, g;
        if (!d.graphicWidth || !d.graphicHeight) {
            var h = new Image;
            h.onreadystatechange = OpenLayers.Function.bind(function () {
                if ("complete" == h.readyState || "interactive" == h.readyState)f = h.width / h.height, g = Math.max(2 * d.pointRadius, d.graphicWidth || 0, d.graphicHeight || 0), b *= f, d.graphicWidth = g * f, d.graphicHeight = g, this.graphicRotate(a, b, c, d)
            }, this);
            h.src = d.externalGraphic
        } else {
            g = Math.max(d.graphicWidth, d.graphicHeight);
            f = d.graphicWidth / d.graphicHeight;
            var k = Math.round(d.graphicWidth || g *
            f), l = Math.round(d.graphicHeight || g);
            a.style.width = k + "px";
            a.style.height = l + "px";
            var m = document.getElementById(a.id + "_image");
            m || (m = this.createNode("olv:imagedata", a.id + "_image"), a.appendChild(m));
            m.style.width = k + "px";
            m.style.height = l + "px";
            m.src = d.externalGraphic;
            m.style.filter = "progid:DXImageTransform.Microsoft.AlphaImageLoader(src='', sizingMethod='scale')";
            m = e * Math.PI / 180;
            e = Math.sin(m);
            m = Math.cos(m);
            e = "progid:DXImageTransform.Microsoft.Matrix(M11=" + m + ",M12=" + -e + ",M21=" + e + ",M22=" + m + ",SizingMethod='auto expand')\n";
            (m = d.graphicOpacity || d.fillOpacity) && 1 != m && (e += "progid:DXImageTransform.Microsoft.BasicImage(opacity=" + m + ")\n");
            a.style.filter = e;
            e = new OpenLayers.Geometry.Point(-b, -c);
            k = (new OpenLayers.Bounds(0, 0, k, l)).toGeometry();
            k.rotate(d.rotation, e);
            k = k.getBounds();
            a.style.left = Math.round(parseInt(a.style.left) + k.left) + "px";
            a.style.top = Math.round(parseInt(a.style.top) - k.bottom) + "px"
        }
    }, postDraw: function (a) {
        a.style.visibility = "visible";
        var b = a._style.fillColor, c = a._style.strokeColor;
        "none" == b && a.fillcolor != b &&
        (a.fillcolor = b);
        "none" == c && a.strokecolor != c && (a.strokecolor = c)
    }, setNodeDimension: function (a, b) {
        var c = b.getBounds();
        if (c) {
            var d = this.getResolution(), c = new OpenLayers.Bounds((c.left - this.featureDx) / d - this.offset.x | 0, c.bottom / d - this.offset.y | 0, (c.right - this.featureDx) / d - this.offset.x | 0, c.top / d - this.offset.y | 0);
            a.style.left = c.left + "px";
            a.style.top = c.top + "px";
            a.style.width = c.getWidth() + "px";
            a.style.height = c.getHeight() + "px";
            a.coordorigin = c.left + " " + c.top;
            a.coordsize = c.getWidth() + " " + c.getHeight()
        }
    }, dashStyle: function (a) {
        a =
            a.strokeDashstyle;
        switch (a) {
            case "solid":
            case "dot":
            case "dash":
            case "dashdot":
            case "longdash":
            case "longdashdot":
                return a;
            default:
                return a = a.split(/[ ,]/), 2 == a.length ? 1 * a[0] >= 2 * a[1] ? "longdash" : 1 == a[0] || 1 == a[1] ? "dot" : "dash" : 4 == a.length ? 1 * a[0] >= 2 * a[1] ? "longdashdot" : "dashdot" : "solid"
        }
    }, createNode: function (a, b) {
        var c = document.createElement(a);
        b && (c.id = b);
        c.unselectable = "on";
        c.onselectstart = OpenLayers.Function.False;
        return c
    }, nodeTypeCompare: function (a, b) {
        var c = b, d = c.indexOf(":");
        -1 != d && (c = c.substr(d +
        1));
        var e = a.nodeName, d = e.indexOf(":");
        -1 != d && (e = e.substr(d + 1));
        return c == e
    }, createRenderRoot: function () {
        return this.nodeFactory(this.container.id + "_vmlRoot", "div")
    }, createRoot: function (a) {
        return this.nodeFactory(this.container.id + a, "olv:group")
    }, drawPoint: function (a, b) {
        return this.drawCircle(a, b, 1)
    }, drawCircle: function (a, b, c) {
        if (!isNaN(b.x) && !isNaN(b.y)) {
            var d = this.getResolution();
            a.style.left = ((b.x - this.featureDx) / d - this.offset.x | 0) - c + "px";
            a.style.top = (b.y / d - this.offset.y | 0) - c + "px";
            b = 2 * c;
            a.style.width =
                b + "px";
            a.style.height = b + "px";
            return a
        }
        return !1
    }, drawLineString: function (a, b) {
        return this.drawLine(a, b, !1)
    }, drawLinearRing: function (a, b) {
        return this.drawLine(a, b, !0)
    }, drawLine: function (a, b, c) {
        this.setNodeDimension(a, b);
        for (var d = this.getResolution(), e = b.components.length, f = Array(e), g, h, k = 0; k < e; k++)g = b.components[k], h = (g.x - this.featureDx) / d - this.offset.x | 0, g = g.y / d - this.offset.y | 0, f[k] = " " + h + "," + g + " l ";
        a.path = "m" + f.join("") + (c ? " x e" : " e");
        return a
    }, drawPolygon: function (a, b) {
        this.setNodeDimension(a,
            b);
        var c = this.getResolution(), d = [], e, f, g, h, k, l, m, n, o, p;
        for (e = 0, f = b.components.length; e < f; e++) {
            d.push("m");
            g = b.components[e].components;
            h = 0 === e;
            l = k = null;
            for (m = 0, n = g.length; m < n; m++)o = g[m], p = (o.x - this.featureDx) / c - this.offset.x | 0, o = o.y / c - this.offset.y | 0, p = " " + p + "," + o, d.push(p), 0 == m && d.push(" l"), h || (k ? k != p && (l ? l != p && (h = !0) : l = p) : k = p);
            d.push(h ? " x " : " ")
        }
        d.push("e");
        a.path = d.join("");
        return a
    }, drawRectangle: function (a, b) {
        var c = this.getResolution();
        a.style.left = ((b.x - this.featureDx) / c - this.offset.x | 0) +
        "px";
        a.style.top = (b.y / c - this.offset.y | 0) + "px";
        a.style.width = (b.width / c | 0) + "px";
        a.style.height = (b.height / c | 0) + "px";
        return a
    }, drawText: function (a, b, c) {
        var d = this.nodeFactory(a + this.LABEL_ID_SUFFIX, "olv:rect"), e = this.nodeFactory(a + this.LABEL_ID_SUFFIX + "_textbox", "olv:textbox"), f = this.getResolution();
        d.style.left = ((c.x - this.featureDx) / f - this.offset.x | 0) + "px";
        d.style.top = (c.y / f - this.offset.y | 0) + "px";
        d.style.flip = "y";
        e.innerText = b.label;
        "inherit" != b.cursor && null != b.cursor && (e.style.cursor = b.cursor);
        b.fontColor &&
        (e.style.color = b.fontColor);
        b.fontOpacity && (e.style.filter = "alpha(opacity=" + 100 * b.fontOpacity + ")");
        b.fontFamily && (e.style.fontFamily = b.fontFamily);
        b.fontSize && (e.style.fontSize = b.fontSize);
        b.fontWeight && (e.style.fontWeight = b.fontWeight);
        b.fontStyle && (e.style.fontStyle = b.fontStyle);
        !0 === b.labelSelect && (d._featureId = a, e._featureId = a, e._geometry = c, e._geometryClass = c.CLASS_NAME);
        e.style.whiteSpace = "nowrap";
        e.inset = "1px,0px,0px,0px";
        d.parentNode || (d.appendChild(e), this.textRoot.appendChild(d));
        b = b.labelAlign ||
        "cm";
        1 == b.length && (b += "m");
        a = e.clientWidth * OpenLayers.Renderer.VML.LABEL_SHIFT[b.substr(0, 1)];
        e = e.clientHeight * OpenLayers.Renderer.VML.LABEL_SHIFT[b.substr(1, 1)];
        d.style.left = parseInt(d.style.left) - a - 1 + "px";
        d.style.top = parseInt(d.style.top) + e + "px"
    }, moveRoot: function (a) {
        var b = this.map.getLayer(a.container.id);
        b instanceof OpenLayers.Layer.Vector.RootContainer && (b = this.map.getLayer(this.container.id));
        b && b.renderer.clear();
        OpenLayers.Renderer.Elements.prototype.moveRoot.apply(this, arguments);
        b && b.redraw()
    },
    importSymbol: function (a) {
        var b = this.container.id + "-" + a, c = this.symbolCache[b];
        if (c)return c;
        c = OpenLayers.Renderer.symbol[a];
        if (!c)throw Error(a + " is not a valid symbol name");
        for (var a = new OpenLayers.Bounds(Number.MAX_VALUE, Number.MAX_VALUE, 0, 0), d = ["m"], e = 0; e < c.length; e += 2) {
            var f = c[e], g = c[e + 1];
            a.left = Math.min(a.left, f);
            a.bottom = Math.min(a.bottom, g);
            a.right = Math.max(a.right, f);
            a.top = Math.max(a.top, g);
            d.push(f);
            d.push(g);
            0 == e && d.push("l")
        }
        d.push("x e");
        c = d.join(" ");
        d = (a.getWidth() - a.getHeight()) / 2;
        0 < d ? (a.bottom -= d, a.top += d) : (a.left += d, a.right -= d);
        c = {path: c, size: a.getWidth(), left: a.left, bottom: a.bottom};
        return this.symbolCache[b] = c
    }, CLASS_NAME: "OpenLayers.Renderer.VML"
});
OpenLayers.Renderer.VML.LABEL_SHIFT = {l: 0, c: 0.5, r: 1, t: 0, m: 0.5, b: 1};
OpenLayers.Layer.Vector = OpenLayers.Class(OpenLayers.Layer, {
    isBaseLayer: !1,
    isFixed: !1,
    features: null,
    filter: null,
    selectedFeatures: null,
    unrenderedFeatures: null,
    reportError: !0,
    style: null,
    styleMap: null,
    strategies: null,
    protocol: null,
    renderers: ["SVG", "VML", "Canvas"],
    renderer: null,
    rendererOptions: null,
    geometryType: null,
    drawn: !1,
    ratio: 1,
    initialize: function (a, b) {
        OpenLayers.Layer.prototype.initialize.apply(this, arguments);
        (!this.renderer || !this.renderer.supported()) && this.assignRenderer();
        if (!this.renderer || !this.renderer.supported())this.renderer = null, this.displayError();
        this.styleMap || (this.styleMap = new OpenLayers.StyleMap);
        this.features = [];
        this.selectedFeatures = [];
        this.unrenderedFeatures = {};
        if (this.strategies)for (var c = 0, d = this.strategies.length; c < d; c++)this.strategies[c].setLayer(this)
    },
    destroy: function () {
        if (this.strategies) {
            var a, b, c;
            for (b = 0, c = this.strategies.length; b < c; b++)a = this.strategies[b], a.autoDestroy && a.destroy();
            this.strategies = null
        }
        this.protocol && (this.protocol.autoDestroy && this.protocol.destroy(),
            this.protocol = null);
        this.destroyFeatures();
        this.unrenderedFeatures = this.selectedFeatures = this.features = null;
        this.renderer && this.renderer.destroy();
        this.drawn = this.geometryType = this.renderer = null;
        OpenLayers.Layer.prototype.destroy.apply(this, arguments)
    },
    clone: function (a) {
        null == a && (a = new OpenLayers.Layer.Vector(this.name, this.getOptions()));
        for (var a = OpenLayers.Layer.prototype.clone.apply(this, [a]), b = this.features, c = b.length, d = Array(c), e = 0; e < c; ++e)d[e] = b[e].clone();
        a.features = d;
        return a
    },
    refresh: function (a) {
        this.calculateInRange() &&
        this.visibility && this.events.triggerEvent("refresh", a)
    },
    assignRenderer: function () {
        for (var a = 0, b = this.renderers.length; a < b; a++) {
            var c = this.renderers[a];
            if ((c = "function" == typeof c ? c : OpenLayers.Renderer[c]) && c.prototype.supported()) {
                this.renderer = new c(this.div, this.rendererOptions);
                break
            }
        }
    },
    displayError: function () {
        this.reportError && OpenLayers.Console.userError(OpenLayers.i18n("browserNotSupported", {renderers: this.renderers.join("\n")}))
    },
    setMap: function (a) {
        OpenLayers.Layer.prototype.setMap.apply(this,
            arguments);
        if (this.renderer) {
            this.renderer.map = this.map;
            var b = this.map.getSize();
            b.w *= this.ratio;
            b.h *= this.ratio;
            this.renderer.setSize(b)
        } else this.map.removeLayer(this)
    },
    afterAdd: function () {
        if (this.strategies) {
            var a, b, c;
            for (b = 0, c = this.strategies.length; b < c; b++)a = this.strategies[b], a.autoActivate && a.activate()
        }
    },
    removeMap: function () {
        this.drawn = !1;
        if (this.strategies) {
            var a, b, c;
            for (b = 0, c = this.strategies.length; b < c; b++)a = this.strategies[b], a.autoActivate && a.deactivate()
        }
    },
    onMapResize: function () {
        OpenLayers.Layer.prototype.onMapResize.apply(this,
            arguments);
        var a = this.map.getSize();
        a.w *= this.ratio;
        a.h *= this.ratio;
        this.renderer.setSize(a)
    },
    moveTo: function (a, b, c) {
        OpenLayers.Layer.prototype.moveTo.apply(this, arguments);
        var d = !0;
        if (!c) {
            this.renderer.root.style.visibility = "hidden";
            var d = this.map.getSize(), e = d.w, d = d.h, e = e / 2 * this.ratio - e / 2, d = d / 2 * this.ratio - d / 2, e = e + parseInt(this.map.layerContainerDiv.style.left, 10), e = -Math.round(e), d = d + parseInt(this.map.layerContainerDiv.style.top, 10), d = -Math.round(d);
            this.div.style.left = e + "px";
            this.div.style.top =
                d + "px";
            d = this.renderer.setExtent(this.map.getExtent().scale(this.ratio), b);
            this.renderer.root.style.visibility = "visible";
            !0 === OpenLayers.IS_GECKO && (this.div.scrollLeft = this.div.scrollLeft);
            if (!b && d)for (var f in this.unrenderedFeatures)e = this.unrenderedFeatures[f], this.drawFeature(e)
        }
        if (!this.drawn || b || !d) {
            this.drawn = !0;
            f = 0;
            for (d = this.features.length; f < d; f++)this.renderer.locked = f !== d - 1, e = this.features[f], this.drawFeature(e)
        }
    },
    display: function (a) {
        OpenLayers.Layer.prototype.display.apply(this, arguments);
        var b = this.div.style.display;
        b != this.renderer.root.style.display && (this.renderer.root.style.display = b)
    },
    addFeatures: function (a, b) {
        OpenLayers.Util.isArray(a) || (a = [a]);
        var c = !b || !b.silent;
        if (c) {
            var d = {features: a};
            if (!1 === this.events.triggerEvent("beforefeaturesadded", d))return;
            a = d.features
        }
        for (var d = [], e = 0, f = a.length; e < f; e++) {
            this.renderer.locked = e != a.length - 1 ? !0 : !1;
            var g = a[e];
            if (this.geometryType && !(g.geometry instanceof this.geometryType))throw new TypeError("addFeatures: component should be an " +
            this.geometryType.prototype.CLASS_NAME);
            g.layer = this;
            !g.style && this.style && (g.style = OpenLayers.Util.extend({}, this.style));
            if (c) {
                if (!1 === this.events.triggerEvent("beforefeatureadded", {feature: g}))continue;
                this.preFeatureInsert(g)
            }
            d.push(g);
            this.features.push(g);
            this.drawFeature(g);
            c && (this.events.triggerEvent("featureadded", {feature: g}), this.onFeatureInsert(g))
        }
        c && this.events.triggerEvent("featuresadded", {features: d})
    },
    removeFeatures: function (a, b) {
        if (a && 0 !== a.length) {
            if (a === this.features)return this.removeAllFeatures(b);
            OpenLayers.Util.isArray(a) || (a = [a]);
            a === this.selectedFeatures && (a = a.slice());
            var c = !b || !b.silent;
            c && this.events.triggerEvent("beforefeaturesremoved", {features: a});
            for (var d = a.length - 1; 0 <= d; d--) {
                this.renderer.locked = 0 != d && a[d - 1].geometry ? !0 : !1;
                var e = a[d];
                delete this.unrenderedFeatures[e.id];
                c && this.events.triggerEvent("beforefeatureremoved", {feature: e});
                this.features = OpenLayers.Util.removeItem(this.features, e);
                e.layer = null;
                e.geometry && this.renderer.eraseFeatures(e);
                -1 != OpenLayers.Util.indexOf(this.selectedFeatures,
                    e) && OpenLayers.Util.removeItem(this.selectedFeatures, e);
                c && this.events.triggerEvent("featureremoved", {feature: e})
            }
            c && this.events.triggerEvent("featuresremoved", {features: a})
        }
    },
    removeAllFeatures: function (a) {
        var a = !a || !a.silent, b = this.features;
        a && this.events.triggerEvent("beforefeaturesremoved", {features: b});
        for (var c, d = b.length - 1; 0 <= d; d--)c = b[d], a && this.events.triggerEvent("beforefeatureremoved", {feature: c}), c.layer = null, a && this.events.triggerEvent("featureremoved", {feature: c});
        this.renderer.clear();
        this.features = [];
        this.unrenderedFeatures = {};
        this.selectedFeatures = [];
        a && this.events.triggerEvent("featuresremoved", {features: b})
    },
    destroyFeatures: function (a, b) {
        void 0 == a && (a = this.features);
        if (a) {
            this.removeFeatures(a, b);
            for (var c = a.length - 1; 0 <= c; c--)a[c].destroy()
        }
    },
    drawFeature: function (a, b) {
        if (this.drawn) {
            if ("object" != typeof b) {
                !b && a.state === OpenLayers.State.DELETE && (b = "delete");
                var c = b || a.renderIntent;
                (b = a.style || this.style) || (b = this.styleMap.createSymbolizer(a, c))
            }
            c = this.renderer.drawFeature(a,
                b);
            !1 === c || null === c ? this.unrenderedFeatures[a.id] = a : delete this.unrenderedFeatures[a.id]
        }
    },
    eraseFeatures: function (a) {
        this.renderer.eraseFeatures(a)
    },
    getFeatureFromEvent: function (a) {
        if (!this.renderer)throw Error("getFeatureFromEvent called on layer with no renderer. This usually means you destroyed a layer, but not some handler which is associated with it.");
        var b = null;
        (a = this.renderer.getFeatureIdFromEvent(a)) && (b = "string" === typeof a ? this.getFeatureById(a) : a);
        return b
    },
    getFeatureBy: function (a, b) {
        for (var c =
            null, d = 0, e = this.features.length; d < e; ++d)if (this.features[d][a] == b) {
            c = this.features[d];
            break
        }
        return c
    },
    getFeatureById: function (a) {
        return this.getFeatureBy("id", a)
    },
    getFeatureByFid: function (a) {
        return this.getFeatureBy("fid", a)
    },
    getFeaturesByAttribute: function (a, b) {
        var c, d, e = this.features.length, f = [];
        for (c = 0; c < e; c++)(d = this.features[c]) && d.attributes && d.attributes[a] === b && f.push(d);
        return f
    },
    onFeatureInsert: function () {
    },
    preFeatureInsert: function () {
    },
    getDataExtent: function () {
        var a = null, b = this.features;
        if (b && 0 < b.length)for (var c = null, d = 0, e = b.length; d < e; d++)if (c = b[d].geometry)null === a && (a = new OpenLayers.Bounds), a.extend(c.getBounds());
        return a
    },
    CLASS_NAME: "OpenLayers.Layer.Vector"
});
OpenLayers.Layer.PointGrid = OpenLayers.Class(OpenLayers.Layer.Vector, {
    dx: null,
    dy: null,
    ratio: 1.5,
    maxFeatures: 250,
    rotation: 0,
    origin: null,
    gridBounds: null,
    initialize: function (a) {
        a = a || {};
        OpenLayers.Layer.Vector.prototype.initialize.apply(this, [a.name, a])
    },
    setMap: function (a) {
        OpenLayers.Layer.Vector.prototype.setMap.apply(this, arguments);
        a.events.register("moveend", this, this.onMoveEnd)
    },
    removeMap: function (a) {
        a.events.unregister("moveend", this, this.onMoveEnd);
        OpenLayers.Layer.Vector.prototype.removeMap.apply(this,
            arguments)
    },
    setRatio: function (a) {
        this.ratio = a;
        this.updateGrid(!0)
    },
    setMaxFeatures: function (a) {
        this.maxFeatures = a;
        this.updateGrid(!0)
    },
    setSpacing: function (a, b) {
        this.dx = a;
        this.dy = b || a;
        this.updateGrid(!0)
    },
    setOrigin: function (a) {
        this.origin = a;
        this.updateGrid(!0)
    },
    getOrigin: function () {
        this.origin || (this.origin = this.map.getExtent().getCenterLonLat());
        return this.origin
    },
    setRotation: function (a) {
        this.rotation = a;
        this.updateGrid(!0)
    },
    onMoveEnd: function () {
        this.updateGrid()
    },
    getViewBounds: function () {
        var a = this.map.getExtent();
        if (this.rotation) {
            var b = this.getOrigin(), b = new OpenLayers.Geometry.Point(b.lon, b.lat), a = a.toGeometry();
            a.rotate(-this.rotation, b);
            a = a.getBounds()
        }
        return a
    },
    updateGrid: function (a) {
        if (a || this.invalidBounds()) {
            var b = this.getViewBounds(), c = this.getOrigin(), a = new OpenLayers.Geometry.Point(c.lon, c.lat), d = b.getWidth(), e = b.getHeight(), f = d / e, g = Math.sqrt(this.dx * this.dy * this.maxFeatures / f), d = Math.min(d * this.ratio, g * f), e = Math.min(e * this.ratio, g), b = b.getCenterLonLat();
            this.gridBounds = new OpenLayers.Bounds(b.lon -
            d / 2, b.lat - e / 2, b.lon + d / 2, b.lat + e / 2);
            for (var b = Math.floor(e / this.dy), d = Math.floor(d / this.dx), e = c.lon + this.dx * Math.ceil((this.gridBounds.left - c.lon) / this.dx), c = c.lat + this.dy * Math.ceil((this.gridBounds.bottom - c.lat) / this.dy), g = Array(b * d), h, k = 0; k < d; ++k)for (var f = e + k * this.dx, l = 0; l < b; ++l)h = c + l * this.dy, h = new OpenLayers.Geometry.Point(f, h), this.rotation && h.rotate(this.rotation, a), g[k * b + l] = new OpenLayers.Feature.Vector(h);
            this.destroyFeatures(this.features, {silent: !0});
            this.addFeatures(g, {silent: !0})
        }
    },
    invalidBounds: function () {
        return !this.gridBounds || !this.gridBounds.containsBounds(this.getViewBounds())
    },
    CLASS_NAME: "OpenLayers.Layer.PointGrid"
});
OpenLayers.Layer.Vector.RootContainer = OpenLayers.Class(OpenLayers.Layer.Vector, {
    displayInLayerSwitcher: !1, layers: null, display: function () {
    }, getFeatureFromEvent: function (a) {
        for (var b = this.layers, c, d = 0; d < b.length; d++)if (c = b[d].getFeatureFromEvent(a))return c
    }, setMap: function (a) {
        OpenLayers.Layer.Vector.prototype.setMap.apply(this, arguments);
        this.collectRoots();
        a.events.register("changelayer", this, this.handleChangeLayer)
    }, removeMap: function (a) {
        a.events.unregister("changelayer", this, this.handleChangeLayer);
        this.resetRoots();
        OpenLayers.Layer.Vector.prototype.removeMap.apply(this, arguments)
    }, collectRoots: function () {
        for (var a, b = 0; b < this.map.layers.length; ++b)a = this.map.layers[b], -1 != OpenLayers.Util.indexOf(this.layers, a) && a.renderer.moveRoot(this.renderer)
    }, resetRoots: function () {
        for (var a, b = 0; b < this.layers.length; ++b)a = this.layers[b], this.renderer && a.renderer.getRenderLayerId() == this.id && this.renderer.moveRoot(a.renderer)
    }, handleChangeLayer: function (a) {
        var b = a.layer;
        "order" == a.property && -1 != OpenLayers.Util.indexOf(this.layers,
            b) && (this.resetRoots(), this.collectRoots())
    }, CLASS_NAME: "OpenLayers.Layer.Vector.RootContainer"
});
OpenLayers.Strategy = OpenLayers.Class({
    layer: null,
    options: null,
    active: null,
    autoActivate: !0,
    autoDestroy: !0,
    initialize: function (a) {
        OpenLayers.Util.extend(this, a);
        this.options = a;
        this.active = !1
    },
    destroy: function () {
        this.deactivate();
        this.options = this.layer = null
    },
    setLayer: function (a) {
        this.layer = a
    },
    activate: function () {
        return !this.active ? this.active = !0 : !1
    },
    deactivate: function () {
        return this.active ? (this.active = !1, !0) : !1
    },
    CLASS_NAME: "OpenLayers.Strategy"
});
OpenLayers.Strategy.Filter = OpenLayers.Class(OpenLayers.Strategy, {
    filter: null, cache: null, caching: !1, activate: function () {
        var a = OpenLayers.Strategy.prototype.activate.apply(this, arguments);
        a && (this.cache = [], this.layer.events.on({
            beforefeaturesadded: this.handleAdd,
            beforefeaturesremoved: this.handleRemove,
            scope: this
        }));
        return a
    }, deactivate: function () {
        this.cache = null;
        this.layer && this.layer.events && this.layer.events.un({
            beforefeaturesadded: this.handleAdd,
            beforefeaturesremoved: this.handleRemove,
            scope: this
        });
        return OpenLayers.Strategy.prototype.deactivate.apply(this, arguments)
    }, handleAdd: function (a) {
        if (!this.caching && this.filter) {
            var b = a.features;
            a.features = [];
            for (var c, d = 0, e = b.length; d < e; ++d)c = b[d], this.filter.evaluate(c) ? a.features.push(c) : this.cache.push(c)
        }
    }, handleRemove: function () {
        this.caching || (this.cache = [])
    }, setFilter: function (a) {
        this.filter = a;
        a = this.cache;
        this.cache = [];
        this.handleAdd({features: this.layer.features});
        0 < this.cache.length && (this.caching = !0, this.layer.removeFeatures(this.cache.slice()),
            this.caching = !1);
        0 < a.length && (a = {features: a}, this.handleAdd(a), 0 < a.features.length && (this.caching = !0, this.layer.addFeatures(a.features), this.caching = !1))
    }, CLASS_NAME: "OpenLayers.Strategy.Filter"
});
OpenLayers.Strategy.Fixed = OpenLayers.Class(OpenLayers.Strategy, {
    preload: !1, activate: function () {
        if (OpenLayers.Strategy.prototype.activate.apply(this, arguments)) {
            this.layer.events.on({refresh: this.load, scope: this});
            if (!0 == this.layer.visibility || this.preload)this.load(); else this.layer.events.on({
                visibilitychanged: this.load,
                scope: this
            });
            return !0
        }
        return !1
    }, deactivate: function () {
        var a = OpenLayers.Strategy.prototype.deactivate.call(this);
        a && this.layer.events.un({
            refresh: this.load, visibilitychanged: this.load,
            scope: this
        });
        return a
    }, load: function (a) {
        var b = this.layer;
        b.events.triggerEvent("loadstart");
        b.protocol.read(OpenLayers.Util.applyDefaults({
            callback: OpenLayers.Function.bind(this.merge, this, b.map.getProjectionObject()),
            filter: b.filter
        }, a));
        b.events.un({visibilitychanged: this.load, scope: this})
    }, merge: function (a, b) {
        var c = this.layer;
        c.destroyFeatures();
        var d = b.features;
        if (d && 0 < d.length) {
            if (!a.equals(c.projection))for (var e, f = 0, g = d.length; f < g; ++f)(e = d[f].geometry) && e.transform(c.projection, a);
            c.addFeatures(d)
        }
        c.events.triggerEvent("loadend")
    },
    CLASS_NAME: "OpenLayers.Strategy.Fixed"
});
OpenLayers.Strategy.Cluster = OpenLayers.Class(OpenLayers.Strategy, {
    distance: 20,
    threshold: null,
    features: null,
    clusters: null,
    clustering: !1,
    resolution: null,
    activate: function () {
        var a = OpenLayers.Strategy.prototype.activate.call(this);
        if (a)this.layer.events.on({beforefeaturesadded: this.cacheFeatures, moveend: this.cluster, scope: this});
        return a
    },
    deactivate: function () {
        var a = OpenLayers.Strategy.prototype.deactivate.call(this);
        a && (this.clearCache(), this.layer.events.un({
            beforefeaturesadded: this.cacheFeatures, moveend: this.cluster,
            scope: this
        }));
        return a
    },
    cacheFeatures: function (a) {
        var b = !0;
        this.clustering || (this.clearCache(), this.features = a.features, this.cluster(), b = !1);
        return b
    },
    clearCache: function () {
        this.features = null
    },
    cluster: function (a) {
        if ((!a || a.zoomChanged) && this.features)if (a = this.layer.map.getResolution(), a != this.resolution || !this.clustersExist()) {
            this.resolution = a;
            for (var a = [], b, c, d, e = 0; e < this.features.length; ++e)if (b = this.features[e], b.geometry) {
                c = !1;
                for (var f = a.length - 1; 0 <= f; --f)if (d = a[f], this.shouldCluster(d, b)) {
                    this.addToCluster(d,
                        b);
                    c = !0;
                    break
                }
                c || a.push(this.createCluster(this.features[e]))
            }
            this.layer.removeAllFeatures();
            if (0 < a.length) {
                if (1 < this.threshold) {
                    b = a.slice();
                    a = [];
                    e = 0;
                    for (d = b.length; e < d; ++e)c = b[e], c.attributes.count < this.threshold ? Array.prototype.push.apply(a, c.cluster) : a.push(c)
                }
                this.clustering = !0;
                this.layer.addFeatures(a);
                this.clustering = !1
            }
            this.clusters = a
        }
    },
    clustersExist: function () {
        var a = !1;
        if (this.clusters && 0 < this.clusters.length && this.clusters.length == this.layer.features.length)for (var a = !0, b = 0; b < this.clusters.length; ++b)if (this.clusters[b] !=
            this.layer.features[b]) {
            a = !1;
            break
        }
        return a
    },
    shouldCluster: function (a, b) {
        var c = a.geometry.getBounds().getCenterLonLat(), d = b.geometry.getBounds().getCenterLonLat();
        return Math.sqrt(Math.pow(c.lon - d.lon, 2) + Math.pow(c.lat - d.lat, 2)) / this.resolution <= this.distance
    },
    addToCluster: function (a, b) {
        a.cluster.push(b);
        a.attributes.count += 1
    },
    createCluster: function (a) {
        var b = a.geometry.getBounds().getCenterLonLat(), b = new OpenLayers.Feature.Vector(new OpenLayers.Geometry.Point(b.lon, b.lat), {count: 1});
        b.cluster = [a];
        return b
    },
    CLASS_NAME: "OpenLayers.Strategy.Cluster"
});
OpenLayers.Strategy.Paging = OpenLayers.Class(OpenLayers.Strategy, {
    features: null, length: 10, num: null, paging: !1, activate: function () {
        var a = OpenLayers.Strategy.prototype.activate.call(this);
        if (a)this.layer.events.on({beforefeaturesadded: this.cacheFeatures, scope: this});
        return a
    }, deactivate: function () {
        var a = OpenLayers.Strategy.prototype.deactivate.call(this);
        a && (this.clearCache(), this.layer.events.un({beforefeaturesadded: this.cacheFeatures, scope: this}));
        return a
    }, cacheFeatures: function (a) {
        this.paging || (this.clearCache(),
            this.features = a.features, this.pageNext(a))
    }, clearCache: function () {
        if (this.features)for (var a = 0; a < this.features.length; ++a)this.features[a].destroy();
        this.num = this.features = null
    }, pageCount: function () {
        return Math.ceil((this.features ? this.features.length : 0) / this.length)
    }, pageNum: function () {
        return this.num
    }, pageLength: function (a) {
        a && 0 < a && (this.length = a);
        return this.length
    }, pageNext: function (a) {
        var b = !1;
        this.features && (null === this.num && (this.num = -1), b = this.page((this.num + 1) * this.length, a));
        return b
    }, pagePrevious: function () {
        var a =
            !1;
        this.features && (null === this.num && (this.num = this.pageCount()), a = this.page((this.num - 1) * this.length));
        return a
    }, page: function (a, b) {
        var c = !1;
        if (this.features && 0 <= a && a < this.features.length) {
            var d = Math.floor(a / this.length);
            d != this.num && (this.paging = !0, c = this.features.slice(a, a + this.length), this.layer.removeFeatures(this.layer.features), this.num = d, b && b.features ? b.features = c : this.layer.addFeatures(c), this.paging = !1, c = !0)
        }
        return c
    }, CLASS_NAME: "OpenLayers.Strategy.Paging"
});
OpenLayers.Strategy.BBOX = OpenLayers.Class(OpenLayers.Strategy, {
    bounds: null, resolution: null, ratio: 2, resFactor: null, response: null, activate: function () {
        var a = OpenLayers.Strategy.prototype.activate.call(this);
        a && (this.layer.events.on({
            moveend: this.update,
            refresh: this.update,
            visibilitychanged: this.update,
            scope: this
        }), this.update());
        return a
    }, deactivate: function () {
        var a = OpenLayers.Strategy.prototype.deactivate.call(this);
        a && this.layer.events.un({
            moveend: this.update, refresh: this.update, visibilitychanged: this.update,
            scope: this
        });
        return a
    }, update: function (a) {
        var b = this.getMapBounds();
        if (null !== b && (a && a.force || this.layer.visibility && this.layer.calculateInRange() && this.invalidBounds(b)))this.calculateBounds(b), this.resolution = this.layer.map.getResolution(), this.triggerRead(a)
    }, getMapBounds: function () {
        if (null === this.layer.map)return null;
        var a = this.layer.map.getExtent();
        a && !this.layer.projection.equals(this.layer.map.getProjectionObject()) && (a = a.clone().transform(this.layer.map.getProjectionObject(), this.layer.projection));
        return a
    }, invalidBounds: function (a) {
        a || (a = this.getMapBounds());
        a = !this.bounds || !this.bounds.containsBounds(a);
        !a && this.resFactor && (a = this.resolution / this.layer.map.getResolution(), a = a >= this.resFactor || a <= 1 / this.resFactor);
        return a
    }, calculateBounds: function (a) {
        a || (a = this.getMapBounds());
        var b = a.getCenterLonLat(), c = a.getWidth() * this.ratio, a = a.getHeight() * this.ratio;
        this.bounds = new OpenLayers.Bounds(b.lon - c / 2, b.lat - a / 2, b.lon + c / 2, b.lat + a / 2)
    }, triggerRead: function (a) {
        this.response && !(a && !0 === a.noAbort) &&
        (this.layer.protocol.abort(this.response), this.layer.events.triggerEvent("loadend"));
        this.layer.events.triggerEvent("loadstart");
        this.response = this.layer.protocol.read(OpenLayers.Util.applyDefaults({
            filter: this.createFilter(),
            callback: this.merge,
            scope: this
        }, a))
    }, createFilter: function () {
        var a = new OpenLayers.Filter.Spatial({
            type: OpenLayers.Filter.Spatial.BBOX,
            value: this.bounds,
            projection: this.layer.projection
        });
        this.layer.filter && (a = new OpenLayers.Filter.Logical({
            type: OpenLayers.Filter.Logical.AND,
            filters: [this.layer.filter, a]
        }));
        return a
    }, merge: function (a) {
        this.layer.destroyFeatures();
        if ((a = a.features) && 0 < a.length) {
            var b = this.layer.projection, c = this.layer.map.getProjectionObject();
            if (!c.equals(b))for (var d, e = 0, f = a.length; e < f; ++e)(d = a[e].geometry) && d.transform(b, c);
            this.layer.addFeatures(a)
        }
        this.response = null;
        this.layer.events.triggerEvent("loadend")
    }, CLASS_NAME: "OpenLayers.Strategy.BBOX"
});
OpenLayers.Strategy.Save = OpenLayers.Class(OpenLayers.Strategy, {
    events: null, auto: !1, timer: null, initialize: function (a) {
        OpenLayers.Strategy.prototype.initialize.apply(this, [a]);
        this.events = new OpenLayers.Events(this)
    }, activate: function () {
        var a = OpenLayers.Strategy.prototype.activate.call(this);
        if (a && this.auto)if ("number" === typeof this.auto)this.timer = window.setInterval(OpenLayers.Function.bind(this.save, this), 1E3 * this.auto); else this.layer.events.on({
            featureadded: this.triggerSave, afterfeaturemodified: this.triggerSave,
            scope: this
        });
        return a
    }, deactivate: function () {
        var a = OpenLayers.Strategy.prototype.deactivate.call(this);
        a && this.auto && ("number" === typeof this.auto ? window.clearInterval(this.timer) : this.layer.events.un({
            featureadded: this.triggerSave,
            afterfeaturemodified: this.triggerSave,
            scope: this
        }));
        return a
    }, triggerSave: function (a) {
        var b = a.feature;
        (b.state === OpenLayers.State.INSERT || b.state === OpenLayers.State.UPDATE || b.state === OpenLayers.State.DELETE) && this.save([a.feature])
    }, save: function (a) {
        a || (a = this.layer.features);
        this.events.triggerEvent("start", {features: a});
        var b = this.layer.projection, c = this.layer.map.getProjectionObject();
        if (!c.equals(b)) {
            for (var d = a.length, e = Array(d), f, g, h = 0; h < d; ++h)f = a[h], g = f.clone(), g.fid = f.fid, g.state = f.state, f.url && (g.url = f.url), g._original = f, g.geometry.transform(c, b), e[h] = g;
            a = e
        }
        this.layer.protocol.commit(a, {callback: this.onCommit, scope: this})
    }, onCommit: function (a) {
        var b = {response: a};
        if (a.success()) {
            for (var c = a.reqFeatures, d, e = [], f = a.insertIds || [], g = 0, h = 0, k = c.length; h < k; ++h)if (d = c[h],
                    d = d._original || d, a = d.state)a == OpenLayers.State.DELETE ? e.push(d) : a == OpenLayers.State.INSERT && (d.fid = f[g], ++g), d.state = null;
            0 < e.length && this.layer.destroyFeatures(e);
            this.events.triggerEvent("success", b)
        } else this.events.triggerEvent("fail", b)
    }, CLASS_NAME: "OpenLayers.Strategy.Save"
});
OpenLayers.Strategy.Refresh = OpenLayers.Class(OpenLayers.Strategy, {
    force: !1, interval: 0, timer: null, activate: function () {
        var a = OpenLayers.Strategy.prototype.activate.call(this);
        a && (!0 === this.layer.visibility && this.start(), this.layer.events.on({
            visibilitychanged: this.reset,
            scope: this
        }));
        return a
    }, deactivate: function () {
        var a = OpenLayers.Strategy.prototype.deactivate.call(this);
        a && this.stop();
        return a
    }, reset: function () {
        !0 === this.layer.visibility ? this.start() : this.stop()
    }, start: function () {
        this.interval && "number" === typeof this.interval && 0 < this.interval && (this.timer = window.setInterval(OpenLayers.Function.bind(this.refresh, this), this.interval))
    }, refresh: function () {
        this.layer && this.layer.refresh && "function" == typeof this.layer.refresh && this.layer.refresh({force: this.force})
    }, stop: function () {
        null !== this.timer && (window.clearInterval(this.timer), this.timer = null)
    }, CLASS_NAME: "OpenLayers.Strategy.Refresh"
});
OpenLayers.Filter = OpenLayers.Class({
    initialize: function (a) {
        OpenLayers.Util.extend(this, a)
    }, destroy: function () {
    }, evaluate: function () {
        return !0
    }, clone: function () {
        return null
    }, toString: function () {
        return OpenLayers.Format && OpenLayers.Format.CQL ? OpenLayers.Format.CQL.prototype.write(this) : Object.prototype.toString.call(this)
    }, CLASS_NAME: "OpenLayers.Filter"
});
OpenLayers.Filter.FeatureId = OpenLayers.Class(OpenLayers.Filter, {
    fids: null, type: "FID", initialize: function (a) {
        this.fids = [];
        OpenLayers.Filter.prototype.initialize.apply(this, [a])
    }, evaluate: function (a) {
        for (var b = 0, c = this.fids.length; b < c; b++)if ((a.fid || a.id) == this.fids[b])return !0;
        return !1
    }, clone: function () {
        var a = new OpenLayers.Filter.FeatureId;
        OpenLayers.Util.extend(a, this);
        a.fids = this.fids.slice();
        return a
    }, CLASS_NAME: "OpenLayers.Filter.FeatureId"
});
OpenLayers.Filter.Logical = OpenLayers.Class(OpenLayers.Filter, {
    filters: null, type: null, initialize: function (a) {
        this.filters = [];
        OpenLayers.Filter.prototype.initialize.apply(this, [a])
    }, destroy: function () {
        this.filters = null;
        OpenLayers.Filter.prototype.destroy.apply(this)
    }, evaluate: function (a) {
        var b, c;
        switch (this.type) {
            case OpenLayers.Filter.Logical.AND:
                for (b = 0, c = this.filters.length; b < c; b++)if (!1 == this.filters[b].evaluate(a))return !1;
                return !0;
            case OpenLayers.Filter.Logical.OR:
                for (b = 0, c = this.filters.length; b <
                c; b++)if (!0 == this.filters[b].evaluate(a))return !0;
                return !1;
            case OpenLayers.Filter.Logical.NOT:
                return !this.filters[0].evaluate(a)
        }
    }, clone: function () {
        for (var a = [], b = 0, c = this.filters.length; b < c; ++b)a.push(this.filters[b].clone());
        return new OpenLayers.Filter.Logical({type: this.type, filters: a})
    }, CLASS_NAME: "OpenLayers.Filter.Logical"
});
OpenLayers.Filter.Logical.AND = "&&";
OpenLayers.Filter.Logical.OR = "||";
OpenLayers.Filter.Logical.NOT = "!";
OpenLayers.Filter.Comparison = OpenLayers.Class(OpenLayers.Filter, {
    type: null,
    property: null,
    value: null,
    matchCase: !0,
    lowerBoundary: null,
    upperBoundary: null,
    initialize: function (a) {
        OpenLayers.Filter.prototype.initialize.apply(this, [a]);
        this.type === OpenLayers.Filter.Comparison.LIKE && void 0 === a.matchCase && (this.matchCase = null)
    },
    evaluate: function (a) {
        a instanceof OpenLayers.Feature.Vector && (a = a.attributes);
        var b = !1, a = a[this.property];
        switch (this.type) {
            case OpenLayers.Filter.Comparison.EQUAL_TO:
                b = this.value;
                b = !this.matchCase && "string" == typeof a && "string" == typeof b ? a.toUpperCase() == b.toUpperCase() : a == b;
                break;
            case OpenLayers.Filter.Comparison.NOT_EQUAL_TO:
                b = this.value;
                b = !this.matchCase && "string" == typeof a && "string" == typeof b ? a.toUpperCase() != b.toUpperCase() : a != b;
                break;
            case OpenLayers.Filter.Comparison.LESS_THAN:
                b = a < this.value;
                break;
            case OpenLayers.Filter.Comparison.GREATER_THAN:
                b = a > this.value;
                break;
            case OpenLayers.Filter.Comparison.LESS_THAN_OR_EQUAL_TO:
                b = a <= this.value;
                break;
            case OpenLayers.Filter.Comparison.GREATER_THAN_OR_EQUAL_TO:
                b =
                    a >= this.value;
                break;
            case OpenLayers.Filter.Comparison.BETWEEN:
                b = a >= this.lowerBoundary && a <= this.upperBoundary;
                break;
            case OpenLayers.Filter.Comparison.LIKE:
                b = RegExp(this.value, "gi").test(a)
        }
        return b
    },
    value2regex: function (a, b, c) {
        if ("." == a)throw Error("'.' is an unsupported wildCard character for OpenLayers.Filter.Comparison");
        a = a ? a : "*";
        b = b ? b : ".";
        this.value = this.value.replace(RegExp("\\" + (c ? c : "!") + "(.|$)", "g"), "\\$1");
        this.value = this.value.replace(RegExp("\\" + b, "g"), ".");
        this.value = this.value.replace(RegExp("\\" +
        a, "g"), ".*");
        this.value = this.value.replace(RegExp("\\\\.\\*", "g"), "\\" + a);
        return this.value = this.value.replace(RegExp("\\\\\\.", "g"), "\\" + b)
    },
    regex2value: function () {
        var a = this.value, a = a.replace(/!/g, "!!"), a = a.replace(/(\\)?\\\./g, function (a, c) {
            return c ? a : "!."
        }), a = a.replace(/(\\)?\\\*/g, function (a, c) {
            return c ? a : "!*"
        }), a = a.replace(/\\\\/g, "\\");
        return a = a.replace(/\.\*/g, "*")
    },
    clone: function () {
        return OpenLayers.Util.extend(new OpenLayers.Filter.Comparison, this)
    },
    CLASS_NAME: "OpenLayers.Filter.Comparison"
});
OpenLayers.Filter.Comparison.EQUAL_TO = "==";
OpenLayers.Filter.Comparison.NOT_EQUAL_TO = "!=";
OpenLayers.Filter.Comparison.LESS_THAN = "<";
OpenLayers.Filter.Comparison.GREATER_THAN = ">";
OpenLayers.Filter.Comparison.LESS_THAN_OR_EQUAL_TO = "<=";
OpenLayers.Filter.Comparison.GREATER_THAN_OR_EQUAL_TO = ">=";
OpenLayers.Filter.Comparison.BETWEEN = "..";
OpenLayers.Filter.Comparison.LIKE = "~";
OpenLayers.Filter.Spatial = OpenLayers.Class(OpenLayers.Filter, {
    type: null, property: null, value: null, distance: null, distanceUnits: null, evaluate: function (a) {
        var b = !1;
        switch (this.type) {
            case OpenLayers.Filter.Spatial.BBOX:
            case OpenLayers.Filter.Spatial.INTERSECTS:
                if (a.geometry) {
                    var c = this.value;
                    "OpenLayers.Bounds" == this.value.CLASS_NAME && (c = this.value.toGeometry());
                    a.geometry.intersects(c) && (b = !0)
                }
                break;
            default:
                throw Error("evaluate is not implemented for this filter type.");
        }
        return b
    }, clone: function () {
        var a =
            OpenLayers.Util.applyDefaults({value: this.value && this.value.clone && this.value.clone()}, this);
        return new OpenLayers.Filter.Spatial(a)
    }, CLASS_NAME: "OpenLayers.Filter.Spatial"
});
OpenLayers.Filter.Spatial.BBOX = "BBOX";
OpenLayers.Filter.Spatial.INTERSECTS = "INTERSECTS";
OpenLayers.Filter.Spatial.DWITHIN = "DWITHIN";
OpenLayers.Filter.Spatial.WITHIN = "WITHIN";
OpenLayers.Filter.Spatial.CONTAINS = "CONTAINS";
OpenLayers.Filter.Function = OpenLayers.Class(OpenLayers.Filter, {
    name: null,
    params: null,
    CLASS_NAME: "OpenLayers.Filter.Function"
});
OpenLayers.Protocol = OpenLayers.Class({
    format: null, options: null, autoDestroy: !0, defaultFilter: null, initialize: function (a) {
        a = a || {};
        OpenLayers.Util.extend(this, a);
        this.options = a
    }, mergeWithDefaultFilter: function (a) {
        return a && this.defaultFilter ? new OpenLayers.Filter.Logical({
            type: OpenLayers.Filter.Logical.AND,
            filters: [this.defaultFilter, a]
        }) : a || this.defaultFilter || void 0
    }, destroy: function () {
        this.format = this.options = null
    }, read: function (a) {
        a = a || {};
        a.filter = this.mergeWithDefaultFilter(a.filter)
    }, create: function () {
    },
    update: function () {
    }, "delete": function () {
    }, commit: function () {
    }, abort: function () {
    }, createCallback: function (a, b, c) {
        return OpenLayers.Function.bind(function () {
            a.apply(this, [b, c])
        }, this)
    }, CLASS_NAME: "OpenLayers.Protocol"
});
OpenLayers.Protocol.Response = OpenLayers.Class({
    code: null,
    requestType: null,
    last: !0,
    features: null,
    data: null,
    reqFeatures: null,
    priv: null,
    error: null,
    initialize: function (a) {
        OpenLayers.Util.extend(this, a)
    },
    success: function () {
        return 0 < this.code
    },
    CLASS_NAME: "OpenLayers.Protocol.Response"
});
OpenLayers.Protocol.Response.SUCCESS = 1;
OpenLayers.Protocol.Response.FAILURE = 0;
OpenLayers.Protocol.HTTP = OpenLayers.Class(OpenLayers.Protocol, {
    url: null,
    headers: null,
    params: null,
    callback: null,
    scope: null,
    readWithPOST: !1,
    updateWithPOST: !1,
    deleteWithPOST: !1,
    wildcarded: !1,
    srsInBBOX: !1,
    initialize: function (a) {
        a = a || {};
        this.params = {};
        this.headers = {};
        OpenLayers.Protocol.prototype.initialize.apply(this, arguments);
        if (!this.filterToParams && OpenLayers.Format.QueryStringFilter) {
            var b = new OpenLayers.Format.QueryStringFilter({wildcarded: this.wildcarded, srsInBBOX: this.srsInBBOX});
            this.filterToParams =
                function (a, d) {
                    return b.write(a, d)
                }
        }
    },
    destroy: function () {
        this.headers = this.params = null;
        OpenLayers.Protocol.prototype.destroy.apply(this)
    },
    read: function (a) {
        OpenLayers.Protocol.prototype.read.apply(this, arguments);
        a = a || {};
        a.params = OpenLayers.Util.applyDefaults(a.params, this.options.params);
        a = OpenLayers.Util.applyDefaults(a, this.options);
        a.filter && this.filterToParams && (a.params = this.filterToParams(a.filter, a.params));
        var b = void 0 !== a.readWithPOST ? a.readWithPOST : this.readWithPOST, c = new OpenLayers.Protocol.Response({requestType: "read"});
        b ? (b = a.headers || {}, b["Content-Type"] = "application/x-www-form-urlencoded", c.priv = OpenLayers.Request.POST({
            url: a.url,
            callback: this.createCallback(this.handleRead, c, a),
            data: OpenLayers.Util.getParameterString(a.params),
            headers: b
        })) : c.priv = OpenLayers.Request.GET({
            url: a.url,
            callback: this.createCallback(this.handleRead, c, a),
            params: a.params,
            headers: a.headers
        });
        return c
    },
    handleRead: function (a, b) {
        this.handleResponse(a, b)
    },
    create: function (a, b) {
        var b = OpenLayers.Util.applyDefaults(b, this.options), c = new OpenLayers.Protocol.Response({
            reqFeatures: a,
            requestType: "create"
        });
        c.priv = OpenLayers.Request.POST({
            url: b.url,
            callback: this.createCallback(this.handleCreate, c, b),
            headers: b.headers,
            data: this.format.write(a)
        });
        return c
    },
    handleCreate: function (a, b) {
        this.handleResponse(a, b)
    },
    update: function (a, b) {
        var b = b || {}, c = b.url || a.url || this.options.url + "/" + a.fid, b = OpenLayers.Util.applyDefaults(b, this.options), d = new OpenLayers.Protocol.Response({
            reqFeatures: a,
            requestType: "update"
        });
        d.priv = OpenLayers.Request[this.updateWithPOST ? "POST" : "PUT"]({
            url: c, callback: this.createCallback(this.handleUpdate,
                d, b), headers: b.headers, data: this.format.write(a)
        });
        return d
    },
    handleUpdate: function (a, b) {
        this.handleResponse(a, b)
    },
    "delete": function (a, b) {
        var b = b || {}, c = b.url || a.url || this.options.url + "/" + a.fid, b = OpenLayers.Util.applyDefaults(b, this.options), d = new OpenLayers.Protocol.Response({
            reqFeatures: a,
            requestType: "delete"
        }), e = this.deleteWithPOST ? "POST" : "DELETE", c = {
            url: c,
            callback: this.createCallback(this.handleDelete, d, b),
            headers: b.headers
        };
        this.deleteWithPOST && (c.data = this.format.write(a));
        d.priv = OpenLayers.Request[e](c);
        return d
    },
    handleDelete: function (a, b) {
        this.handleResponse(a, b)
    },
    handleResponse: function (a, b) {
        var c = a.priv;
        b.callback && (200 <= c.status && 300 > c.status ? ("delete" != a.requestType && (a.features = this.parseFeatures(c)), a.code = OpenLayers.Protocol.Response.SUCCESS) : a.code = OpenLayers.Protocol.Response.FAILURE, b.callback.call(b.scope, a))
    },
    parseFeatures: function (a) {
        var b = a.responseXML;
        if (!b || !b.documentElement)b = a.responseText;
        return !b || 0 >= b.length ? null : this.format.read(b)
    },
    commit: function (a, b) {
        function c(a) {
            for (var b =
                a.features ? a.features.length : 0, c = Array(b), e = 0; e < b; ++e)c[e] = a.features[e].fid;
            r.insertIds = c;
            d.apply(this, [a])
        }

        function d(a) {
            this.callUserCallback(a, b);
            p = p && a.success();
            f++;
            f >= o && b.callback && (r.code = p ? OpenLayers.Protocol.Response.SUCCESS : OpenLayers.Protocol.Response.FAILURE, b.callback.apply(b.scope, [r]))
        }

        var b = OpenLayers.Util.applyDefaults(b, this.options), e = [], f = 0, g = {};
        g[OpenLayers.State.INSERT] = [];
        g[OpenLayers.State.UPDATE] = [];
        g[OpenLayers.State.DELETE] = [];
        for (var h, k, l = [], m = 0, n = a.length; m < n; ++m)if (h =
                a[m], k = g[h.state])k.push(h), l.push(h);
        var o = (0 < g[OpenLayers.State.INSERT].length ? 1 : 0) + g[OpenLayers.State.UPDATE].length + g[OpenLayers.State.DELETE].length, p = !0, r = new OpenLayers.Protocol.Response({reqFeatures: l});
        h = g[OpenLayers.State.INSERT];
        0 < h.length && e.push(this.create(h, OpenLayers.Util.applyDefaults({callback: c, scope: this}, b.create)));
        h = g[OpenLayers.State.UPDATE];
        for (m = h.length - 1; 0 <= m; --m)e.push(this.update(h[m], OpenLayers.Util.applyDefaults({
            callback: d,
            scope: this
        }, b.update)));
        h = g[OpenLayers.State.DELETE];
        for (m = h.length - 1; 0 <= m; --m)e.push(this["delete"](h[m], OpenLayers.Util.applyDefaults({
            callback: d,
            scope: this
        }, b["delete"])));
        return e
    },
    abort: function (a) {
        a && a.priv.abort()
    },
    callUserCallback: function (a, b) {
        var c = b[a.requestType];
        c && c.callback && c.callback.call(c.scope, a)
    },
    CLASS_NAME: "OpenLayers.Protocol.HTTP"
});
OpenLayers.Protocol.WFS = function (a) {
    var a = OpenLayers.Util.applyDefaults(a, OpenLayers.Protocol.WFS.DEFAULTS), b = OpenLayers.Protocol.WFS["v" + a.version.replace(/\./g, "_")];
    if (!b)throw"Unsupported WFS version: " + a.version;
    return new b(a)
};
OpenLayers.Protocol.WFS.fromWMSLayer = function (a, b) {
    var c, d;
    c = a.params.LAYERS;
    c = (OpenLayers.Util.isArray(c) ? c[0] : c).split(":");
    1 < c.length && (d = c[0]);
    c = c.pop();
    d = {
        url: a.url,
        featureType: c,
        featurePrefix: d,
        srsName: a.projection && a.projection.getCode() || a.map && a.map.getProjectionObject().getCode(),
        version: "1.1.0"
    };
    return new OpenLayers.Protocol.WFS(OpenLayers.Util.applyDefaults(b, d))
};
OpenLayers.Protocol.WFS.DEFAULTS = {version: "1.0.0"};
OpenLayers.Protocol.WFS.v1 = OpenLayers.Class(OpenLayers.Protocol, {
    version: null,
    srsName: "EPSG:4326",
    featureType: null,
    featureNS: null,
    geometryName: "the_geom",
    schema: null,
    featurePrefix: "feature",
    formatOptions: null,
    readFormat: null,
    readOptions: null,
    initialize: function (a) {
        OpenLayers.Protocol.prototype.initialize.apply(this, [a]);
        a.format || (this.format = OpenLayers.Format.WFST(OpenLayers.Util.extend({
            version: this.version,
            featureType: this.featureType,
            featureNS: this.featureNS,
            featurePrefix: this.featurePrefix,
            geometryName: this.geometryName,
            srsName: this.srsName,
            schema: this.schema
        }, this.formatOptions)));
        !a.geometryName && 1 < parseFloat(this.format.version) && this.setGeometryName(null)
    },
    destroy: function () {
        this.options && !this.options.format && this.format.destroy();
        this.format = null;
        OpenLayers.Protocol.prototype.destroy.apply(this)
    },
    read: function (a) {
        OpenLayers.Protocol.prototype.read.apply(this, arguments);
        a = OpenLayers.Util.extend({}, a);
        OpenLayers.Util.applyDefaults(a, this.options || {});
        var b = new OpenLayers.Protocol.Response({requestType: "read"}),
            c = OpenLayers.Format.XML.prototype.write.apply(this.format, [this.format.writeNode("wfs:GetFeature", a)]);
        b.priv = OpenLayers.Request.POST({
            url: a.url,
            callback: this.createCallback(this.handleRead, b, a),
            params: a.params,
            headers: a.headers,
            data: c
        });
        return b
    },
    setFeatureType: function (a) {
        this.featureType = a;
        this.format.featureType = a
    },
    setGeometryName: function (a) {
        this.geometryName = a;
        this.format.geometryName = a
    },
    handleRead: function (a, b) {
        b = OpenLayers.Util.extend({}, b);
        OpenLayers.Util.applyDefaults(b, this.options);
        if (b.callback) {
            var c =
                a.priv;
            200 <= c.status && 300 > c.status ? (c = this.parseResponse(c, b.readOptions)) && !1 !== c.success ? (b.readOptions && "object" == b.readOptions.output ? OpenLayers.Util.extend(a, c) : a.features = c, a.code = OpenLayers.Protocol.Response.SUCCESS) : (a.code = OpenLayers.Protocol.Response.FAILURE, a.error = c) : a.code = OpenLayers.Protocol.Response.FAILURE;
            b.callback.call(b.scope, a)
        }
    },
    parseResponse: function (a, b) {
        var c = a.responseXML;
        if (!c || !c.documentElement)c = a.responseText;
        if (!c || 0 >= c.length)return null;
        c = null !== this.readFormat ? this.readFormat.read(c) :
            this.format.read(c, b);
        if (!this.featureNS) {
            var d = this.readFormat || this.format;
            this.featureNS = d.featureNS;
            d.autoConfig = !1;
            this.geometryName || this.setGeometryName(d.geometryName)
        }
        return c
    },
    commit: function (a, b) {
        b = OpenLayers.Util.extend({}, b);
        OpenLayers.Util.applyDefaults(b, this.options);
        var c = new OpenLayers.Protocol.Response({requestType: "commit", reqFeatures: a});
        c.priv = OpenLayers.Request.POST({
            url: b.url,
            headers: b.headers,
            data: this.format.write(a, b),
            callback: this.createCallback(this.handleCommit, c, b)
        });
        return c
    },
    handleCommit: function (a, b) {
        if (b.callback) {
            var c = a.priv, d = c.responseXML;
            if (!d || !d.documentElement)d = c.responseText;
            c = this.format.read(d) || {};
            a.insertIds = c.insertIds || [];
            c.success ? a.code = OpenLayers.Protocol.Response.SUCCESS : (a.code = OpenLayers.Protocol.Response.FAILURE, a.error = c);
            b.callback.call(b.scope, a)
        }
    },
    filterDelete: function (a, b) {
        b = OpenLayers.Util.extend({}, b);
        OpenLayers.Util.applyDefaults(b, this.options);
        new OpenLayers.Protocol.Response({requestType: "commit"});
        var c = this.format.createElementNSPlus("wfs:Transaction",
            {
                attributes: {
                    service: "WFS",
                    version: this.version
                }
            }), d = this.format.createElementNSPlus("wfs:Delete", {attributes: {typeName: (b.featureNS ? this.featurePrefix + ":" : "") + b.featureType}});
        b.featureNS && d.setAttribute("xmlns:" + this.featurePrefix, b.featureNS);
        var e = this.format.writeNode("ogc:Filter", a);
        d.appendChild(e);
        c.appendChild(d);
        c = OpenLayers.Format.XML.prototype.write.apply(this.format, [c]);
        return OpenLayers.Request.POST({
            url: this.url, callback: b.callback || function () {
            }, data: c
        })
    },
    abort: function (a) {
        a && a.priv.abort()
    },
    CLASS_NAME: "OpenLayers.Protocol.WFS.v1"
});
OpenLayers.Protocol.WFS.v1_0_0 = OpenLayers.Class(OpenLayers.Protocol.WFS.v1, {
    version: "1.0.0",
    CLASS_NAME: "OpenLayers.Protocol.WFS.v1_0_0"
});
OpenLayers.Protocol.WFS.v1_1_0 = OpenLayers.Class(OpenLayers.Protocol.WFS.v1, {
    version: "1.1.0",
    initialize: function (a) {
        OpenLayers.Protocol.WFS.v1.prototype.initialize.apply(this, arguments);
        this.outputFormat && !this.readFormat && ("gml2" == this.outputFormat.toLowerCase() ? this.readFormat = new OpenLayers.Format.GML.v2({
            featureType: this.featureType,
            featureNS: this.featureNS,
            geometryName: this.geometryName
        }) : "json" == this.outputFormat.toLowerCase() && (this.readFormat = new OpenLayers.Format.GeoJSON))
    },
    CLASS_NAME: "OpenLayers.Protocol.WFS.v1_1_0"
});
OpenLayers.Protocol.CSW = function (a) {
    var a = OpenLayers.Util.applyDefaults(a, OpenLayers.Protocol.CSW.DEFAULTS), b = OpenLayers.Protocol.CSW["v" + a.version.replace(/\./g, "_")];
    if (!b)throw"Unsupported CSW version: " + a.version;
    return new b(a)
};
OpenLayers.Protocol.CSW.DEFAULTS = {version: "2.0.2"};
OpenLayers.Protocol.CSW.v2_0_2 = OpenLayers.Class(OpenLayers.Protocol, {
    formatOptions: null, initialize: function (a) {
        OpenLayers.Protocol.prototype.initialize.apply(this, [a]);
        a.format || (this.format = new OpenLayers.Format.CSWGetRecords.v2_0_2(OpenLayers.Util.extend({}, this.formatOptions)))
    }, destroy: function () {
        this.options && !this.options.format && this.format.destroy();
        this.format = null;
        OpenLayers.Protocol.prototype.destroy.apply(this)
    }, read: function (a) {
        a = OpenLayers.Util.extend({}, a);
        OpenLayers.Util.applyDefaults(a,
            this.options || {});
        var b = new OpenLayers.Protocol.Response({requestType: "read"}), c = this.format.write(a.params);
        b.priv = OpenLayers.Request.POST({
            url: a.url,
            callback: this.createCallback(this.handleRead, b, a),
            params: a.params,
            headers: a.headers,
            data: c
        });
        return b
    }, handleRead: function (a, b) {
        if (b.callback) {
            var c = a.priv;
            200 <= c.status && 300 > c.status ? (a.data = this.parseData(c), a.code = OpenLayers.Protocol.Response.SUCCESS) : a.code = OpenLayers.Protocol.Response.FAILURE;
            b.callback.call(b.scope, a)
        }
    }, parseData: function (a) {
        var b =
            a.responseXML;
        if (!b || !b.documentElement)b = a.responseText;
        return !b || 0 >= b.length ? null : this.format.read(b)
    }, CLASS_NAME: "OpenLayers.Protocol.CSW.v2_0_2"
});
OpenLayers.Protocol.Script = OpenLayers.Class(OpenLayers.Protocol, {
    url: null,
    params: null,
    callback: null,
    callbackTemplate: "OpenLayers.Protocol.Script.registry.${id}",
    callbackKey: "callback",
    callbackPrefix: "",
    scope: null,
    format: null,
    pendingRequests: null,
    srsInBBOX: !1,
    initialize: function (a) {
        a = a || {};
        this.params = {};
        this.pendingRequests = {};
        OpenLayers.Protocol.prototype.initialize.apply(this, arguments);
        this.format || (this.format = new OpenLayers.Format.GeoJSON);
        if (!this.filterToParams && OpenLayers.Format.QueryStringFilter) {
            var b =
                new OpenLayers.Format.QueryStringFilter({srsInBBOX: this.srsInBBOX});
            this.filterToParams = function (a, d) {
                return b.write(a, d)
            }
        }
    },
    read: function (a) {
        OpenLayers.Protocol.prototype.read.apply(this, arguments);
        a = OpenLayers.Util.applyDefaults(a, this.options);
        a.params = OpenLayers.Util.applyDefaults(a.params, this.options.params);
        a.filter && this.filterToParams && (a.params = this.filterToParams(a.filter, a.params));
        var b = new OpenLayers.Protocol.Response({requestType: "read"}), c = this.createRequest(a.url, a.params, OpenLayers.Function.bind(function (c) {
            b.data =
                c;
            this.handleRead(b, a)
        }, this));
        b.priv = c;
        return b
    },
    createRequest: function (a, b, c) {
        var c = OpenLayers.Protocol.Script.register(c), d = OpenLayers.String.format(this.callbackTemplate, {id: c}), b = OpenLayers.Util.extend({}, b);
        b[this.callbackKey] = this.callbackPrefix + d;
        a = OpenLayers.Util.urlAppend(a, OpenLayers.Util.getParameterString(b));
        b = document.createElement("script");
        b.type = "text/javascript";
        b.src = a;
        b.id = "OpenLayers_Protocol_Script_" + c;
        this.pendingRequests[b.id] = b;
        document.getElementsByTagName("head")[0].appendChild(b);
        return b
    },
    destroyRequest: function (a) {
        OpenLayers.Protocol.Script.unregister(a.id.split("_").pop());
        delete this.pendingRequests[a.id];
        a.parentNode && a.parentNode.removeChild(a)
    },
    handleRead: function (a, b) {
        this.handleResponse(a, b)
    },
    handleResponse: function (a, b) {
        b.callback && (a.data ? (a.features = this.parseFeatures(a.data), a.code = OpenLayers.Protocol.Response.SUCCESS) : a.code = OpenLayers.Protocol.Response.FAILURE, this.destroyRequest(a.priv), b.callback.call(b.scope, a))
    },
    parseFeatures: function (a) {
        return this.format.read(a)
    },
    abort: function (a) {
        if (a)this.destroyRequest(a.priv); else for (var b in this.pendingRequests)this.destroyRequest(this.pendingRequests[b])
    },
    destroy: function () {
        this.abort();
        delete this.params;
        delete this.format;
        OpenLayers.Protocol.prototype.destroy.apply(this)
    },
    CLASS_NAME: "OpenLayers.Protocol.Script"
});
(function () {
    var a = OpenLayers.Protocol.Script, b = 0;
    a.registry = {};
    a.register = function (c) {
        var d = "c" + ++b;
        a.registry[d] = function () {
            c.apply(this, arguments)
        };
        return d
    };
    a.unregister = function (b) {
        delete a.registry[b]
    }
})();
OpenLayers.Protocol.SOS = function (a) {
    var a = OpenLayers.Util.applyDefaults(a, OpenLayers.Protocol.SOS.DEFAULTS), b = OpenLayers.Protocol.SOS["v" + a.version.replace(/\./g, "_")];
    if (!b)throw"Unsupported SOS version: " + a.version;
    return new b(a)
};
OpenLayers.Protocol.SOS.DEFAULTS = {version: "1.0.0"};
OpenLayers.Protocol.SOS.v1_0_0 = OpenLayers.Class(OpenLayers.Protocol, {
    fois: null, formatOptions: null, initialize: function (a) {
        OpenLayers.Protocol.prototype.initialize.apply(this, [a]);
        a.format || (this.format = new OpenLayers.Format.SOSGetFeatureOfInterest(this.formatOptions))
    }, destroy: function () {
        this.options && !this.options.format && this.format.destroy();
        this.format = null;
        OpenLayers.Protocol.prototype.destroy.apply(this)
    }, read: function (a) {
        a = OpenLayers.Util.extend({}, a);
        OpenLayers.Util.applyDefaults(a, this.options ||
        {});
        var b = new OpenLayers.Protocol.Response({requestType: "read"}), c = this.format, c = OpenLayers.Format.XML.prototype.write.apply(c, [c.writeNode("sos:GetFeatureOfInterest", {fois: this.fois})]);
        b.priv = OpenLayers.Request.POST({url: a.url, callback: this.createCallback(this.handleRead, b, a), data: c});
        return b
    }, handleRead: function (a, b) {
        if (b.callback) {
            var c = a.priv;
            200 <= c.status && 300 > c.status ? (a.features = this.parseFeatures(c), a.code = OpenLayers.Protocol.Response.SUCCESS) : a.code = OpenLayers.Protocol.Response.FAILURE;
            b.callback.call(b.scope, a)
        }
    }, parseFeatures: function (a) {
        var b = a.responseXML;
        if (!b || !b.documentElement)b = a.responseText;
        return !b || 0 >= b.length ? null : this.format.read(b)
    }, CLASS_NAME: "OpenLayers.Protocol.SOS.v1_0_0"
});
OpenLayers.Layer.PointTrack = OpenLayers.Class(OpenLayers.Layer.Vector, {
    dataFrom: null, styleFrom: null, addNodes: function (a, b) {
        if (2 > a.length)throw Error("At least two point features have to be added to create a line from");
        for (var c = Array(a.length - 1), d, e, f, g = 0, h = a.length; g < h; g++) {
            d = a[g];
            if (f = d.geometry) {
                if ("OpenLayers.Geometry.Point" != f.CLASS_NAME)throw new TypeError("Only features with point geometries are supported.");
            } else f = d.lonlat, f = new OpenLayers.Geometry.Point(f.lon, f.lat);
            if (0 < g) {
                d = null != this.dataFrom ?
                a[g + this.dataFrom].data || a[g + this.dataFrom].attributes : null;
                var k = null != this.styleFrom ? a[g + this.styleFrom].style : null;
                e = new OpenLayers.Geometry.LineString([e, f]);
                c[g - 1] = new OpenLayers.Feature.Vector(e, d, k)
            }
            e = f
        }
        this.addFeatures(c, b)
    }, CLASS_NAME: "OpenLayers.Layer.PointTrack"
});
OpenLayers.Layer.PointTrack.SOURCE_NODE = -1;
OpenLayers.Layer.PointTrack.TARGET_NODE = 0;
OpenLayers.Layer.PointTrack.dataFrom = {SOURCE_NODE: -1, TARGET_NODE: 0};
OpenLayers.Style = OpenLayers.Class({
    id: null,
    name: null,
    title: null,
    description: null,
    layerName: null,
    isDefault: !1,
    rules: null,
    context: null,
    defaultStyle: null,
    defaultsPerSymbolizer: !1,
    propertyStyles: null,
    initialize: function (a, b) {
        OpenLayers.Util.extend(this, b);
        this.rules = [];
        b && b.rules && this.addRules(b.rules);
        this.setDefaultStyle(a || OpenLayers.Feature.Vector.style["default"]);
        this.id = OpenLayers.Util.createUniqueID(this.CLASS_NAME + "_")
    },
    destroy: function () {
        for (var a = 0, b = this.rules.length; a < b; a++)this.rules[a].destroy(),
            this.rules[a] = null;
        this.defaultStyle = this.rules = null
    },
    createSymbolizer: function (a) {
        for (var b = this.defaultsPerSymbolizer ? {} : this.createLiterals(OpenLayers.Util.extend({}, this.defaultStyle), a), c = this.rules, d, e = [], f = !1, g = 0, h = c.length; g < h; g++)d = c[g], d.evaluate(a) && (d instanceof OpenLayers.Rule && d.elseFilter ? e.push(d) : (f = !0, this.applySymbolizer(d, b, a)));
        if (!1 == f && 0 < e.length) {
            f = !0;
            g = 0;
            for (h = e.length; g < h; g++)this.applySymbolizer(e[g], b, a)
        }
        0 < c.length && !1 == f && (b.display = "none");
        null != b.label && "string" !== typeof b.label &&
        (b.label = "" + b.label);
        return b
    },
    applySymbolizer: function (a, b, c) {
        var d = c.geometry ? this.getSymbolizerPrefix(c.geometry) : OpenLayers.Style.SYMBOLIZER_PREFIXES[0], a = a.symbolizer[d] || a.symbolizer;
        !0 === this.defaultsPerSymbolizer && (d = this.defaultStyle, OpenLayers.Util.applyDefaults(a, {pointRadius: d.pointRadius}), (!0 === a.stroke || !0 === a.graphic) && OpenLayers.Util.applyDefaults(a, {
            strokeWidth: d.strokeWidth,
            strokeColor: d.strokeColor,
            strokeOpacity: d.strokeOpacity,
            strokeDashstyle: d.strokeDashstyle,
            strokeLinecap: d.strokeLinecap
        }),
        (!0 === a.fill || !0 === a.graphic) && OpenLayers.Util.applyDefaults(a, {
            fillColor: d.fillColor,
            fillOpacity: d.fillOpacity
        }), !0 === a.graphic && OpenLayers.Util.applyDefaults(a, {
            pointRadius: this.defaultStyle.pointRadius,
            externalGraphic: this.defaultStyle.externalGraphic,
            graphicName: this.defaultStyle.graphicName,
            graphicOpacity: this.defaultStyle.graphicOpacity,
            graphicWidth: this.defaultStyle.graphicWidth,
            graphicHeight: this.defaultStyle.graphicHeight,
            graphicXOffset: this.defaultStyle.graphicXOffset,
            graphicYOffset: this.defaultStyle.graphicYOffset
        }));
        return this.createLiterals(OpenLayers.Util.extend(b, a), c)
    },
    createLiterals: function (a, b) {
        var c = OpenLayers.Util.extend({}, b.attributes || b.data);
        OpenLayers.Util.extend(c, this.context);
        for (var d in this.propertyStyles)a[d] = OpenLayers.Style.createLiteral(a[d], c, b, d);
        return a
    },
    findPropertyStyles: function () {
        var a = {};
        this.addPropertyStyles(a, this.defaultStyle);
        for (var b = this.rules, c, d, e = 0, f = b.length; e < f; e++) {
            c = b[e].symbolizer;
            for (var g in c)if (d = c[g], "object" == typeof d)this.addPropertyStyles(a, d); else {
                this.addPropertyStyles(a,
                    c);
                break
            }
        }
        return a
    },
    addPropertyStyles: function (a, b) {
        var c, d;
        for (d in b)c = b[d], "string" == typeof c && c.match(/\$\{\w+\}/) && (a[d] = !0);
        return a
    },
    addRules: function (a) {
        Array.prototype.push.apply(this.rules, a);
        this.propertyStyles = this.findPropertyStyles()
    },
    setDefaultStyle: function (a) {
        this.defaultStyle = a;
        this.propertyStyles = this.findPropertyStyles()
    },
    getSymbolizerPrefix: function (a) {
        for (var b = OpenLayers.Style.SYMBOLIZER_PREFIXES, c = 0, d = b.length; c < d; c++)if (-1 != a.CLASS_NAME.indexOf(b[c]))return b[c]
    },
    clone: function () {
        var a =
            OpenLayers.Util.extend({}, this);
        if (this.rules) {
            a.rules = [];
            for (var b = 0, c = this.rules.length; b < c; ++b)a.rules.push(this.rules[b].clone())
        }
        a.context = this.context && OpenLayers.Util.extend({}, this.context);
        b = OpenLayers.Util.extend({}, this.defaultStyle);
        return new OpenLayers.Style(b, a)
    },
    CLASS_NAME: "OpenLayers.Style"
});
OpenLayers.Style.createLiteral = function (a, b, c, d) {
    "string" == typeof a && -1 != a.indexOf("${") && (a = OpenLayers.String.format(a, b, [c, d]), a = isNaN(a) || !a ? a : parseFloat(a));
    return a
};
OpenLayers.Style.SYMBOLIZER_PREFIXES = ["Point", "Line", "Polygon", "Text", "Raster"];
OpenLayers.Style2 = OpenLayers.Class({
    id: null,
    name: null,
    title: null,
    description: null,
    layerName: null,
    isDefault: !1,
    rules: null,
    initialize: function (a) {
        OpenLayers.Util.extend(this, a);
        this.id = OpenLayers.Util.createUniqueID(this.CLASS_NAME + "_")
    },
    destroy: function () {
        for (var a = 0, b = this.rules.length; a < b; a++)this.rules[a].destroy();
        delete this.rules
    },
    clone: function () {
        var a = OpenLayers.Util.extend({}, this);
        if (this.rules) {
            a.rules = [];
            for (var b = 0, c = this.rules.length; b < c; ++b)a.rules.push(this.rules[b].clone())
        }
        return new OpenLayers.Style2(a)
    },
    CLASS_NAME: "OpenLayers.Style2"
});
OpenLayers.StyleMap = OpenLayers.Class({
    styles: null, extendDefault: !0, initialize: function (a, b) {
        this.styles = {
            "default": new OpenLayers.Style(OpenLayers.Feature.Vector.style["default"]),
            select: new OpenLayers.Style(OpenLayers.Feature.Vector.style.select),
            temporary: new OpenLayers.Style(OpenLayers.Feature.Vector.style.temporary),
            "delete": new OpenLayers.Style(OpenLayers.Feature.Vector.style["delete"])
        };
        if (a instanceof OpenLayers.Style)this.styles["default"] = a, this.styles.select = a, this.styles.temporary = a, this.styles["delete"] =
            a; else if ("object" == typeof a)for (var c in a)if (a[c]instanceof OpenLayers.Style)this.styles[c] = a[c]; else if ("object" == typeof a[c])this.styles[c] = new OpenLayers.Style(a[c]); else {
            this.styles["default"] = new OpenLayers.Style(a);
            this.styles.select = new OpenLayers.Style(a);
            this.styles.temporary = new OpenLayers.Style(a);
            this.styles["delete"] = new OpenLayers.Style(a);
            break
        }
        OpenLayers.Util.extend(this, b)
    }, destroy: function () {
        for (var a in this.styles)this.styles[a].destroy();
        this.styles = null
    }, createSymbolizer: function (a,
                                   b) {
        a || (a = new OpenLayers.Feature.Vector);
        this.styles[b] || (b = "default");
        a.renderIntent = b;
        var c = {};
        this.extendDefault && "default" != b && (c = this.styles["default"].createSymbolizer(a));
        return OpenLayers.Util.extend(c, this.styles[b].createSymbolizer(a))
    }, addUniqueValueRules: function (a, b, c, d) {
        var e = [], f;
        for (f in c)e.push(new OpenLayers.Rule({
            symbolizer: c[f],
            context: d,
            filter: new OpenLayers.Filter.Comparison({
                type: OpenLayers.Filter.Comparison.EQUAL_TO,
                property: b,
                value: f
            })
        }));
        this.styles[a].addRules(e)
    }, CLASS_NAME: "OpenLayers.StyleMap"
});
OpenLayers.Rule = OpenLayers.Class({
    id: null,
    name: null,
    title: null,
    description: null,
    context: null,
    filter: null,
    elseFilter: !1,
    symbolizer: null,
    symbolizers: null,
    minScaleDenominator: null,
    maxScaleDenominator: null,
    initialize: function (a) {
        this.symbolizer = {};
        OpenLayers.Util.extend(this, a);
        this.symbolizers && delete this.symbolizer;
        this.id = OpenLayers.Util.createUniqueID(this.CLASS_NAME + "_")
    },
    destroy: function () {
        for (var a in this.symbolizer)this.symbolizer[a] = null;
        this.symbolizer = null;
        delete this.symbolizers
    },
    evaluate: function (a) {
        var b =
            this.getContext(a), c = !0;
        if (this.minScaleDenominator || this.maxScaleDenominator)var d = a.layer.map.getScale();
        this.minScaleDenominator && (c = d >= OpenLayers.Style.createLiteral(this.minScaleDenominator, b));
        c && this.maxScaleDenominator && (c = d < OpenLayers.Style.createLiteral(this.maxScaleDenominator, b));
        c && this.filter && (c = "OpenLayers.Filter.FeatureId" == this.filter.CLASS_NAME ? this.filter.evaluate(a) : this.filter.evaluate(b));
        return c
    },
    getContext: function (a) {
        var b = this.context;
        b || (b = a.attributes || a.data);
        "function" == typeof this.context && (b = this.context(a));
        return b
    },
    clone: function () {
        var a = OpenLayers.Util.extend({}, this);
        if (this.symbolizers) {
            var b = this.symbolizers.length;
            a.symbolizers = Array(b);
            for (var c = 0; c < b; ++c)a.symbolizers[c] = this.symbolizers[c].clone()
        } else {
            a.symbolizer = {};
            for (var d in this.symbolizer)b = this.symbolizer[d], c = typeof b, "object" === c ? a.symbolizer[d] = OpenLayers.Util.extend({}, b) : "string" === c && (a.symbolizer[d] = b)
        }
        a.filter = this.filter && this.filter.clone();
        a.context = this.context && OpenLayers.Util.extend({},
            this.context);
        return new OpenLayers.Rule(a)
    },
    CLASS_NAME: "OpenLayers.Rule"
});
OpenLayers.Format = OpenLayers.Class({
    options: null,
    externalProjection: null,
    internalProjection: null,
    data: null,
    keepData: !1,
    initialize: function (a) {
        OpenLayers.Util.extend(this, a);
        this.options = a
    },
    destroy: function () {
    },
    read: function () {
        throw Error("Read not implemented.");
    },
    write: function () {
        throw Error("Write not implemented.");
    },
    CLASS_NAME: "OpenLayers.Format"
});
OpenLayers.Format.QueryStringFilter = function () {
    function a(a) {
        a = a.replace(/%/g, "\\%");
        a = a.replace(/\\\\\.(\*)?/g, function (a, b) {
            return b ? a : "\\\\_"
        });
        a = a.replace(/\\\\\.\*/g, "\\\\%");
        a = a.replace(/(\\)?\.(\*)?/g, function (a, b, c) {
            return b || c ? a : "_"
        });
        a = a.replace(/(\\)?\.\*/g, function (a, b) {
            return b ? a : "%"
        });
        a = a.replace(/\\\./g, ".");
        return a = a.replace(/(\\)?\\\*/g, function (a, b) {
            return b ? a : "*"
        })
    }

    var b = {};
    b[OpenLayers.Filter.Comparison.EQUAL_TO] = "eq";
    b[OpenLayers.Filter.Comparison.NOT_EQUAL_TO] = "ne";
    b[OpenLayers.Filter.Comparison.LESS_THAN] =
        "lt";
    b[OpenLayers.Filter.Comparison.LESS_THAN_OR_EQUAL_TO] = "lte";
    b[OpenLayers.Filter.Comparison.GREATER_THAN] = "gt";
    b[OpenLayers.Filter.Comparison.GREATER_THAN_OR_EQUAL_TO] = "gte";
    b[OpenLayers.Filter.Comparison.LIKE] = "ilike";
    return OpenLayers.Class(OpenLayers.Format, {
        wildcarded: !1, srsInBBOX: !1, write: function (c, d) {
            var d = d || {}, e = c.CLASS_NAME, e = e.substring(e.lastIndexOf(".") + 1);
            switch (e) {
                case "Spatial":
                    switch (c.type) {
                        case OpenLayers.Filter.Spatial.BBOX:
                            d.bbox = c.value.toArray();
                            this.srsInBBOX && c.projection &&
                            d.bbox.push(c.projection.getCode());
                            break;
                        case OpenLayers.Filter.Spatial.DWITHIN:
                            d.tolerance = c.distance;
                        case OpenLayers.Filter.Spatial.WITHIN:
                            d.lon = c.value.x;
                            d.lat = c.value.y;
                            break;
                        default:
                            OpenLayers.Console.warn("Unknown spatial filter type " + c.type)
                    }
                    break;
                case "Comparison":
                    e = b[c.type];
                    if (void 0 !== e) {
                        var f = c.value;
                        c.type == OpenLayers.Filter.Comparison.LIKE && (f = a(f), this.wildcarded && (f = "%" + f + "%"));
                        d[c.property + "__" + e] = f;
                        d.queryable = d.queryable || [];
                        d.queryable.push(c.property)
                    } else OpenLayers.Console.warn("Unknown comparison filter type " +
                    c.type);
                    break;
                case "Logical":
                    if (c.type === OpenLayers.Filter.Logical.AND) {
                        e = 0;
                        for (f = c.filters.length; e < f; e++)d = this.write(c.filters[e], d)
                    } else OpenLayers.Console.warn("Unsupported logical filter type " + c.type);
                    break;
                default:
                    OpenLayers.Console.warn("Unknown filter type " + e)
            }
            return d
        }, CLASS_NAME: "OpenLayers.Format.QueryStringFilter"
    })
}();
OpenLayers.Format.XML = OpenLayers.Class(OpenLayers.Format, {
    namespaces: null,
    namespaceAlias: null,
    defaultPrefix: null,
    readers: {},
    writers: {},
    xmldom: null,
    initialize: function (a) {
        window.ActiveXObject && (this.xmldom = new ActiveXObject("Microsoft.XMLDOM"));
        OpenLayers.Format.prototype.initialize.apply(this, [a]);
        this.namespaces = OpenLayers.Util.extend({}, this.namespaces);
        this.namespaceAlias = {};
        for (var b in this.namespaces)this.namespaceAlias[this.namespaces[b]] = b
    },
    destroy: function () {
        this.xmldom = null;
        OpenLayers.Format.prototype.destroy.apply(this,
            arguments)
    },
    setNamespace: function (a, b) {
        this.namespaces[a] = b;
        this.namespaceAlias[b] = a
    },
    read: function (a) {
        var b = a.indexOf("<");
        0 < b && (a = a.substring(b));
        b = OpenLayers.Util.Try(OpenLayers.Function.bind(function () {
            var b;
            b = window.ActiveXObject && !this.xmldom ? new ActiveXObject("Microsoft.XMLDOM") : this.xmldom;
            b.loadXML(a);
            return b
        }, this), function () {
            return (new DOMParser).parseFromString(a, "text/xml")
        }, function () {
            var b = new XMLHttpRequest;
            b.open("GET", "data:text/xml;charset=utf-8," + encodeURIComponent(a), !1);
            b.overrideMimeType &&
            b.overrideMimeType("text/xml");
            b.send(null);
            return b.responseXML
        });
        this.keepData && (this.data = b);
        return b
    },
    write: function (a) {
        if (this.xmldom)a = a.xml; else {
            var b = new XMLSerializer;
            if (1 == a.nodeType) {
                var c = document.implementation.createDocument("", "", null);
                c.importNode && (a = c.importNode(a, !0));
                c.appendChild(a);
                a = b.serializeToString(c)
            } else a = b.serializeToString(a)
        }
        return a
    },
    createElementNS: function (a, b) {
        return this.xmldom ? "string" == typeof a ? this.xmldom.createNode(1, b, a) : this.xmldom.createNode(1, b, "") : document.createElementNS(a,
            b)
    },
    createTextNode: function (a) {
        "string" !== typeof a && (a = "" + a);
        return this.xmldom ? this.xmldom.createTextNode(a) : document.createTextNode(a)
    },
    getElementsByTagNameNS: function (a, b, c) {
        var d = [];
        if (a.getElementsByTagNameNS)d = a.getElementsByTagNameNS(b, c); else for (var a = a.getElementsByTagName("*"), e, f, g = 0, h = a.length; g < h; ++g)if (e = a[g], f = e.prefix ? e.prefix + ":" + c : c, "*" == c || f == e.nodeName)("*" == b || b == e.namespaceURI) && d.push(e);
        return d
    },
    getAttributeNodeNS: function (a, b, c) {
        var d = null;
        if (a.getAttributeNodeNS)d = a.getAttributeNodeNS(b,
            c); else for (var a = a.attributes, e, f, g = 0, h = a.length; g < h; ++g)if (e = a[g], e.namespaceURI == b && (f = e.prefix ? e.prefix + ":" + c : c, f == e.nodeName)) {
            d = e;
            break
        }
        return d
    },
    getAttributeNS: function (a, b, c) {
        var d = "";
        if (a.getAttributeNS)d = a.getAttributeNS(b, c) || ""; else if (a = this.getAttributeNodeNS(a, b, c))d = a.nodeValue;
        return d
    },
    getChildValue: function (a, b) {
        var c = b || "";
        if (a)for (var d = a.firstChild; d; d = d.nextSibling)switch (d.nodeType) {
            case 3:
            case 4:
                c += d.nodeValue
        }
        return c
    },
    isSimpleContent: function (a) {
        for (var b = !0, a = a.firstChild; a; a =
            a.nextSibling)if (1 === a.nodeType) {
            b = !1;
            break
        }
        return b
    },
    contentType: function (a) {
        for (var b = !1, c = !1, d = OpenLayers.Format.XML.CONTENT_TYPE.EMPTY, a = a.firstChild; a; a = a.nextSibling) {
            switch (a.nodeType) {
                case 1:
                    c = !0;
                    break;
                case 8:
                    break;
                default:
                    b = !0
            }
            if (c && b)break
        }
        if (c && b)d = OpenLayers.Format.XML.CONTENT_TYPE.MIXED; else {
            if (c)return OpenLayers.Format.XML.CONTENT_TYPE.COMPLEX;
            if (b)return OpenLayers.Format.XML.CONTENT_TYPE.SIMPLE
        }
        return d
    },
    hasAttributeNS: function (a, b, c) {
        return a.hasAttributeNS ? a.hasAttributeNS(b, c) :
            !!this.getAttributeNodeNS(a, b, c)
    },
    setAttributeNS: function (a, b, c, d) {
        if (a.setAttributeNS)a.setAttributeNS(b, c, d); else if (this.xmldom)b ? (b = a.ownerDocument.createNode(2, c, b), b.nodeValue = d, a.setAttributeNode(b)) : a.setAttribute(c, d); else throw"setAttributeNS not implemented";
    },
    createElementNSPlus: function (a, b) {
        var b = b || {}, c = b.uri || this.namespaces[b.prefix];
        c || (c = a.indexOf(":"), c = this.namespaces[a.substring(0, c)]);
        c || (c = this.namespaces[this.defaultPrefix]);
        c = this.createElementNS(c, a);
        b.attributes && this.setAttributes(c,
            b.attributes);
        var d = b.value;
        null != d && c.appendChild(this.createTextNode(d));
        return c
    },
    setAttributes: function (a, b) {
        var c, d, e;
        for (e in b)null != b[e] && b[e].toString && (c = b[e].toString(), d = this.namespaces[e.substring(0, e.indexOf(":"))] || null, this.setAttributeNS(a, d, e, c))
    },
    readNode: function (a, b) {
        b || (b = {});
        var c = this.readers[a.namespaceURI ? this.namespaceAlias[a.namespaceURI] : this.defaultPrefix];
        if (c) {
            var d = a.localName || a.nodeName.split(":").pop();
            (c = c[d] || c["*"]) && c.apply(this, [a, b])
        }
        return b
    },
    readChildNodes: function (a,
                              b) {
        b || (b = {});
        for (var c = a.childNodes, d, e = 0, f = c.length; e < f; ++e)d = c[e], 1 == d.nodeType && this.readNode(d, b);
        return b
    },
    writeNode: function (a, b, c) {
        var d, e = a.indexOf(":");
        0 < e ? (d = a.substring(0, e), a = a.substring(e + 1)) : d = c ? this.namespaceAlias[c.namespaceURI] : this.defaultPrefix;
        b = this.writers[d][a].apply(this, [b]);
        c && c.appendChild(b);
        return b
    },
    getChildEl: function (a, b, c) {
        return a && this.getThisOrNextEl(a.firstChild, b, c)
    },
    getNextEl: function (a, b, c) {
        return a && this.getThisOrNextEl(a.nextSibling, b, c)
    },
    getThisOrNextEl: function (a,
                               b, c) {
        a:for (; a; a = a.nextSibling)switch (a.nodeType) {
            case 1:
                if ((!b || b === (a.localName || a.nodeName.split(":").pop())) && (!c || c === a.namespaceURI))break a;
                a = null;
                break a;
            case 3:
                if (/^\s*$/.test(a.nodeValue))break;
            case 4:
            case 6:
            case 12:
            case 10:
            case 11:
                a = null;
                break a
        }
        return a || null
    },
    lookupNamespaceURI: function (a, b) {
        var c = null;
        if (a)if (a.lookupNamespaceURI)c = a.lookupNamespaceURI(b); else a:switch (a.nodeType) {
            case 1:
                if (null !== a.namespaceURI && a.prefix === b) {
                    c = a.namespaceURI;
                    break a
                }
                if (c = a.attributes.length)for (var d,
                                                     e = 0; e < c; ++e)if (d = a.attributes[e], "xmlns" === d.prefix && d.name === "xmlns:" + b) {
                    c = d.value || null;
                    break a
                } else if ("xmlns" === d.name && null === b) {
                    c = d.value || null;
                    break a
                }
                c = this.lookupNamespaceURI(a.parentNode, b);
                break a;
            case 2:
                c = this.lookupNamespaceURI(a.ownerElement, b);
                break a;
            case 9:
                c = this.lookupNamespaceURI(a.documentElement, b);
                break a;
            case 6:
            case 12:
            case 10:
            case 11:
                break a;
            default:
                c = this.lookupNamespaceURI(a.parentNode, b)
        }
        return c
    },
    getXMLDoc: function () {
        !OpenLayers.Format.XML.document && !this.xmldom && (document.implementation &&
        document.implementation.createDocument ? OpenLayers.Format.XML.document = document.implementation.createDocument("", "", null) : !this.xmldom && window.ActiveXObject && (this.xmldom = new ActiveXObject("Microsoft.XMLDOM")));
        return OpenLayers.Format.XML.document || this.xmldom
    },
    CLASS_NAME: "OpenLayers.Format.XML"
});
OpenLayers.Format.XML.CONTENT_TYPE = {EMPTY: 0, SIMPLE: 1, COMPLEX: 2, MIXED: 3};
OpenLayers.Format.XML.lookupNamespaceURI = OpenLayers.Function.bind(OpenLayers.Format.XML.prototype.lookupNamespaceURI, OpenLayers.Format.XML.prototype);
OpenLayers.Format.XML.document = null;
OpenLayers.Format.XML.VersionedOGC = OpenLayers.Class(OpenLayers.Format.XML, {
    defaultVersion: null,
    version: null,
    profile: null,
    errorProperty: null,
    name: null,
    stringifyOutput: !1,
    parser: null,
    initialize: function (a) {
        OpenLayers.Format.XML.prototype.initialize.apply(this, [a]);
        a = this.CLASS_NAME;
        this.name = a.substring(a.lastIndexOf(".") + 1)
    },
    getVersion: function (a, b) {
        var c;
        a ? (c = this.version, c || (c = a.getAttribute("version"), c || (c = this.defaultVersion))) : c = b && b.version || this.version || this.defaultVersion;
        return c
    },
    getParser: function (a) {
        var a =
            a || this.defaultVersion, b = this.profile ? "_" + this.profile : "";
        if (!this.parser || this.parser.VERSION != a) {
            var c = OpenLayers.Format[this.name]["v" + a.replace(/\./g, "_") + b];
            if (!c)throw"Can't find a " + this.name + " parser for version " + a + b;
            this.parser = new c(this.options)
        }
        return this.parser
    },
    write: function (a, b) {
        this.parser = this.getParser(this.getVersion(null, b));
        var c = this.parser.write(a, b);
        return !1 === this.stringifyOutput ? c : OpenLayers.Format.XML.prototype.write.apply(this, [c])
    },
    read: function (a, b) {
        "string" == typeof a &&
        (a = OpenLayers.Format.XML.prototype.read.apply(this, [a]));
        var c = this.getVersion(a.documentElement);
        this.parser = this.getParser(c);
        var d = this.parser.read(a, b);
        if (null !== this.errorProperty && void 0 === d[this.errorProperty]) {
            var e = new OpenLayers.Format.OGCExceptionReport;
            d.error = e.read(a)
        }
        d.version = c;
        return d
    },
    CLASS_NAME: "OpenLayers.Format.XML.VersionedOGC"
});
OpenLayers.Format.Context = OpenLayers.Class(OpenLayers.Format.XML.VersionedOGC, {
    layerOptions: null, layerParams: null, read: function (a, b) {
        var c = OpenLayers.Format.XML.VersionedOGC.prototype.read.apply(this, arguments);
        if (b && b.map)if (this.context = c, b.map instanceof OpenLayers.Map)c = this.mergeContextToMap(c, b.map); else {
            var d = b.map;
            if (OpenLayers.Util.isElement(d) || "string" == typeof d)d = {div: d};
            c = this.contextToMap(c, d)
        }
        return c
    }, getLayerFromContext: function (a) {
        var b, c, d = {
            queryable: a.queryable,
            visibility: a.visibility,
            maxExtent: a.maxExtent,
            metadata: OpenLayers.Util.applyDefaults(a.metadata, {
                styles: a.styles,
                formats: a.formats,
                "abstract": a["abstract"],
                dataURL: a.dataURL
            }),
            numZoomLevels: a.numZoomLevels,
            units: a.units,
            isBaseLayer: a.isBaseLayer,
            opacity: a.opacity,
            displayInLayerSwitcher: a.displayInLayerSwitcher,
            singleTile: a.singleTile,
            tileSize: a.tileSize ? new OpenLayers.Size(a.tileSize.width, a.tileSize.height) : void 0,
            minScale: a.minScale || a.maxScaleDenominator,
            maxScale: a.maxScale || a.minScaleDenominator,
            srs: a.srs,
            dimensions: a.dimensions,
            metadataURL: a.metadataURL
        };
        this.layerOptions && OpenLayers.Util.applyDefaults(d, this.layerOptions);
        var e = {layers: a.name, transparent: a.transparent, version: a.version};
        if (a.formats && 0 < a.formats.length) {
            e.format = a.formats[0].value;
            for (b = 0, c = a.formats.length; b < c; b++) {
                var f = a.formats[b];
                if (!0 == f.current) {
                    e.format = f.value;
                    break
                }
            }
        }
        if (a.styles && 0 < a.styles.length)for (b = 0, c = a.styles.length; b < c; b++)if (f = a.styles[b], !0 == f.current) {
            f.href ? e.sld = f.href : f.body ? e.sld_body = f.body : e.styles = f.name;
            break
        }
        this.layerParams &&
        OpenLayers.Util.applyDefaults(e, this.layerParams);
        b = null;
        c = a.service;
        c == OpenLayers.Format.Context.serviceTypes.WFS ? (d.strategies = [new OpenLayers.Strategy.BBOX], d.protocol = new OpenLayers.Protocol.WFS({
            url: a.url,
            featurePrefix: a.name.split(":")[0],
            featureType: a.name.split(":").pop()
        }), b = new OpenLayers.Layer.Vector(a.title || a.name, d)) : c == OpenLayers.Format.Context.serviceTypes.KML ? (d.strategies = [new OpenLayers.Strategy.Fixed], d.protocol = new OpenLayers.Protocol.HTTP({
            url: a.url,
            format: new OpenLayers.Format.KML
        }),
            b = new OpenLayers.Layer.Vector(a.title || a.name, d)) : c == OpenLayers.Format.Context.serviceTypes.GML ? (d.strategies = [new OpenLayers.Strategy.Fixed], d.protocol = new OpenLayers.Protocol.HTTP({
            url: a.url,
            format: new OpenLayers.Format.GML
        }), b = new OpenLayers.Layer.Vector(a.title || a.name, d)) : a.features ? (b = new OpenLayers.Layer.Vector(a.title || a.name, d), b.addFeatures(a.features)) : !0 !== a.categoryLayer && (b = new OpenLayers.Layer.WMS(a.title || a.name, a.url, e, d));
        return b
    }, getLayersFromContext: function (a) {
        for (var b = [], c =
            0, d = a.length; c < d; c++) {
            var e = this.getLayerFromContext(a[c]);
            null !== e && b.push(e)
        }
        return b
    }, contextToMap: function (a, b) {
        b = OpenLayers.Util.applyDefaults({maxExtent: a.maxExtent, projection: a.projection, units: a.units}, b);
        b.maxExtent && (b.maxResolution = b.maxExtent.getWidth() / OpenLayers.Map.TILE_WIDTH);
        b.metadata = {
            contactInformation: a.contactInformation,
            "abstract": a["abstract"],
            keywords: a.keywords,
            logo: a.logo,
            descriptionURL: a.descriptionURL
        };
        var c = new OpenLayers.Map(b);
        c.addLayers(this.getLayersFromContext(a.layersContext));
        c.setCenter(a.bounds.getCenterLonLat(), c.getZoomForExtent(a.bounds, !0));
        return c
    }, mergeContextToMap: function (a, b) {
        b.addLayers(this.getLayersFromContext(a.layersContext));
        return b
    }, write: function (a, b) {
        a = this.toContext(a);
        return OpenLayers.Format.XML.VersionedOGC.prototype.write.apply(this, arguments)
    }, CLASS_NAME: "OpenLayers.Format.Context"
});
OpenLayers.Format.Context.serviceTypes = {
    WMS: "urn:ogc:serviceType:WMS",
    WFS: "urn:ogc:serviceType:WFS",
    WCS: "urn:ogc:serviceType:WCS",
    GML: "urn:ogc:serviceType:GML",
    SLD: "urn:ogc:serviceType:SLD",
    FES: "urn:ogc:serviceType:FES",
    KML: "urn:ogc:serviceType:KML"
};
OpenLayers.Format.ArcXML = OpenLayers.Class(OpenLayers.Format.XML, {
    fontStyleKeys: "antialiasing,blockout,font,fontcolor,fontsize,fontstyle,glowing,interval,outline,printmode,shadow,transparency".split(","),
    request: null,
    response: null,
    initialize: function (a) {
        this.request = new OpenLayers.Format.ArcXML.Request;
        this.response = new OpenLayers.Format.ArcXML.Response;
        if (a)if ("feature" == a.requesttype) {
            this.request.get_image = null;
            var b = this.request.get_feature.query;
            this.addCoordSys(b.featurecoordsys, a.featureCoordSys);
            this.addCoordSys(b.filtercoordsys, a.filterCoordSys);
            a.polygon ? (b.isspatial = !0, b.spatialfilter.polygon = a.polygon) : a.envelope && (b.isspatial = !0, b.spatialfilter.envelope = {
                minx: 0,
                miny: 0,
                maxx: 0,
                maxy: 0
            }, this.parseEnvelope(b.spatialfilter.envelope, a.envelope))
        } else"image" == a.requesttype ? (this.request.get_feature = null, b = this.request.get_image.properties, this.parseEnvelope(b.envelope, a.envelope), this.addLayers(b.layerlist, a.layers), this.addImageSize(b.imagesize, a.tileSize), this.addCoordSys(b.featurecoordsys,
            a.featureCoordSys), this.addCoordSys(b.filtercoordsys, a.filterCoordSys)) : this.request = null;
        OpenLayers.Format.XML.prototype.initialize.apply(this, [a])
    },
    parseEnvelope: function (a, b) {
        b && 4 == b.length && (a.minx = b[0], a.miny = b[1], a.maxx = b[2], a.maxy = b[3])
    },
    addLayers: function (a, b) {
        for (var c = 0, d = b.length; c < d; c++)a.push(b[c])
    },
    addImageSize: function (a, b) {
        null !== b && (a.width = b.w, a.height = b.h, a.printwidth = b.w, a.printheight = b.h)
    },
    addCoordSys: function (a, b) {
        "string" == typeof b ? (a.id = parseInt(b), a.string = b) : "object" == typeof b &&
        null !== b.proj && (a.id = b.proj.srsProjNumber, a.string = b.proj.srsCode)
    },
    iserror: function (a) {
        var b = null;
        a ? (a = OpenLayers.Format.XML.prototype.read.apply(this, [a]), a = a.documentElement.getElementsByTagName("ERROR"), b = null !== a && 0 < a.length) : b = "" !== this.response.error;
        return b
    },
    read: function (a) {
        "string" == typeof a && (a = OpenLayers.Format.XML.prototype.read.apply(this, [a]));
        var b = null;
        a && a.documentElement && (b = "ARCXML" == a.documentElement.nodeName ? a.documentElement : a.documentElement.getElementsByTagName("ARCXML")[0]);
        if (!b || "parsererror" === b.firstChild.nodeName) {
            var c, d;
            try {
                c = a.firstChild.nodeValue, d = a.firstChild.childNodes[1].firstChild.nodeValue
            } catch (e) {
            }
            throw{message: "Error parsing the ArcXML request", error: c, source: d};
        }
        return this.parseResponse(b)
    },
    write: function (a) {
        a || (a = this.request);
        var b = this.createElementNS("", "ARCXML");
        b.setAttribute("version", "1.1");
        var c = this.createElementNS("", "REQUEST");
        if (null != a.get_image) {
            var d = this.createElementNS("", "GET_IMAGE");
            c.appendChild(d);
            var e = this.createElementNS("",
                "PROPERTIES");
            d.appendChild(e);
            a = a.get_image.properties;
            null != a.featurecoordsys && (d = this.createElementNS("", "FEATURECOORDSYS"), e.appendChild(d), 0 === a.featurecoordsys.id ? d.setAttribute("string", a.featurecoordsys.string) : d.setAttribute("id", a.featurecoordsys.id));
            null != a.filtercoordsys && (d = this.createElementNS("", "FILTERCOORDSYS"), e.appendChild(d), 0 === a.filtercoordsys.id ? d.setAttribute("string", a.filtercoordsys.string) : d.setAttribute("id", a.filtercoordsys.id));
            null != a.envelope && (d = this.createElementNS("",
                "ENVELOPE"), e.appendChild(d), d.setAttribute("minx", a.envelope.minx), d.setAttribute("miny", a.envelope.miny), d.setAttribute("maxx", a.envelope.maxx), d.setAttribute("maxy", a.envelope.maxy));
            d = this.createElementNS("", "IMAGESIZE");
            e.appendChild(d);
            d.setAttribute("height", a.imagesize.height);
            d.setAttribute("width", a.imagesize.width);
            if (a.imagesize.height != a.imagesize.printheight || a.imagesize.width != a.imagesize.printwidth)d.setAttribute("printheight", a.imagesize.printheight), d.setArrtibute("printwidth", a.imagesize.printwidth);
            null != a.background && (d = this.createElementNS("", "BACKGROUND"), e.appendChild(d), d.setAttribute("color", a.background.color.r + "," + a.background.color.g + "," + a.background.color.b), null !== a.background.transcolor && d.setAttribute("transcolor", a.background.transcolor.r + "," + a.background.transcolor.g + "," + a.background.transcolor.b));
            if (null != a.layerlist && 0 < a.layerlist.length) {
                d = this.createElementNS("", "LAYERLIST");
                e.appendChild(d);
                for (e = 0; e < a.layerlist.length; e++) {
                    var f = this.createElementNS("", "LAYERDEF");
                    d.appendChild(f);
                    f.setAttribute("id", a.layerlist[e].id);
                    f.setAttribute("visible", a.layerlist[e].visible);
                    if ("object" == typeof a.layerlist[e].query) {
                        var g = a.layerlist[e].query;
                        if (0 > g.where.length)continue;
                        var h = null, h = "boolean" == typeof g.spatialfilter && g.spatialfilter ? this.createElementNS("", "SPATIALQUERY") : this.createElementNS("", "QUERY");
                        h.setAttribute("where", g.where);
                        "number" == typeof g.accuracy && 0 < g.accuracy && h.setAttribute("accuracy", g.accuracy);
                        "number" == typeof g.featurelimit && 2E3 > g.featurelimit && h.setAttribute("featurelimit",
                            g.featurelimit);
                        "string" == typeof g.subfields && "#ALL#" != g.subfields && h.setAttribute("subfields", g.subfields);
                        "string" == typeof g.joinexpression && 0 < g.joinexpression.length && h.setAttribute("joinexpression", g.joinexpression);
                        "string" == typeof g.jointables && 0 < g.jointables.length && h.setAttribute("jointables", g.jointables);
                        f.appendChild(h)
                    }
                    "object" == typeof a.layerlist[e].renderer && this.addRenderer(f, a.layerlist[e].renderer)
                }
            }
        } else null != a.get_feature && (d = this.createElementNS("", "GET_FEATURES"), d.setAttribute("outputmode",
            "newxml"), d.setAttribute("checkesc", "true"), a.get_feature.geometry ? d.setAttribute("geometry", a.get_feature.geometry) : d.setAttribute("geometry", "false"), a.get_feature.compact && d.setAttribute("compact", a.get_feature.compact), "number" == a.get_feature.featurelimit && d.setAttribute("featurelimit", a.get_feature.featurelimit), d.setAttribute("globalenvelope", "true"), c.appendChild(d), null != a.get_feature.layer && 0 < a.get_feature.layer.length && (e = this.createElementNS("", "LAYER"), e.setAttribute("id", a.get_feature.layer),
            d.appendChild(e)), a = a.get_feature.query, null != a && (e = a.isspatial ? this.createElementNS("", "SPATIALQUERY") : this.createElementNS("", "QUERY"), d.appendChild(e), "number" == typeof a.accuracy && e.setAttribute("accuracy", a.accuracy), null != a.featurecoordsys && (d = this.createElementNS("", "FEATURECOORDSYS"), 0 == a.featurecoordsys.id ? d.setAttribute("string", a.featurecoordsys.string) : d.setAttribute("id", a.featurecoordsys.id), e.appendChild(d)), null != a.filtercoordsys && (d = this.createElementNS("", "FILTERCOORDSYS"), 0 === a.filtercoordsys.id ?
            d.setAttribute("string", a.filtercoordsys.string) : d.setAttribute("id", a.filtercoordsys.id), e.appendChild(d)), 0 < a.buffer && (d = this.createElementNS("", "BUFFER"), d.setAttribute("distance", a.buffer), e.appendChild(d)), a.isspatial && (d = this.createElementNS("", "SPATIALFILTER"), d.setAttribute("relation", a.spatialfilter.relation), e.appendChild(d), a.spatialfilter.envelope ? (f = this.createElementNS("", "ENVELOPE"), f.setAttribute("minx", a.spatialfilter.envelope.minx), f.setAttribute("miny", a.spatialfilter.envelope.miny),
            f.setAttribute("maxx", a.spatialfilter.envelope.maxx), f.setAttribute("maxy", a.spatialfilter.envelope.maxy), d.appendChild(f)) : "object" == typeof a.spatialfilter.polygon && d.appendChild(this.writePolygonGeometry(a.spatialfilter.polygon))), null != a.where && 0 < a.where.length && e.setAttribute("where", a.where)));
        b.appendChild(c);
        return OpenLayers.Format.XML.prototype.write.apply(this, [b])
    },
    addGroupRenderer: function (a, b) {
        var c = this.createElementNS("", "GROUPRENDERER");
        a.appendChild(c);
        for (var d = 0; d < b.length; d++)this.addRenderer(c,
            b[d])
    },
    addRenderer: function (a, b) {
        if (OpenLayers.Util.isArray(b))this.addGroupRenderer(a, b); else {
            var c = this.createElementNS("", b.type.toUpperCase() + "RENDERER");
            a.appendChild(c);
            "VALUEMAPRENDERER" == c.tagName ? this.addValueMapRenderer(c, b) : "VALUEMAPLABELRENDERER" == c.tagName ? this.addValueMapLabelRenderer(c, b) : "SIMPLELABELRENDERER" == c.tagName ? this.addSimpleLabelRenderer(c, b) : "SCALEDEPENDENTRENDERER" == c.tagName && this.addScaleDependentRenderer(c, b)
        }
    },
    addScaleDependentRenderer: function (a, b) {
        ("string" == typeof b.lower ||
        "number" == typeof b.lower) && a.setAttribute("lower", b.lower);
        ("string" == typeof b.upper || "number" == typeof b.upper) && a.setAttribute("upper", b.upper);
        this.addRenderer(a, b.renderer)
    },
    addValueMapLabelRenderer: function (a, b) {
        a.setAttribute("lookupfield", b.lookupfield);
        a.setAttribute("labelfield", b.labelfield);
        if ("object" == typeof b.exacts)for (var c = 0, d = b.exacts.length; c < d; c++) {
            var e = b.exacts[c], f = this.createElementNS("", "EXACT");
            "string" == typeof e.value && f.setAttribute("value", e.value);
            "string" == typeof e.label &&
            f.setAttribute("label", e.label);
            "string" == typeof e.method && f.setAttribute("method", e.method);
            a.appendChild(f);
            if ("object" == typeof e.symbol) {
                var g = null;
                "text" == e.symbol.type && (g = this.createElementNS("", "TEXTSYMBOL"));
                if (null != g) {
                    for (var h = this.fontStyleKeys, k = 0, l = h.length; k < l; k++) {
                        var m = h[k];
                        e.symbol[m] && g.setAttribute(m, e.symbol[m])
                    }
                    f.appendChild(g)
                }
            }
        }
    },
    addValueMapRenderer: function (a, b) {
        a.setAttribute("lookupfield", b.lookupfield);
        if ("object" == typeof b.ranges)for (var c = 0, d = b.ranges.length; c < d; c++) {
            var e =
                b.ranges[c], f = this.createElementNS("", "RANGE");
            f.setAttribute("lower", e.lower);
            f.setAttribute("upper", e.upper);
            a.appendChild(f);
            if ("object" == typeof e.symbol) {
                var g = null;
                "simplepolygon" == e.symbol.type && (g = this.createElementNS("", "SIMPLEPOLYGONSYMBOL"));
                null != g && ("string" == typeof e.symbol.boundarycolor && g.setAttribute("boundarycolor", e.symbol.boundarycolor), "string" == typeof e.symbol.fillcolor && g.setAttribute("fillcolor", e.symbol.fillcolor), "number" == typeof e.symbol.filltransparency && g.setAttribute("filltransparency",
                    e.symbol.filltransparency), f.appendChild(g))
            }
        } else if ("object" == typeof b.exacts) {
            c = 0;
            for (d = b.exacts.length; c < d; c++)e = b.exacts[c], f = this.createElementNS("", "EXACT"), "string" == typeof e.value && f.setAttribute("value", e.value), "string" == typeof e.label && f.setAttribute("label", e.label), "string" == typeof e.method && f.setAttribute("method", e.method), a.appendChild(f), "object" == typeof e.symbol && (g = null, "simplemarker" == e.symbol.type && (g = this.createElementNS("", "SIMPLEMARKERSYMBOL")), null != g && ("string" == typeof e.symbol.antialiasing &&
            g.setAttribute("antialiasing", e.symbol.antialiasing), "string" == typeof e.symbol.color && g.setAttribute("color", e.symbol.color), "string" == typeof e.symbol.outline && g.setAttribute("outline", e.symbol.outline), "string" == typeof e.symbol.overlap && g.setAttribute("overlap", e.symbol.overlap), "string" == typeof e.symbol.shadow && g.setAttribute("shadow", e.symbol.shadow), "number" == typeof e.symbol.transparency && g.setAttribute("transparency", e.symbol.transparency), "string" == typeof e.symbol.usecentroid && g.setAttribute("usecentroid",
                e.symbol.usecentroid), "number" == typeof e.symbol.width && g.setAttribute("width", e.symbol.width), f.appendChild(g)))
        }
    },
    addSimpleLabelRenderer: function (a, b) {
        a.setAttribute("field", b.field);
        for (var c = "featureweight,howmanylabels,labelbufferratio,labelpriorities,labelweight,linelabelposition,rotationalangles".split(","), d = 0, e = c.length; d < e; d++) {
            var f = c[d];
            b[f] && a.setAttribute(f, b[f])
        }
        if ("text" == b.symbol.type) {
            var g = b.symbol, h = this.createElementNS("", "TEXTSYMBOL");
            a.appendChild(h);
            c = this.fontStyleKeys;
            d = 0;
            for (e = c.length; d < e; d++)f = c[d], g[f] && h.setAttribute(f, b[f])
        }
    },
    writePolygonGeometry: function (a) {
        if (!(a instanceof OpenLayers.Geometry.Polygon))throw{
            message: "Cannot write polygon geometry to ArcXML with an " + a.CLASS_NAME + " object.",
            geometry: a
        };
        for (var b = this.createElementNS("", "POLYGON"), c = 0, d = a.components.length; c < d; c++) {
            for (var e = a.components[c], f = this.createElementNS("", "RING"), g = 0, h = e.components.length; g < h; g++) {
                var k = e.components[g], l = this.createElementNS("", "POINT");
                l.setAttribute("x", k.x);
                l.setAttribute("y",
                    k.y);
                f.appendChild(l)
            }
            b.appendChild(f)
        }
        return b
    },
    parseResponse: function (a) {
        "string" == typeof a && (a = (new OpenLayers.Format.XML).read(a));
        var b = new OpenLayers.Format.ArcXML.Response, c = a.getElementsByTagName("ERROR");
        if (null != c && 0 < c.length)b.error = this.getChildValue(c, "Unknown error."); else {
            c = a.getElementsByTagName("RESPONSE");
            if (null == c || 0 == c.length)return b.error = "No RESPONSE tag found in ArcXML response.", b;
            var d = c[0].firstChild.nodeName;
            "#text" == d && (d = c[0].firstChild.nextSibling.nodeName);
            if ("IMAGE" ==
                d)c = a.getElementsByTagName("ENVELOPE"), a = a.getElementsByTagName("OUTPUT"), null == c || 0 == c.length ? b.error = "No ENVELOPE tag found in ArcXML response." : null == a || 0 == a.length ? b.error = "No OUTPUT tag found in ArcXML response." : (c = this.parseAttributes(c[0]), d = this.parseAttributes(a[0]), b.image = "string" == typeof d.type ? {
                envelope: c,
                output: {type: d.type, data: this.getChildValue(a[0])}
            } : {envelope: c, output: d}); else if ("FEATURES" == d) {
                if (a = c[0].getElementsByTagName("FEATURES"), c = a[0].getElementsByTagName("FEATURECOUNT"),
                        b.features.featurecount = c[0].getAttribute("count"), 0 < b.features.featurecount) {
                    c = a[0].getElementsByTagName("ENVELOPE");
                    b.features.envelope = this.parseAttributes(c[0], "number");
                    a = a[0].getElementsByTagName("FEATURE");
                    for (c = 0; c < a.length; c++) {
                        for (var d = new OpenLayers.Feature.Vector, e = a[c].getElementsByTagName("FIELD"), f = 0; f < e.length; f++) {
                            var g = e[f].getAttribute("name"), h = e[f].getAttribute("value");
                            d.attributes[g] = h
                        }
                        e = a[c].getElementsByTagName("POLYGON");
                        if (0 < e.length) {
                            e = e[0].getElementsByTagName("RING");
                            f = [];
                            for (g = 0; g < e.length; g++) {
                                h = [];
                                h.push(this.parsePointGeometry(e[g]));
                                for (var k = e[g].getElementsByTagName("HOLE"), l = 0; l < k.length; l++)h.push(this.parsePointGeometry(k[l]));
                                f.push(new OpenLayers.Geometry.Polygon(h))
                            }
                            d.geometry = 1 == f.length ? f[0] : new OpenLayers.Geometry.MultiPolygon(f)
                        }
                        b.features.feature.push(d)
                    }
                }
            } else b.error = "Unidentified response type."
        }
        return b
    },
    parseAttributes: function (a, b) {
        for (var c = {}, d = 0; d < a.attributes.length; d++)c[a.attributes[d].nodeName] = "number" == b ? parseFloat(a.attributes[d].nodeValue) :
            a.attributes[d].nodeValue;
        return c
    },
    parsePointGeometry: function (a) {
        var b = [], c = a.getElementsByTagName("COORDS");
        if (0 < c.length) {
            a = this.getChildValue(c[0]);
            a = a.split(/;/);
            for (c = 0; c < a.length; c++) {
                var d = a[c].split(/ /);
                b.push(new OpenLayers.Geometry.Point(d[0], d[1]))
            }
        } else if (a = a.getElementsByTagName("POINT"), 0 < a.length)for (c = 0; c < a.length; c++)b.push(new OpenLayers.Geometry.Point(parseFloat(a[c].getAttribute("x")), parseFloat(a[c].getAttribute("y"))));
        return new OpenLayers.Geometry.LinearRing(b)
    },
    CLASS_NAME: "OpenLayers.Format.ArcXML"
});
OpenLayers.Format.ArcXML.Request = OpenLayers.Class({
    initialize: function () {
        return OpenLayers.Util.extend(this, {
            get_image: {
                properties: {
                    background: null,
                    draw: !0,
                    envelope: {minx: 0, miny: 0, maxx: 0, maxy: 0},
                    featurecoordsys: {id: 0, string: "", datumtransformid: 0, datumtransformstring: ""},
                    filtercoordsys: {id: 0, string: "", datumtransformid: 0, datumtransformstring: ""},
                    imagesize: {height: 0, width: 0, dpi: 96, printheight: 0, printwidth: 0, scalesymbols: !1},
                    layerlist: [],
                    output: {
                        baseurl: "", legendbaseurl: "", legendname: "", legendpath: "",
                        legendurl: "", name: "", path: "", type: "jpg", url: ""
                    }
                }
            },
            get_feature: {
                layer: "",
                query: {
                    isspatial: !1,
                    featurecoordsys: {id: 0, string: "", datumtransformid: 0, datumtransformstring: ""},
                    filtercoordsys: {id: 0, string: "", datumtransformid: 0, datumtransformstring: ""},
                    buffer: 0,
                    where: "",
                    spatialfilter: {relation: "envelope_intersection", envelope: null}
                }
            },
            environment: {separators: {cs: " ", ts: ";"}},
            layer: [],
            workspaces: []
        })
    }, CLASS_NAME: "OpenLayers.Format.ArcXML.Request"
});
OpenLayers.Format.ArcXML.Response = OpenLayers.Class({
    initialize: function () {
        return OpenLayers.Util.extend(this, {
            image: {envelope: null, output: ""},
            features: {featurecount: 0, envelope: null, feature: []},
            error: ""
        })
    }, CLASS_NAME: "OpenLayers.Format.ArcXML.Response"
});
OpenLayers.Format.ArcXML.Features = OpenLayers.Class(OpenLayers.Format.XML, {
    read: function (a) {
        return (new OpenLayers.Format.ArcXML).read(a).features.feature
    }
});
OpenLayers.Format.GML = OpenLayers.Class(OpenLayers.Format.XML, {
    featureNS: "http://mapserver.gis.umn.edu/mapserver",
    featurePrefix: "feature",
    featureName: "featureMember",
    layerName: "features",
    geometryName: "geometry",
    collectionName: "FeatureCollection",
    gmlns: "http://www.opengis.net/gml",
    extractAttributes: !0,
    xy: !0,
    initialize: function (a) {
        this.regExes = {trimSpace: /^\s*|\s*$/g, removeSpace: /\s*/g, splitSpace: /\s+/, trimComma: /\s*,\s*/g};
        OpenLayers.Format.XML.prototype.initialize.apply(this, [a])
    },
    read: function (a) {
        "string" == typeof a && (a = OpenLayers.Format.XML.prototype.read.apply(this, [a]));
        for (var a = this.getElementsByTagNameNS(a.documentElement, this.gmlns, this.featureName), b = [], c = 0; c < a.length; c++) {
            var d = this.parseFeature(a[c]);
            d && b.push(d)
        }
        return b
    },
    parseFeature: function (a) {
        for (var b = "MultiPolygon,Polygon,MultiLineString,LineString,MultiPoint,Point,Envelope".split(","), c, d, e, f = 0; f < b.length; ++f)if (c = b[f], d = this.getElementsByTagNameNS(a, this.gmlns, c), 0 < d.length) {
            if (e = this.parseGeometry[c.toLowerCase()])e = e.apply(this,
                [d[0]]), this.internalProjection && this.externalProjection && e.transform(this.externalProjection, this.internalProjection); else throw new TypeError("Unsupported geometry type: " + c);
            break
        }
        var g;
        c = this.getElementsByTagNameNS(a, this.gmlns, "Box");
        for (f = 0; f < c.length; ++f)b = c[f], d = this.parseGeometry.box.apply(this, [b]), b = b.parentNode, "boundedBy" === (b.localName || b.nodeName.split(":").pop()) ? g = d : e = d.toGeometry();
        var h;
        this.extractAttributes && (h = this.parseAttributes(a));
        h = new OpenLayers.Feature.Vector(e, h);
        h.bounds =
            g;
        h.gml = {
            featureType: a.firstChild.nodeName.split(":")[1],
            featureNS: a.firstChild.namespaceURI,
            featureNSPrefix: a.firstChild.prefix
        };
        for (var a = a.firstChild, k; a && !(1 == a.nodeType && (k = a.getAttribute("fid") || a.getAttribute("id")));)a = a.nextSibling;
        h.fid = k;
        return h
    },
    parseGeometry: {
        point: function (a) {
            var b, c;
            c = [];
            b = this.getElementsByTagNameNS(a, this.gmlns, "pos");
            0 < b.length && (c = b[0].firstChild.nodeValue, c = c.replace(this.regExes.trimSpace, ""), c = c.split(this.regExes.splitSpace));
            0 == c.length && (b = this.getElementsByTagNameNS(a,
                this.gmlns, "coordinates"), 0 < b.length && (c = b[0].firstChild.nodeValue, c = c.replace(this.regExes.removeSpace, ""), c = c.split(",")));
            0 == c.length && (b = this.getElementsByTagNameNS(a, this.gmlns, "coord"), 0 < b.length && (a = this.getElementsByTagNameNS(b[0], this.gmlns, "X"), b = this.getElementsByTagNameNS(b[0], this.gmlns, "Y"), 0 < a.length && 0 < b.length && (c = [a[0].firstChild.nodeValue, b[0].firstChild.nodeValue])));
            2 == c.length && (c[2] = null);
            return this.xy ? new OpenLayers.Geometry.Point(c[0], c[1], c[2]) : new OpenLayers.Geometry.Point(c[1],
                c[0], c[2])
        }, multipoint: function (a) {
            var a = this.getElementsByTagNameNS(a, this.gmlns, "Point"), b = [];
            if (0 < a.length)for (var c, d = 0; d < a.length; ++d)(c = this.parseGeometry.point.apply(this, [a[d]])) && b.push(c);
            return new OpenLayers.Geometry.MultiPoint(b)
        }, linestring: function (a, b) {
            var c, d;
            d = [];
            var e = [];
            c = this.getElementsByTagNameNS(a, this.gmlns, "posList");
            if (0 < c.length) {
                d = this.getChildValue(c[0]);
                d = d.replace(this.regExes.trimSpace, "");
                d = d.split(this.regExes.splitSpace);
                var f = parseInt(c[0].getAttribute("dimension")),
                    g, h, k;
                for (c = 0; c < d.length / f; ++c)g = c * f, h = d[g], k = d[g + 1], g = 2 == f ? null : d[g + 2], this.xy ? e.push(new OpenLayers.Geometry.Point(h, k, g)) : e.push(new OpenLayers.Geometry.Point(k, h, g))
            }
            if (0 == d.length && (c = this.getElementsByTagNameNS(a, this.gmlns, "coordinates"), 0 < c.length)) {
                d = this.getChildValue(c[0]);
                d = d.replace(this.regExes.trimSpace, "");
                d = d.replace(this.regExes.trimComma, ",");
                f = d.split(this.regExes.splitSpace);
                for (c = 0; c < f.length; ++c)d = f[c].split(","), 2 == d.length && (d[2] = null), this.xy ? e.push(new OpenLayers.Geometry.Point(d[0],
                    d[1], d[2])) : e.push(new OpenLayers.Geometry.Point(d[1], d[0], d[2]))
            }
            d = null;
            0 != e.length && (d = b ? new OpenLayers.Geometry.LinearRing(e) : new OpenLayers.Geometry.LineString(e));
            return d
        }, multilinestring: function (a) {
            var a = this.getElementsByTagNameNS(a, this.gmlns, "LineString"), b = [];
            if (0 < a.length)for (var c, d = 0; d < a.length; ++d)(c = this.parseGeometry.linestring.apply(this, [a[d]])) && b.push(c);
            return new OpenLayers.Geometry.MultiLineString(b)
        }, polygon: function (a) {
            var a = this.getElementsByTagNameNS(a, this.gmlns, "LinearRing"),
                b = [];
            if (0 < a.length)for (var c, d = 0; d < a.length; ++d)(c = this.parseGeometry.linestring.apply(this, [a[d], !0])) && b.push(c);
            return new OpenLayers.Geometry.Polygon(b)
        }, multipolygon: function (a) {
            var a = this.getElementsByTagNameNS(a, this.gmlns, "Polygon"), b = [];
            if (0 < a.length)for (var c, d = 0; d < a.length; ++d)(c = this.parseGeometry.polygon.apply(this, [a[d]])) && b.push(c);
            return new OpenLayers.Geometry.MultiPolygon(b)
        }, envelope: function (a) {
            var b = [], c, d, e = this.getElementsByTagNameNS(a, this.gmlns, "lowerCorner");
            if (0 < e.length) {
                c =
                    [];
                0 < e.length && (c = e[0].firstChild.nodeValue, c = c.replace(this.regExes.trimSpace, ""), c = c.split(this.regExes.splitSpace));
                2 == c.length && (c[2] = null);
                var f = this.xy ? new OpenLayers.Geometry.Point(c[0], c[1], c[2]) : new OpenLayers.Geometry.Point(c[1], c[0], c[2])
            }
            a = this.getElementsByTagNameNS(a, this.gmlns, "upperCorner");
            if (0 < a.length) {
                c = [];
                0 < a.length && (c = a[0].firstChild.nodeValue, c = c.replace(this.regExes.trimSpace, ""), c = c.split(this.regExes.splitSpace));
                2 == c.length && (c[2] = null);
                var g = this.xy ? new OpenLayers.Geometry.Point(c[0],
                    c[1], c[2]) : new OpenLayers.Geometry.Point(c[1], c[0], c[2])
            }
            f && g && (b.push(new OpenLayers.Geometry.Point(f.x, f.y)), b.push(new OpenLayers.Geometry.Point(g.x, f.y)), b.push(new OpenLayers.Geometry.Point(g.x, g.y)), b.push(new OpenLayers.Geometry.Point(f.x, g.y)), b.push(new OpenLayers.Geometry.Point(f.x, f.y)), b = new OpenLayers.Geometry.LinearRing(b), d = new OpenLayers.Geometry.Polygon([b]));
            return d
        }, box: function (a) {
            var b = this.getElementsByTagNameNS(a, this.gmlns, "coordinates"), c = a = null;
            0 < b.length && (b = b[0].firstChild.nodeValue,
                b = b.split(" "), 2 == b.length && (a = b[0].split(","), c = b[1].split(",")));
            if (null !== a && null !== c)return new OpenLayers.Bounds(parseFloat(a[0]), parseFloat(a[1]), parseFloat(c[0]), parseFloat(c[1]))
        }
    },
    parseAttributes: function (a) {
        for (var b = {}, a = a.firstChild, c, d, e; a;) {
            if (1 == a.nodeType) {
                a = a.childNodes;
                for (c = 0; c < a.length; ++c)if (d = a[c], 1 == d.nodeType)if (e = d.childNodes, 1 == e.length) {
                    if (e = e[0], 3 == e.nodeType || 4 == e.nodeType)d = d.prefix ? d.nodeName.split(":")[1] : d.nodeName, e = e.nodeValue.replace(this.regExes.trimSpace, ""),
                        b[d] = e
                } else b[d.nodeName.split(":").pop()] = null;
                break
            }
            a = a.nextSibling
        }
        return b
    },
    write: function (a) {
        OpenLayers.Util.isArray(a) || (a = [a]);
        for (var b = this.createElementNS("http://www.opengis.net/wfs", "wfs:" + this.collectionName), c = 0; c < a.length; c++)b.appendChild(this.createFeatureXML(a[c]));
        return OpenLayers.Format.XML.prototype.write.apply(this, [b])
    },
    createFeatureXML: function (a) {
        var b = this.buildGeometryNode(a.geometry), c = this.createElementNS(this.featureNS, this.featurePrefix + ":" + this.geometryName);
        c.appendChild(b);
        var b = this.createElementNS(this.gmlns, "gml:" + this.featureName), d = this.createElementNS(this.featureNS, this.featurePrefix + ":" + this.layerName);
        d.setAttribute("fid", a.fid || a.id);
        d.appendChild(c);
        for (var e in a.attributes) {
            var c = this.createTextNode(a.attributes[e]), f = this.createElementNS(this.featureNS, this.featurePrefix + ":" + e.substring(e.lastIndexOf(":") + 1));
            f.appendChild(c);
            d.appendChild(f)
        }
        b.appendChild(d);
        return b
    },
    buildGeometryNode: function (a) {
        this.externalProjection && this.internalProjection && (a =
            a.clone(), a.transform(this.internalProjection, this.externalProjection));
        var b = a.CLASS_NAME;
        return this.buildGeometry[b.substring(b.lastIndexOf(".") + 1).toLowerCase()].apply(this, [a])
    },
    buildGeometry: {
        point: function (a) {
            var b = this.createElementNS(this.gmlns, "gml:Point");
            b.appendChild(this.buildCoordinatesNode(a));
            return b
        }, multipoint: function (a) {
            for (var b = this.createElementNS(this.gmlns, "gml:MultiPoint"), a = a.components, c, d, e = 0; e < a.length; e++)c = this.createElementNS(this.gmlns, "gml:pointMember"), d = this.buildGeometry.point.apply(this,
                [a[e]]), c.appendChild(d), b.appendChild(c);
            return b
        }, linestring: function (a) {
            var b = this.createElementNS(this.gmlns, "gml:LineString");
            b.appendChild(this.buildCoordinatesNode(a));
            return b
        }, multilinestring: function (a) {
            for (var b = this.createElementNS(this.gmlns, "gml:MultiLineString"), a = a.components, c, d, e = 0; e < a.length; ++e)c = this.createElementNS(this.gmlns, "gml:lineStringMember"), d = this.buildGeometry.linestring.apply(this, [a[e]]), c.appendChild(d), b.appendChild(c);
            return b
        }, linearring: function (a) {
            var b = this.createElementNS(this.gmlns,
                "gml:LinearRing");
            b.appendChild(this.buildCoordinatesNode(a));
            return b
        }, polygon: function (a) {
            for (var b = this.createElementNS(this.gmlns, "gml:Polygon"), a = a.components, c, d, e = 0; e < a.length; ++e)c = 0 == e ? "outerBoundaryIs" : "innerBoundaryIs", c = this.createElementNS(this.gmlns, "gml:" + c), d = this.buildGeometry.linearring.apply(this, [a[e]]), c.appendChild(d), b.appendChild(c);
            return b
        }, multipolygon: function (a) {
            for (var b = this.createElementNS(this.gmlns, "gml:MultiPolygon"), a = a.components, c, d, e = 0; e < a.length; ++e)c = this.createElementNS(this.gmlns,
                "gml:polygonMember"), d = this.buildGeometry.polygon.apply(this, [a[e]]), c.appendChild(d), b.appendChild(c);
            return b
        }, bounds: function (a) {
            var b = this.createElementNS(this.gmlns, "gml:Box");
            b.appendChild(this.buildCoordinatesNode(a));
            return b
        }
    },
    buildCoordinatesNode: function (a) {
        var b = this.createElementNS(this.gmlns, "gml:coordinates");
        b.setAttribute("decimal", ".");
        b.setAttribute("cs", ",");
        b.setAttribute("ts", " ");
        var c = [];
        if (a instanceof OpenLayers.Bounds)c.push(a.left + "," + a.bottom), c.push(a.right + "," + a.top);
        else for (var a = a.components ? a.components : [a], d = 0; d < a.length; d++)c.push(a[d].x + "," + a[d].y);
        c = this.createTextNode(c.join(" "));
        b.appendChild(c);
        return b
    },
    CLASS_NAME: "OpenLayers.Format.GML"
});
OpenLayers.Format.GML || (OpenLayers.Format.GML = {});
OpenLayers.Format.GML.Base = OpenLayers.Class(OpenLayers.Format.XML, {
    namespaces: {
        gml: "http://www.opengis.net/gml",
        xlink: "http://www.w3.org/1999/xlink",
        xsi: "http://www.w3.org/2001/XMLSchema-instance",
        wfs: "http://www.opengis.net/wfs"
    },
    defaultPrefix: "gml",
    schemaLocation: null,
    featureType: null,
    featureNS: null,
    geometryName: "geometry",
    extractAttributes: !0,
    srsName: null,
    xy: !0,
    geometryTypes: null,
    singleFeatureType: null,
    regExes: {
        trimSpace: /^\s*|\s*$/g,
        removeSpace: /\s*/g,
        splitSpace: /\s+/,
        trimComma: /\s*,\s*/g,
        featureMember: /^(.*:)?featureMembers?$/
    },
    initialize: function (a) {
        OpenLayers.Format.XML.prototype.initialize.apply(this, [a]);
        this.setGeometryTypes();
        a && a.featureNS && this.setNamespace("feature", a.featureNS);
        this.singleFeatureType = !a || "string" === typeof a.featureType
    },
    read: function (a) {
        "string" == typeof a && (a = OpenLayers.Format.XML.prototype.read.apply(this, [a]));
        a && 9 == a.nodeType && (a = a.documentElement);
        var b = [];
        this.readNode(a, {features: b}, !0);
        if (0 == b.length) {
            var c = this.getElementsByTagNameNS(a, this.namespaces.gml, "featureMember");
            if (c.length)for (var a =
                0, d = c.length; a < d; ++a)this.readNode(c[a], {features: b}, !0); else c = this.getElementsByTagNameNS(a, this.namespaces.gml, "featureMembers"), c.length && this.readNode(c[0], {features: b}, !0)
        }
        return b
    },
    readNode: function (a, b, c) {
        !0 === c && !0 === this.autoConfig && (this.featureType = null, delete this.namespaceAlias[this.featureNS], delete this.namespaces.feature, this.featureNS = null);
        !this.featureNS && !(a.prefix in this.namespaces) && a.parentNode.namespaceURI == this.namespaces.gml && this.regExes.featureMember.test(a.parentNode.nodeName) &&
        (this.featureType = a.nodeName.split(":").pop(), this.setNamespace("feature", a.namespaceURI), this.featureNS = a.namespaceURI, this.autoConfig = !0);
        return OpenLayers.Format.XML.prototype.readNode.apply(this, [a, b])
    },
    readers: {
        gml: {
            featureMember: function (a, b) {
                this.readChildNodes(a, b)
            }, featureMembers: function (a, b) {
                this.readChildNodes(a, b)
            }, name: function (a, b) {
                b.name = this.getChildValue(a)
            }, boundedBy: function (a, b) {
                var c = {};
                this.readChildNodes(a, c);
                c.components && 0 < c.components.length && (b.bounds = c.components[0])
            },
            Point: function (a, b) {
                var c = {points: []};
                this.readChildNodes(a, c);
                b.components || (b.components = []);
                b.components.push(c.points[0])
            }, coordinates: function (a, b) {
                for (var c = this.getChildValue(a).replace(this.regExes.trimSpace, ""), c = c.replace(this.regExes.trimComma, ","), c = c.split(this.regExes.splitSpace), d, e = c.length, f = Array(e), g = 0; g < e; ++g)d = c[g].split(","), f[g] = this.xy ? new OpenLayers.Geometry.Point(d[0], d[1], d[2]) : new OpenLayers.Geometry.Point(d[1], d[0], d[2]);
                b.points = f
            }, coord: function (a, b) {
                var c = {};
                this.readChildNodes(a,
                    c);
                b.points || (b.points = []);
                b.points.push(new OpenLayers.Geometry.Point(c.x, c.y, c.z))
            }, X: function (a, b) {
                b.x = this.getChildValue(a)
            }, Y: function (a, b) {
                b.y = this.getChildValue(a)
            }, Z: function (a, b) {
                b.z = this.getChildValue(a)
            }, MultiPoint: function (a, b) {
                var c = {components: []};
                this.readChildNodes(a, c);
                b.components = [new OpenLayers.Geometry.MultiPoint(c.components)]
            }, pointMember: function (a, b) {
                this.readChildNodes(a, b)
            }, LineString: function (a, b) {
                var c = {};
                this.readChildNodes(a, c);
                b.components || (b.components = []);
                b.components.push(new OpenLayers.Geometry.LineString(c.points))
            },
            MultiLineString: function (a, b) {
                var c = {components: []};
                this.readChildNodes(a, c);
                b.components = [new OpenLayers.Geometry.MultiLineString(c.components)]
            }, lineStringMember: function (a, b) {
                this.readChildNodes(a, b)
            }, Polygon: function (a, b) {
                var c = {outer: null, inner: []};
                this.readChildNodes(a, c);
                c.inner.unshift(c.outer);
                b.components || (b.components = []);
                b.components.push(new OpenLayers.Geometry.Polygon(c.inner))
            }, LinearRing: function (a, b) {
                var c = {};
                this.readChildNodes(a, c);
                b.components = [new OpenLayers.Geometry.LinearRing(c.points)]
            },
            MultiPolygon: function (a, b) {
                var c = {components: []};
                this.readChildNodes(a, c);
                b.components = [new OpenLayers.Geometry.MultiPolygon(c.components)]
            }, polygonMember: function (a, b) {
                this.readChildNodes(a, b)
            }, GeometryCollection: function (a, b) {
                var c = {components: []};
                this.readChildNodes(a, c);
                b.components = [new OpenLayers.Geometry.Collection(c.components)]
            }, geometryMember: function (a, b) {
                this.readChildNodes(a, b)
            }
        }, feature: {
            "*": function (a, b) {
                var c, d = a.localName || a.nodeName.split(":").pop();
                b.features ? !this.singleFeatureType &&
                -1 !== OpenLayers.Util.indexOf(this.featureType, d) ? c = "_typeName" : d === this.featureType && (c = "_typeName") : 0 == a.childNodes.length || 1 == a.childNodes.length && 3 == a.firstChild.nodeType ? this.extractAttributes && (c = "_attribute") : c = "_geometry";
                c && this.readers.feature[c].apply(this, [a, b])
            }, _typeName: function (a, b) {
                var c = {components: [], attributes: {}};
                this.readChildNodes(a, c);
                c.name && (c.attributes.name = c.name);
                var d = new OpenLayers.Feature.Vector(c.components[0], c.attributes);
                this.singleFeatureType || (d.type = a.nodeName.split(":").pop(),
                    d.namespace = a.namespaceURI);
                var e = a.getAttribute("fid") || this.getAttributeNS(a, this.namespaces.gml, "id");
                e && (d.fid = e);
                this.internalProjection && this.externalProjection && d.geometry && d.geometry.transform(this.externalProjection, this.internalProjection);
                c.bounds && (d.bounds = c.bounds);
                b.features.push(d)
            }, _geometry: function (a, b) {
                this.geometryName || (this.geometryName = a.nodeName.split(":").pop());
                this.readChildNodes(a, b)
            }, _attribute: function (a, b) {
                var c = a.localName || a.nodeName.split(":").pop(), d = this.getChildValue(a);
                b.attributes[c] = d
            }
        }, wfs: {
            FeatureCollection: function (a, b) {
                this.readChildNodes(a, b)
            }
        }
    },
    write: function (a) {
        a = this.writeNode("gml:" + (OpenLayers.Util.isArray(a) ? "featureMembers" : "featureMember"), a);
        this.setAttributeNS(a, this.namespaces.xsi, "xsi:schemaLocation", this.schemaLocation);
        return OpenLayers.Format.XML.prototype.write.apply(this, [a])
    },
    writers: {
        gml: {
            featureMember: function (a) {
                var b = this.createElementNSPlus("gml:featureMember");
                this.writeNode("feature:_typeName", a, b);
                return b
            }, MultiPoint: function (a) {
                for (var b =
                    this.createElementNSPlus("gml:MultiPoint"), a = a.components || [a], c = 0, d = a.length; c < d; ++c)this.writeNode("pointMember", a[c], b);
                return b
            }, pointMember: function (a) {
                var b = this.createElementNSPlus("gml:pointMember");
                this.writeNode("Point", a, b);
                return b
            }, MultiLineString: function (a) {
                for (var b = this.createElementNSPlus("gml:MultiLineString"), a = a.components || [a], c = 0, d = a.length; c < d; ++c)this.writeNode("lineStringMember", a[c], b);
                return b
            }, lineStringMember: function (a) {
                var b = this.createElementNSPlus("gml:lineStringMember");
                this.writeNode("LineString", a, b);
                return b
            }, MultiPolygon: function (a) {
                for (var b = this.createElementNSPlus("gml:MultiPolygon"), a = a.components || [a], c = 0, d = a.length; c < d; ++c)this.writeNode("polygonMember", a[c], b);
                return b
            }, polygonMember: function (a) {
                var b = this.createElementNSPlus("gml:polygonMember");
                this.writeNode("Polygon", a, b);
                return b
            }, GeometryCollection: function (a) {
                for (var b = this.createElementNSPlus("gml:GeometryCollection"), c = 0, d = a.components.length; c < d; ++c)this.writeNode("geometryMember", a.components[c],
                    b);
                return b
            }, geometryMember: function (a) {
                var b = this.createElementNSPlus("gml:geometryMember"), a = this.writeNode("feature:_geometry", a);
                b.appendChild(a.firstChild);
                return b
            }
        }, feature: {
            _typeName: function (a) {
                var b = this.createElementNSPlus("feature:" + this.featureType, {attributes: {fid: a.fid}});
                a.geometry && this.writeNode("feature:_geometry", a.geometry, b);
                for (var c in a.attributes) {
                    var d = a.attributes[c];
                    null != d && this.writeNode("feature:_attribute", {name: c, value: d}, b)
                }
                return b
            }, _geometry: function (a) {
                this.externalProjection &&
                this.internalProjection && (a = a.clone().transform(this.internalProjection, this.externalProjection));
                var b = this.createElementNSPlus("feature:" + this.geometryName), a = this.writeNode("gml:" + this.geometryTypes[a.CLASS_NAME], a, b);
                this.srsName && a.setAttribute("srsName", this.srsName);
                return b
            }, _attribute: function (a) {
                return this.createElementNSPlus("feature:" + a.name, {value: a.value})
            }
        }, wfs: {
            FeatureCollection: function (a) {
                for (var b = this.createElementNSPlus("wfs:FeatureCollection"), c = 0, d = a.length; c < d; ++c)this.writeNode("gml:featureMember",
                    a[c], b);
                return b
            }
        }
    },
    setGeometryTypes: function () {
        this.geometryTypes = {
            "OpenLayers.Geometry.Point": "Point",
            "OpenLayers.Geometry.MultiPoint": "MultiPoint",
            "OpenLayers.Geometry.LineString": "LineString",
            "OpenLayers.Geometry.MultiLineString": "MultiLineString",
            "OpenLayers.Geometry.Polygon": "Polygon",
            "OpenLayers.Geometry.MultiPolygon": "MultiPolygon",
            "OpenLayers.Geometry.Collection": "GeometryCollection"
        }
    },
    CLASS_NAME: "OpenLayers.Format.GML.Base"
});
OpenLayers.Format.GML.v2 = OpenLayers.Class(OpenLayers.Format.GML.Base, {
    schemaLocation: "http://www.opengis.net/gml http://schemas.opengis.net/gml/2.1.2/feature.xsd",
    initialize: function (a) {
        OpenLayers.Format.GML.Base.prototype.initialize.apply(this, [a])
    },
    readers: {
        gml: OpenLayers.Util.applyDefaults({
            outerBoundaryIs: function (a, b) {
                var c = {};
                this.readChildNodes(a, c);
                b.outer = c.components[0]
            }, innerBoundaryIs: function (a, b) {
                var c = {};
                this.readChildNodes(a, c);
                b.inner.push(c.components[0])
            }, Box: function (a, b) {
                var c =
                {};
                this.readChildNodes(a, c);
                b.components || (b.components = []);
                var d = c.points[0], c = c.points[1];
                b.components.push(new OpenLayers.Bounds(d.x, d.y, c.x, c.y))
            }
        }, OpenLayers.Format.GML.Base.prototype.readers.gml),
        feature: OpenLayers.Format.GML.Base.prototype.readers.feature,
        wfs: OpenLayers.Format.GML.Base.prototype.readers.wfs
    },
    write: function (a) {
        a = this.writeNode(OpenLayers.Util.isArray(a) ? "wfs:FeatureCollection" : "gml:featureMember", a);
        this.setAttributeNS(a, this.namespaces.xsi, "xsi:schemaLocation", this.schemaLocation);
        return OpenLayers.Format.XML.prototype.write.apply(this, [a])
    },
    writers: {
        gml: OpenLayers.Util.applyDefaults({
            Point: function (a) {
                var b = this.createElementNSPlus("gml:Point");
                this.writeNode("coordinates", [a], b);
                return b
            }, coordinates: function (a) {
                for (var b = a.length, c = Array(b), d, e = 0; e < b; ++e)d = a[e], c[e] = this.xy ? d.x + "," + d.y : d.y + "," + d.x, void 0 != d.z && (c[e] += "," + d.z);
                return this.createElementNSPlus("gml:coordinates", {
                    attributes: {decimal: ".", cs: ",", ts: " "},
                    value: 1 == b ? c[0] : c.join(" ")
                })
            }, LineString: function (a) {
                var b =
                    this.createElementNSPlus("gml:LineString");
                this.writeNode("coordinates", a.components, b);
                return b
            }, Polygon: function (a) {
                var b = this.createElementNSPlus("gml:Polygon");
                this.writeNode("outerBoundaryIs", a.components[0], b);
                for (var c = 1; c < a.components.length; ++c)this.writeNode("innerBoundaryIs", a.components[c], b);
                return b
            }, outerBoundaryIs: function (a) {
                var b = this.createElementNSPlus("gml:outerBoundaryIs");
                this.writeNode("LinearRing", a, b);
                return b
            }, innerBoundaryIs: function (a) {
                var b = this.createElementNSPlus("gml:innerBoundaryIs");
                this.writeNode("LinearRing", a, b);
                return b
            }, LinearRing: function (a) {
                var b = this.createElementNSPlus("gml:LinearRing");
                this.writeNode("coordinates", a.components, b);
                return b
            }, Box: function (a) {
                var b = this.createElementNSPlus("gml:Box");
                this.writeNode("coordinates", [{x: a.left, y: a.bottom}, {x: a.right, y: a.top}], b);
                this.srsName && b.setAttribute("srsName", this.srsName);
                return b
            }
        }, OpenLayers.Format.GML.Base.prototype.writers.gml),
        feature: OpenLayers.Format.GML.Base.prototype.writers.feature,
        wfs: OpenLayers.Format.GML.Base.prototype.writers.wfs
    },
    CLASS_NAME: "OpenLayers.Format.GML.v2"
});
OpenLayers.Format.GML.v3 = OpenLayers.Class(OpenLayers.Format.GML.Base, {
    schemaLocation: "http://www.opengis.net/gml http://schemas.opengis.net/gml/3.1.1/profiles/gmlsfProfile/1.0.0/gmlsf.xsd",
    curve: !1,
    multiCurve: !0,
    surface: !1,
    multiSurface: !0,
    initialize: function (a) {
        OpenLayers.Format.GML.Base.prototype.initialize.apply(this, [a])
    },
    readers: {
        gml: OpenLayers.Util.applyDefaults({
            featureMembers: function (a, b) {
                this.readChildNodes(a, b)
            }, Curve: function (a, b) {
                var c = {points: []};
                this.readChildNodes(a, c);
                b.components ||
                (b.components = []);
                b.components.push(new OpenLayers.Geometry.LineString(c.points))
            }, segments: function (a, b) {
                this.readChildNodes(a, b)
            }, LineStringSegment: function (a, b) {
                var c = {};
                this.readChildNodes(a, c);
                c.points && Array.prototype.push.apply(b.points, c.points)
            }, pos: function (a, b) {
                var c = this.getChildValue(a).replace(this.regExes.trimSpace, "").split(this.regExes.splitSpace), c = this.xy ? new OpenLayers.Geometry.Point(c[0], c[1], c[2]) : new OpenLayers.Geometry.Point(c[1], c[0], c[2]);
                b.points = [c]
            }, posList: function (a,
                                  b) {
                for (var c = this.getChildValue(a).replace(this.regExes.trimSpace, "").split(this.regExes.splitSpace), d = parseInt(a.getAttribute("dimension")) || 2, e, f, g, h = Array(c.length / d), k = 0, l = c.length; k < l; k += d)e = c[k], f = c[k + 1], g = 2 == d ? void 0 : c[k + 2], h[k / d] = this.xy ? new OpenLayers.Geometry.Point(e, f, g) : new OpenLayers.Geometry.Point(f, e, g);
                b.points = h
            }, Surface: function (a, b) {
                this.readChildNodes(a, b)
            }, patches: function (a, b) {
                this.readChildNodes(a, b)
            }, PolygonPatch: function (a, b) {
                this.readers.gml.Polygon.apply(this, [a, b])
            }, exterior: function (a,
                                   b) {
                var c = {};
                this.readChildNodes(a, c);
                b.outer = c.components[0]
            }, interior: function (a, b) {
                var c = {};
                this.readChildNodes(a, c);
                b.inner.push(c.components[0])
            }, MultiCurve: function (a, b) {
                var c = {components: []};
                this.readChildNodes(a, c);
                0 < c.components.length && (b.components = [new OpenLayers.Geometry.MultiLineString(c.components)])
            }, curveMember: function (a, b) {
                this.readChildNodes(a, b)
            }, MultiSurface: function (a, b) {
                var c = {components: []};
                this.readChildNodes(a, c);
                0 < c.components.length && (b.components = [new OpenLayers.Geometry.MultiPolygon(c.components)])
            },
            surfaceMember: function (a, b) {
                this.readChildNodes(a, b)
            }, surfaceMembers: function (a, b) {
                this.readChildNodes(a, b)
            }, pointMembers: function (a, b) {
                this.readChildNodes(a, b)
            }, lineStringMembers: function (a, b) {
                this.readChildNodes(a, b)
            }, polygonMembers: function (a, b) {
                this.readChildNodes(a, b)
            }, geometryMembers: function (a, b) {
                this.readChildNodes(a, b)
            }, Envelope: function (a, b) {
                var c = {points: Array(2)};
                this.readChildNodes(a, c);
                b.components || (b.components = []);
                var d = c.points[0], c = c.points[1];
                b.components.push(new OpenLayers.Bounds(d.x,
                    d.y, c.x, c.y))
            }, lowerCorner: function (a, b) {
                var c = {};
                this.readers.gml.pos.apply(this, [a, c]);
                b.points[0] = c.points[0]
            }, upperCorner: function (a, b) {
                var c = {};
                this.readers.gml.pos.apply(this, [a, c]);
                b.points[1] = c.points[0]
            }
        }, OpenLayers.Format.GML.Base.prototype.readers.gml),
        feature: OpenLayers.Format.GML.Base.prototype.readers.feature,
        wfs: OpenLayers.Format.GML.Base.prototype.readers.wfs
    },
    write: function (a) {
        a = this.writeNode("gml:" + (OpenLayers.Util.isArray(a) ? "featureMembers" : "featureMember"), a);
        this.setAttributeNS(a,
            this.namespaces.xsi, "xsi:schemaLocation", this.schemaLocation);
        return OpenLayers.Format.XML.prototype.write.apply(this, [a])
    },
    writers: {
        gml: OpenLayers.Util.applyDefaults({
            featureMembers: function (a) {
                for (var b = this.createElementNSPlus("gml:featureMembers"), c = 0, d = a.length; c < d; ++c)this.writeNode("feature:_typeName", a[c], b);
                return b
            }, Point: function (a) {
                var b = this.createElementNSPlus("gml:Point");
                this.writeNode("pos", a, b);
                return b
            }, pos: function (a) {
                return this.createElementNSPlus("gml:pos", {
                    value: this.xy ? a.x +
                    " " + a.y : a.y + " " + a.x
                })
            }, LineString: function (a) {
                var b = this.createElementNSPlus("gml:LineString");
                this.writeNode("posList", a.components, b);
                return b
            }, Curve: function (a) {
                var b = this.createElementNSPlus("gml:Curve");
                this.writeNode("segments", a, b);
                return b
            }, segments: function (a) {
                var b = this.createElementNSPlus("gml:segments");
                this.writeNode("LineStringSegment", a, b);
                return b
            }, LineStringSegment: function (a) {
                var b = this.createElementNSPlus("gml:LineStringSegment");
                this.writeNode("posList", a.components, b);
                return b
            },
            posList: function (a) {
                for (var b = a.length, c = Array(b), d, e = 0; e < b; ++e)d = a[e], c[e] = this.xy ? d.x + " " + d.y : d.y + " " + d.x;
                return this.createElementNSPlus("gml:posList", {value: c.join(" ")})
            }, Surface: function (a) {
                var b = this.createElementNSPlus("gml:Surface");
                this.writeNode("patches", a, b);
                return b
            }, patches: function (a) {
                var b = this.createElementNSPlus("gml:patches");
                this.writeNode("PolygonPatch", a, b);
                return b
            }, PolygonPatch: function (a) {
                var b = this.createElementNSPlus("gml:PolygonPatch", {attributes: {interpolation: "planar"}});
                this.writeNode("exterior", a.components[0], b);
                for (var c = 1, d = a.components.length; c < d; ++c)this.writeNode("interior", a.components[c], b);
                return b
            }, Polygon: function (a) {
                var b = this.createElementNSPlus("gml:Polygon");
                this.writeNode("exterior", a.components[0], b);
                for (var c = 1, d = a.components.length; c < d; ++c)this.writeNode("interior", a.components[c], b);
                return b
            }, exterior: function (a) {
                var b = this.createElementNSPlus("gml:exterior");
                this.writeNode("LinearRing", a, b);
                return b
            }, interior: function (a) {
                var b = this.createElementNSPlus("gml:interior");
                this.writeNode("LinearRing", a, b);
                return b
            }, LinearRing: function (a) {
                var b = this.createElementNSPlus("gml:LinearRing");
                this.writeNode("posList", a.components, b);
                return b
            }, MultiCurve: function (a) {
                for (var b = this.createElementNSPlus("gml:MultiCurve"), a = a.components || [a], c = 0, d = a.length; c < d; ++c)this.writeNode("curveMember", a[c], b);
                return b
            }, curveMember: function (a) {
                var b = this.createElementNSPlus("gml:curveMember");
                this.curve ? this.writeNode("Curve", a, b) : this.writeNode("LineString", a, b);
                return b
            }, MultiSurface: function (a) {
                for (var b =
                    this.createElementNSPlus("gml:MultiSurface"), a = a.components || [a], c = 0, d = a.length; c < d; ++c)this.writeNode("surfaceMember", a[c], b);
                return b
            }, surfaceMember: function (a) {
                var b = this.createElementNSPlus("gml:surfaceMember");
                this.surface ? this.writeNode("Surface", a, b) : this.writeNode("Polygon", a, b);
                return b
            }, Envelope: function (a) {
                var b = this.createElementNSPlus("gml:Envelope");
                this.writeNode("lowerCorner", a, b);
                this.writeNode("upperCorner", a, b);
                this.srsName && b.setAttribute("srsName", this.srsName);
                return b
            }, lowerCorner: function (a) {
                return this.createElementNSPlus("gml:lowerCorner",
                    {value: this.xy ? a.left + " " + a.bottom : a.bottom + " " + a.left})
            }, upperCorner: function (a) {
                return this.createElementNSPlus("gml:upperCorner", {value: this.xy ? a.right + " " + a.top : a.top + " " + a.right})
            }
        }, OpenLayers.Format.GML.Base.prototype.writers.gml),
        feature: OpenLayers.Format.GML.Base.prototype.writers.feature,
        wfs: OpenLayers.Format.GML.Base.prototype.writers.wfs
    },
    setGeometryTypes: function () {
        this.geometryTypes = {
            "OpenLayers.Geometry.Point": "Point",
            "OpenLayers.Geometry.MultiPoint": "MultiPoint",
            "OpenLayers.Geometry.LineString": !0 ===
            this.curve ? "Curve" : "LineString",
            "OpenLayers.Geometry.MultiLineString": !1 === this.multiCurve ? "MultiLineString" : "MultiCurve",
            "OpenLayers.Geometry.Polygon": !0 === this.surface ? "Surface" : "Polygon",
            "OpenLayers.Geometry.MultiPolygon": !1 === this.multiSurface ? "MultiPolygon" : "MultiSurface",
            "OpenLayers.Geometry.Collection": "GeometryCollection"
        }
    },
    CLASS_NAME: "OpenLayers.Format.GML.v3"
});
OpenLayers.Format.Atom = OpenLayers.Class(OpenLayers.Format.XML, {
    namespaces: {atom: "http://www.w3.org/2005/Atom", georss: "http://www.georss.org/georss"},
    feedTitle: "untitled",
    defaultEntryTitle: "untitled",
    gmlParser: null,
    xy: !1,
    read: function (a) {
        "string" == typeof a && (a = OpenLayers.Format.XML.prototype.read.apply(this, [a]));
        return this.parseFeatures(a)
    },
    write: function (a) {
        var b;
        if (OpenLayers.Util.isArray(a)) {
            b = this.createElementNSPlus("atom:feed");
            b.appendChild(this.createElementNSPlus("atom:title", {value: this.feedTitle}));
            for (var c = 0, d = a.length; c < d; c++)b.appendChild(this.buildEntryNode(a[c]))
        } else b = this.buildEntryNode(a);
        return OpenLayers.Format.XML.prototype.write.apply(this, [b])
    },
    buildContentNode: function (a) {
        var b = this.createElementNSPlus("atom:content", {attributes: {type: a.type || null}});
        if (a.src)b.setAttribute("src", a.src); else if ("text" == a.type || null == a.type)b.appendChild(this.createTextNode(a.value)); else if ("html" == a.type) {
            if ("string" != typeof a.value)throw"HTML content must be in form of an escaped string";
            b.appendChild(this.createTextNode(a.value))
        } else"xhtml" ==
        a.type ? b.appendChild(a.value) : "xhtml" == a.type || a.type.match(/(\+|\/)xml$/) ? b.appendChild(a.value) : b.appendChild(this.createTextNode(a.value));
        return b
    },
    buildEntryNode: function (a) {
        var b = a.attributes, c = b.atom || {}, d = this.createElementNSPlus("atom:entry");
        if (c.authors)for (var e = OpenLayers.Util.isArray(c.authors) ? c.authors : [c.authors], f = 0, g = e.length; f < g; f++)d.appendChild(this.buildPersonConstructNode("author", e[f]));
        if (c.categories)for (var e = OpenLayers.Util.isArray(c.categories) ? c.categories : [c.categories],
                                  h, f = 0, g = e.length; f < g; f++)h = e[f], d.appendChild(this.createElementNSPlus("atom:category", {
            attributes: {
                term: h.term,
                scheme: h.scheme || null,
                label: h.label || null
            }
        }));
        c.content && d.appendChild(this.buildContentNode(c.content));
        if (c.contributors) {
            e = OpenLayers.Util.isArray(c.contributors) ? c.contributors : [c.contributors];
            f = 0;
            for (g = e.length; f < g; f++)d.appendChild(this.buildPersonConstructNode("contributor", e[f]))
        }
        a.fid && d.appendChild(this.createElementNSPlus("atom:id", {value: a.fid}));
        if (c.links) {
            e = OpenLayers.Util.isArray(c.links) ?
                c.links : [c.links];
            f = 0;
            for (g = e.length; f < g; f++)h = e[f], d.appendChild(this.createElementNSPlus("atom:link", {
                attributes: {
                    href: h.href,
                    rel: h.rel || null,
                    type: h.type || null,
                    hreflang: h.hreflang || null,
                    title: h.title || null,
                    length: h.length || null
                }
            }))
        }
        c.published && d.appendChild(this.createElementNSPlus("atom:published", {value: c.published}));
        c.rights && d.appendChild(this.createElementNSPlus("atom:rights", {value: c.rights}));
        if (c.summary || b.description)d.appendChild(this.createElementNSPlus("atom:summary", {
            value: c.summary ||
            b.description
        }));
        d.appendChild(this.createElementNSPlus("atom:title", {value: c.title || b.title || this.defaultEntryTitle}));
        c.updated && d.appendChild(this.createElementNSPlus("atom:updated", {value: c.updated}));
        a.geometry && (b = this.createElementNSPlus("georss:where"), b.appendChild(this.buildGeometryNode(a.geometry)), d.appendChild(b));
        return d
    },
    initGmlParser: function () {
        this.gmlParser = new OpenLayers.Format.GML.v3({
            xy: this.xy, featureNS: "http://example.com#feature", internalProjection: this.internalProjection,
            externalProjection: this.externalProjection
        })
    },
    buildGeometryNode: function (a) {
        this.gmlParser || this.initGmlParser();
        return this.gmlParser.writeNode("feature:_geometry", a).firstChild
    },
    buildPersonConstructNode: function (a, b) {
        var c = ["uri", "email"], d = this.createElementNSPlus("atom:" + a);
        d.appendChild(this.createElementNSPlus("atom:name", {value: b.name}));
        for (var e = 0, f = c.length; e < f; e++)b[c[e]] && d.appendChild(this.createElementNSPlus("atom:" + c[e], {value: b[c[e]]}));
        return d
    },
    getFirstChildValue: function (a, b, c,
                                  d) {
        return (a = this.getElementsByTagNameNS(a, b, c)) && 0 < a.length ? this.getChildValue(a[0], d) : d
    },
    parseFeature: function (a) {
        var b = {}, c = null, d = null, e = null, f = this.namespaces.atom;
        this.parsePersonConstructs(a, "author", b);
        d = this.getElementsByTagNameNS(a, f, "category");
        0 < d.length && (b.categories = []);
        for (var g = 0, h = d.length; g < h; g++) {
            c = {};
            c.term = d[g].getAttribute("term");
            if (e = d[g].getAttribute("scheme"))c.scheme = e;
            if (e = d[g].getAttribute("label"))c.label = e;
            b.categories.push(c)
        }
        d = this.getElementsByTagNameNS(a, f, "content");
        if (0 < d.length) {
            c = {};
            if (e = d[0].getAttribute("type"))c.type = e;
            (e = d[0].getAttribute("src")) ? c.src = e : (c.value = "text" == c.type || "html" == c.type || null == c.type ? this.getFirstChildValue(a, f, "content", null) : "xhtml" == c.type || c.type.match(/(\+|\/)xml$/) ? this.getChildEl(d[0]) : this.getFirstChildValue(a, f, "content", null), b.content = c)
        }
        this.parsePersonConstructs(a, "contributor", b);
        b.id = this.getFirstChildValue(a, f, "id", null);
        d = this.getElementsByTagNameNS(a, f, "link");
        0 < d.length && (b.links = Array(d.length));
        for (var k = ["rel",
            "type", "hreflang", "title", "length"], g = 0, h = d.length; g < h; g++) {
            c = {};
            c.href = d[g].getAttribute("href");
            for (var l = 0, m = k.length; l < m; l++)(e = d[g].getAttribute(k[l])) && (c[k[l]] = e);
            b.links[g] = c
        }
        if (c = this.getFirstChildValue(a, f, "published", null))b.published = c;
        if (c = this.getFirstChildValue(a, f, "rights", null))b.rights = c;
        if (c = this.getFirstChildValue(a, f, "summary", null))b.summary = c;
        b.title = this.getFirstChildValue(a, f, "title", null);
        b.updated = this.getFirstChildValue(a, f, "updated", null);
        c = {
            title: b.title, description: b.summary,
            atom: b
        };
        a = this.parseLocations(a)[0];
        a = new OpenLayers.Feature.Vector(a, c);
        a.fid = b.id;
        return a
    },
    parseFeatures: function (a) {
        var b = [], c = this.getElementsByTagNameNS(a, this.namespaces.atom, "entry");
        0 == c.length && (c = [a]);
        for (var a = 0, d = c.length; a < d; a++)b.push(this.parseFeature(c[a]));
        return b
    },
    parseLocations: function (a) {
        var b = this.namespaces.georss, c = {components: []}, d = this.getElementsByTagNameNS(a, b, "where");
        if (d && 0 < d.length) {
            this.gmlParser || this.initGmlParser();
            for (var e = 0, f = d.length; e < f; e++)this.gmlParser.readChildNodes(d[e],
                c)
        }
        c = c.components;
        if ((d = this.getElementsByTagNameNS(a, b, "point")) && 0 < d.length) {
            e = 0;
            for (f = d.length; e < f; e++) {
                var g = OpenLayers.String.trim(d[e].firstChild.nodeValue).split(/\s+/);
                2 != g.length && (g = OpenLayers.String.trim(d[e].firstChild.nodeValue).split(/\s*,\s*/));
                c.push(new OpenLayers.Geometry.Point(g[1], g[0]))
            }
        }
        var h = this.getElementsByTagNameNS(a, b, "line");
        if (h && 0 < h.length)for (var k, e = 0, f = h.length; e < f; e++) {
            d = OpenLayers.String.trim(h[e].firstChild.nodeValue).split(/\s+/);
            k = [];
            for (var l = 0, m = d.length; l <
            m; l += 2)g = new OpenLayers.Geometry.Point(d[l + 1], d[l]), k.push(g);
            c.push(new OpenLayers.Geometry.LineString(k))
        }
        if ((a = this.getElementsByTagNameNS(a, b, "polygon")) && 0 < a.length) {
            e = 0;
            for (f = a.length; e < f; e++) {
                d = OpenLayers.String.trim(a[e].firstChild.nodeValue).split(/\s+/);
                k = [];
                l = 0;
                for (m = d.length; l < m; l += 2)g = new OpenLayers.Geometry.Point(d[l + 1], d[l]), k.push(g);
                c.push(new OpenLayers.Geometry.Polygon([new OpenLayers.Geometry.LinearRing(c)]))
            }
        }
        if (this.internalProjection && this.externalProjection) {
            e = 0;
            for (f = c.length; e <
            f; e++)c[e] && c[e].transform(this.externalProjection, this.internalProjection)
        }
        return c
    },
    parsePersonConstructs: function (a, b, c) {
        for (var d = [], e = this.namespaces.atom, a = this.getElementsByTagNameNS(a, e, b), f = ["uri", "email"], g = 0, h = a.length; g < h; g++) {
            var k = {};
            k.name = this.getFirstChildValue(a[g], e, "name", null);
            for (var l = 0, m = f.length; l < m; l++) {
                var n = this.getFirstChildValue(a[g], e, f[l], null);
                n && (k[f[l]] = n)
            }
            d.push(k)
        }
        0 < d.length && (c[b + "s"] = d)
    },
    CLASS_NAME: "OpenLayers.Format.Atom"
});
OpenLayers.Format.KML = OpenLayers.Class(OpenLayers.Format.XML, {
    namespaces: {kml: "http://www.opengis.net/kml/2.2", gx: "http://www.google.com/kml/ext/2.2"},
    kmlns: "http://earth.google.com/kml/2.0",
    placemarksDesc: "No description available",
    foldersName: "OpenLayers export",
    foldersDesc: "Exported on " + new Date,
    extractAttributes: !0,
    kvpAttributes: !1,
    extractStyles: !1,
    extractTracks: !1,
    trackAttributes: null,
    internalns: null,
    features: null,
    styles: null,
    styleBaseUrl: "",
    fetched: null,
    maxDepth: 0,
    initialize: function (a) {
        this.regExes =
        {
            trimSpace: /^\s*|\s*$/g,
            removeSpace: /\s*/g,
            splitSpace: /\s+/,
            trimComma: /\s*,\s*/g,
            kmlColor: /(\w{2})(\w{2})(\w{2})(\w{2})/,
            kmlIconPalette: /root:\/\/icons\/palette-(\d+)(\.\w+)/,
            straightBracket: /\$\[(.*?)\]/g
        };
        this.externalProjection = new OpenLayers.Projection("EPSG:4326");
        OpenLayers.Format.XML.prototype.initialize.apply(this, [a])
    },
    read: function (a) {
        this.features = [];
        this.styles = {};
        this.fetched = {};
        return this.parseData(a, {depth: 0, styleBaseUrl: this.styleBaseUrl})
    },
    parseData: function (a, b) {
        "string" == typeof a &&
        (a = OpenLayers.Format.XML.prototype.read.apply(this, [a]));
        for (var c = ["Link", "NetworkLink", "Style", "StyleMap", "Placemark"], d = 0, e = c.length; d < e; ++d) {
            var f = c[d], g = this.getElementsByTagNameNS(a, "*", f);
            if (0 != g.length)switch (f.toLowerCase()) {
                case "link":
                case "networklink":
                    this.parseLinks(g, b);
                    break;
                case "style":
                    this.extractStyles && this.parseStyles(g, b);
                    break;
                case "stylemap":
                    this.extractStyles && this.parseStyleMaps(g, b);
                    break;
                case "placemark":
                    this.parseFeatures(g, b)
            }
        }
        return this.features
    },
    parseLinks: function (a,
                          b) {
        if (b.depth >= this.maxDepth)return !1;
        var c = OpenLayers.Util.extend({}, b);
        c.depth++;
        for (var d = 0, e = a.length; d < e; d++) {
            var f = this.parseProperty(a[d], "*", "href");
            f && !this.fetched[f] && (this.fetched[f] = !0, (f = this.fetchLink(f)) && this.parseData(f, c))
        }
    },
    fetchLink: function (a) {
        if (a = OpenLayers.Request.GET({url: a, async: !1}))return a.responseText
    },
    parseStyles: function (a, b) {
        for (var c = 0, d = a.length; c < d; c++) {
            var e = this.parseStyle(a[c]);
            e && (this.styles[(b.styleBaseUrl || "") + "#" + e.id] = e)
        }
    },
    parseKmlColor: function (a) {
        var b =
            null;
        a && (a = a.match(this.regExes.kmlColor)) && (b = {
            color: "#" + a[4] + a[3] + a[2],
            opacity: parseInt(a[1], 16) / 255
        });
        return b
    },
    parseStyle: function (a) {
        for (var b = {}, c = ["LineStyle", "PolyStyle", "IconStyle", "BalloonStyle", "LabelStyle"], d, e, f = 0, g = c.length; f < g; ++f)if (d = c[f], e = this.getElementsByTagNameNS(a, "*", d)[0])switch (d.toLowerCase()) {
            case "linestyle":
                d = this.parseProperty(e, "*", "color");
                if (d = this.parseKmlColor(d))b.strokeColor = d.color, b.strokeOpacity = d.opacity;
                (d = this.parseProperty(e, "*", "width")) && (b.strokeWidth =
                    d);
                break;
            case "polystyle":
                d = this.parseProperty(e, "*", "color");
                if (d = this.parseKmlColor(d))b.fillOpacity = d.opacity, b.fillColor = d.color;
                "0" == this.parseProperty(e, "*", "fill") && (b.fillColor = "none");
                "0" == this.parseProperty(e, "*", "outline") && (b.strokeWidth = "0");
                break;
            case "iconstyle":
                var h = parseFloat(this.parseProperty(e, "*", "scale") || 1);
                d = 32 * h;
                var k = 32 * h, l = this.getElementsByTagNameNS(e, "*", "Icon")[0];
                if (l) {
                    var m = this.parseProperty(l, "*", "href");
                    if (m) {
                        var n = this.parseProperty(l, "*", "w"), o = this.parseProperty(l,
                            "*", "h");
                        OpenLayers.String.startsWith(m, "http://maps.google.com/mapfiles/kml") && !n && !o && (o = n = 64, h /= 2);
                        n = n || o;
                        o = o || n;
                        n && (d = parseInt(n) * h);
                        o && (k = parseInt(o) * h);
                        if (o = m.match(this.regExes.kmlIconPalette))n = o[1], o = o[2], m = this.parseProperty(l, "*", "x"), l = this.parseProperty(l, "*", "y"), m = "http://maps.google.com/mapfiles/kml/pal" + n + "/icon" + (8 * (l ? 7 - l / 32 : 7) + (m ? m / 32 : 0)) + o;
                        b.graphicOpacity = 1;
                        b.externalGraphic = m
                    }
                }
                if (e = this.getElementsByTagNameNS(e, "*", "hotSpot")[0])m = parseFloat(e.getAttribute("x")), l = parseFloat(e.getAttribute("y")),
                    n = e.getAttribute("xunits"), "pixels" == n ? b.graphicXOffset = -m * h : "insetPixels" == n ? b.graphicXOffset = -d + m * h : "fraction" == n && (b.graphicXOffset = -d * m), e = e.getAttribute("yunits"), "pixels" == e ? b.graphicYOffset = -k + l * h + 1 : "insetPixels" == e ? b.graphicYOffset = -(l * h) + 1 : "fraction" == e && (b.graphicYOffset = -k * (1 - l) + 1);
                b.graphicWidth = d;
                b.graphicHeight = k;
                break;
            case "balloonstyle":
                (e = OpenLayers.Util.getXmlNodeValue(e)) && (b.balloonStyle = e.replace(this.regExes.straightBracket, "${$1}"));
                break;
            case "labelstyle":
                if (d = this.parseProperty(e,
                        "*", "color"), d = this.parseKmlColor(d))b.fontColor = d.color, b.fontOpacity = d.opacity
        }
        !b.strokeColor && b.fillColor && (b.strokeColor = b.fillColor);
        if ((a = a.getAttribute("id")) && b)b.id = a;
        return b
    },
    parseStyleMaps: function (a, b) {
        for (var c = 0, d = a.length; c < d; c++)for (var e = a[c], f = this.getElementsByTagNameNS(e, "*", "Pair"), e = e.getAttribute("id"), g = 0, h = f.length; g < h; g++) {
            var k = f[g], l = this.parseProperty(k, "*", "key");
            (k = this.parseProperty(k, "*", "styleUrl")) && "normal" == l && (this.styles[(b.styleBaseUrl || "") + "#" + e] = this.styles[(b.styleBaseUrl ||
            "") + k])
        }
    },
    parseFeatures: function (a, b) {
        for (var c = [], d = 0, e = a.length; d < e; d++) {
            var f = a[d], g = this.parseFeature.apply(this, [f]);
            if (g) {
                this.extractStyles && g.attributes && g.attributes.styleUrl && (g.style = this.getStyle(g.attributes.styleUrl, b));
                if (this.extractStyles) {
                    var h = this.getElementsByTagNameNS(f, "*", "Style")[0];
                    if (h && (h = this.parseStyle(h)))g.style = OpenLayers.Util.extend(g.style, h)
                }
                if (this.extractTracks) {
                    if ((f = this.getElementsByTagNameNS(f, this.namespaces.gx, "Track")) && 0 < f.length)g = {
                        features: [],
                        feature: g
                    },
                        this.readNode(f[0], g), 0 < g.features.length && c.push.apply(c, g.features)
                } else c.push(g)
            } else throw"Bad Placemark: " + d;
        }
        this.features = this.features.concat(c)
    },
    readers: {
        kml: {
            when: function (a, b) {
                b.whens.push(OpenLayers.Date.parse(this.getChildValue(a)))
            }, _trackPointAttribute: function (a, b) {
                var c = a.nodeName.split(":").pop();
                b.attributes[c].push(this.getChildValue(a))
            }
        }, gx: {
            Track: function (a, b) {
                var c = {whens: [], points: [], angles: []};
                if (this.trackAttributes) {
                    var d;
                    c.attributes = {};
                    for (var e = 0, f = this.trackAttributes.length; e <
                    f; ++e)d = this.trackAttributes[e], c.attributes[d] = [], d in this.readers.kml || (this.readers.kml[d] = this.readers.kml._trackPointAttribute)
                }
                this.readChildNodes(a, c);
                if (c.whens.length !== c.points.length)throw Error("gx:Track with unequal number of when (" + c.whens.length + ") and gx:coord (" + c.points.length + ") elements.");
                var g = 0 < c.angles.length;
                if (g && c.whens.length !== c.angles.length)throw Error("gx:Track with unequal number of when (" + c.whens.length + ") and gx:angles (" + c.angles.length + ") elements.");
                for (var h,
                         k, e = 0, f = c.whens.length; e < f; ++e) {
                    h = b.feature.clone();
                    h.fid = b.feature.fid || b.feature.id;
                    k = c.points[e];
                    h.geometry = k;
                    "z"in k && (h.attributes.altitude = k.z);
                    this.internalProjection && this.externalProjection && h.geometry.transform(this.externalProjection, this.internalProjection);
                    if (this.trackAttributes) {
                        k = 0;
                        for (var l = this.trackAttributes.length; k < l; ++k)h.attributes[d] = c.attributes[this.trackAttributes[k]][e]
                    }
                    h.attributes.when = c.whens[e];
                    h.attributes.trackId = b.feature.id;
                    g && (k = c.angles[e], h.attributes.heading =
                        parseFloat(k[0]), h.attributes.tilt = parseFloat(k[1]), h.attributes.roll = parseFloat(k[2]));
                    b.features.push(h)
                }
            }, coord: function (a, b) {
                var c = this.getChildValue(a).replace(this.regExes.trimSpace, "").split(/\s+/), d = new OpenLayers.Geometry.Point(c[0], c[1]);
                2 < c.length && (d.z = parseFloat(c[2]));
                b.points.push(d)
            }, angles: function (a, b) {
                var c = this.getChildValue(a).replace(this.regExes.trimSpace, "").split(/\s+/);
                b.angles.push(c)
            }
        }
    },
    parseFeature: function (a) {
        for (var b = ["MultiGeometry", "Polygon", "LineString", "Point"],
                 c, d, e, f = 0, g = b.length; f < g; ++f)if (c = b[f], this.internalns = a.namespaceURI ? a.namespaceURI : this.kmlns, d = this.getElementsByTagNameNS(a, this.internalns, c), 0 < d.length) {
            if (b = this.parseGeometry[c.toLowerCase()])e = b.apply(this, [d[0]]), this.internalProjection && this.externalProjection && e.transform(this.externalProjection, this.internalProjection); else throw new TypeError("Unsupported geometry type: " + c);
            break
        }
        var h;
        this.extractAttributes && (h = this.parseAttributes(a));
        c = new OpenLayers.Feature.Vector(e, h);
        a = a.getAttribute("id") ||
        a.getAttribute("name");
        null != a && (c.fid = a);
        return c
    },
    getStyle: function (a, b) {
        var c = OpenLayers.Util.removeTail(a), d = OpenLayers.Util.extend({}, b);
        d.depth++;
        d.styleBaseUrl = c;
        !this.styles[a] && !OpenLayers.String.startsWith(a, "#") && d.depth <= this.maxDepth && !this.fetched[c] && (c = this.fetchLink(c)) && this.parseData(c, d);
        return OpenLayers.Util.extend({}, this.styles[a])
    },
    parseGeometry: {
        point: function (a) {
            var b = this.getElementsByTagNameNS(a, this.internalns, "coordinates"), a = [];
            if (0 < b.length)var c = b[0].firstChild.nodeValue,
                c = c.replace(this.regExes.removeSpace, ""), a = c.split(",");
            if (1 < a.length)2 == a.length && (a[2] = null), b = new OpenLayers.Geometry.Point(a[0], a[1], a[2]); else throw"Bad coordinate string: " + c;
            return b
        }, linestring: function (a, b) {
            var c = this.getElementsByTagNameNS(a, this.internalns, "coordinates"), d = null;
            if (0 < c.length) {
                for (var c = this.getChildValue(c[0]), c = c.replace(this.regExes.trimSpace, ""), c = c.replace(this.regExes.trimComma, ","), d = c.split(this.regExes.splitSpace), e = d.length, f = Array(e), g, h, k = 0; k < e; ++k)if (g = d[k].split(","),
                        h = g.length, 1 < h)2 == g.length && (g[2] = null), f[k] = new OpenLayers.Geometry.Point(g[0], g[1], g[2]); else throw"Bad LineString point coordinates: " + d[k];
                if (e)d = b ? new OpenLayers.Geometry.LinearRing(f) : new OpenLayers.Geometry.LineString(f); else throw"Bad LineString coordinates: " + c;
            }
            return d
        }, polygon: function (a) {
            var a = this.getElementsByTagNameNS(a, this.internalns, "LinearRing"), b = a.length, c = Array(b);
            if (0 < b)for (var d = 0, e = a.length; d < e; ++d)if (b = this.parseGeometry.linestring.apply(this, [a[d], !0]))c[d] = b; else throw"Bad LinearRing geometry: " +
            d;
            return new OpenLayers.Geometry.Polygon(c)
        }, multigeometry: function (a) {
            for (var b, c = [], d = a.childNodes, e = 0, f = d.length; e < f; ++e)a = d[e], 1 == a.nodeType && (b = this.parseGeometry[(a.prefix ? a.nodeName.split(":")[1] : a.nodeName).toLowerCase()]) && c.push(b.apply(this, [a]));
            return new OpenLayers.Geometry.Collection(c)
        }
    },
    parseAttributes: function (a) {
        var b = {}, c = a.getElementsByTagName("ExtendedData");
        c.length && (b = this.parseExtendedData(c[0]));
        for (var d, e, f, a = a.childNodes, c = 0, g = a.length; c < g; ++c)if (d = a[c], 1 == d.nodeType &&
            (e = d.childNodes, 1 <= e.length && 3 >= e.length)) {
            switch (e.length) {
                case 1:
                    f = e[0];
                    break;
                case 2:
                    f = e[0];
                    e = e[1];
                    f = 3 == f.nodeType || 4 == f.nodeType ? f : e;
                    break;
                default:
                    f = e[1]
            }
            if (3 == f.nodeType || 4 == f.nodeType)if (d = d.prefix ? d.nodeName.split(":")[1] : d.nodeName, f = OpenLayers.Util.getXmlNodeValue(f))f = f.replace(this.regExes.trimSpace, ""), b[d] = f
        }
        return b
    },
    parseExtendedData: function (a) {
        var b = {}, c, d, e, f, g = a.getElementsByTagName("Data");
        for (c = 0, d = g.length; c < d; c++) {
            e = g[c];
            f = e.getAttribute("name");
            var h = {}, k = e.getElementsByTagName("value");
            k.length && (h.value = this.getChildValue(k[0]));
            this.kvpAttributes ? b[f] = h.value : (e = e.getElementsByTagName("displayName"), e.length && (h.displayName = this.getChildValue(e[0])), b[f] = h)
        }
        a = a.getElementsByTagName("SimpleData");
        for (c = 0, d = a.length; c < d; c++)h = {}, e = a[c], f = e.getAttribute("name"), h.value = this.getChildValue(e), this.kvpAttributes ? b[f] = h.value : (h.displayName = f, b[f] = h);
        return b
    },
    parseProperty: function (a, b, c) {
        var d, a = this.getElementsByTagNameNS(a, b, c);
        try {
            d = OpenLayers.Util.getXmlNodeValue(a[0])
        } catch (e) {
            d =
                null
        }
        return d
    },
    write: function (a) {
        OpenLayers.Util.isArray(a) || (a = [a]);
        for (var b = this.createElementNS(this.kmlns, "kml"), c = this.createFolderXML(), d = 0, e = a.length; d < e; ++d)c.appendChild(this.createPlacemarkXML(a[d]));
        b.appendChild(c);
        return OpenLayers.Format.XML.prototype.write.apply(this, [b])
    },
    createFolderXML: function () {
        var a = this.createElementNS(this.kmlns, "Folder");
        if (this.foldersName) {
            var b = this.createElementNS(this.kmlns, "name"), c = this.createTextNode(this.foldersName);
            b.appendChild(c);
            a.appendChild(b)
        }
        this.foldersDesc &&
        (b = this.createElementNS(this.kmlns, "description"), c = this.createTextNode(this.foldersDesc), b.appendChild(c), a.appendChild(b));
        return a
    },
    createPlacemarkXML: function (a) {
        var b = this.createElementNS(this.kmlns, "name");
        b.appendChild(this.createTextNode(a.style && a.style.label ? a.style.label : a.attributes.name || a.id));
        var c = this.createElementNS(this.kmlns, "description");
        c.appendChild(this.createTextNode(a.attributes.description || this.placemarksDesc));
        var d = this.createElementNS(this.kmlns, "Placemark");
        null !=
        a.fid && d.setAttribute("id", a.fid);
        d.appendChild(b);
        d.appendChild(c);
        b = this.buildGeometryNode(a.geometry);
        d.appendChild(b);
        a.attributes && (a = this.buildExtendedData(a.attributes)) && d.appendChild(a);
        return d
    },
    buildGeometryNode: function (a) {
        var b = a.CLASS_NAME, b = this.buildGeometry[b.substring(b.lastIndexOf(".") + 1).toLowerCase()], c = null;
        b && (c = b.apply(this, [a]));
        return c
    },
    buildGeometry: {
        point: function (a) {
            var b = this.createElementNS(this.kmlns, "Point");
            b.appendChild(this.buildCoordinatesNode(a));
            return b
        }, multipoint: function (a) {
            return this.buildGeometry.collection.apply(this,
                [a])
        }, linestring: function (a) {
            var b = this.createElementNS(this.kmlns, "LineString");
            b.appendChild(this.buildCoordinatesNode(a));
            return b
        }, multilinestring: function (a) {
            return this.buildGeometry.collection.apply(this, [a])
        }, linearring: function (a) {
            var b = this.createElementNS(this.kmlns, "LinearRing");
            b.appendChild(this.buildCoordinatesNode(a));
            return b
        }, polygon: function (a) {
            for (var b = this.createElementNS(this.kmlns, "Polygon"), a = a.components, c, d, e = 0, f = a.length; e < f; ++e)c = 0 == e ? "outerBoundaryIs" : "innerBoundaryIs",
                c = this.createElementNS(this.kmlns, c), d = this.buildGeometry.linearring.apply(this, [a[e]]), c.appendChild(d), b.appendChild(c);
            return b
        }, multipolygon: function (a) {
            return this.buildGeometry.collection.apply(this, [a])
        }, collection: function (a) {
            for (var b = this.createElementNS(this.kmlns, "MultiGeometry"), c, d = 0, e = a.components.length; d < e; ++d)(c = this.buildGeometryNode.apply(this, [a.components[d]])) && b.appendChild(c);
            return b
        }
    },
    buildCoordinatesNode: function (a) {
        var b = this.createElementNS(this.kmlns, "coordinates"),
            c;
        if (c = a.components) {
            for (var d = c.length, e = Array(d), f = 0; f < d; ++f)a = c[f], e[f] = this.buildCoordinates(a);
            c = e.join(" ")
        } else c = this.buildCoordinates(a);
        c = this.createTextNode(c);
        b.appendChild(c);
        return b
    },
    buildCoordinates: function (a) {
        this.internalProjection && this.externalProjection && (a = a.clone(), a.transform(this.internalProjection, this.externalProjection));
        return a.x + "," + a.y
    },
    buildExtendedData: function (a) {
        var b = this.createElementNS(this.kmlns, "ExtendedData"), c;
        for (c in a)if (a[c] && "name" != c && "description" !=
            c && "styleUrl" != c) {
            var d = this.createElementNS(this.kmlns, "Data");
            d.setAttribute("name", c);
            var e = this.createElementNS(this.kmlns, "value");
            if ("object" == typeof a[c]) {
                if (a[c].value && e.appendChild(this.createTextNode(a[c].value)), a[c].displayName) {
                    var f = this.createElementNS(this.kmlns, "displayName");
                    f.appendChild(this.getXMLDoc().createCDATASection(a[c].displayName));
                    d.appendChild(f)
                }
            } else e.appendChild(this.createTextNode(a[c]));
            d.appendChild(e);
            b.appendChild(d)
        }
        return this.isSimpleContent(b) ? null : b
    },
    CLASS_NAME: "OpenLayers.Format.KML"
});
OpenLayers.Format.GeoRSS = OpenLayers.Class(OpenLayers.Format.XML, {
    rssns: "http://backend.userland.com/rss2",
    featureNS: "http://mapserver.gis.umn.edu/mapserver",
    georssns: "http://www.georss.org/georss",
    geons: "http://www.w3.org/2003/01/geo/wgs84_pos#",
    featureTitle: "Untitled",
    featureDescription: "No Description",
    gmlParser: null,
    xy: !1,
    createGeometryFromItem: function (a) {
        var b = this.getElementsByTagNameNS(a, this.georssns, "point"), c = this.getElementsByTagNameNS(a, this.geons, "lat"), d = this.getElementsByTagNameNS(a,
            this.geons, "long"), e = this.getElementsByTagNameNS(a, this.georssns, "line"), f = this.getElementsByTagNameNS(a, this.georssns, "polygon"), g = this.getElementsByTagNameNS(a, this.georssns, "where"), a = this.getElementsByTagNameNS(a, this.georssns, "box");
        if (0 < b.length || 0 < c.length && 0 < d.length) {
            0 < b.length ? (c = OpenLayers.String.trim(b[0].firstChild.nodeValue).split(/\s+/), 2 != c.length && (c = OpenLayers.String.trim(b[0].firstChild.nodeValue).split(/\s*,\s*/))) : c = [parseFloat(c[0].firstChild.nodeValue), parseFloat(d[0].firstChild.nodeValue)];
            var h = new OpenLayers.Geometry.Point(c[1], c[0])
        } else if (0 < e.length) {
            c = OpenLayers.String.trim(this.getChildValue(e[0])).split(/\s+/);
            d = [];
            e = 0;
            for (f = c.length; e < f; e += 2)b = new OpenLayers.Geometry.Point(c[e + 1], c[e]), d.push(b);
            h = new OpenLayers.Geometry.LineString(d)
        } else if (0 < f.length) {
            c = OpenLayers.String.trim(this.getChildValue(f[0])).split(/\s+/);
            d = [];
            e = 0;
            for (f = c.length; e < f; e += 2)b = new OpenLayers.Geometry.Point(c[e + 1], c[e]), d.push(b);
            h = new OpenLayers.Geometry.Polygon([new OpenLayers.Geometry.LinearRing(d)])
        } else 0 <
        g.length ? (this.gmlParser || (this.gmlParser = new OpenLayers.Format.GML({xy: this.xy})), h = this.gmlParser.parseFeature(g[0]).geometry) : 0 < a.length && (c = OpenLayers.String.trim(a[0].firstChild.nodeValue).split(/\s+/), d = [], 3 < c.length && (b = new OpenLayers.Geometry.Point(c[1], c[0]), d.push(b), b = new OpenLayers.Geometry.Point(c[1], c[2]), d.push(b), b = new OpenLayers.Geometry.Point(c[3], c[2]), d.push(b), b = new OpenLayers.Geometry.Point(c[3], c[0]), d.push(b), b = new OpenLayers.Geometry.Point(c[1], c[0]), d.push(b)), h = new OpenLayers.Geometry.Polygon([new OpenLayers.Geometry.LinearRing(d)]));
        h && this.internalProjection && this.externalProjection && h.transform(this.externalProjection, this.internalProjection);
        return h
    },
    createFeatureFromItem: function (a) {
        var b = this.createGeometryFromItem(a), c = this._getChildValue(a, "*", "title", this.featureTitle), d = this._getChildValue(a, "*", "description", this._getChildValue(a, "*", "content", this._getChildValue(a, "*", "summary", this.featureDescription))), e = this._getChildValue(a, "*", "link");
        if (!e)try {
            e = this.getElementsByTagNameNS(a, "*", "link")[0].getAttribute("href")
        } catch (f) {
            e =
                null
        }
        a = this._getChildValue(a, "*", "id", null);
        b = new OpenLayers.Feature.Vector(b, {title: c, description: d, link: e});
        b.fid = a;
        return b
    },
    _getChildValue: function (a, b, c, d) {
        return (a = this.getElementsByTagNameNS(a, b, c)) && a[0] && a[0].firstChild && a[0].firstChild.nodeValue ? this.getChildValue(a[0]) : void 0 == d ? "" : d
    },
    read: function (a) {
        "string" == typeof a && (a = OpenLayers.Format.XML.prototype.read.apply(this, [a]));
        var b = null, b = this.getElementsByTagNameNS(a, "*", "item");
        0 == b.length && (b = this.getElementsByTagNameNS(a, "*", "entry"));
        for (var a = b.length, c = Array(a), d = 0; d < a; d++)c[d] = this.createFeatureFromItem(b[d]);
        return c
    },
    write: function (a) {
        var b;
        if (OpenLayers.Util.isArray(a)) {
            b = this.createElementNS(this.rssns, "rss");
            for (var c = 0, d = a.length; c < d; c++)b.appendChild(this.createFeatureXML(a[c]))
        } else b = this.createFeatureXML(a);
        return OpenLayers.Format.XML.prototype.write.apply(this, [b])
    },
    createFeatureXML: function (a) {
        var b = this.buildGeometryNode(a.geometry), c = this.createElementNS(this.rssns, "item"), d = this.createElementNS(this.rssns, "title");
        d.appendChild(this.createTextNode(a.attributes.title ? a.attributes.title : ""));
        var e = this.createElementNS(this.rssns, "description");
        e.appendChild(this.createTextNode(a.attributes.description ? a.attributes.description : ""));
        c.appendChild(d);
        c.appendChild(e);
        a.attributes.link && (d = this.createElementNS(this.rssns, "link"), d.appendChild(this.createTextNode(a.attributes.link)), c.appendChild(d));
        for (var f in a.attributes)"link" == f || "title" == f || "description" == f || (d = this.createTextNode(a.attributes[f]), e = f, -1 !=
        f.search(":") && (e = f.split(":")[1]), e = this.createElementNS(this.featureNS, "feature:" + e), e.appendChild(d), c.appendChild(e));
        c.appendChild(b);
        return c
    },
    buildGeometryNode: function (a) {
        this.internalProjection && this.externalProjection && (a = a.clone(), a.transform(this.internalProjection, this.externalProjection));
        var b;
        if ("OpenLayers.Geometry.Polygon" == a.CLASS_NAME)b = this.createElementNS(this.georssns, "georss:polygon"), b.appendChild(this.buildCoordinatesNode(a.components[0])); else if ("OpenLayers.Geometry.LineString" ==
            a.CLASS_NAME)b = this.createElementNS(this.georssns, "georss:line"), b.appendChild(this.buildCoordinatesNode(a)); else if ("OpenLayers.Geometry.Point" == a.CLASS_NAME)b = this.createElementNS(this.georssns, "georss:point"), b.appendChild(this.buildCoordinatesNode(a)); else throw"Couldn't parse " + a.CLASS_NAME;
        return b
    },
    buildCoordinatesNode: function (a) {
        var b = null;
        a.components && (b = a.components);
        if (b) {
            for (var a = b.length, c = Array(a), d = 0; d < a; d++)c[d] = b[d].y + " " + b[d].x;
            b = c.join(" ")
        } else b = a.y + " " + a.x;
        return this.createTextNode(b)
    },
    CLASS_NAME: "OpenLayers.Format.GeoRSS"
});
OpenLayers.Format.WFS = OpenLayers.Class(OpenLayers.Format.GML, {
    layer: null, wfsns: "http://www.opengis.net/wfs", ogcns: "http://www.opengis.net/ogc", initialize: function (a, b) {
        OpenLayers.Format.GML.prototype.initialize.apply(this, [a]);
        this.layer = b;
        this.layer.featureNS && (this.featureNS = this.layer.featureNS);
        this.layer.options.geometry_column && (this.geometryName = this.layer.options.geometry_column);
        this.layer.options.typename && (this.featureName = this.layer.options.typename)
    }, write: function (a) {
        var b = this.createElementNS(this.wfsns,
            "wfs:Transaction");
        b.setAttribute("version", "1.0.0");
        b.setAttribute("service", "WFS");
        for (var c = 0; c < a.length; c++)switch (a[c].state) {
            case OpenLayers.State.INSERT:
                b.appendChild(this.insert(a[c]));
                break;
            case OpenLayers.State.UPDATE:
                b.appendChild(this.update(a[c]));
                break;
            case OpenLayers.State.DELETE:
                b.appendChild(this.remove(a[c]))
        }
        return OpenLayers.Format.XML.prototype.write.apply(this, [b])
    }, createFeatureXML: function (a) {
        var b = this.buildGeometryNode(a.geometry), c = this.createElementNS(this.featureNS, "feature:" +
        this.geometryName);
        c.appendChild(b);
        b = this.createElementNS(this.featureNS, "feature:" + this.featureName);
        b.appendChild(c);
        for (var d in a.attributes) {
            var c = this.createTextNode(a.attributes[d]), e = d;
            -1 != d.search(":") && (e = d.split(":")[1]);
            e = this.createElementNS(this.featureNS, "feature:" + e);
            e.appendChild(c);
            b.appendChild(e)
        }
        return b
    }, insert: function (a) {
        var b = this.createElementNS(this.wfsns, "wfs:Insert");
        b.appendChild(this.createFeatureXML(a));
        return b
    }, update: function (a) {
        a.fid || OpenLayers.Console.userError(OpenLayers.i18n("noFID"));
        var b = this.createElementNS(this.wfsns, "wfs:Update");
        b.setAttribute("typeName", this.featurePrefix + ":" + this.featureName);
        b.setAttribute("xmlns:" + this.featurePrefix, this.featureNS);
        var c = this.createElementNS(this.wfsns, "wfs:Property"), d = this.createElementNS(this.wfsns, "wfs:Name"), e = this.createTextNode(this.geometryName);
        d.appendChild(e);
        c.appendChild(d);
        d = this.createElementNS(this.wfsns, "wfs:Value");
        e = this.buildGeometryNode(a.geometry);
        a.layer && e.setAttribute("srsName", a.layer.projection.getCode());
        d.appendChild(e);
        c.appendChild(d);
        b.appendChild(c);
        for (var f in a.attributes)c = this.createElementNS(this.wfsns, "wfs:Property"), d = this.createElementNS(this.wfsns, "wfs:Name"), d.appendChild(this.createTextNode(f)), c.appendChild(d), d = this.createElementNS(this.wfsns, "wfs:Value"), d.appendChild(this.createTextNode(a.attributes[f])), c.appendChild(d), b.appendChild(c);
        c = this.createElementNS(this.ogcns, "ogc:Filter");
        f = this.createElementNS(this.ogcns, "ogc:FeatureId");
        f.setAttribute("fid", a.fid);
        c.appendChild(f);
        b.appendChild(c);
        return b
    }, remove: function (a) {
        if (!a.fid)return OpenLayers.Console.userError(OpenLayers.i18n("noFID")), !1;
        var b = this.createElementNS(this.wfsns, "wfs:Delete");
        b.setAttribute("typeName", this.featurePrefix + ":" + this.featureName);
        b.setAttribute("xmlns:" + this.featurePrefix, this.featureNS);
        var c = this.createElementNS(this.ogcns, "ogc:Filter"), d = this.createElementNS(this.ogcns, "ogc:FeatureId");
        d.setAttribute("fid", a.fid);
        c.appendChild(d);
        b.appendChild(c);
        return b
    }, destroy: function () {
        this.layer =
            null
    }, CLASS_NAME: "OpenLayers.Format.WFS"
});
OpenLayers.Format.OWSCommon = OpenLayers.Class(OpenLayers.Format.XML.VersionedOGC, {
    defaultVersion: "1.0.0",
    getVersion: function (a) {
        var b = this.version;
        b || ((a = a.getAttribute("xmlns:ows")) && "1.1" === a.substring(a.lastIndexOf("/") + 1) && (b = "1.1.0"), b || (b = this.defaultVersion));
        return b
    },
    CLASS_NAME: "OpenLayers.Format.OWSCommon"
});
OpenLayers.Format.OWSCommon.v1 = OpenLayers.Class(OpenLayers.Format.XML, {
    regExes: {trimSpace: /^\s*|\s*$/g, removeSpace: /\s*/g, splitSpace: /\s+/, trimComma: /\s*,\s*/g},
    read: function (a, b) {
        OpenLayers.Util.applyDefaults(b, this.options);
        var c = {};
        this.readChildNodes(a, c);
        return c
    },
    readers: {
        ows: {
            Exception: function (a, b) {
                var c = {code: a.getAttribute("exceptionCode"), locator: a.getAttribute("locator"), texts: []};
                b.exceptions.push(c);
                this.readChildNodes(a, c)
            }, ExceptionText: function (a, b) {
                var c = this.getChildValue(a);
                b.texts.push(c)
            },
            ServiceIdentification: function (a, b) {
                b.serviceIdentification = {};
                this.readChildNodes(a, b.serviceIdentification)
            }, Title: function (a, b) {
                b.title = this.getChildValue(a)
            }, Abstract: function (a, b) {
                b["abstract"] = this.getChildValue(a)
            }, Keywords: function (a, b) {
                b.keywords = {};
                this.readChildNodes(a, b.keywords)
            }, Keyword: function (a, b) {
                b[this.getChildValue(a)] = !0
            }, ServiceType: function (a, b) {
                b.serviceType = {codeSpace: a.getAttribute("codeSpace"), value: this.getChildValue(a)}
            }, ServiceTypeVersion: function (a, b) {
                b.serviceTypeVersion =
                    this.getChildValue(a)
            }, Fees: function (a, b) {
                b.fees = this.getChildValue(a)
            }, AccessConstraints: function (a, b) {
                b.accessConstraints = this.getChildValue(a)
            }, ServiceProvider: function (a, b) {
                b.serviceProvider = {};
                this.readChildNodes(a, b.serviceProvider)
            }, ProviderName: function (a, b) {
                b.providerName = this.getChildValue(a)
            }, ProviderSite: function (a, b) {
                b.providerSite = this.getAttributeNS(a, this.namespaces.xlink, "href")
            }, ServiceContact: function (a, b) {
                b.serviceContact = {};
                this.readChildNodes(a, b.serviceContact)
            }, IndividualName: function (a,
                                         b) {
                b.individualName = this.getChildValue(a)
            }, PositionName: function (a, b) {
                b.positionName = this.getChildValue(a)
            }, ContactInfo: function (a, b) {
                b.contactInfo = {};
                this.readChildNodes(a, b.contactInfo)
            }, Phone: function (a, b) {
                b.phone = {};
                this.readChildNodes(a, b.phone)
            }, Voice: function (a, b) {
                b.voice = this.getChildValue(a)
            }, Address: function (a, b) {
                b.address = {};
                this.readChildNodes(a, b.address)
            }, DeliveryPoint: function (a, b) {
                b.deliveryPoint = this.getChildValue(a)
            }, City: function (a, b) {
                b.city = this.getChildValue(a)
            }, AdministrativeArea: function (a,
                                             b) {
                b.administrativeArea = this.getChildValue(a)
            }, PostalCode: function (a, b) {
                b.postalCode = this.getChildValue(a)
            }, Country: function (a, b) {
                b.country = this.getChildValue(a)
            }, ElectronicMailAddress: function (a, b) {
                b.electronicMailAddress = this.getChildValue(a)
            }, Role: function (a, b) {
                b.role = this.getChildValue(a)
            }, OperationsMetadata: function (a, b) {
                b.operationsMetadata = {};
                this.readChildNodes(a, b.operationsMetadata)
            }, Operation: function (a, b) {
                var c = a.getAttribute("name");
                b[c] = {};
                this.readChildNodes(a, b[c])
            }, DCP: function (a,
                              b) {
                b.dcp = {};
                this.readChildNodes(a, b.dcp)
            }, HTTP: function (a, b) {
                b.http = {};
                this.readChildNodes(a, b.http)
            }, Get: function (a, b) {
                b.get || (b.get = []);
                var c = {url: this.getAttributeNS(a, this.namespaces.xlink, "href")};
                this.readChildNodes(a, c);
                b.get.push(c)
            }, Post: function (a, b) {
                b.post || (b.post = []);
                var c = {url: this.getAttributeNS(a, this.namespaces.xlink, "href")};
                this.readChildNodes(a, c);
                b.post.push(c)
            }, Parameter: function (a, b) {
                b.parameters || (b.parameters = {});
                var c = a.getAttribute("name");
                b.parameters[c] = {};
                this.readChildNodes(a,
                    b.parameters[c])
            }, Constraint: function (a, b) {
                b.constraints || (b.constraints = {});
                var c = a.getAttribute("name");
                b.constraints[c] = {};
                this.readChildNodes(a, b.constraints[c])
            }, Value: function (a, b) {
                b[this.getChildValue(a)] = !0
            }, OutputFormat: function (a, b) {
                b.formats.push({value: this.getChildValue(a)});
                this.readChildNodes(a, b)
            }, WGS84BoundingBox: function (a, b) {
                var c = {};
                c.crs = a.getAttribute("crs");
                b.BoundingBox ? b.BoundingBox.push(c) : (b.projection = c.crs, c = b);
                this.readChildNodes(a, c)
            }, BoundingBox: function (a, b) {
                this.readers.ows.WGS84BoundingBox.apply(this,
                    [a, b])
            }, LowerCorner: function (a, b) {
                var c = this.getChildValue(a).replace(this.regExes.trimSpace, ""), c = c.replace(this.regExes.trimComma, ","), c = c.split(this.regExes.splitSpace);
                b.left = c[0];
                b.bottom = c[1]
            }, UpperCorner: function (a, b) {
                var c = this.getChildValue(a).replace(this.regExes.trimSpace, ""), c = c.replace(this.regExes.trimComma, ","), c = c.split(this.regExes.splitSpace);
                b.right = c[0];
                b.top = c[1];
                b.bounds = new OpenLayers.Bounds(b.left, b.bottom, b.right, b.top);
                delete b.left;
                delete b.bottom;
                delete b.right;
                delete b.top
            },
            Language: function (a, b) {
                b.language = this.getChildValue(a)
            }
        }
    },
    writers: {
        ows: {
            BoundingBox: function (a) {
                var b = this.createElementNSPlus("ows:BoundingBox", {attributes: {crs: a.projection}});
                this.writeNode("ows:LowerCorner", a, b);
                this.writeNode("ows:UpperCorner", a, b);
                return b
            }, LowerCorner: function (a) {
                return this.createElementNSPlus("ows:LowerCorner", {value: a.bounds.left + " " + a.bounds.bottom})
            }, UpperCorner: function (a) {
                return this.createElementNSPlus("ows:UpperCorner", {value: a.bounds.right + " " + a.bounds.top})
            }, Identifier: function (a) {
                return this.createElementNSPlus("ows:Identifier",
                    {value: a})
            }, Title: function (a) {
                return this.createElementNSPlus("ows:Title", {value: a})
            }, Abstract: function (a) {
                return this.createElementNSPlus("ows:Abstract", {value: a})
            }, OutputFormat: function (a) {
                return this.createElementNSPlus("ows:OutputFormat", {value: a})
            }
        }
    },
    CLASS_NAME: "OpenLayers.Format.OWSCommon.v1"
});
OpenLayers.Format.OWSCommon.v1_0_0 = OpenLayers.Class(OpenLayers.Format.OWSCommon.v1, {
    namespaces: {ows: "http://www.opengis.net/ows", xlink: "http://www.w3.org/1999/xlink"},
    readers: {
        ows: OpenLayers.Util.applyDefaults({
            ExceptionReport: function (a, b) {
                b.success = !1;
                b.exceptionReport = {
                    version: a.getAttribute("version"),
                    language: a.getAttribute("language"),
                    exceptions: []
                };
                this.readChildNodes(a, b.exceptionReport)
            }
        }, OpenLayers.Format.OWSCommon.v1.prototype.readers.ows)
    },
    writers: {ows: OpenLayers.Format.OWSCommon.v1.prototype.writers.ows},
    CLASS_NAME: "OpenLayers.Format.OWSCommon.v1_0_0"
});
OpenLayers.Format.OWSCommon.v1_1_0 = OpenLayers.Class(OpenLayers.Format.OWSCommon.v1, {
    namespaces: {ows: "http://www.opengis.net/ows/1.1", xlink: "http://www.w3.org/1999/xlink"}, readers: {
        ows: OpenLayers.Util.applyDefaults({
            ExceptionReport: function (a, b) {
                b.exceptionReport = {
                    version: a.getAttribute("version"),
                    language: a.getAttribute("xml:lang"),
                    exceptions: []
                };
                this.readChildNodes(a, b.exceptionReport)
            }, AllowedValues: function (a, b) {
                b.allowedValues = {};
                this.readChildNodes(a, b.allowedValues)
            }, AnyValue: function (a, b) {
                b.anyValue = !0
            }, DataType: function (a, b) {
                b.dataType = this.getChildValue(a)
            }, Range: function (a, b) {
                b.range = {};
                this.readChildNodes(a, b.range)
            }, MinimumValue: function (a, b) {
                b.minValue = this.getChildValue(a)
            }, MaximumValue: function (a, b) {
                b.maxValue = this.getChildValue(a)
            }, Identifier: function (a, b) {
                b.identifier = this.getChildValue(a)
            }, SupportedCRS: function (a, b) {
                b.supportedCRS = this.getChildValue(a)
            }
        }, OpenLayers.Format.OWSCommon.v1.prototype.readers.ows)
    }, writers: {
        ows: OpenLayers.Util.applyDefaults({
            Range: function (a) {
                var b = this.createElementNSPlus("ows:Range",
                    {attributes: {"ows:rangeClosure": a.closure}});
                this.writeNode("ows:MinimumValue", a.minValue, b);
                this.writeNode("ows:MaximumValue", a.maxValue, b);
                return b
            }, MinimumValue: function (a) {
                return this.createElementNSPlus("ows:MinimumValue", {value: a})
            }, MaximumValue: function (a) {
                return this.createElementNSPlus("ows:MaximumValue", {value: a})
            }, Value: function (a) {
                return this.createElementNSPlus("ows:Value", {value: a})
            }
        }, OpenLayers.Format.OWSCommon.v1.prototype.writers.ows)
    }, CLASS_NAME: "OpenLayers.Format.OWSCommon.v1_1_0"
});
OpenLayers.Format.WFSCapabilities = OpenLayers.Class(OpenLayers.Format.XML.VersionedOGC, {
    defaultVersion: "1.1.0",
    errorProperty: "service",
    CLASS_NAME: "OpenLayers.Format.WFSCapabilities"
});
OpenLayers.Format.WFSCapabilities.v1 = OpenLayers.Class(OpenLayers.Format.XML, {
    namespaces: {
        wfs: "http://www.opengis.net/wfs",
        xlink: "http://www.w3.org/1999/xlink",
        xsi: "http://www.w3.org/2001/XMLSchema-instance",
        ows: "http://www.opengis.net/ows"
    }, defaultPrefix: "wfs", read: function (a) {
        "string" == typeof a && (a = OpenLayers.Format.XML.prototype.read.apply(this, [a]));
        a && 9 == a.nodeType && (a = a.documentElement);
        var b = {};
        this.readNode(a, b);
        return b
    }, readers: {
        wfs: {
            WFS_Capabilities: function (a, b) {
                this.readChildNodes(a, b)
            },
            FeatureTypeList: function (a, b) {
                b.featureTypeList = {featureTypes: []};
                this.readChildNodes(a, b.featureTypeList)
            }, FeatureType: function (a, b) {
                var c = {};
                this.readChildNodes(a, c);
                b.featureTypes.push(c)
            }, Name: function (a, b) {
                var c = this.getChildValue(a);
                c && (c = c.split(":"), b.name = c.pop(), 0 < c.length && (b.featureNS = this.lookupNamespaceURI(a, c[0])))
            }, Title: function (a, b) {
                var c = this.getChildValue(a);
                c && (b.title = c)
            }, Abstract: function (a, b) {
                var c = this.getChildValue(a);
                c && (b["abstract"] = c)
            }
        }
    }, CLASS_NAME: "OpenLayers.Format.WFSCapabilities.v1"
});
OpenLayers.Format.WFSCapabilities.v1_0_0 = OpenLayers.Class(OpenLayers.Format.WFSCapabilities.v1, {
    readers: {
        wfs: OpenLayers.Util.applyDefaults({
            Service: function (a, b) {
                b.service = {};
                this.readChildNodes(a, b.service)
            }, Fees: function (a, b) {
                var c = this.getChildValue(a);
                c && "none" != c.toLowerCase() && (b.fees = c)
            }, AccessConstraints: function (a, b) {
                var c = this.getChildValue(a);
                c && "none" != c.toLowerCase() && (b.accessConstraints = c)
            }, OnlineResource: function (a, b) {
                var c = this.getChildValue(a);
                c && "none" != c.toLowerCase() && (b.onlineResource =
                    c)
            }, Keywords: function (a, b) {
                var c = this.getChildValue(a);
                c && "none" != c.toLowerCase() && (b.keywords = c.split(", "))
            }, Capability: function (a, b) {
                b.capability = {};
                this.readChildNodes(a, b.capability)
            }, Request: function (a, b) {
                b.request = {};
                this.readChildNodes(a, b.request)
            }, GetFeature: function (a, b) {
                b.getfeature = {href: {}, formats: []};
                this.readChildNodes(a, b.getfeature)
            }, ResultFormat: function (a, b) {
                for (var c = a.childNodes, d, e = 0; e < c.length; e++)d = c[e], 1 == d.nodeType && b.formats.push(d.nodeName)
            }, DCPType: function (a, b) {
                this.readChildNodes(a,
                    b)
            }, HTTP: function (a, b) {
                this.readChildNodes(a, b.href)
            }, Get: function (a, b) {
                b.get = a.getAttribute("onlineResource")
            }, Post: function (a, b) {
                b.post = a.getAttribute("onlineResource")
            }, SRS: function (a, b) {
                var c = this.getChildValue(a);
                c && (b.srs = c)
            }
        }, OpenLayers.Format.WFSCapabilities.v1.prototype.readers.wfs)
    }, CLASS_NAME: "OpenLayers.Format.WFSCapabilities.v1_0_0"
});
OpenLayers.Format.WFSCapabilities.v1_1_0 = OpenLayers.Class(OpenLayers.Format.WFSCapabilities.v1, {
    regExes: {
        trimSpace: /^\s*|\s*$/g,
        removeSpace: /\s*/g,
        splitSpace: /\s+/,
        trimComma: /\s*,\s*/g
    }, readers: {
        wfs: OpenLayers.Util.applyDefaults({
            DefaultSRS: function (a, b) {
                var c = this.getChildValue(a);
                c && (b.srs = c)
            }
        }, OpenLayers.Format.WFSCapabilities.v1.prototype.readers.wfs),
        ows: OpenLayers.Format.OWSCommon.v1.prototype.readers.ows
    }, CLASS_NAME: "OpenLayers.Format.WFSCapabilities.v1_1_0"
});
OpenLayers.Format.WFSDescribeFeatureType = OpenLayers.Class(OpenLayers.Format.XML, {
    namespaces: {xsd: "http://www.w3.org/2001/XMLSchema"}, readers: {
        xsd: {
            schema: function (a, b) {
                var c = [], d = {};
                this.readChildNodes(a, {complexTypes: c, customTypes: d});
                for (var e = a.attributes, f, g, h = 0, k = e.length; h < k; ++h)f = e[h], g = f.name, 0 == g.indexOf("xmlns") ? this.setNamespace(g.split(":")[1] || "", f.value) : b[g] = f.value;
                b.featureTypes = c;
                b.targetPrefix = this.namespaceAlias[b.targetNamespace];
                h = 0;
                for (k = c.length; h < k; ++h)e = c[h], f = d[e.typeName],
                d[e.typeName] && (e.typeName = f.name)
            }, complexType: function (a, b) {
                var c = {typeName: a.getAttribute("name")};
                this.readChildNodes(a, c);
                b.complexTypes.push(c)
            }, complexContent: function (a, b) {
                this.readChildNodes(a, b)
            }, extension: function (a, b) {
                this.readChildNodes(a, b)
            }, sequence: function (a, b) {
                var c = {elements: []};
                this.readChildNodes(a, c);
                b.properties = c.elements
            }, element: function (a, b) {
                if (b.elements) {
                    for (var c = {}, d = a.attributes, e, f = 0, g = d.length; f < g; ++f)e = d[f], c[e.name] = e.value;
                    (d = c.type) || (d = {}, this.readChildNodes(a,
                        d), c.restriction = d, c.type = d.base);
                    c.localType = (d.base || d).split(":").pop();
                    b.elements.push(c)
                }
                b.complexTypes && (d = a.getAttribute("type"), c = d.split(":").pop(), b.customTypes[c] = {
                    name: a.getAttribute("name"),
                    type: d
                })
            }, simpleType: function (a, b) {
                this.readChildNodes(a, b)
            }, restriction: function (a, b) {
                b.base = a.getAttribute("base");
                this.readRestriction(a, b)
            }
        }
    }, readRestriction: function (a, b) {
        for (var c = a.childNodes, d, e, f = 0, g = c.length; f < g; ++f)d = c[f], 1 == d.nodeType && (e = d.nodeName.split(":").pop(), d = d.getAttribute("value"),
            b[e] ? ("string" == typeof b[e] && (b[e] = [b[e]]), b[e].push(d)) : b[e] = d)
    }, read: function (a) {
        "string" == typeof a && (a = OpenLayers.Format.XML.prototype.read.apply(this, [a]));
        a && 9 == a.nodeType && (a = a.documentElement);
        var b = {};
        this.readNode(a, b);
        return b
    }, CLASS_NAME: "OpenLayers.Format.WFSDescribeFeatureType"
});
OpenLayers.Format.WMSDescribeLayer = OpenLayers.Class(OpenLayers.Format.XML.VersionedOGC, {
    defaultVersion: "1.1.1",
    getVersion: function (a, b) {
        var c = OpenLayers.Format.XML.VersionedOGC.prototype.getVersion.apply(this, arguments);
        if ("1.1.1" == c || "1.1.0" == c)c = "1.1";
        return c
    },
    CLASS_NAME: "OpenLayers.Format.WMSDescribeLayer"
});
OpenLayers.Format.WMSDescribeLayer.v1_1 = OpenLayers.Class(OpenLayers.Format.WMSDescribeLayer, {
    initialize: function (a) {
        OpenLayers.Format.WMSDescribeLayer.prototype.initialize.apply(this, [a])
    }, read: function (a) {
        "string" == typeof a && (a = OpenLayers.Format.XML.prototype.read.apply(this, [a]));
        for (var a = a.documentElement.childNodes, b = [], c, d, e = 0; e < a.length; ++e)if (c = a[e], d = c.nodeName, "LayerDescription" == d) {
            d = c.getAttribute("name");
            var f = "", g = "", h = "";
            c.getAttribute("owsType") ? (f = c.getAttribute("owsType"), g = c.getAttribute("owsURL")) :
                "" != c.getAttribute("wfs") ? (f = "WFS", g = c.getAttribute("wfs")) : "" != c.getAttribute("wcs") && (f = "WCS", g = c.getAttribute("wcs"));
            c = c.getElementsByTagName("Query");
            0 < c.length && ((h = c[0].getAttribute("typeName")) || (h = c[0].getAttribute("typename")));
            b.push({layerName: d, owsType: f, owsURL: g, typeName: h})
        }
        return b
    }, CLASS_NAME: "OpenLayers.Format.WMSDescribeLayer.v1_1"
});
OpenLayers.Format.WKT = OpenLayers.Class(OpenLayers.Format, {
    initialize: function (a) {
        this.regExes = {
            typeStr: /^\s*(\w+)\s*\(\s*(.*)\s*\)\s*$/,
            spaces: /\s+/,
            parenComma: /\)\s*,\s*\(/,
            doubleParenComma: /\)\s*\)\s*,\s*\(\s*\(/,
            trimParens: /^\s*\(?(.*?)\)?\s*$/
        };
        OpenLayers.Format.prototype.initialize.apply(this, [a])
    }, read: function (a) {
        var b, c, a = a.replace(/[\n\r]/g, " ");
        if (c = this.regExes.typeStr.exec(a))if (a = c[1].toLowerCase(), c = c[2], this.parse[a] && (b = this.parse[a].apply(this, [c])), this.internalProjection && this.externalProjection)if (b &&
            "OpenLayers.Feature.Vector" == b.CLASS_NAME)b.geometry.transform(this.externalProjection, this.internalProjection); else if (b && "geometrycollection" != a && "object" == typeof b) {
            a = 0;
            for (c = b.length; a < c; a++)b[a].geometry.transform(this.externalProjection, this.internalProjection)
        }
        return b
    }, write: function (a) {
        var b, c;
        a.constructor == Array ? c = !0 : (a = [a], c = !1);
        var d = [];
        c && d.push("GEOMETRYCOLLECTION(");
        for (var e = 0, f = a.length; e < f; ++e)c && 0 < e && d.push(","), b = a[e].geometry, d.push(this.extractGeometry(b));
        c && d.push(")");
        return d.join("")
    },
    extractGeometry: function (a) {
        var b = a.CLASS_NAME.split(".")[2].toLowerCase();
        if (!this.extract[b])return null;
        this.internalProjection && this.externalProjection && (a = a.clone(), a.transform(this.internalProjection, this.externalProjection));
        return ("collection" == b ? "GEOMETRYCOLLECTION" : b.toUpperCase()) + "(" + this.extract[b].apply(this, [a]) + ")"
    }, extract: {
        point: function (a) {
            return a.x + " " + a.y
        }, multipoint: function (a) {
            for (var b = [], c = 0, d = a.components.length; c < d; ++c)b.push("(" + this.extract.point.apply(this, [a.components[c]]) +
            ")");
            return b.join(",")
        }, linestring: function (a) {
            for (var b = [], c = 0, d = a.components.length; c < d; ++c)b.push(this.extract.point.apply(this, [a.components[c]]));
            return b.join(",")
        }, multilinestring: function (a) {
            for (var b = [], c = 0, d = a.components.length; c < d; ++c)b.push("(" + this.extract.linestring.apply(this, [a.components[c]]) + ")");
            return b.join(",")
        }, polygon: function (a) {
            for (var b = [], c = 0, d = a.components.length; c < d; ++c)b.push("(" + this.extract.linestring.apply(this, [a.components[c]]) + ")");
            return b.join(",")
        }, multipolygon: function (a) {
            for (var b =
                [], c = 0, d = a.components.length; c < d; ++c)b.push("(" + this.extract.polygon.apply(this, [a.components[c]]) + ")");
            return b.join(",")
        }, collection: function (a) {
            for (var b = [], c = 0, d = a.components.length; c < d; ++c)b.push(this.extractGeometry.apply(this, [a.components[c]]));
            return b.join(",")
        }
    }, parse: {
        point: function (a) {
            a = OpenLayers.String.trim(a).split(this.regExes.spaces);
            return new OpenLayers.Feature.Vector(new OpenLayers.Geometry.Point(a[0], a[1]))
        }, multipoint: function (a) {
            for (var b = OpenLayers.String.trim(a).split(","),
                     c = [], d = 0, e = b.length; d < e; ++d)a = b[d].replace(this.regExes.trimParens, "$1"), c.push(this.parse.point.apply(this, [a]).geometry);
            return new OpenLayers.Feature.Vector(new OpenLayers.Geometry.MultiPoint(c))
        }, linestring: function (a) {
            for (var a = OpenLayers.String.trim(a).split(","), b = [], c = 0, d = a.length; c < d; ++c)b.push(this.parse.point.apply(this, [a[c]]).geometry);
            return new OpenLayers.Feature.Vector(new OpenLayers.Geometry.LineString(b))
        }, multilinestring: function (a) {
            for (var b = OpenLayers.String.trim(a).split(this.regExes.parenComma),
                     c = [], d = 0, e = b.length; d < e; ++d)a = b[d].replace(this.regExes.trimParens, "$1"), c.push(this.parse.linestring.apply(this, [a]).geometry);
            return new OpenLayers.Feature.Vector(new OpenLayers.Geometry.MultiLineString(c))
        }, polygon: function (a) {
            for (var b, a = OpenLayers.String.trim(a).split(this.regExes.parenComma), c = [], d = 0, e = a.length; d < e; ++d)b = a[d].replace(this.regExes.trimParens, "$1"), b = this.parse.linestring.apply(this, [b]).geometry, b = new OpenLayers.Geometry.LinearRing(b.components), c.push(b);
            return new OpenLayers.Feature.Vector(new OpenLayers.Geometry.Polygon(c))
        },
        multipolygon: function (a) {
            for (var b = OpenLayers.String.trim(a).split(this.regExes.doubleParenComma), c = [], d = 0, e = b.length; d < e; ++d)a = b[d].replace(this.regExes.trimParens, "$1"), c.push(this.parse.polygon.apply(this, [a]).geometry);
            return new OpenLayers.Feature.Vector(new OpenLayers.Geometry.MultiPolygon(c))
        }, geometrycollection: function (a) {
            for (var a = a.replace(/,\s*([A-Za-z])/g, "|$1"), a = OpenLayers.String.trim(a).split("|"), b = [], c = 0, d = a.length; c < d; ++c)b.push(OpenLayers.Format.WKT.prototype.read.apply(this, [a[c]]));
            return b
        }
    }, CLASS_NAME: "OpenLayers.Format.WKT"
});
OpenLayers.Format.CQL = function () {
    function a(a) {
        function b() {
            var a = e.pop();
            switch (a.type) {
                case "LOGICAL":
                    var c = b(), g = b();
                    return new OpenLayers.Filter.Logical({filters: [g, c], type: f[a.text.toUpperCase()]});
                case "NOT":
                    return c = b(), new OpenLayers.Filter.Logical({filters: [c], type: OpenLayers.Filter.Logical.NOT});
                case "BETWEEN":
                    return e.pop(), g = b(), a = b(), c = b(), new OpenLayers.Filter.Comparison({
                        property: c,
                        lowerBoundary: a,
                        upperBoundary: g,
                        type: OpenLayers.Filter.Comparison.BETWEEN
                    });
                case "COMPARISON":
                    return g =
                        b(), c = b(), new OpenLayers.Filter.Comparison({
                        property: c,
                        value: g,
                        type: d[a.text.toUpperCase()]
                    });
                case "VALUE":
                    return /^'.*'$/.test(a.text) ? a.text.substr(1, a.text.length - 2) : Number(a.text);
                case "SPATIAL":
                    switch (a.text.toUpperCase()) {
                        case "BBOX":
                            var c = b(), a = b(), g = b(), h = b(), k = b();
                            return new OpenLayers.Filter.Spatial({
                                type: OpenLayers.Filter.Spatial.BBOX,
                                property: k,
                                value: OpenLayers.Bounds.fromArray([h, g, a, c])
                            });
                        case "INTERSECTS":
                            return g = b(), c = b(), new OpenLayers.Filter.Spatial({
                                type: OpenLayers.Filter.Spatial.INTERSECTS,
                                property: c, value: g
                            });
                        case "WITHIN":
                            return g = b(), c = b(), new OpenLayers.Filter.Spatial({
                                type: OpenLayers.Filter.Spatial.WITHIN,
                                property: c,
                                value: g
                            });
                        case "CONTAINS":
                            return g = b(), c = b(), new OpenLayers.Filter.Spatial({
                                type: OpenLayers.Filter.Spatial.CONTAINS,
                                property: c,
                                value: g
                            });
                        case "DWITHIN":
                            return a = b(), g = b(), c = b(), new OpenLayers.Filter.Spatial({
                                type: OpenLayers.Filter.Spatial.DWITHIN,
                                value: g,
                                property: c,
                                distance: Number(a)
                            })
                    }
                case "GEOMETRY":
                    return OpenLayers.Geometry.fromWKT(a.text);
                default:
                    return a.text
            }
        }

        for (var c = [], e = []; a.length;) {
            var g = a.shift();
            switch (g.type) {
                case "PROPERTY":
                case "GEOMETRY":
                case "VALUE":
                    e.push(g);
                    break;
                case "COMPARISON":
                case "BETWEEN":
                case "LOGICAL":
                    for (var k = h[g.type]; 0 < c.length && h[c[c.length - 1].type] <= k;)e.push(c.pop());
                    c.push(g);
                    break;
                case "SPATIAL":
                case "NOT":
                case "LPAREN":
                    c.push(g);
                    break;
                case "RPAREN":
                    for (; 0 < c.length && "LPAREN" != c[c.length - 1].type;)e.push(c.pop());
                    c.pop();
                    0 < c.length && "SPATIAL" == c[c.length - 1].type && e.push(c.pop());
                case "COMMA":
                case "END":
                    break;
                default:
                    throw Error("Unknown token type " +
                    g.type);
            }
        }
        for (; 0 < c.length;)e.push(c.pop());
        a = b();
        if (0 < e.length) {
            a = "Remaining tokens after building AST: \n";
            for (c = e.length - 1; 0 <= c; c--)a += e[c].type + ": " + e[c].text + "\n";
            throw Error(a);
        }
        return a
    }

    var b = {
            PROPERTY: /^[_a-zA-Z]\w*/,
            COMPARISON: /^(=|<>|<=|<|>=|>|LIKE)/i,
            COMMA: /^,/,
            LOGICAL: /^(AND|OR)/i,
            VALUE: /^('\w+'|\d+(\.\d*)?|\.\d+)/,
            LPAREN: /^\(/,
            RPAREN: /^\)/,
            SPATIAL: /^(BBOX|INTERSECTS|DWITHIN|WITHIN|CONTAINS)/i,
            NOT: /^NOT/i,
            BETWEEN: /^BETWEEN/i,
            GEOMETRY: function (a) {
                var b = /^(POINT|LINESTRING|POLYGON|MULTIPOINT|MULTILINESTRING|MULTIPOLYGON|GEOMETRYCOLLECTION)/.exec(a);
                if (b) {
                    var c = a.length, b = a.indexOf("(", b[0].length);
                    if (-1 < b)for (var d = 1; b < c && 0 < d;)switch (b++, a.charAt(b)) {
                        case "(":
                            d++;
                            break;
                        case ")":
                            d--
                    }
                    return [a.substr(0, b + 1)]
                }
            },
            END: /^$/
        }, c = {
            LPAREN: ["GEOMETRY", "SPATIAL", "PROPERTY", "VALUE", "LPAREN"],
            RPAREN: ["NOT", "LOGICAL", "END", "RPAREN"],
            PROPERTY: ["COMPARISON", "BETWEEN", "COMMA"],
            BETWEEN: ["VALUE"],
            COMPARISON: ["VALUE"],
            COMMA: ["GEOMETRY", "VALUE", "PROPERTY"],
            VALUE: ["LOGICAL", "COMMA", "RPAREN", "END"],
            SPATIAL: ["LPAREN"],
            LOGICAL: ["NOT", "VALUE", "SPATIAL", "PROPERTY", "LPAREN"],
            NOT: ["PROPERTY", "LPAREN"],
            GEOMETRY: ["COMMA", "RPAREN"]
        }, d = {
            "=": OpenLayers.Filter.Comparison.EQUAL_TO,
            "<>": OpenLayers.Filter.Comparison.NOT_EQUAL_TO,
            "<": OpenLayers.Filter.Comparison.LESS_THAN,
            "<=": OpenLayers.Filter.Comparison.LESS_THAN_OR_EQUAL_TO,
            ">": OpenLayers.Filter.Comparison.GREATER_THAN,
            ">=": OpenLayers.Filter.Comparison.GREATER_THAN_OR_EQUAL_TO,
            LIKE: OpenLayers.Filter.Comparison.LIKE,
            BETWEEN: OpenLayers.Filter.Comparison.BETWEEN
        }, e = {}, f = {AND: OpenLayers.Filter.Logical.AND, OR: OpenLayers.Filter.Logical.OR},
        g = {}, h = {RPAREN: 3, LOGICAL: 2, COMPARISON: 1}, k;
    for (k in d)d.hasOwnProperty(k) && (e[d[k]] = k);
    for (k in f)f.hasOwnProperty(k) && (g[f[k]] = k);
    return OpenLayers.Class(OpenLayers.Format, {
        read: function (d) {
            var e = d, d = [], f, g = ["NOT", "GEOMETRY", "SPATIAL", "PROPERTY", "LPAREN"];
            do {
                a:{
                    f = g;
                    for (var h = void 0, g = void 0, k = f.length, h = 0; h < k; h++) {
                        var g = f[h], u = b[g]instanceof RegExp ? b[g].exec(e) : (0, b[g])(e);
                        if (u) {
                            f = u[0];
                            e = e.substr(f.length).replace(/^\s*/, "");
                            f = {type: g, text: f, remainder: e};
                            break a
                        }
                    }
                    d = "ERROR: In parsing: [" + e + "], expected one of: ";
                    for (h = 0; h < k; h++)g = f[h], d += "\n    " + g + ": " + b[g];
                    throw Error(d);
                }
                e = f.remainder;
                g = c[f.type];
                if ("END" != f.type && !g)throw Error("No follows list for " + f.type);
                d.push(f)
            } while ("END" != f.type);
            d = a(d);
            this.keepData && (this.data = d);
            return d
        }, write: function (a) {
            if (a instanceof OpenLayers.Geometry)return a.toString();
            switch (a.CLASS_NAME) {
                case "OpenLayers.Filter.Spatial":
                    switch (a.type) {
                        case OpenLayers.Filter.Spatial.BBOX:
                            return "BBOX(" + a.property + "," + a.value.toBBOX() + ")";
                        case OpenLayers.Filter.Spatial.DWITHIN:
                            return "DWITHIN(" +
                                a.property + ", " + this.write(a.value) + ", " + a.distance + ")";
                        case OpenLayers.Filter.Spatial.WITHIN:
                            return "WITHIN(" + a.property + ", " + this.write(a.value) + ")";
                        case OpenLayers.Filter.Spatial.INTERSECTS:
                            return "INTERSECTS(" + a.property + ", " + this.write(a.value) + ")";
                        case OpenLayers.Filter.Spatial.CONTAINS:
                            return "CONTAINS(" + a.property + ", " + this.write(a.value) + ")";
                        default:
                            throw Error("Unknown spatial filter type: " + a.type);
                    }
                case "OpenLayers.Filter.Logical":
                    if (a.type == OpenLayers.Filter.Logical.NOT)return "NOT (" + this.write(a.filters[0]) +
                        ")";
                    for (var b = "(", c = !0, d = 0; d < a.filters.length; d++)c ? c = !1 : b += ") " + g[a.type] + " (", b += this.write(a.filters[d]);
                    return b + ")";
                case "OpenLayers.Filter.Comparison":
                    return a.type == OpenLayers.Filter.Comparison.BETWEEN ? a.property + " BETWEEN " + this.write(a.lowerBoundary) + " AND " + this.write(a.upperBoundary) : a.property + " " + e[a.type] + " " + this.write(a.value);
                case void 0:
                    if ("string" === typeof a)return "'" + a + "'";
                    if ("number" === typeof a)return "" + a;
                default:
                    throw Error("Can't encode: " + a.CLASS_NAME + " " + a);
            }
        }, CLASS_NAME: "OpenLayers.Format.CQL"
    })
}();
OpenLayers.Format.OSM = OpenLayers.Class(OpenLayers.Format.XML, {
    checkTags: !1, interestingTagsExclude: null, areaTags: null, initialize: function (a) {
        for (var b = {
            interestingTagsExclude: "source,source_ref,source:ref,history,attribution,created_by".split(","),
            areaTags: "area,building,leisure,tourism,ruins,historic,landuse,military,natural,sport".split(",")
        }, b = OpenLayers.Util.extend(b, a), c = {}, a = 0; a < b.interestingTagsExclude.length; a++)c[b.interestingTagsExclude[a]] = !0;
        b.interestingTagsExclude = c;
        c = {};
        for (a = 0; a < b.areaTags.length; a++)c[b.areaTags[a]] = !0;
        b.areaTags = c;
        this.externalProjection = new OpenLayers.Projection("EPSG:4326");
        OpenLayers.Format.XML.prototype.initialize.apply(this, [b])
    }, read: function (a) {
        "string" == typeof a && (a = OpenLayers.Format.XML.prototype.read.apply(this, [a]));
        for (var b = this.getNodes(a), c = this.getWays(a), a = Array(c.length), d = 0; d < c.length; d++) {
            for (var e = Array(c[d].nodes.length), f = this.isWayArea(c[d]) ? 1 : 0, g = 0; g < c[d].nodes.length; g++) {
                var h = b[c[d].nodes[g]], k = new OpenLayers.Geometry.Point(h.lon, h.lat);
                k.osm_id = parseInt(c[d].nodes[g]);
                e[g] = k;
                h.used = !0
            }
            h = f ? new OpenLayers.Geometry.Polygon(new OpenLayers.Geometry.LinearRing(e)) : new OpenLayers.Geometry.LineString(e);
            this.internalProjection && this.externalProjection && h.transform(this.externalProjection, this.internalProjection);
            e = new OpenLayers.Feature.Vector(h, c[d].tags);
            e.osm_id = parseInt(c[d].id);
            e.fid = "way." + e.osm_id;
            a[d] = e
        }
        for (var l in b) {
            h = b[l];
            if (!h.used || this.checkTags) {
                if (this.checkTags) {
                    c = this.getTags(h.node, !0);
                    if (h.used && !c[1])continue;
                    c = c[0]
                } else c = this.getTags(h.node);
                e =
                    new OpenLayers.Feature.Vector(new OpenLayers.Geometry.Point(h.lon, h.lat), c);
                this.internalProjection && this.externalProjection && e.geometry.transform(this.externalProjection, this.internalProjection);
                e.osm_id = parseInt(l);
                e.fid = "node." + e.osm_id;
                a.push(e)
            }
            h.node = null
        }
        return a
    }, getNodes: function (a) {
        for (var a = a.getElementsByTagName("node"), b = {}, c = 0; c < a.length; c++) {
            var d = a[c], e = d.getAttribute("id");
            b[e] = {lat: d.getAttribute("lat"), lon: d.getAttribute("lon"), node: d}
        }
        return b
    }, getWays: function (a) {
        for (var a = a.getElementsByTagName("way"),
                 b = [], c = 0; c < a.length; c++) {
            var d = a[c], e = {id: d.getAttribute("id")};
            e.tags = this.getTags(d);
            d = d.getElementsByTagName("nd");
            e.nodes = Array(d.length);
            for (var f = 0; f < d.length; f++)e.nodes[f] = d[f].getAttribute("ref");
            b.push(e)
        }
        return b
    }, getTags: function (a, b) {
        for (var c = a.getElementsByTagName("tag"), d = {}, e = !1, f = 0; f < c.length; f++) {
            var g = c[f].getAttribute("k");
            d[g] = c[f].getAttribute("v");
            b && (this.interestingTagsExclude[g] || (e = !0))
        }
        return b ? [d, e] : d
    }, isWayArea: function (a) {
        var b = !1, c = !1;
        a.nodes[0] == a.nodes[a.nodes.length -
        1] && (b = !0);
        if (this.checkTags)for (var d in a.tags)if (this.areaTags[d]) {
            c = !0;
            break
        }
        return b && (this.checkTags ? c : !0)
    }, write: function (a) {
        OpenLayers.Util.isArray(a) || (a = [a]);
        this.osm_id = 1;
        this.created_nodes = {};
        var b = this.createElementNS(null, "osm");
        b.setAttribute("version", "0.5");
        b.setAttribute("generator", "OpenLayers " + OpenLayers.VERSION_NUMBER);
        for (var c = a.length - 1; 0 <= c; c--)for (var d = this.createFeatureNodes(a[c]), e = 0; e < d.length; e++)b.appendChild(d[e]);
        return OpenLayers.Format.XML.prototype.write.apply(this,
            [b])
    }, createFeatureNodes: function (a) {
        var b = [], c = a.geometry.CLASS_NAME, c = c.substring(c.lastIndexOf(".") + 1), c = c.toLowerCase();
        (c = this.createXML[c]) && (b = c.apply(this, [a]));
        return b
    }, createXML: {
        point: function (a) {
            var b = null, c = a.geometry ? a.geometry : a;
            this.internalProjection && this.externalProjection && (c = c.clone(), c.transform(this.internalProjection, this.externalProjection));
            var d = !1;
            a.osm_id ? (b = a.osm_id, this.created_nodes[b] && (d = !0)) : (b = -this.osm_id, this.osm_id++);
            var e = d ? this.created_nodes[b] : this.createElementNS(null,
                "node");
            this.created_nodes[b] = e;
            e.setAttribute("id", b);
            e.setAttribute("lon", c.x);
            e.setAttribute("lat", c.y);
            a.attributes && this.serializeTags(a, e);
            this.setState(a, e);
            return d ? [] : [e]
        }, linestring: function (a) {
            var b, c = [], d = a.geometry;
            a.osm_id ? b = a.osm_id : (b = -this.osm_id, this.osm_id++);
            var e = this.createElementNS(null, "way");
            e.setAttribute("id", b);
            for (b = 0; b < d.components.length; b++) {
                var f = this.createXML.point.apply(this, [d.components[b]]);
                if (f.length) {
                    var f = f[0], g = f.getAttribute("id");
                    c.push(f)
                } else g = d.components[b].osm_id,
                    f = this.created_nodes[g];
                this.setState(a, f);
                f = this.createElementNS(null, "nd");
                f.setAttribute("ref", g);
                e.appendChild(f)
            }
            this.serializeTags(a, e);
            c.push(e);
            return c
        }, polygon: function (a) {
            var b = OpenLayers.Util.extend({area: "yes"}, a.attributes), b = new OpenLayers.Feature.Vector(a.geometry.components[0], b);
            b.osm_id = a.osm_id;
            return this.createXML.linestring.apply(this, [b])
        }
    }, serializeTags: function (a, b) {
        for (var c in a.attributes) {
            var d = this.createElementNS(null, "tag");
            d.setAttribute("k", c);
            d.setAttribute("v",
                a.attributes[c]);
            b.appendChild(d)
        }
    }, setState: function (a, b) {
        if (a.state) {
            var c = null;
            switch (a.state) {
                case OpenLayers.State.UPDATE:
                case OpenLayers.State.DELETE:
                    c = "delete"
            }
            c && b.setAttribute("action", c)
        }
    }, CLASS_NAME: "OpenLayers.Format.OSM"
});
OpenLayers.Format.GPX = OpenLayers.Class(OpenLayers.Format.XML, {
    defaultDesc: "No description available",
    extractWaypoints: !0,
    extractTracks: !0,
    extractRoutes: !0,
    extractAttributes: !0,
    namespaces: {gpx: "http://www.topografix.com/GPX/1/1", xsi: "http://www.w3.org/2001/XMLSchema-instance"},
    schemaLocation: "http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd",
    creator: "OpenLayers",
    initialize: function (a) {
        this.externalProjection = new OpenLayers.Projection("EPSG:4326");
        OpenLayers.Format.XML.prototype.initialize.apply(this,
            [a])
    },
    read: function (a) {
        "string" == typeof a && (a = OpenLayers.Format.XML.prototype.read.apply(this, [a]));
        var b = [];
        if (this.extractTracks)for (var c = a.getElementsByTagName("trk"), d = 0, e = c.length; d < e; d++) {
            var f = {};
            this.extractAttributes && (f = this.parseAttributes(c[d]));
            for (var g = this.getElementsByTagNameNS(c[d], c[d].namespaceURI, "trkseg"), h = 0, k = g.length; h < k; h++) {
                var l = this.extractSegment(g[h], "trkpt");
                b.push(new OpenLayers.Feature.Vector(l, f))
            }
        }
        if (this.extractRoutes) {
            e = a.getElementsByTagName("rte");
            c = 0;
            for (d =
                     e.length; c < d; c++)f = {}, this.extractAttributes && (f = this.parseAttributes(e[c])), g = this.extractSegment(e[c], "rtept"), b.push(new OpenLayers.Feature.Vector(g, f))
        }
        if (this.extractWaypoints) {
            a = a.getElementsByTagName("wpt");
            c = 0;
            for (e = a.length; c < e; c++)f = {}, this.extractAttributes && (f = this.parseAttributes(a[c])), d = new OpenLayers.Geometry.Point(a[c].getAttribute("lon"), a[c].getAttribute("lat")), b.push(new OpenLayers.Feature.Vector(d, f))
        }
        if (this.internalProjection && this.externalProjection) {
            f = 0;
            for (a = b.length; f <
            a; f++)b[f].geometry.transform(this.externalProjection, this.internalProjection)
        }
        return b
    },
    extractSegment: function (a, b) {
        for (var c = this.getElementsByTagNameNS(a, a.namespaceURI, b), d = [], e = 0, f = c.length; e < f; e++)d.push(new OpenLayers.Geometry.Point(c[e].getAttribute("lon"), c[e].getAttribute("lat")));
        return new OpenLayers.Geometry.LineString(d)
    },
    parseAttributes: function (a) {
        for (var b = {}, a = a.firstChild, c, d; a;) {
            if (1 == a.nodeType && a.firstChild && (c = a.firstChild, 3 == c.nodeType || 4 == c.nodeType))d = a.prefix ? a.nodeName.split(":")[1] :
                a.nodeName, "trkseg" != d && "rtept" != d && (b[d] = c.nodeValue);
            a = a.nextSibling
        }
        return b
    },
    write: function (a, b) {
        var a = OpenLayers.Util.isArray(a) ? a : [a], c = this.createElementNS(this.namespaces.gpx, "gpx");
        c.setAttribute("version", "1.1");
        c.setAttribute("creator", this.creator);
        this.setAttributes(c, {"xsi:schemaLocation": this.schemaLocation});
        b && "object" == typeof b && c.appendChild(this.buildMetadataNode(b));
        for (var d = 0, e = a.length; d < e; d++)c.appendChild(this.buildFeatureNode(a[d]));
        return OpenLayers.Format.XML.prototype.write.apply(this,
            [c])
    },
    buildMetadataNode: function (a) {
        for (var b = ["name", "desc", "author"], c = this.createElementNSPlus("gpx:metadata"), d = 0; d < b.length; d++) {
            var e = b[d];
            if (a[e]) {
                var f = this.createElementNSPlus("gpx:" + e);
                f.appendChild(this.createTextNode(a[e]));
                c.appendChild(f)
            }
        }
        return c
    },
    buildFeatureNode: function (a) {
        var b = a.geometry, b = b.clone();
        this.internalProjection && this.externalProjection && b.transform(this.internalProjection, this.externalProjection);
        if ("OpenLayers.Geometry.Point" == b.CLASS_NAME) {
            var c = this.buildWptNode(b);
            this.appendAttributesNode(c, a);
            return c
        }
        c = this.createElementNSPlus("gpx:trk");
        this.appendAttributesNode(c, a);
        for (var a = this.buildTrkSegNode(b), a = OpenLayers.Util.isArray(a) ? a : [a], b = 0, d = a.length; b < d; b++)c.appendChild(a[b]);
        return c
    },
    buildTrkSegNode: function (a) {
        var b, c, d, e;
        if ("OpenLayers.Geometry.LineString" == a.CLASS_NAME || "OpenLayers.Geometry.LinearRing" == a.CLASS_NAME) {
            b = this.createElementNSPlus("gpx:trkseg");
            for (c = 0, d = a.components.length; c < d; c++)e = a.components[c], b.appendChild(this.buildTrkPtNode(e));
            return b
        }
        b = [];
        for (c = 0, d = a.components.length; c < d; c++)b.push(this.buildTrkSegNode(a.components[c]));
        return b
    },
    buildTrkPtNode: function (a) {
        var b = this.createElementNSPlus("gpx:trkpt");
        b.setAttribute("lon", a.x);
        b.setAttribute("lat", a.y);
        return b
    },
    buildWptNode: function (a) {
        var b = this.createElementNSPlus("gpx:wpt");
        b.setAttribute("lon", a.x);
        b.setAttribute("lat", a.y);
        return b
    },
    appendAttributesNode: function (a, b) {
        var c = this.createElementNSPlus("gpx:name");
        c.appendChild(this.createTextNode(b.attributes.name ||
        b.id));
        a.appendChild(c);
        c = this.createElementNSPlus("gpx:desc");
        c.appendChild(this.createTextNode(b.attributes.description || this.defaultDesc));
        a.appendChild(c)
    },
    CLASS_NAME: "OpenLayers.Format.GPX"
});
OpenLayers.Format.Filter = OpenLayers.Class(OpenLayers.Format.XML.VersionedOGC, {
    defaultVersion: "1.0.0",
    CLASS_NAME: "OpenLayers.Format.Filter"
});
OpenLayers.Format.Filter.v1 = OpenLayers.Class(OpenLayers.Format.XML, {
    namespaces: {
        ogc: "http://www.opengis.net/ogc",
        gml: "http://www.opengis.net/gml",
        xlink: "http://www.w3.org/1999/xlink",
        xsi: "http://www.w3.org/2001/XMLSchema-instance"
    }, defaultPrefix: "ogc", schemaLocation: null, initialize: function (a) {
        OpenLayers.Format.XML.prototype.initialize.apply(this, [a])
    }, read: function (a) {
        var b = {};
        this.readers.ogc.Filter.apply(this, [a, b]);
        return b.filter
    }, readers: {
        ogc: {
            _expression: function (a) {
                for (var b = "", c = a.firstChild; c; c =
                    c.nextSibling)switch (c.nodeType) {
                    case 1:
                        a = this.readNode(c);
                        a.property ? b += "${" + a.property + "}" : void 0 !== a.value && (b += a.value);
                        break;
                    case 3:
                    case 4:
                        b += c.nodeValue
                }
                return b
            }, Filter: function (a, b) {
                var c = {fids: [], filters: []};
                this.readChildNodes(a, c);
                0 < c.fids.length ? b.filter = new OpenLayers.Filter.FeatureId({fids: c.fids}) : 0 < c.filters.length && (b.filter = c.filters[0])
            }, FeatureId: function (a, b) {
                var c = a.getAttribute("fid");
                c && b.fids.push(c)
            }, And: function (a, b) {
                var c = new OpenLayers.Filter.Logical({type: OpenLayers.Filter.Logical.AND});
                this.readChildNodes(a, c);
                b.filters.push(c)
            }, Or: function (a, b) {
                var c = new OpenLayers.Filter.Logical({type: OpenLayers.Filter.Logical.OR});
                this.readChildNodes(a, c);
                b.filters.push(c)
            }, Not: function (a, b) {
                var c = new OpenLayers.Filter.Logical({type: OpenLayers.Filter.Logical.NOT});
                this.readChildNodes(a, c);
                b.filters.push(c)
            }, PropertyIsLessThan: function (a, b) {
                var c = new OpenLayers.Filter.Comparison({type: OpenLayers.Filter.Comparison.LESS_THAN});
                this.readChildNodes(a, c);
                b.filters.push(c)
            }, PropertyIsGreaterThan: function (a,
                                                b) {
                var c = new OpenLayers.Filter.Comparison({type: OpenLayers.Filter.Comparison.GREATER_THAN});
                this.readChildNodes(a, c);
                b.filters.push(c)
            }, PropertyIsLessThanOrEqualTo: function (a, b) {
                var c = new OpenLayers.Filter.Comparison({type: OpenLayers.Filter.Comparison.LESS_THAN_OR_EQUAL_TO});
                this.readChildNodes(a, c);
                b.filters.push(c)
            }, PropertyIsGreaterThanOrEqualTo: function (a, b) {
                var c = new OpenLayers.Filter.Comparison({type: OpenLayers.Filter.Comparison.GREATER_THAN_OR_EQUAL_TO});
                this.readChildNodes(a, c);
                b.filters.push(c)
            },
            PropertyIsBetween: function (a, b) {
                var c = new OpenLayers.Filter.Comparison({type: OpenLayers.Filter.Comparison.BETWEEN});
                this.readChildNodes(a, c);
                b.filters.push(c)
            }, Literal: function (a, b) {
                b.value = OpenLayers.String.numericIf(this.getChildValue(a))
            }, PropertyName: function (a, b) {
                b.property = this.getChildValue(a)
            }, LowerBoundary: function (a, b) {
                b.lowerBoundary = OpenLayers.String.numericIf(this.readers.ogc._expression.call(this, a))
            }, UpperBoundary: function (a, b) {
                b.upperBoundary = OpenLayers.String.numericIf(this.readers.ogc._expression.call(this,
                    a))
            }, Intersects: function (a, b) {
                this.readSpatial(a, b, OpenLayers.Filter.Spatial.INTERSECTS)
            }, Within: function (a, b) {
                this.readSpatial(a, b, OpenLayers.Filter.Spatial.WITHIN)
            }, Contains: function (a, b) {
                this.readSpatial(a, b, OpenLayers.Filter.Spatial.CONTAINS)
            }, DWithin: function (a, b) {
                this.readSpatial(a, b, OpenLayers.Filter.Spatial.DWITHIN)
            }, Distance: function (a, b) {
                b.distance = parseInt(this.getChildValue(a));
                b.distanceUnits = a.getAttribute("units")
            }, Function: function () {
            }
        }
    }, readSpatial: function (a, b, c) {
        c = new OpenLayers.Filter.Spatial({type: c});
        this.readChildNodes(a, c);
        c.value = c.components[0];
        delete c.components;
        b.filters.push(c)
    }, writeOgcExpression: function (a, b) {
        if (a instanceof OpenLayers.Filter.Function) {
            var c = this.writeNode("Function", a, b);
            b.appendChild(c)
        } else this.writeNode("Literal", a, b);
        return b
    }, write: function (a) {
        return this.writers.ogc.Filter.apply(this, [a])
    }, writeFeatureIdNodes: function (a, b) {
        for (var c = 0, d = a.fids.length; c < d; ++c)this.writeNode("FeatureId", a.fids[c], b)
    }, writers: {
        ogc: {
            Filter: function (a) {
                var b = this.createElementNSPlus("ogc:Filter");
                "FID" === a.type ? OpenLayers.Format.Filter.v1.prototype.writeFeatureIdNodes.call(this, a, b) : this.writeNode(this.getFilterType(a), a, b);
                return b
            }, FeatureId: function (a) {
                return this.createElementNSPlus("ogc:FeatureId", {attributes: {fid: a}})
            }, And: function (a) {
                for (var b = this.createElementNSPlus("ogc:And"), c, d = 0, e = a.filters.length; d < e; ++d)c = a.filters[d], "FID" === c.type ? OpenLayers.Format.Filter.v1.prototype.writeFeatureIdNodes.call(this, c, b) : this.writeNode(this.getFilterType(c), c, b);
                return b
            }, Or: function (a) {
                for (var b =
                    this.createElementNSPlus("ogc:Or"), c, d = 0, e = a.filters.length; d < e; ++d)c = a.filters[d], "FID" === c.type ? OpenLayers.Format.Filter.v1.prototype.writeFeatureIdNodes.call(this, c, b) : this.writeNode(this.getFilterType(c), c, b);
                return b
            }, Not: function (a) {
                var b = this.createElementNSPlus("ogc:Not"), a = a.filters[0];
                "FID" === a.type ? OpenLayers.Format.Filter.v1.prototype.writeFeatureIdNodes.call(this, a, b) : this.writeNode(this.getFilterType(a), a, b);
                return b
            }, PropertyIsLessThan: function (a) {
                var b = this.createElementNSPlus("ogc:PropertyIsLessThan");
                this.writeNode("PropertyName", a, b);
                this.writeOgcExpression(a.value, b);
                return b
            }, PropertyIsGreaterThan: function (a) {
                var b = this.createElementNSPlus("ogc:PropertyIsGreaterThan");
                this.writeNode("PropertyName", a, b);
                this.writeOgcExpression(a.value, b);
                return b
            }, PropertyIsLessThanOrEqualTo: function (a) {
                var b = this.createElementNSPlus("ogc:PropertyIsLessThanOrEqualTo");
                this.writeNode("PropertyName", a, b);
                this.writeOgcExpression(a.value, b);
                return b
            }, PropertyIsGreaterThanOrEqualTo: function (a) {
                var b = this.createElementNSPlus("ogc:PropertyIsGreaterThanOrEqualTo");
                this.writeNode("PropertyName", a, b);
                this.writeOgcExpression(a.value, b);
                return b
            }, PropertyIsBetween: function (a) {
                var b = this.createElementNSPlus("ogc:PropertyIsBetween");
                this.writeNode("PropertyName", a, b);
                this.writeNode("LowerBoundary", a, b);
                this.writeNode("UpperBoundary", a, b);
                return b
            }, PropertyName: function (a) {
                return this.createElementNSPlus("ogc:PropertyName", {value: a.property})
            }, Literal: function (a) {
                return this.createElementNSPlus("ogc:Literal", {value: a})
            }, LowerBoundary: function (a) {
                var b = this.createElementNSPlus("ogc:LowerBoundary");
                this.writeOgcExpression(a.lowerBoundary, b);
                return b
            }, UpperBoundary: function (a) {
                var b = this.createElementNSPlus("ogc:UpperBoundary");
                this.writeNode("Literal", a.upperBoundary, b);
                return b
            }, INTERSECTS: function (a) {
                return this.writeSpatial(a, "Intersects")
            }, WITHIN: function (a) {
                return this.writeSpatial(a, "Within")
            }, CONTAINS: function (a) {
                return this.writeSpatial(a, "Contains")
            }, DWITHIN: function (a) {
                var b = this.writeSpatial(a, "DWithin");
                this.writeNode("Distance", a, b);
                return b
            }, Distance: function (a) {
                return this.createElementNSPlus("ogc:Distance",
                    {attributes: {units: a.distanceUnits}, value: a.distance})
            }, Function: function (a) {
                for (var b = this.createElementNSPlus("ogc:Function", {attributes: {name: a.name}}), a = a.params, c = 0, d = a.length; c < d; c++)this.writeOgcExpression(a[c], b);
                return b
            }
        }
    }, getFilterType: function (a) {
        var b = this.filterMap[a.type];
        if (!b)throw"Filter writing not supported for rule type: " + a.type;
        return b
    }, filterMap: {
        "&&": "And",
        "||": "Or",
        "!": "Not",
        "==": "PropertyIsEqualTo",
        "!=": "PropertyIsNotEqualTo",
        "<": "PropertyIsLessThan",
        ">": "PropertyIsGreaterThan",
        "<=": "PropertyIsLessThanOrEqualTo",
        ">=": "PropertyIsGreaterThanOrEqualTo",
        "..": "PropertyIsBetween",
        "~": "PropertyIsLike",
        BBOX: "BBOX",
        DWITHIN: "DWITHIN",
        WITHIN: "WITHIN",
        CONTAINS: "CONTAINS",
        INTERSECTS: "INTERSECTS",
        FID: "FeatureId"
    }, CLASS_NAME: "OpenLayers.Format.Filter.v1"
});
OpenLayers.Format.Filter.v1_0_0 = OpenLayers.Class(OpenLayers.Format.GML.v2, OpenLayers.Format.Filter.v1, {
    VERSION: "1.0.0", schemaLocation: "http://www.opengis.net/ogc/filter/1.0.0/filter.xsd", initialize: function (a) {
        OpenLayers.Format.GML.v2.prototype.initialize.apply(this, [a])
    }, readers: {
        ogc: OpenLayers.Util.applyDefaults({
            PropertyIsEqualTo: function (a, b) {
                var c = new OpenLayers.Filter.Comparison({type: OpenLayers.Filter.Comparison.EQUAL_TO});
                this.readChildNodes(a, c);
                b.filters.push(c)
            }, PropertyIsNotEqualTo: function (a,
                                               b) {
                var c = new OpenLayers.Filter.Comparison({type: OpenLayers.Filter.Comparison.NOT_EQUAL_TO});
                this.readChildNodes(a, c);
                b.filters.push(c)
            }, PropertyIsLike: function (a, b) {
                var c = new OpenLayers.Filter.Comparison({type: OpenLayers.Filter.Comparison.LIKE});
                this.readChildNodes(a, c);
                var d = a.getAttribute("wildCard"), e = a.getAttribute("singleChar"), f = a.getAttribute("escape");
                c.value2regex(d, e, f);
                b.filters.push(c)
            }
        }, OpenLayers.Format.Filter.v1.prototype.readers.ogc), gml: OpenLayers.Format.GML.v2.prototype.readers.gml,
        feature: OpenLayers.Format.GML.v2.prototype.readers.feature
    }, writers: {
        ogc: OpenLayers.Util.applyDefaults({
            PropertyIsEqualTo: function (a) {
                var b = this.createElementNSPlus("ogc:PropertyIsEqualTo");
                this.writeNode("PropertyName", a, b);
                this.writeOgcExpression(a.value, b);
                return b
            }, PropertyIsNotEqualTo: function (a) {
                var b = this.createElementNSPlus("ogc:PropertyIsNotEqualTo");
                this.writeNode("PropertyName", a, b);
                this.writeOgcExpression(a.value, b);
                return b
            }, PropertyIsLike: function (a) {
                var b = this.createElementNSPlus("ogc:PropertyIsLike",
                    {attributes: {wildCard: "*", singleChar: ".", escape: "!"}});
                this.writeNode("PropertyName", a, b);
                this.writeNode("Literal", a.regex2value(), b);
                return b
            }, BBOX: function (a) {
                var b = this.createElementNSPlus("ogc:BBOX");
                a.property && this.writeNode("PropertyName", a, b);
                var c = this.writeNode("gml:Box", a.value, b);
                a.projection && c.setAttribute("srsName", a.projection);
                return b
            }
        }, OpenLayers.Format.Filter.v1.prototype.writers.ogc),
        gml: OpenLayers.Format.GML.v2.prototype.writers.gml,
        feature: OpenLayers.Format.GML.v2.prototype.writers.feature
    },
    writeSpatial: function (a, b) {
        var c = this.createElementNSPlus("ogc:" + b);
        this.writeNode("PropertyName", a, c);
        if (a.value instanceof OpenLayers.Filter.Function)this.writeNode("Function", a.value, c); else {
            var d;
            d = a.value instanceof OpenLayers.Geometry ? this.writeNode("feature:_geometry", a.value).firstChild : this.writeNode("gml:Box", a.value);
            a.projection && d.setAttribute("srsName", a.projection);
            c.appendChild(d)
        }
        return c
    }, CLASS_NAME: "OpenLayers.Format.Filter.v1_0_0"
});
OpenLayers.Format.Filter.v1_1_0 = OpenLayers.Class(OpenLayers.Format.GML.v3, OpenLayers.Format.Filter.v1, {
    VERSION: "1.1.0", schemaLocation: "http://www.opengis.net/ogc/filter/1.1.0/filter.xsd", initialize: function (a) {
        OpenLayers.Format.GML.v3.prototype.initialize.apply(this, [a])
    }, readers: {
        ogc: OpenLayers.Util.applyDefaults({
            PropertyIsEqualTo: function (a, b) {
                var c = a.getAttribute("matchCase"), c = new OpenLayers.Filter.Comparison({
                    type: OpenLayers.Filter.Comparison.EQUAL_TO,
                    matchCase: !("false" === c || "0" === c)
                });
                this.readChildNodes(a,
                    c);
                b.filters.push(c)
            }, PropertyIsNotEqualTo: function (a, b) {
                var c = a.getAttribute("matchCase"), c = new OpenLayers.Filter.Comparison({
                    type: OpenLayers.Filter.Comparison.NOT_EQUAL_TO,
                    matchCase: !("false" === c || "0" === c)
                });
                this.readChildNodes(a, c);
                b.filters.push(c)
            }, PropertyIsLike: function (a, b) {
                var c = new OpenLayers.Filter.Comparison({type: OpenLayers.Filter.Comparison.LIKE});
                this.readChildNodes(a, c);
                var d = a.getAttribute("wildCard"), e = a.getAttribute("singleChar"), f = a.getAttribute("escapeChar");
                c.value2regex(d, e,
                    f);
                b.filters.push(c)
            }
        }, OpenLayers.Format.Filter.v1.prototype.readers.ogc),
        gml: OpenLayers.Format.GML.v3.prototype.readers.gml,
        feature: OpenLayers.Format.GML.v3.prototype.readers.feature
    }, writers: {
        ogc: OpenLayers.Util.applyDefaults({
                PropertyIsEqualTo: function (a) {
                    var b = this.createElementNSPlus("ogc:PropertyIsEqualTo", {attributes: {matchCase: a.matchCase}});
                    this.writeNode("PropertyName", a, b);
                    this.writeOgcExpression(a.value, b);
                    return b
                }, PropertyIsNotEqualTo: function (a) {
                    var b = this.createElementNSPlus("ogc:PropertyIsNotEqualTo",
                        {attributes: {matchCase: a.matchCase}});
                    this.writeNode("PropertyName", a, b);
                    this.writeOgcExpression(a.value, b);
                    return b
                }, PropertyIsLike: function (a) {
                    var b = this.createElementNSPlus("ogc:PropertyIsLike", {
                        attributes: {
                            matchCase: a.matchCase,
                            wildCard: "*",
                            singleChar: ".",
                            escapeChar: "!"
                        }
                    });
                    this.writeNode("PropertyName", a, b);
                    this.writeNode("Literal", a.regex2value(), b);
                    return b
                }, BBOX: function (a) {
                    var b = this.createElementNSPlus("ogc:BBOX");
                    a.property && this.writeNode("PropertyName", a, b);
                    var c = this.writeNode("gml:Envelope",
                        a.value);
                    a.projection && c.setAttribute("srsName", a.projection);
                    b.appendChild(c);
                    return b
                }, SortBy: function (a) {
                    for (var b = this.createElementNSPlus("ogc:SortBy"), c = 0, d = a.length; c < d; c++)this.writeNode("ogc:SortProperty", a[c], b);
                    return b
                }, SortProperty: function (a) {
                    var b = this.createElementNSPlus("ogc:SortProperty");
                    this.writeNode("ogc:PropertyName", a, b);
                    this.writeNode("ogc:SortOrder", "DESC" == a.order ? "DESC" : "ASC", b);
                    return b
                }, SortOrder: function (a) {
                    return this.createElementNSPlus("ogc:SortOrder", {value: a})
                }
            },
            OpenLayers.Format.Filter.v1.prototype.writers.ogc),
        gml: OpenLayers.Format.GML.v3.prototype.writers.gml,
        feature: OpenLayers.Format.GML.v3.prototype.writers.feature
    }, writeSpatial: function (a, b) {
        var c = this.createElementNSPlus("ogc:" + b);
        this.writeNode("PropertyName", a, c);
        if (a.value instanceof OpenLayers.Filter.Function)this.writeNode("Function", a.value, c); else {
            var d;
            d = a.value instanceof OpenLayers.Geometry ? this.writeNode("feature:_geometry", a.value).firstChild : this.writeNode("gml:Envelope", a.value);
            a.projection &&
            d.setAttribute("srsName", a.projection);
            c.appendChild(d)
        }
        return c
    }, CLASS_NAME: "OpenLayers.Format.Filter.v1_1_0"
});
OpenLayers.Format.SLD = OpenLayers.Class(OpenLayers.Format.XML.VersionedOGC, {
    profile: null,
    defaultVersion: "1.0.0",
    stringifyOutput: !0,
    namedLayersAsArray: !1,
    CLASS_NAME: "OpenLayers.Format.SLD"
});
OpenLayers.Format.SLD.v1 = OpenLayers.Class(OpenLayers.Format.Filter.v1_0_0, {
    namespaces: {
        sld: "http://www.opengis.net/sld",
        ogc: "http://www.opengis.net/ogc",
        gml: "http://www.opengis.net/gml",
        xlink: "http://www.w3.org/1999/xlink",
        xsi: "http://www.w3.org/2001/XMLSchema-instance"
    },
    defaultPrefix: "sld",
    schemaLocation: null,
    multipleSymbolizers: !1,
    featureTypeCounter: null,
    defaultSymbolizer: {
        fillColor: "#808080",
        fillOpacity: 1,
        strokeColor: "#000000",
        strokeOpacity: 1,
        strokeWidth: 1,
        strokeDashstyle: "solid",
        pointRadius: 3,
        graphicName: "square"
    },
    read: function (a, b) {
        var b = OpenLayers.Util.applyDefaults(b, this.options), c = {namedLayers: !0 === b.namedLayersAsArray ? [] : {}};
        this.readChildNodes(a, c);
        return c
    },
    readers: OpenLayers.Util.applyDefaults({
        sld: {
            StyledLayerDescriptor: function (a, b) {
                b.version = a.getAttribute("version");
                this.readChildNodes(a, b)
            }, Name: function (a, b) {
                b.name = this.getChildValue(a)
            }, Title: function (a, b) {
                b.title = this.getChildValue(a)
            }, Abstract: function (a, b) {
                b.description = this.getChildValue(a)
            }, NamedLayer: function (a, b) {
                var c =
                {userStyles: [], namedStyles: []};
                this.readChildNodes(a, c);
                for (var d = 0, e = c.userStyles.length; d < e; ++d)c.userStyles[d].layerName = c.name;
                OpenLayers.Util.isArray(b.namedLayers) ? b.namedLayers.push(c) : b.namedLayers[c.name] = c
            }, NamedStyle: function (a, b) {
                b.namedStyles.push(this.getChildName(a.firstChild))
            }, UserStyle: function (a, b) {
                var c = {defaultsPerSymbolizer: !0, rules: []};
                this.featureTypeCounter = -1;
                this.readChildNodes(a, c);
                this.multipleSymbolizers ? (delete c.defaultsPerSymbolizer, c = new OpenLayers.Style2(c)) : c = new OpenLayers.Style(this.defaultSymbolizer,
                    c);
                b.userStyles.push(c)
            }, IsDefault: function (a, b) {
                "1" == this.getChildValue(a) && (b.isDefault = !0)
            }, FeatureTypeStyle: function (a, b) {
                ++this.featureTypeCounter;
                var c = {rules: this.multipleSymbolizers ? b.rules : []};
                this.readChildNodes(a, c);
                this.multipleSymbolizers || (b.rules = c.rules)
            }, Rule: function (a, b) {
                var c;
                this.multipleSymbolizers && (c = {symbolizers: []});
                c = new OpenLayers.Rule(c);
                this.readChildNodes(a, c);
                b.rules.push(c)
            }, ElseFilter: function (a, b) {
                b.elseFilter = !0
            }, MinScaleDenominator: function (a, b) {
                b.minScaleDenominator =
                    parseFloat(this.getChildValue(a))
            }, MaxScaleDenominator: function (a, b) {
                b.maxScaleDenominator = parseFloat(this.getChildValue(a))
            }, TextSymbolizer: function (a, b) {
                var c = {};
                this.readChildNodes(a, c);
                this.multipleSymbolizers ? (c.zIndex = this.featureTypeCounter, b.symbolizers.push(new OpenLayers.Symbolizer.Text(c))) : b.symbolizer.Text = OpenLayers.Util.applyDefaults(c, b.symbolizer.Text)
            }, LabelPlacement: function (a, b) {
                this.readChildNodes(a, b)
            }, PointPlacement: function (a, b) {
                var c = {};
                this.readChildNodes(a, c);
                c.labelRotation =
                    c.rotation;
                delete c.rotation;
                var d, e = b.labelAnchorPointX, f = b.labelAnchorPointY;
                e <= 1 / 3 ? d = "l" : e > 1 / 3 && e < 2 / 3 ? d = "c" : e >= 2 / 3 && (d = "r");
                f <= 1 / 3 ? d += "b" : f > 1 / 3 && f < 2 / 3 ? d += "m" : f >= 2 / 3 && (d += "t");
                c.labelAlign = d;
                OpenLayers.Util.applyDefaults(b, c)
            }, AnchorPoint: function (a, b) {
                this.readChildNodes(a, b)
            }, AnchorPointX: function (a, b) {
                var c = this.readers.ogc._expression.call(this, a);
                c && (b.labelAnchorPointX = c)
            }, AnchorPointY: function (a, b) {
                var c = this.readers.ogc._expression.call(this, a);
                c && (b.labelAnchorPointY = c)
            }, Displacement: function (a,
                                       b) {
                this.readChildNodes(a, b)
            }, DisplacementX: function (a, b) {
                var c = this.readers.ogc._expression.call(this, a);
                c && (b.labelXOffset = c)
            }, DisplacementY: function (a, b) {
                var c = this.readers.ogc._expression.call(this, a);
                c && (b.labelYOffset = c)
            }, LinePlacement: function (a, b) {
                this.readChildNodes(a, b)
            }, PerpendicularOffset: function (a, b) {
                var c = this.readers.ogc._expression.call(this, a);
                c && (b.labelPerpendicularOffset = c)
            }, Label: function (a, b) {
                var c = this.readers.ogc._expression.call(this, a);
                c && (b.label = c)
            }, Font: function (a, b) {
                this.readChildNodes(a,
                    b)
            }, Halo: function (a, b) {
                var c = {};
                this.readChildNodes(a, c);
                b.haloRadius = c.haloRadius;
                b.haloColor = c.fillColor;
                b.haloOpacity = c.fillOpacity
            }, Radius: function (a, b) {
                var c = this.readers.ogc._expression.call(this, a);
                null != c && (b.haloRadius = c)
            }, RasterSymbolizer: function (a, b) {
                var c = {};
                this.readChildNodes(a, c);
                this.multipleSymbolizers ? (c.zIndex = this.featureTypeCounter, b.symbolizers.push(new OpenLayers.Symbolizer.Raster(c))) : b.symbolizer.Raster = OpenLayers.Util.applyDefaults(c, b.symbolizer.Raster)
            }, Geometry: function (a,
                                   b) {
                b.geometry = {};
                this.readChildNodes(a, b.geometry)
            }, ColorMap: function (a, b) {
                b.colorMap = [];
                this.readChildNodes(a, b.colorMap)
            }, ColorMapEntry: function (a, b) {
                var c = a.getAttribute("quantity"), d = a.getAttribute("opacity");
                b.push({
                    color: a.getAttribute("color"),
                    quantity: null !== c ? parseFloat(c) : void 0,
                    label: a.getAttribute("label") || void 0,
                    opacity: null !== d ? parseFloat(d) : void 0
                })
            }, LineSymbolizer: function (a, b) {
                var c = {};
                this.readChildNodes(a, c);
                this.multipleSymbolizers ? (c.zIndex = this.featureTypeCounter, b.symbolizers.push(new OpenLayers.Symbolizer.Line(c))) :
                    b.symbolizer.Line = OpenLayers.Util.applyDefaults(c, b.symbolizer.Line)
            }, PolygonSymbolizer: function (a, b) {
                var c = {fill: !1, stroke: !1};
                this.multipleSymbolizers || (c = b.symbolizer.Polygon || c);
                this.readChildNodes(a, c);
                this.multipleSymbolizers ? (c.zIndex = this.featureTypeCounter, b.symbolizers.push(new OpenLayers.Symbolizer.Polygon(c))) : b.symbolizer.Polygon = c
            }, PointSymbolizer: function (a, b) {
                var c = {fill: !1, stroke: !1, graphic: !1};
                this.multipleSymbolizers || (c = b.symbolizer.Point || c);
                this.readChildNodes(a, c);
                this.multipleSymbolizers ?
                    (c.zIndex = this.featureTypeCounter, b.symbolizers.push(new OpenLayers.Symbolizer.Point(c))) : b.symbolizer.Point = c
            }, Stroke: function (a, b) {
                b.stroke = !0;
                this.readChildNodes(a, b)
            }, Fill: function (a, b) {
                b.fill = !0;
                this.readChildNodes(a, b)
            }, CssParameter: function (a, b) {
                var c = a.getAttribute("name"), d = this.cssMap[c];
                b.label && ("fill" === c ? d = "fontColor" : "fill-opacity" === c && (d = "fontOpacity"));
                d && (c = this.readers.ogc._expression.call(this, a)) && (b[d] = c)
            }, Graphic: function (a, b) {
                b.graphic = !0;
                var c = {};
                this.readChildNodes(a, c);
                for (var d = "stroke,strokeColor,strokeWidth,strokeOpacity,strokeLinecap,fill,fillColor,fillOpacity,graphicName,rotation,graphicFormat".split(","), e, f, g = 0, h = d.length; g < h; ++g)e = d[g], f = c[e], void 0 != f && (b[e] = f);
                void 0 != c.opacity && (b.graphicOpacity = c.opacity);
                void 0 != c.size && (isNaN(c.size / 2) ? b.graphicWidth = c.size : b.pointRadius = c.size / 2);
                void 0 != c.href && (b.externalGraphic = c.href);
                void 0 != c.rotation && (b.rotation = c.rotation)
            }, ExternalGraphic: function (a, b) {
                this.readChildNodes(a, b)
            }, Mark: function (a, b) {
                this.readChildNodes(a,
                    b)
            }, WellKnownName: function (a, b) {
                b.graphicName = this.getChildValue(a)
            }, Opacity: function (a, b) {
                var c = this.readers.ogc._expression.call(this, a);
                c && (b.opacity = c)
            }, Size: function (a, b) {
                var c = this.readers.ogc._expression.call(this, a);
                c && (b.size = c)
            }, Rotation: function (a, b) {
                var c = this.readers.ogc._expression.call(this, a);
                c && (b.rotation = c)
            }, OnlineResource: function (a, b) {
                b.href = this.getAttributeNS(a, this.namespaces.xlink, "href")
            }, Format: function (a, b) {
                b.graphicFormat = this.getChildValue(a)
            }
        }
    }, OpenLayers.Format.Filter.v1_0_0.prototype.readers),
    cssMap: {
        stroke: "strokeColor",
        "stroke-opacity": "strokeOpacity",
        "stroke-width": "strokeWidth",
        "stroke-linecap": "strokeLinecap",
        "stroke-dasharray": "strokeDashstyle",
        fill: "fillColor",
        "fill-opacity": "fillOpacity",
        "font-family": "fontFamily",
        "font-size": "fontSize",
        "font-weight": "fontWeight",
        "font-style": "fontStyle"
    },
    getCssProperty: function (a) {
        var b = null, c;
        for (c in this.cssMap)if (this.cssMap[c] == a) {
            b = c;
            break
        }
        return b
    },
    getGraphicFormat: function (a) {
        var b, c;
        for (c in this.graphicFormats)if (this.graphicFormats[c].test(a)) {
            b =
                c;
            break
        }
        return b || this.defaultGraphicFormat
    },
    defaultGraphicFormat: "image/png",
    graphicFormats: {"image/jpeg": /\.jpe?g$/i, "image/gif": /\.gif$/i, "image/png": /\.png$/i},
    write: function (a) {
        return this.writers.sld.StyledLayerDescriptor.apply(this, [a])
    },
    writers: OpenLayers.Util.applyDefaults({
        sld: {
            _OGCExpression: function (a, b) {
                var c = this.createElementNSPlus(a), d = "string" == typeof b ? b.split("${") : [b];
                c.appendChild(this.createTextNode(d[0]));
                for (var e, f, g = 1, h = d.length; g < h; g++)e = d[g], f = e.indexOf("}"), 0 < f ? (this.writeNode("ogc:PropertyName",
                    {property: e.substring(0, f)}, c), c.appendChild(this.createTextNode(e.substring(++f)))) : c.appendChild(this.createTextNode("${" + e));
                return c
            }, StyledLayerDescriptor: function (a) {
                var b = this.createElementNSPlus("sld:StyledLayerDescriptor", {
                    attributes: {
                        version: this.VERSION,
                        "xsi:schemaLocation": this.schemaLocation
                    }
                });
                b.setAttribute("xmlns:ogc", this.namespaces.ogc);
                b.setAttribute("xmlns:gml", this.namespaces.gml);
                a.name && this.writeNode("Name", a.name, b);
                a.title && this.writeNode("Title", a.title, b);
                a.description &&
                this.writeNode("Abstract", a.description, b);
                if (OpenLayers.Util.isArray(a.namedLayers))for (var c = 0, d = a.namedLayers.length; c < d; ++c)this.writeNode("NamedLayer", a.namedLayers[c], b); else for (c in a.namedLayers)this.writeNode("NamedLayer", a.namedLayers[c], b);
                return b
            }, Name: function (a) {
                return this.createElementNSPlus("sld:Name", {value: a})
            }, Title: function (a) {
                return this.createElementNSPlus("sld:Title", {value: a})
            }, Abstract: function (a) {
                return this.createElementNSPlus("sld:Abstract", {value: a})
            }, NamedLayer: function (a) {
                var b =
                    this.createElementNSPlus("sld:NamedLayer");
                this.writeNode("Name", a.name, b);
                if (a.namedStyles)for (var c = 0, d = a.namedStyles.length; c < d; ++c)this.writeNode("NamedStyle", a.namedStyles[c], b);
                if (a.userStyles) {
                    c = 0;
                    for (d = a.userStyles.length; c < d; ++c)this.writeNode("UserStyle", a.userStyles[c], b)
                }
                return b
            }, NamedStyle: function (a) {
                var b = this.createElementNSPlus("sld:NamedStyle");
                this.writeNode("Name", a, b);
                return b
            }, UserStyle: function (a) {
                var b = this.createElementNSPlus("sld:UserStyle");
                a.name && this.writeNode("Name",
                    a.name, b);
                a.title && this.writeNode("Title", a.title, b);
                a.description && this.writeNode("Abstract", a.description, b);
                a.isDefault && this.writeNode("IsDefault", a.isDefault, b);
                if (this.multipleSymbolizers && a.rules) {
                    for (var c = {"0": []}, d = [0], e, f, g, h, k, l = 0, m = a.rules.length; l < m; ++l)if (e = a.rules[l], e.symbolizers) {
                        f = {};
                        for (var n = 0, o = e.symbolizers.length; n < o; ++n)g = e.symbolizers[n], h = g.zIndex, h in f || (k = e.clone(), k.symbolizers = [], f[h] = k), f[h].symbolizers.push(g.clone());
                        for (h in f)h in c || (d.push(h), c[h] = []), c[h].push(f[h])
                    } else c[0].push(e.clone());
                    d.sort();
                    l = 0;
                    for (m = d.length; l < m; ++l)e = c[d[l]], 0 < e.length && (k = a.clone(), k.rules = c[d[l]], this.writeNode("FeatureTypeStyle", k, b))
                } else this.writeNode("FeatureTypeStyle", a, b);
                return b
            }, IsDefault: function (a) {
                return this.createElementNSPlus("sld:IsDefault", {value: a ? "1" : "0"})
            }, FeatureTypeStyle: function (a) {
                for (var b = this.createElementNSPlus("sld:FeatureTypeStyle"), c = 0, d = a.rules.length; c < d; ++c)this.writeNode("Rule", a.rules[c], b);
                return b
            }, Rule: function (a) {
                var b = this.createElementNSPlus("sld:Rule");
                a.name &&
                this.writeNode("Name", a.name, b);
                a.title && this.writeNode("Title", a.title, b);
                a.description && this.writeNode("Abstract", a.description, b);
                a.elseFilter ? this.writeNode("ElseFilter", null, b) : a.filter && this.writeNode("ogc:Filter", a.filter, b);
                void 0 != a.minScaleDenominator && this.writeNode("MinScaleDenominator", a.minScaleDenominator, b);
                void 0 != a.maxScaleDenominator && this.writeNode("MaxScaleDenominator", a.maxScaleDenominator, b);
                var c, d;
                if (this.multipleSymbolizers && a.symbolizers)for (var e = 0, f = a.symbolizers.length; e <
                f; ++e)d = a.symbolizers[e], c = d.CLASS_NAME.split(".").pop(), this.writeNode(c + "Symbolizer", d, b); else for (var f = OpenLayers.Style.SYMBOLIZER_PREFIXES, e = 0, g = f.length; e < g; ++e)c = f[e], (d = a.symbolizer[c]) && this.writeNode(c + "Symbolizer", d, b);
                return b
            }, ElseFilter: function () {
                return this.createElementNSPlus("sld:ElseFilter")
            }, MinScaleDenominator: function (a) {
                return this.createElementNSPlus("sld:MinScaleDenominator", {value: a})
            }, MaxScaleDenominator: function (a) {
                return this.createElementNSPlus("sld:MaxScaleDenominator",
                    {value: a})
            }, LineSymbolizer: function (a) {
                var b = this.createElementNSPlus("sld:LineSymbolizer");
                this.writeNode("Stroke", a, b);
                return b
            }, Stroke: function (a) {
                var b = this.createElementNSPlus("sld:Stroke");
                void 0 != a.strokeColor && this.writeNode("CssParameter", {symbolizer: a, key: "strokeColor"}, b);
                void 0 != a.strokeOpacity && this.writeNode("CssParameter", {symbolizer: a, key: "strokeOpacity"}, b);
                void 0 != a.strokeWidth && this.writeNode("CssParameter", {symbolizer: a, key: "strokeWidth"}, b);
                void 0 != a.strokeDashstyle && "solid" !==
                a.strokeDashstyle && this.writeNode("CssParameter", {symbolizer: a, key: "strokeDashstyle"}, b);
                void 0 != a.strokeLinecap && this.writeNode("CssParameter", {symbolizer: a, key: "strokeLinecap"}, b);
                return b
            }, CssParameter: function (a) {
                return this.createElementNSPlus("sld:CssParameter", {
                    attributes: {name: this.getCssProperty(a.key)},
                    value: a.symbolizer[a.key]
                })
            }, TextSymbolizer: function (a) {
                var b = this.createElementNSPlus("sld:TextSymbolizer");
                null != a.label && this.writeNode("Label", a.label, b);
                (null != a.fontFamily || null != a.fontSize ||
                null != a.fontWeight || null != a.fontStyle) && this.writeNode("Font", a, b);
                (null != a.labelAnchorPointX || null != a.labelAnchorPointY || null != a.labelAlign || null != a.labelXOffset || null != a.labelYOffset || null != a.labelRotation || null != a.labelPerpendicularOffset) && this.writeNode("LabelPlacement", a, b);
                (null != a.haloRadius || null != a.haloColor || null != a.haloOpacity) && this.writeNode("Halo", a, b);
                (null != a.fontColor || null != a.fontOpacity) && this.writeNode("Fill", {
                    fillColor: a.fontColor,
                    fillOpacity: a.fontOpacity
                }, b);
                return b
            }, LabelPlacement: function (a) {
                var b =
                    this.createElementNSPlus("sld:LabelPlacement");
                (null != a.labelAnchorPointX || null != a.labelAnchorPointY || null != a.labelAlign || null != a.labelXOffset || null != a.labelYOffset || null != a.labelRotation) && null == a.labelPerpendicularOffset && this.writeNode("PointPlacement", a, b);
                null != a.labelPerpendicularOffset && this.writeNode("LinePlacement", a, b);
                return b
            }, LinePlacement: function (a) {
                var b = this.createElementNSPlus("sld:LinePlacement");
                this.writeNode("PerpendicularOffset", a.labelPerpendicularOffset, b);
                return b
            }, PerpendicularOffset: function (a) {
                return this.createElementNSPlus("sld:PerpendicularOffset",
                    {value: a})
            }, PointPlacement: function (a) {
                var b = this.createElementNSPlus("sld:PointPlacement");
                (null != a.labelAnchorPointX || null != a.labelAnchorPointY || null != a.labelAlign) && this.writeNode("AnchorPoint", a, b);
                (null != a.labelXOffset || null != a.labelYOffset) && this.writeNode("Displacement", a, b);
                null != a.labelRotation && this.writeNode("Rotation", a.labelRotation, b);
                return b
            }, AnchorPoint: function (a) {
                var b = this.createElementNSPlus("sld:AnchorPoint"), c = a.labelAnchorPointX, d = a.labelAnchorPointY;
                null != c && this.writeNode("AnchorPointX",
                    c, b);
                null != d && this.writeNode("AnchorPointY", d, b);
                if (null == c && null == d) {
                    var e = a.labelAlign.substr(0, 1), a = a.labelAlign.substr(1, 1);
                    "l" === e ? c = 0 : "c" === e ? c = 0.5 : "r" === e && (c = 1);
                    "b" === a ? d = 0 : "m" === a ? d = 0.5 : "t" === a && (d = 1);
                    this.writeNode("AnchorPointX", c, b);
                    this.writeNode("AnchorPointY", d, b)
                }
                return b
            }, AnchorPointX: function (a) {
                return this.createElementNSPlus("sld:AnchorPointX", {value: a})
            }, AnchorPointY: function (a) {
                return this.createElementNSPlus("sld:AnchorPointY", {value: a})
            }, Displacement: function (a) {
                var b = this.createElementNSPlus("sld:Displacement");
                null != a.labelXOffset && this.writeNode("DisplacementX", a.labelXOffset, b);
                null != a.labelYOffset && this.writeNode("DisplacementY", a.labelYOffset, b);
                return b
            }, DisplacementX: function (a) {
                return this.createElementNSPlus("sld:DisplacementX", {value: a})
            }, DisplacementY: function (a) {
                return this.createElementNSPlus("sld:DisplacementY", {value: a})
            }, Font: function (a) {
                var b = this.createElementNSPlus("sld:Font");
                a.fontFamily && this.writeNode("CssParameter", {symbolizer: a, key: "fontFamily"}, b);
                a.fontSize && this.writeNode("CssParameter",
                    {symbolizer: a, key: "fontSize"}, b);
                a.fontWeight && this.writeNode("CssParameter", {symbolizer: a, key: "fontWeight"}, b);
                a.fontStyle && this.writeNode("CssParameter", {symbolizer: a, key: "fontStyle"}, b);
                return b
            }, Label: function (a) {
                return this.writers.sld._OGCExpression.call(this, "sld:Label", a)
            }, Halo: function (a) {
                var b = this.createElementNSPlus("sld:Halo");
                a.haloRadius && this.writeNode("Radius", a.haloRadius, b);
                (a.haloColor || a.haloOpacity) && this.writeNode("Fill", {
                    fillColor: a.haloColor,
                    fillOpacity: a.haloOpacity
                }, b);
                return b
            }, Radius: function (a) {
                return this.createElementNSPlus("sld:Radius", {value: a})
            }, RasterSymbolizer: function (a) {
                var b = this.createElementNSPlus("sld:RasterSymbolizer");
                a.geometry && this.writeNode("Geometry", a.geometry, b);
                a.opacity && this.writeNode("Opacity", a.opacity, b);
                a.colorMap && this.writeNode("ColorMap", a.colorMap, b);
                return b
            }, Geometry: function (a) {
                var b = this.createElementNSPlus("sld:Geometry");
                a.property && this.writeNode("ogc:PropertyName", a, b);
                return b
            }, ColorMap: function (a) {
                for (var b = this.createElementNSPlus("sld:ColorMap"),
                         c = 0, d = a.length; c < d; ++c)this.writeNode("ColorMapEntry", a[c], b);
                return b
            }, ColorMapEntry: function (a) {
                var b = this.createElementNSPlus("sld:ColorMapEntry");
                b.setAttribute("color", a.color);
                void 0 !== a.opacity && b.setAttribute("opacity", parseFloat(a.opacity));
                void 0 !== a.quantity && b.setAttribute("quantity", parseFloat(a.quantity));
                void 0 !== a.label && b.setAttribute("label", a.label);
                return b
            }, PolygonSymbolizer: function (a) {
                var b = this.createElementNSPlus("sld:PolygonSymbolizer");
                !1 !== a.fill && this.writeNode("Fill",
                    a, b);
                !1 !== a.stroke && this.writeNode("Stroke", a, b);
                return b
            }, Fill: function (a) {
                var b = this.createElementNSPlus("sld:Fill");
                a.fillColor && this.writeNode("CssParameter", {symbolizer: a, key: "fillColor"}, b);
                null != a.fillOpacity && this.writeNode("CssParameter", {symbolizer: a, key: "fillOpacity"}, b);
                return b
            }, PointSymbolizer: function (a) {
                var b = this.createElementNSPlus("sld:PointSymbolizer");
                this.writeNode("Graphic", a, b);
                return b
            }, Graphic: function (a) {
                var b = this.createElementNSPlus("sld:Graphic");
                void 0 != a.externalGraphic ?
                    this.writeNode("ExternalGraphic", a, b) : this.writeNode("Mark", a, b);
                void 0 != a.graphicOpacity && this.writeNode("Opacity", a.graphicOpacity, b);
                void 0 != a.pointRadius ? this.writeNode("Size", 2 * a.pointRadius, b) : void 0 != a.graphicWidth && this.writeNode("Size", a.graphicWidth, b);
                void 0 != a.rotation && this.writeNode("Rotation", a.rotation, b);
                return b
            }, ExternalGraphic: function (a) {
                var b = this.createElementNSPlus("sld:ExternalGraphic");
                this.writeNode("OnlineResource", a.externalGraphic, b);
                this.writeNode("Format", a.graphicFormat ||
                this.getGraphicFormat(a.externalGraphic), b);
                return b
            }, Mark: function (a) {
                var b = this.createElementNSPlus("sld:Mark");
                a.graphicName && this.writeNode("WellKnownName", a.graphicName, b);
                !1 !== a.fill && this.writeNode("Fill", a, b);
                !1 !== a.stroke && this.writeNode("Stroke", a, b);
                return b
            }, WellKnownName: function (a) {
                return this.createElementNSPlus("sld:WellKnownName", {value: a})
            }, Opacity: function (a) {
                return this.createElementNSPlus("sld:Opacity", {value: a})
            }, Size: function (a) {
                return this.writers.sld._OGCExpression.call(this,
                    "sld:Size", a)
            }, Rotation: function (a) {
                return this.createElementNSPlus("sld:Rotation", {value: a})
            }, OnlineResource: function (a) {
                return this.createElementNSPlus("sld:OnlineResource", {
                    attributes: {
                        "xlink:type": "simple",
                        "xlink:href": a
                    }
                })
            }, Format: function (a) {
                return this.createElementNSPlus("sld:Format", {value: a})
            }
        }
    }, OpenLayers.Format.Filter.v1_0_0.prototype.writers),
    CLASS_NAME: "OpenLayers.Format.SLD.v1"
});
OpenLayers.Format.SLD.v1_0_0 = OpenLayers.Class(OpenLayers.Format.SLD.v1, {
    VERSION: "1.0.0",
    schemaLocation: "http://www.opengis.net/sld http://schemas.opengis.net/sld/1.0.0/StyledLayerDescriptor.xsd",
    CLASS_NAME: "OpenLayers.Format.SLD.v1_0_0"
});
OpenLayers.Format.SLD.v1_0_0_GeoServer = OpenLayers.Class(OpenLayers.Format.SLD.v1_0_0, {
    version: "1.0.0",
    profile: "GeoServer",
    readers: OpenLayers.Util.applyDefaults({
        sld: OpenLayers.Util.applyDefaults({
            Priority: function (a, b) {
                var c = this.readers.ogc._expression.call(this, a);
                c && (b.priority = c)
            }, VendorOption: function (a, b) {
                b.vendorOptions || (b.vendorOptions = {});
                b.vendorOptions[a.getAttribute("name")] = this.getChildValue(a)
            }
        }, OpenLayers.Format.SLD.v1_0_0.prototype.readers.sld)
    }, OpenLayers.Format.SLD.v1_0_0.prototype.readers),
    writers: OpenLayers.Util.applyDefaults({
        sld: OpenLayers.Util.applyDefaults({
            Priority: function (a) {
                return this.writers.sld._OGCExpression.call(this, "sld:Priority", a)
            }, VendorOption: function (a) {
                return this.createElementNSPlus("sld:VendorOption", {attributes: {name: a.name}, value: a.value})
            }, TextSymbolizer: function (a) {
                var b = OpenLayers.Format.SLD.v1_0_0.prototype.writers.sld.TextSymbolizer.apply(this, arguments);
                !1 !== a.graphic && (a.externalGraphic || a.graphicName) && this.writeNode("Graphic", a, b);
                "priority"in a &&
                this.writeNode("Priority", a.priority, b);
                return this.addVendorOptions(b, a)
            }, PointSymbolizer: function (a) {
                return this.addVendorOptions(OpenLayers.Format.SLD.v1_0_0.prototype.writers.sld.PointSymbolizer.apply(this, arguments), a)
            }, LineSymbolizer: function (a) {
                return this.addVendorOptions(OpenLayers.Format.SLD.v1_0_0.prototype.writers.sld.LineSymbolizer.apply(this, arguments), a)
            }, PolygonSymbolizer: function (a) {
                return this.addVendorOptions(OpenLayers.Format.SLD.v1_0_0.prototype.writers.sld.PolygonSymbolizer.apply(this,
                    arguments), a)
            }
        }, OpenLayers.Format.SLD.v1_0_0.prototype.writers.sld)
    }, OpenLayers.Format.SLD.v1_0_0.prototype.writers),
    addVendorOptions: function (a, b) {
        if (b.vendorOptions)for (var c in b.vendorOptions)this.writeNode("VendorOption", {
            name: c,
            value: b.vendorOptions[c]
        }, a);
        return a
    },
    CLASS_NAME: "OpenLayers.Format.SLD.v1_0_0_GeoServer"
});
OpenLayers.Format.CSWGetDomain = function (a) {
    var a = OpenLayers.Util.applyDefaults(a, OpenLayers.Format.CSWGetDomain.DEFAULTS), b = OpenLayers.Format.CSWGetDomain["v" + a.version.replace(/\./g, "_")];
    if (!b)throw"Unsupported CSWGetDomain version: " + a.version;
    return new b(a)
};
OpenLayers.Format.CSWGetDomain.DEFAULTS = {version: "2.0.2"};
OpenLayers.Format.CSWGetDomain.v2_0_2 = OpenLayers.Class(OpenLayers.Format.XML, {
    namespaces: {
        xlink: "http://www.w3.org/1999/xlink",
        xsi: "http://www.w3.org/2001/XMLSchema-instance",
        csw: "http://www.opengis.net/cat/csw/2.0.2"
    },
    defaultPrefix: "csw",
    version: "2.0.2",
    schemaLocation: "http://www.opengis.net/cat/csw/2.0.2 http://schemas.opengis.net/csw/2.0.2/CSW-discovery.xsd",
    PropertyName: null,
    ParameterName: null,
    read: function (a) {
        "string" == typeof a && (a = OpenLayers.Format.XML.prototype.read.apply(this, [a]));
        a && 9 ==
        a.nodeType && (a = a.documentElement);
        var b = {};
        this.readNode(a, b);
        return b
    },
    readers: {
        csw: {
            GetDomainResponse: function (a, b) {
                this.readChildNodes(a, b)
            }, DomainValues: function (a, b) {
                OpenLayers.Util.isArray(b.DomainValues) || (b.DomainValues = []);
                for (var c = a.attributes, d = {}, e = 0, f = c.length; e < f; ++e)d[c[e].name] = c[e].nodeValue;
                this.readChildNodes(a, d);
                b.DomainValues.push(d)
            }, PropertyName: function (a, b) {
                b.PropertyName = this.getChildValue(a)
            }, ParameterName: function (a, b) {
                b.ParameterName = this.getChildValue(a)
            }, ListOfValues: function (a,
                                       b) {
                OpenLayers.Util.isArray(b.ListOfValues) || (b.ListOfValues = []);
                this.readChildNodes(a, b.ListOfValues)
            }, Value: function (a, b) {
                for (var c = a.attributes, d = {}, e = 0, f = c.length; e < f; ++e)d[c[e].name] = c[e].nodeValue;
                d.value = this.getChildValue(a);
                b.push({Value: d})
            }, ConceptualScheme: function (a, b) {
                b.ConceptualScheme = {};
                this.readChildNodes(a, b.ConceptualScheme)
            }, Name: function (a, b) {
                b.Name = this.getChildValue(a)
            }, Document: function (a, b) {
                b.Document = this.getChildValue(a)
            }, Authority: function (a, b) {
                b.Authority = this.getChildValue(a)
            },
            RangeOfValues: function (a, b) {
                b.RangeOfValues = {};
                this.readChildNodes(a, b.RangeOfValues)
            }, MinValue: function (a, b) {
                for (var c = a.attributes, d = {}, e = 0, f = c.length; e < f; ++e)d[c[e].name] = c[e].nodeValue;
                d.value = this.getChildValue(a);
                b.MinValue = d
            }, MaxValue: function (a, b) {
                for (var c = a.attributes, d = {}, e = 0, f = c.length; e < f; ++e)d[c[e].name] = c[e].nodeValue;
                d.value = this.getChildValue(a);
                b.MaxValue = d
            }
        }
    },
    write: function (a) {
        a = this.writeNode("csw:GetDomain", a);
        return OpenLayers.Format.XML.prototype.write.apply(this, [a])
    },
    writers: {
        csw: {
            GetDomain: function (a) {
                var b =
                    this.createElementNSPlus("csw:GetDomain", {attributes: {service: "CSW", version: this.version}});
                if (a.PropertyName || this.PropertyName)this.writeNode("csw:PropertyName", a.PropertyName || this.PropertyName, b); else if (a.ParameterName || this.ParameterName)this.writeNode("csw:ParameterName", a.ParameterName || this.ParameterName, b);
                this.readChildNodes(b, a);
                return b
            }, PropertyName: function (a) {
                return this.createElementNSPlus("csw:PropertyName", {value: a})
            }, ParameterName: function (a) {
                return this.createElementNSPlus("csw:ParameterName",
                    {value: a})
            }
        }
    },
    CLASS_NAME: "OpenLayers.Format.CSWGetDomain.v2_0_2"
});
OpenLayers.Format.CSWGetRecords = function (a) {
    var a = OpenLayers.Util.applyDefaults(a, OpenLayers.Format.CSWGetRecords.DEFAULTS), b = OpenLayers.Format.CSWGetRecords["v" + a.version.replace(/\./g, "_")];
    if (!b)throw"Unsupported CSWGetRecords version: " + a.version;
    return new b(a)
};
OpenLayers.Format.CSWGetRecords.DEFAULTS = {version: "2.0.2"};
OpenLayers.Format.CSWGetRecords.v2_0_2 = OpenLayers.Class(OpenLayers.Format.XML, {
    namespaces: {
        csw: "http://www.opengis.net/cat/csw/2.0.2",
        dc: "http://purl.org/dc/elements/1.1/",
        dct: "http://purl.org/dc/terms/",
        gmd: "http://www.isotc211.org/2005/gmd",
        geonet: "http://www.fao.org/geonetwork",
        ogc: "http://www.opengis.net/ogc",
        ows: "http://www.opengis.net/ows",
        xlink: "http://www.w3.org/1999/xlink",
        xsi: "http://www.w3.org/2001/XMLSchema-instance"
    },
    defaultPrefix: "csw",
    version: "2.0.2",
    schemaLocation: "http://www.opengis.net/cat/csw/2.0.2 http://schemas.opengis.net/csw/2.0.2/CSW-discovery.xsd",
    requestId: null,
    resultType: null,
    outputFormat: null,
    outputSchema: null,
    startPosition: null,
    maxRecords: null,
    DistributedSearch: null,
    ResponseHandler: null,
    Query: null,
    regExes: {trimSpace: /^\s*|\s*$/g, removeSpace: /\s*/g, splitSpace: /\s+/, trimComma: /\s*,\s*/g},
    initialize: function (a) {
        OpenLayers.Format.XML.prototype.initialize.apply(this, [a])
    },
    read: function (a) {
        "string" == typeof a && (a = OpenLayers.Format.XML.prototype.read.apply(this, [a]));
        a && 9 == a.nodeType && (a = a.documentElement);
        var b = {};
        this.readNode(a, b);
        return b
    },
    readers: {
        csw: {
            GetRecordsResponse: function (a, b) {
                b.records = [];
                this.readChildNodes(a, b);
                var c = this.getAttributeNS(a, "", "version");
                "" != c && (b.version = c)
            }, RequestId: function (a, b) {
                b.RequestId = this.getChildValue(a)
            }, SearchStatus: function (a, b) {
                b.SearchStatus = {};
                var c = this.getAttributeNS(a, "", "timestamp");
                "" != c && (b.SearchStatus.timestamp = c)
            }, SearchResults: function (a, b) {
                this.readChildNodes(a, b);
                for (var c = a.attributes, d = {}, e = 0, f = c.length; e < f; ++e)d[c[e].name] = "numberOfRecordsMatched" == c[e].name || "numberOfRecordsReturned" ==
                c[e].name || "nextRecord" == c[e].name ? parseInt(c[e].nodeValue) : c[e].nodeValue;
                b.SearchResults = d
            }, SummaryRecord: function (a, b) {
                var c = {type: "SummaryRecord"};
                this.readChildNodes(a, c);
                b.records.push(c)
            }, BriefRecord: function (a, b) {
                var c = {type: "BriefRecord"};
                this.readChildNodes(a, c);
                b.records.push(c)
            }, DCMIRecord: function (a, b) {
                var c = {type: "DCMIRecord"};
                this.readChildNodes(a, c);
                b.records.push(c)
            }, Record: function (a, b) {
                var c = {type: "Record"};
                this.readChildNodes(a, c);
                b.records.push(c)
            }, "*": function (a, b) {
                var c = a.localName ||
                    a.nodeName.split(":").pop();
                b[c] = this.getChildValue(a)
            }
        }, geonet: {
            info: function (a, b) {
                var c = {};
                this.readChildNodes(a, c);
                b.gninfo = c
            }
        }, dc: {
            "*": function (a, b) {
                var c = a.localName || a.nodeName.split(":").pop();
                OpenLayers.Util.isArray(b[c]) || (b[c] = []);
                for (var d = {}, e = a.attributes, f = 0, g = e.length; f < g; ++f)d[e[f].name] = e[f].nodeValue;
                d.value = this.getChildValue(a);
                "" != d.value && b[c].push(d)
            }
        }, dct: {
            "*": function (a, b) {
                var c = a.localName || a.nodeName.split(":").pop();
                OpenLayers.Util.isArray(b[c]) || (b[c] = []);
                b[c].push(this.getChildValue(a))
            }
        },
        ows: OpenLayers.Util.applyDefaults({
            BoundingBox: function (a, b) {
                b.bounds && (b.BoundingBox = [{
                    crs: b.projection,
                    value: [b.bounds.left, b.bounds.bottom, b.bounds.right, b.bounds.top]
                }], delete b.projection, delete b.bounds);
                OpenLayers.Format.OWSCommon.v1_0_0.prototype.readers.ows.BoundingBox.apply(this, arguments)
            }
        }, OpenLayers.Format.OWSCommon.v1_0_0.prototype.readers.ows)
    },
    write: function (a) {
        a = this.writeNode("csw:GetRecords", a);
        a.setAttribute("xmlns:gmd", this.namespaces.gmd);
        return OpenLayers.Format.XML.prototype.write.apply(this,
            [a])
    },
    writers: {
        csw: {
            GetRecords: function (a) {
                a || (a = {});
                var b = this.createElementNSPlus("csw:GetRecords", {
                    attributes: {
                        service: "CSW",
                        version: this.version,
                        requestId: a.requestId || this.requestId,
                        resultType: a.resultType || this.resultType,
                        outputFormat: a.outputFormat || this.outputFormat,
                        outputSchema: a.outputSchema || this.outputSchema,
                        startPosition: a.startPosition || this.startPosition,
                        maxRecords: a.maxRecords || this.maxRecords
                    }
                });
                if (a.DistributedSearch || this.DistributedSearch)this.writeNode("csw:DistributedSearch",
                    a.DistributedSearch || this.DistributedSearch, b);
                var c = a.ResponseHandler || this.ResponseHandler;
                if (OpenLayers.Util.isArray(c) && 0 < c.length)for (var d = 0, e = c.length; d < e; d++)this.writeNode("csw:ResponseHandler", c[d], b);
                this.writeNode("Query", a.Query || this.Query, b);
                return b
            }, DistributedSearch: function (a) {
                return this.createElementNSPlus("csw:DistributedSearch", {attributes: {hopCount: a.hopCount}})
            }, ResponseHandler: function (a) {
                return this.createElementNSPlus("csw:ResponseHandler", {value: a.value})
            }, Query: function (a) {
                a ||
                (a = {});
                var b = this.createElementNSPlus("csw:Query", {attributes: {typeNames: a.typeNames || "csw:Record"}}), c = a.ElementName;
                if (OpenLayers.Util.isArray(c) && 0 < c.length)for (var d = 0, e = c.length; d < e; d++)this.writeNode("csw:ElementName", c[d], b); else this.writeNode("csw:ElementSetName", a.ElementSetName || {value: "summary"}, b);
                a.Constraint && this.writeNode("csw:Constraint", a.Constraint, b);
                a.SortBy && this.writeNode("ogc:SortBy", a.SortBy, b);
                return b
            }, ElementName: function (a) {
                return this.createElementNSPlus("csw:ElementName",
                    {value: a.value})
            }, ElementSetName: function (a) {
                return this.createElementNSPlus("csw:ElementSetName", {
                    attributes: {typeNames: a.typeNames},
                    value: a.value
                })
            }, Constraint: function (a) {
                var b = this.createElementNSPlus("csw:Constraint", {attributes: {version: a.version}});
                if (a.Filter) {
                    var c = new OpenLayers.Format.Filter({version: a.version});
                    b.appendChild(c.write(a.Filter))
                } else a.CqlText && (a = this.createElementNSPlus("CqlText", {value: a.CqlText.value}), b.appendChild(a));
                return b
            }
        }, ogc: OpenLayers.Format.Filter.v1_1_0.prototype.writers.ogc
    },
    CLASS_NAME: "OpenLayers.Format.CSWGetRecords.v2_0_2"
});
OpenLayers.Format.WFST = function (a) {
    var a = OpenLayers.Util.applyDefaults(a, OpenLayers.Format.WFST.DEFAULTS), b = OpenLayers.Format.WFST["v" + a.version.replace(/\./g, "_")];
    if (!b)throw"Unsupported WFST version: " + a.version;
    return new b(a)
};
OpenLayers.Format.WFST.DEFAULTS = {version: "1.0.0"};
OpenLayers.Format.WFST.v1 = OpenLayers.Class(OpenLayers.Format.XML, {
    namespaces: {
        xlink: "http://www.w3.org/1999/xlink",
        xsi: "http://www.w3.org/2001/XMLSchema-instance",
        wfs: "http://www.opengis.net/wfs",
        gml: "http://www.opengis.net/gml",
        ogc: "http://www.opengis.net/ogc",
        ows: "http://www.opengis.net/ows"
    },
    defaultPrefix: "wfs",
    version: null,
    schemaLocations: null,
    srsName: null,
    extractAttributes: !0,
    xy: !0,
    stateName: null,
    initialize: function (a) {
        this.stateName = {};
        this.stateName[OpenLayers.State.INSERT] = "wfs:Insert";
        this.stateName[OpenLayers.State.UPDATE] =
            "wfs:Update";
        this.stateName[OpenLayers.State.DELETE] = "wfs:Delete";
        OpenLayers.Format.XML.prototype.initialize.apply(this, [a])
    },
    getSrsName: function (a, b) {
        var c = b && b.srsName;
        c || (c = a && a.layer ? a.layer.projection.getCode() : this.srsName);
        return c
    },
    read: function (a, b) {
        b = b || {};
        OpenLayers.Util.applyDefaults(b, {output: "features"});
        "string" == typeof a && (a = OpenLayers.Format.XML.prototype.read.apply(this, [a]));
        a && 9 == a.nodeType && (a = a.documentElement);
        var c = {};
        a && this.readNode(a, c, !0);
        c.features && "features" === b.output &&
        (c = c.features);
        return c
    },
    readers: {
        wfs: {
            FeatureCollection: function (a, b) {
                b.features = [];
                this.readChildNodes(a, b)
            }
        }
    },
    write: function (a, b) {
        var c = this.writeNode("wfs:Transaction", {features: a, options: b}), d = this.schemaLocationAttr();
        d && this.setAttributeNS(c, this.namespaces.xsi, "xsi:schemaLocation", d);
        return OpenLayers.Format.XML.prototype.write.apply(this, [c])
    },
    writers: {
        wfs: {
            GetFeature: function (a) {
                var b = this.createElementNSPlus("wfs:GetFeature", {
                    attributes: {
                        service: "WFS",
                        version: this.version,
                        handle: a && a.handle,
                        outputFormat: a && a.outputFormat,
                        maxFeatures: a && a.maxFeatures,
                        "xsi:schemaLocation": this.schemaLocationAttr(a)
                    }
                });
                if ("string" == typeof this.featureType)this.writeNode("Query", a, b); else for (var c = 0, d = this.featureType.length; c < d; c++)a.featureType = this.featureType[c], this.writeNode("Query", a, b);
                return b
            }, Transaction: function (a) {
                var a = a || {}, b = a.options || {}, c = this.createElementNSPlus("wfs:Transaction", {
                    attributes: {
                        service: "WFS",
                        version: this.version,
                        handle: b.handle
                    }
                }), d, e = a.features;
                if (e) {
                    !0 === b.multi && OpenLayers.Util.extend(this.geometryTypes,
                        {
                            "OpenLayers.Geometry.Point": "MultiPoint",
                            "OpenLayers.Geometry.LineString": !0 === this.multiCurve ? "MultiCurve" : "MultiLineString",
                            "OpenLayers.Geometry.Polygon": !0 === this.multiSurface ? "MultiSurface" : "MultiPolygon"
                        });
                    var f, g;
                    for (a = 0, d = e.length; a < d; ++a)g = e[a], (f = this.stateName[g.state]) && this.writeNode(f, {
                        feature: g,
                        options: b
                    }, c);
                    !0 === b.multi && this.setGeometryTypes()
                }
                if (b.nativeElements)for (a = 0, d = b.nativeElements.length; a < d; ++a)this.writeNode("wfs:Native", b.nativeElements[a], c);
                return c
            }, Native: function (a) {
                return this.createElementNSPlus("wfs:Native",
                    {attributes: {vendorId: a.vendorId, safeToIgnore: a.safeToIgnore}, value: a.value})
            }, Insert: function (a) {
                var b = a.feature, a = a.options, a = this.createElementNSPlus("wfs:Insert", {attributes: {handle: a && a.handle}});
                this.srsName = this.getSrsName(b);
                this.writeNode("feature:_typeName", b, a);
                return a
            }, Update: function (a) {
                var b = a.feature, a = a.options, a = this.createElementNSPlus("wfs:Update", {
                    attributes: {
                        handle: a && a.handle,
                        typeName: (this.featureNS ? this.featurePrefix + ":" : "") + this.featureType
                    }
                });
                this.featureNS && a.setAttribute("xmlns:" +
                this.featurePrefix, this.featureNS);
                var c = b.modified;
                if (null !== this.geometryName && (!c || void 0 !== c.geometry))this.srsName = this.getSrsName(b), this.writeNode("Property", {
                    name: this.geometryName,
                    value: b.geometry
                }, a);
                for (var d in b.attributes)void 0 !== b.attributes[d] && (!c || !c.attributes || c.attributes && void 0 !== c.attributes[d]) && this.writeNode("Property", {
                    name: d,
                    value: b.attributes[d]
                }, a);
                this.writeNode("ogc:Filter", new OpenLayers.Filter.FeatureId({fids: [b.fid]}), a);
                return a
            }, Property: function (a) {
                var b = this.createElementNSPlus("wfs:Property");
                this.writeNode("Name", a.name, b);
                null !== a.value && this.writeNode("Value", a.value, b);
                return b
            }, Name: function (a) {
                return this.createElementNSPlus("wfs:Name", {value: a})
            }, Value: function (a) {
                var b;
                a instanceof OpenLayers.Geometry ? (b = this.createElementNSPlus("wfs:Value"), a = this.writeNode("feature:_geometry", a).firstChild, b.appendChild(a)) : b = this.createElementNSPlus("wfs:Value", {value: a});
                return b
            }, Delete: function (a) {
                var b = a.feature, a = a.options, a = this.createElementNSPlus("wfs:Delete", {
                    attributes: {
                        handle: a &&
                        a.handle, typeName: (this.featureNS ? this.featurePrefix + ":" : "") + this.featureType
                    }
                });
                this.featureNS && a.setAttribute("xmlns:" + this.featurePrefix, this.featureNS);
                this.writeNode("ogc:Filter", new OpenLayers.Filter.FeatureId({fids: [b.fid]}), a);
                return a
            }
        }
    },
    schemaLocationAttr: function (a) {
        var a = OpenLayers.Util.extend({
            featurePrefix: this.featurePrefix,
            schema: this.schema
        }, a), b = OpenLayers.Util.extend({}, this.schemaLocations);
        a.schema && (b[a.featurePrefix] = a.schema);
        var a = [], c, d;
        for (d in b)(c = this.namespaces[d]) &&
        a.push(c + " " + b[d]);
        return a.join(" ") || void 0
    },
    setFilterProperty: function (a) {
        if (a.filters)for (var b = 0, c = a.filters.length; b < c; ++b)OpenLayers.Format.WFST.v1.prototype.setFilterProperty.call(this, a.filters[b]); else a instanceof OpenLayers.Filter.Spatial && !a.property && (a.property = this.geometryName)
    },
    CLASS_NAME: "OpenLayers.Format.WFST.v1"
});
OpenLayers.Format.WFST.v1_0_0 = OpenLayers.Class(OpenLayers.Format.Filter.v1_0_0, OpenLayers.Format.WFST.v1, {
    version: "1.0.0",
    srsNameInQuery: !1,
    schemaLocations: {wfs: "http://schemas.opengis.net/wfs/1.0.0/WFS-transaction.xsd"},
    initialize: function (a) {
        OpenLayers.Format.Filter.v1_0_0.prototype.initialize.apply(this, [a]);
        OpenLayers.Format.WFST.v1.prototype.initialize.apply(this, [a])
    },
    readNode: function (a, b) {
        return OpenLayers.Format.GML.v2.prototype.readNode.apply(this, [a, b])
    },
    readers: {
        wfs: OpenLayers.Util.applyDefaults({
            WFS_TransactionResponse: function (a,
                                               b) {
                b.insertIds = [];
                b.success = !1;
                this.readChildNodes(a, b)
            }, InsertResult: function (a, b) {
                var c = {fids: []};
                this.readChildNodes(a, c);
                b.insertIds.push(c.fids[0])
            }, TransactionResult: function (a, b) {
                this.readChildNodes(a, b)
            }, Status: function (a, b) {
                this.readChildNodes(a, b)
            }, SUCCESS: function (a, b) {
                b.success = !0
            }
        }, OpenLayers.Format.WFST.v1.prototype.readers.wfs),
        gml: OpenLayers.Format.GML.v2.prototype.readers.gml,
        feature: OpenLayers.Format.GML.v2.prototype.readers.feature,
        ogc: OpenLayers.Format.Filter.v1_0_0.prototype.readers.ogc
    },
    writers: {
        wfs: OpenLayers.Util.applyDefaults({
            Query: function (a) {
                var a = OpenLayers.Util.extend({
                    featureNS: this.featureNS,
                    featurePrefix: this.featurePrefix,
                    featureType: this.featureType,
                    srsName: this.srsName,
                    srsNameInQuery: this.srsNameInQuery
                }, a), b = a.featurePrefix, c = this.createElementNSPlus("wfs:Query", {attributes: {typeName: (b ? b + ":" : "") + a.featureType}});
                a.srsNameInQuery && a.srsName && c.setAttribute("srsName", a.srsName);
                a.featureNS && c.setAttribute("xmlns:" + b, a.featureNS);
                if (a.propertyNames)for (var b = 0, d = a.propertyNames.length; b <
                d; b++)this.writeNode("ogc:PropertyName", {property: a.propertyNames[b]}, c);
                a.filter && (this.setFilterProperty(a.filter), this.writeNode("ogc:Filter", a.filter, c));
                return c
            }
        }, OpenLayers.Format.WFST.v1.prototype.writers.wfs),
        gml: OpenLayers.Format.GML.v2.prototype.writers.gml,
        feature: OpenLayers.Format.GML.v2.prototype.writers.feature,
        ogc: OpenLayers.Format.Filter.v1_0_0.prototype.writers.ogc
    },
    CLASS_NAME: "OpenLayers.Format.WFST.v1_0_0"
});
OpenLayers.Format.WFST.v1_1_0 = OpenLayers.Class(OpenLayers.Format.Filter.v1_1_0, OpenLayers.Format.WFST.v1, {
    version: "1.1.0", schemaLocations: {wfs: "http://schemas.opengis.net/wfs/1.1.0/wfs.xsd"}, initialize: function (a) {
        OpenLayers.Format.Filter.v1_1_0.prototype.initialize.apply(this, [a]);
        OpenLayers.Format.WFST.v1.prototype.initialize.apply(this, [a])
    }, readNode: function (a, b) {
        return OpenLayers.Format.GML.v3.prototype.readNode.apply(this, [a, b])
    }, readers: {
        wfs: OpenLayers.Util.applyDefaults({
            FeatureCollection: function (a,
                                         b) {
                b.numberOfFeatures = parseInt(a.getAttribute("numberOfFeatures"));
                OpenLayers.Format.WFST.v1.prototype.readers.wfs.FeatureCollection.apply(this, arguments)
            }, TransactionResponse: function (a, b) {
                b.insertIds = [];
                b.success = !1;
                this.readChildNodes(a, b)
            }, TransactionSummary: function (a, b) {
                b.success = !0
            }, InsertResults: function (a, b) {
                this.readChildNodes(a, b)
            }, Feature: function (a, b) {
                var c = {fids: []};
                this.readChildNodes(a, c);
                b.insertIds.push(c.fids[0])
            }
        }, OpenLayers.Format.WFST.v1.prototype.readers.wfs),
        gml: OpenLayers.Format.GML.v3.prototype.readers.gml,
        feature: OpenLayers.Format.GML.v3.prototype.readers.feature,
        ogc: OpenLayers.Format.Filter.v1_1_0.prototype.readers.ogc,
        ows: OpenLayers.Format.OWSCommon.v1_0_0.prototype.readers.ows
    }, writers: {
        wfs: OpenLayers.Util.applyDefaults({
            GetFeature: function (a) {
                var b = OpenLayers.Format.WFST.v1.prototype.writers.wfs.GetFeature.apply(this, arguments);
                a && this.setAttributes(b, {resultType: a.resultType, startIndex: a.startIndex, count: a.count});
                return b
            }, Query: function (a) {
                var a = OpenLayers.Util.extend({
                    featureNS: this.featureNS,
                    featurePrefix: this.featurePrefix, featureType: this.featureType, srsName: this.srsName
                }, a), b = a.featurePrefix, c = this.createElementNSPlus("wfs:Query", {
                    attributes: {
                        typeName: (b ? b + ":" : "") + a.featureType,
                        srsName: a.srsName
                    }
                });
                a.featureNS && c.setAttribute("xmlns:" + b, a.featureNS);
                if (a.propertyNames)for (var b = 0, d = a.propertyNames.length; b < d; b++)this.writeNode("wfs:PropertyName", {property: a.propertyNames[b]}, c);
                a.filter && (OpenLayers.Format.WFST.v1_1_0.prototype.setFilterProperty.call(this, a.filter), this.writeNode("ogc:Filter",
                    a.filter, c));
                return c
            }, PropertyName: function (a) {
                return this.createElementNSPlus("wfs:PropertyName", {value: a.property})
            }
        }, OpenLayers.Format.WFST.v1.prototype.writers.wfs),
        gml: OpenLayers.Format.GML.v3.prototype.writers.gml,
        feature: OpenLayers.Format.GML.v3.prototype.writers.feature,
        ogc: OpenLayers.Format.Filter.v1_1_0.prototype.writers.ogc
    }, CLASS_NAME: "OpenLayers.Format.WFST.v1_1_0"
});
OpenLayers.Format.Text = OpenLayers.Class(OpenLayers.Format, {
    defaultStyle: null, extractStyles: !0, initialize: function (a) {
        a = a || {};
        !1 !== a.extractStyles && (a.defaultStyle = {
            externalGraphic: OpenLayers.Util.getImageLocation("marker.png"),
            graphicWidth: 21,
            graphicHeight: 25,
            graphicXOffset: -10.5,
            graphicYOffset: -12.5
        });
        OpenLayers.Format.prototype.initialize.apply(this, [a])
    }, read: function (a) {
        for (var a = a.split("\n"), b, c = [], d = 0; d < a.length - 1; d++) {
            var e = a[d].replace(/^\s*/, "").replace(/\s*$/, "");
            if ("#" != e.charAt(0))if (b) {
                for (var e =
                    e.split("\t"), f = new OpenLayers.Geometry.Point(0, 0), g = {}, h = this.defaultStyle ? OpenLayers.Util.applyDefaults({}, this.defaultStyle) : null, k = !1, l = 0; l < e.length; l++)if (e[l])if ("point" == b[l])k = e[l].split(","), f.y = parseFloat(k[0]), f.x = parseFloat(k[1]), k = !0; else if ("lat" == b[l])f.y = parseFloat(e[l]), k = !0; else if ("lon" == b[l])f.x = parseFloat(e[l]), k = !0; else if ("title" == b[l])g.title = e[l]; else if ("image" == b[l] || "icon" == b[l] && h)h.externalGraphic = e[l]; else if ("iconSize" == b[l] && h) {
                    var m = e[l].split(",");
                    h.graphicWidth =
                        parseFloat(m[0]);
                    h.graphicHeight = parseFloat(m[1])
                } else"iconOffset" == b[l] && h ? (m = e[l].split(","), h.graphicXOffset = parseFloat(m[0]), h.graphicYOffset = parseFloat(m[1])) : "description" == b[l] ? g.description = e[l] : "overflow" == b[l] ? g.overflow = e[l] : g[b[l]] = e[l];
                k && (this.internalProjection && this.externalProjection && f.transform(this.externalProjection, this.internalProjection), e = new OpenLayers.Feature.Vector(f, g, h), c.push(e))
            } else b = e.split("\t")
        }
        return c
    }, CLASS_NAME: "OpenLayers.Format.Text"
});
OpenLayers.Format.JSON = OpenLayers.Class(OpenLayers.Format, {
    indent: "    ", space: " ", newline: "\n", level: 0, pretty: !1, nativeJSON: function () {
        return !(!window.JSON || !("function" == typeof JSON.parse && "function" == typeof JSON.stringify))
    }(), read: function (a, b) {
        var c;
        if (this.nativeJSON)c = JSON.parse(a, b); else try {
            if (/^[\],:{}\s]*$/.test(a.replace(/\\["\\\/bfnrtu]/g, "@").replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, "]").replace(/(?:^|:|,)(?:\s*\[)+/g, "")) && (c = eval("(" + a + ")"), "function" === typeof b)) {
                var d = function (a, c) {
                    if (c && "object" === typeof c)for (var e in c)c.hasOwnProperty(e) && (c[e] = d(e, c[e]));
                    return b(a, c)
                };
                c = d("", c)
            }
        } catch (e) {
        }
        this.keepData && (this.data = c);
        return c
    }, write: function (a, b) {
        this.pretty = !!b;
        var c = null, d = typeof a;
        if (this.serialize[d])try {
            c = !this.pretty && this.nativeJSON ? JSON.stringify(a) : this.serialize[d].apply(this, [a])
        } catch (e) {
            OpenLayers.Console.error("Trouble serializing: " + e)
        }
        return c
    }, writeIndent: function () {
        var a = [];
        if (this.pretty)for (var b = 0; b < this.level; ++b)a.push(this.indent);
        return a.join("")
    }, writeNewline: function () {
        return this.pretty ? this.newline : ""
    }, writeSpace: function () {
        return this.pretty ? this.space : ""
    }, serialize: {
        object: function (a) {
            if (null == a)return "null";
            if (a.constructor == Date)return this.serialize.date.apply(this, [a]);
            if (a.constructor == Array)return this.serialize.array.apply(this, [a]);
            var b = ["{"];
            this.level += 1;
            var c, d, e, f = !1;
            for (c in a)a.hasOwnProperty(c) && (d = OpenLayers.Format.JSON.prototype.write.apply(this, [c, this.pretty]), e = OpenLayers.Format.JSON.prototype.write.apply(this,
                [a[c], this.pretty]), null != d && null != e && (f && b.push(","), b.push(this.writeNewline(), this.writeIndent(), d, ":", this.writeSpace(), e), f = !0));
            this.level -= 1;
            b.push(this.writeNewline(), this.writeIndent(), "}");
            return b.join("")
        }, array: function (a) {
            var b, c = ["["];
            this.level += 1;
            for (var d = 0, e = a.length; d < e; ++d)b = OpenLayers.Format.JSON.prototype.write.apply(this, [a[d], this.pretty]), null != b && (0 < d && c.push(","), c.push(this.writeNewline(), this.writeIndent(), b));
            this.level -= 1;
            c.push(this.writeNewline(), this.writeIndent(),
                "]");
            return c.join("")
        }, string: function (a) {
            var b = {"\u0008": "\\b", "\t": "\\t", "\n": "\\n", "\u000c": "\\f", "\r": "\\r", '"': '\\"', "\\": "\\\\"};
            return /["\\\x00-\x1f]/.test(a) ? '"' + a.replace(/([\x00-\x1f\\"])/g, function (a, d) {
                var e = b[d];
                if (e)return e;
                e = d.charCodeAt();
                return "\\u00" + Math.floor(e / 16).toString(16) + (e % 16).toString(16)
            }) + '"' : '"' + a + '"'
        }, number: function (a) {
            return isFinite(a) ? "" + a : "null"
        }, "boolean": function (a) {
            return "" + a
        }, date: function (a) {
            function b(a) {
                return 10 > a ? "0" + a : a
            }

            return '"' + a.getFullYear() + "-" +
                b(a.getMonth() + 1) + "-" + b(a.getDate()) + "T" + b(a.getHours()) + ":" + b(a.getMinutes()) + ":" + b(a.getSeconds()) + '"'
        }
    }, CLASS_NAME: "OpenLayers.Format.JSON"
});
OpenLayers.Format.GeoJSON = OpenLayers.Class(OpenLayers.Format.JSON, {
    ignoreExtraDims: !1, read: function (a, b, c) {
        var b = b ? b : "FeatureCollection", d = null, e = null;
        if (e = "string" == typeof a ? OpenLayers.Format.JSON.prototype.read.apply(this, [a, c]) : a)if ("string" != typeof e.type)OpenLayers.Console.error("Bad GeoJSON - no type: " + a); else {
            if (this.isValidType(e, b))switch (b) {
                case "Geometry":
                    try {
                        d = this.parseGeometry(e)
                    } catch (f) {
                        OpenLayers.Console.error(f)
                    }
                    break;
                case "Feature":
                    try {
                        d = this.parseFeature(e), d.type = "Feature"
                    } catch (g) {
                        OpenLayers.Console.error(g)
                    }
                    break;
                case "FeatureCollection":
                    switch (d = [], e.type) {
                        case "Feature":
                            try {
                                d.push(this.parseFeature(e))
                            } catch (h) {
                                d = null, OpenLayers.Console.error(h)
                            }
                            break;
                        case "FeatureCollection":
                            a = 0;
                            for (b = e.features.length; a < b; ++a)try {
                                d.push(this.parseFeature(e.features[a]))
                            } catch (k) {
                                d = null, OpenLayers.Console.error(k)
                            }
                            break;
                        default:
                            try {
                                var l = this.parseGeometry(e);
                                d.push(new OpenLayers.Feature.Vector(l))
                            } catch (m) {
                                d = null, OpenLayers.Console.error(m)
                            }
                    }
            }
        } else OpenLayers.Console.error("Bad JSON: " + a);
        return d
    }, isValidType: function (a,
                              b) {
        var c = !1;
        switch (b) {
            case "Geometry":
                -1 == OpenLayers.Util.indexOf("Point,MultiPoint,LineString,MultiLineString,Polygon,MultiPolygon,Box,GeometryCollection".split(","), a.type) ? OpenLayers.Console.error("Unsupported geometry type: " + a.type) : c = !0;
                break;
            case "FeatureCollection":
                c = !0;
                break;
            default:
                a.type == b ? c = !0 : OpenLayers.Console.error("Cannot convert types from " + a.type + " to " + b)
        }
        return c
    }, parseFeature: function (a) {
        var b, c, d;
        c = a.properties ? a.properties : {};
        d = a.geometry && a.geometry.bbox || a.bbox;
        try {
            b = this.parseGeometry(a.geometry)
        } catch (e) {
            throw e;
        }
        b = new OpenLayers.Feature.Vector(b, c);
        d && (b.bounds = OpenLayers.Bounds.fromArray(d));
        a.id && (b.fid = a.id);
        return b
    }, parseGeometry: function (a) {
        if (null == a)return null;
        var b, c = !1;
        if ("GeometryCollection" == a.type) {
            if (!OpenLayers.Util.isArray(a.geometries))throw"GeometryCollection must have geometries array: " + a;
            b = a.geometries.length;
            for (var c = Array(b), d = 0; d < b; ++d)c[d] = this.parseGeometry.apply(this, [a.geometries[d]]);
            b = new OpenLayers.Geometry.Collection(c);
            c = !0
        } else {
            if (!OpenLayers.Util.isArray(a.coordinates))throw"Geometry must have coordinates array: " +
            a;
            if (!this.parseCoords[a.type.toLowerCase()])throw"Unsupported geometry type: " + a.type;
            try {
                b = this.parseCoords[a.type.toLowerCase()].apply(this, [a.coordinates])
            } catch (e) {
                throw e;
            }
        }
        this.internalProjection && this.externalProjection && !c && b.transform(this.externalProjection, this.internalProjection);
        return b
    }, parseCoords: {
        point: function (a) {
            if (!1 == this.ignoreExtraDims && 2 != a.length)throw"Only 2D points are supported: " + a;
            return new OpenLayers.Geometry.Point(a[0], a[1])
        }, multipoint: function (a) {
            for (var b = [],
                     c = null, d = 0, e = a.length; d < e; ++d) {
                try {
                    c = this.parseCoords.point.apply(this, [a[d]])
                } catch (f) {
                    throw f;
                }
                b.push(c)
            }
            return new OpenLayers.Geometry.MultiPoint(b)
        }, linestring: function (a) {
            for (var b = [], c = null, d = 0, e = a.length; d < e; ++d) {
                try {
                    c = this.parseCoords.point.apply(this, [a[d]])
                } catch (f) {
                    throw f;
                }
                b.push(c)
            }
            return new OpenLayers.Geometry.LineString(b)
        }, multilinestring: function (a) {
            for (var b = [], c = null, d = 0, e = a.length; d < e; ++d) {
                try {
                    c = this.parseCoords.linestring.apply(this, [a[d]])
                } catch (f) {
                    throw f;
                }
                b.push(c)
            }
            return new OpenLayers.Geometry.MultiLineString(b)
        },
        polygon: function (a) {
            for (var b = [], c, d, e = 0, f = a.length; e < f; ++e) {
                try {
                    d = this.parseCoords.linestring.apply(this, [a[e]])
                } catch (g) {
                    throw g;
                }
                c = new OpenLayers.Geometry.LinearRing(d.components);
                b.push(c)
            }
            return new OpenLayers.Geometry.Polygon(b)
        }, multipolygon: function (a) {
            for (var b = [], c = null, d = 0, e = a.length; d < e; ++d) {
                try {
                    c = this.parseCoords.polygon.apply(this, [a[d]])
                } catch (f) {
                    throw f;
                }
                b.push(c)
            }
            return new OpenLayers.Geometry.MultiPolygon(b)
        }, box: function (a) {
            if (2 != a.length)throw"GeoJSON box coordinates must have 2 elements";
            return new OpenLayers.Geometry.Polygon([new OpenLayers.Geometry.LinearRing([new OpenLayers.Geometry.Point(a[0][0], a[0][1]), new OpenLayers.Geometry.Point(a[1][0], a[0][1]), new OpenLayers.Geometry.Point(a[1][0], a[1][1]), new OpenLayers.Geometry.Point(a[0][0], a[1][1]), new OpenLayers.Geometry.Point(a[0][0], a[0][1])])])
        }
    }, write: function (a, b) {
        var c = {type: null};
        if (OpenLayers.Util.isArray(a)) {
            c.type = "FeatureCollection";
            var d = a.length;
            c.features = Array(d);
            for (var e = 0; e < d; ++e) {
                var f = a[e];
                if (!f instanceof OpenLayers.Feature.Vector)throw"FeatureCollection only supports collections of features: " +
                f;
                c.features[e] = this.extract.feature.apply(this, [f])
            }
        } else 0 == a.CLASS_NAME.indexOf("OpenLayers.Geometry") ? c = this.extract.geometry.apply(this, [a]) : a instanceof OpenLayers.Feature.Vector && (c = this.extract.feature.apply(this, [a]), a.layer && a.layer.projection && (c.crs = this.createCRSObject(a)));
        return OpenLayers.Format.JSON.prototype.write.apply(this, [c, b])
    }, createCRSObject: function (a) {
        var a = a.layer.projection.toString(), b = {};
        a.match(/epsg:/i) && (a = parseInt(a.substring(a.indexOf(":") + 1)), b = 4326 == a ? {
            type: "name",
            properties: {name: "urn:ogc:def:crs:OGC:1.3:CRS84"}
        } : {type: "name", properties: {name: "EPSG:" + a}});
        return b
    }, extract: {
        feature: function (a) {
            var b = this.extract.geometry.apply(this, [a.geometry]), b = {
                type: "Feature",
                properties: a.attributes,
                geometry: b
            };
            null != a.fid && (b.id = a.fid);
            return b
        }, geometry: function (a) {
            if (null == a)return null;
            this.internalProjection && this.externalProjection && (a = a.clone(), a.transform(this.internalProjection, this.externalProjection));
            var b = a.CLASS_NAME.split(".")[2], a = this.extract[b.toLowerCase()].apply(this,
                [a]);
            return "Collection" == b ? {type: "GeometryCollection", geometries: a} : {type: b, coordinates: a}
        }, point: function (a) {
            return [a.x, a.y]
        }, multipoint: function (a) {
            for (var b = [], c = 0, d = a.components.length; c < d; ++c)b.push(this.extract.point.apply(this, [a.components[c]]));
            return b
        }, linestring: function (a) {
            for (var b = [], c = 0, d = a.components.length; c < d; ++c)b.push(this.extract.point.apply(this, [a.components[c]]));
            return b
        }, multilinestring: function (a) {
            for (var b = [], c = 0, d = a.components.length; c < d; ++c)b.push(this.extract.linestring.apply(this,
                [a.components[c]]));
            return b
        }, polygon: function (a) {
            for (var b = [], c = 0, d = a.components.length; c < d; ++c)b.push(this.extract.linestring.apply(this, [a.components[c]]));
            return b
        }, multipolygon: function (a) {
            for (var b = [], c = 0, d = a.components.length; c < d; ++c)b.push(this.extract.polygon.apply(this, [a.components[c]]));
            return b
        }, collection: function (a) {
            for (var b = a.components.length, c = Array(b), d = 0; d < b; ++d)c[d] = this.extract.geometry.apply(this, [a.components[d]]);
            return c
        }
    }, CLASS_NAME: "OpenLayers.Format.GeoJSON"
});
OpenLayers.Format.WMC = OpenLayers.Class(OpenLayers.Format.Context, {
    defaultVersion: "1.1.0", layerToContext: function (a) {
        var b = this.getParser(), c = {
            queryable: a.queryable,
            visibility: a.visibility,
            name: a.params.LAYERS,
            title: a.name,
            "abstract": a.metadata["abstract"],
            dataURL: a.metadata.dataURL,
            metadataURL: a.metadataURL,
            server: {version: a.params.VERSION, url: a.url},
            maxExtent: a.maxExtent,
            transparent: a.params.TRANSPARENT,
            numZoomLevels: a.numZoomLevels,
            units: a.units,
            isBaseLayer: a.isBaseLayer,
            opacity: 1 == a.opacity ? void 0 :
                a.opacity,
            displayInLayerSwitcher: a.displayInLayerSwitcher,
            singleTile: a.singleTile,
            tileSize: a.singleTile || !a.tileSize ? void 0 : {width: a.tileSize.w, height: a.tileSize.h},
            minScale: a.options.resolutions || a.options.scales || a.options.maxResolution || a.options.minScale ? a.minScale : void 0,
            maxScale: a.options.resolutions || a.options.scales || a.options.minResolution || a.options.maxScale ? a.maxScale : void 0,
            formats: [],
            styles: [],
            srs: a.srs,
            dimensions: a.dimensions
        };
        a.metadata.servertitle && (c.server.title = a.metadata.servertitle);
        if (a.metadata.formats && 0 < a.metadata.formats.length)for (var d = 0, e = a.metadata.formats.length; d < e; d++) {
            var f = a.metadata.formats[d];
            c.formats.push({value: f.value, current: f.value == a.params.FORMAT})
        } else c.formats.push({value: a.params.FORMAT, current: !0});
        if (a.metadata.styles && 0 < a.metadata.styles.length) {
            d = 0;
            for (e = a.metadata.styles.length; d < e; d++)b = a.metadata.styles[d], b.current = b.href == a.params.SLD || b.body == a.params.SLD_BODY || b.name == a.params.STYLES ? !0 : !1, c.styles.push(b)
        } else c.styles.push({
            href: a.params.SLD,
            body: a.params.SLD_BODY,
            name: a.params.STYLES || b.defaultStyleName,
            title: b.defaultStyleTitle,
            current: !0
        });
        return c
    }, toContext: function (a) {
        var b = {}, c = a.layers;
        if ("OpenLayers.Map" == a.CLASS_NAME) {
            var d = a.metadata || {};
            b.size = a.getSize();
            b.bounds = a.getExtent();
            b.projection = a.projection;
            b.title = a.title;
            b.keywords = d.keywords;
            b["abstract"] = d["abstract"];
            b.logo = d.logo;
            b.descriptionURL = d.descriptionURL;
            b.contactInformation = d.contactInformation;
            b.maxExtent = a.maxExtent
        } else OpenLayers.Util.applyDefaults(b, a), void 0 !=
        b.layers && delete b.layers;
        void 0 == b.layersContext && (b.layersContext = []);
        if (void 0 != c && OpenLayers.Util.isArray(c)) {
            a = 0;
            for (d = c.length; a < d; a++) {
                var e = c[a];
                e instanceof OpenLayers.Layer.WMS && b.layersContext.push(this.layerToContext(e))
            }
        }
        return b
    }, CLASS_NAME: "OpenLayers.Format.WMC"
});
OpenLayers.Format.WMC.v1 = OpenLayers.Class(OpenLayers.Format.XML, {
    namespaces: {
        ol: "http://openlayers.org/context",
        wmc: "http://www.opengis.net/context",
        sld: "http://www.opengis.net/sld",
        xlink: "http://www.w3.org/1999/xlink",
        xsi: "http://www.w3.org/2001/XMLSchema-instance"
    }, schemaLocation: "", getNamespacePrefix: function (a) {
        var b = null;
        if (null == a)b = this.namespaces[this.defaultPrefix]; else for (b in this.namespaces)if (this.namespaces[b] == a)break;
        return b
    }, defaultPrefix: "wmc", rootPrefix: null, defaultStyleName: "",
    defaultStyleTitle: "Default", initialize: function (a) {
        OpenLayers.Format.XML.prototype.initialize.apply(this, [a])
    }, read: function (a) {
        "string" == typeof a && (a = OpenLayers.Format.XML.prototype.read.apply(this, [a]));
        a = a.documentElement;
        this.rootPrefix = a.prefix;
        var b = {version: a.getAttribute("version")};
        this.runChildNodes(b, a);
        return b
    }, runChildNodes: function (a, b) {
        for (var c = b.childNodes, d, e, f, g = 0, h = c.length; g < h; ++g)d = c[g], 1 == d.nodeType && (e = this.getNamespacePrefix(d.namespaceURI), f = d.nodeName.split(":").pop(),
        (e = this["read_" + e + "_" + f]) && e.apply(this, [a, d]))
    }, read_wmc_General: function (a, b) {
        this.runChildNodes(a, b)
    }, read_wmc_BoundingBox: function (a, b) {
        a.projection = b.getAttribute("SRS");
        a.bounds = new OpenLayers.Bounds(b.getAttribute("minx"), b.getAttribute("miny"), b.getAttribute("maxx"), b.getAttribute("maxy"))
    }, read_wmc_LayerList: function (a, b) {
        a.layersContext = [];
        this.runChildNodes(a, b)
    }, read_wmc_Layer: function (a, b) {
        var c = {
            visibility: "1" != b.getAttribute("hidden"), queryable: "1" == b.getAttribute("queryable"), formats: [],
            styles: [], metadata: {}
        };
        this.runChildNodes(c, b);
        a.layersContext.push(c)
    }, read_wmc_Extension: function (a, b) {
        this.runChildNodes(a, b)
    }, read_ol_units: function (a, b) {
        a.units = this.getChildValue(b)
    }, read_ol_maxExtent: function (a, b) {
        var c = new OpenLayers.Bounds(b.getAttribute("minx"), b.getAttribute("miny"), b.getAttribute("maxx"), b.getAttribute("maxy"));
        a.maxExtent = c
    }, read_ol_transparent: function (a, b) {
        a.transparent = this.getChildValue(b)
    }, read_ol_numZoomLevels: function (a, b) {
        a.numZoomLevels = parseInt(this.getChildValue(b))
    },
    read_ol_opacity: function (a, b) {
        a.opacity = parseFloat(this.getChildValue(b))
    }, read_ol_singleTile: function (a, b) {
        a.singleTile = "true" == this.getChildValue(b)
    }, read_ol_tileSize: function (a, b) {
        var c = {width: b.getAttribute("width"), height: b.getAttribute("height")};
        a.tileSize = c
    }, read_ol_isBaseLayer: function (a, b) {
        a.isBaseLayer = "true" == this.getChildValue(b)
    }, read_ol_displayInLayerSwitcher: function (a, b) {
        a.displayInLayerSwitcher = "true" == this.getChildValue(b)
    }, read_wmc_Server: function (a, b) {
        a.version = b.getAttribute("version");
        a.url = this.getOnlineResource_href(b);
        a.metadata.servertitle = b.getAttribute("title")
    }, read_wmc_FormatList: function (a, b) {
        this.runChildNodes(a, b)
    }, read_wmc_Format: function (a, b) {
        var c = {value: this.getChildValue(b)};
        "1" == b.getAttribute("current") && (c.current = !0);
        a.formats.push(c)
    }, read_wmc_StyleList: function (a, b) {
        this.runChildNodes(a, b)
    }, read_wmc_Style: function (a, b) {
        var c = {};
        this.runChildNodes(c, b);
        "1" == b.getAttribute("current") && (c.current = !0);
        a.styles.push(c)
    }, read_wmc_SLD: function (a, b) {
        this.runChildNodes(a,
            b)
    }, read_sld_StyledLayerDescriptor: function (a, b) {
        var c = OpenLayers.Format.XML.prototype.write.apply(this, [b]);
        a.body = c
    }, read_sld_FeatureTypeStyle: function (a, b) {
        var c = OpenLayers.Format.XML.prototype.write.apply(this, [b]);
        a.body = c
    }, read_wmc_OnlineResource: function (a, b) {
        a.href = this.getAttributeNS(b, this.namespaces.xlink, "href")
    }, read_wmc_Name: function (a, b) {
        var c = this.getChildValue(b);
        c && (a.name = c)
    }, read_wmc_Title: function (a, b) {
        var c = this.getChildValue(b);
        c && (a.title = c)
    }, read_wmc_MetadataURL: function (a,
                                       b) {
        a.metadataURL = this.getOnlineResource_href(b)
    }, read_wmc_KeywordList: function (a, b) {
        a.keywords = [];
        this.runChildNodes(a.keywords, b)
    }, read_wmc_Keyword: function (a, b) {
        a.push(this.getChildValue(b))
    }, read_wmc_Abstract: function (a, b) {
        var c = this.getChildValue(b);
        c && (a["abstract"] = c)
    }, read_wmc_LogoURL: function (a, b) {
        a.logo = {
            width: b.getAttribute("width"),
            height: b.getAttribute("height"),
            format: b.getAttribute("format"),
            href: this.getOnlineResource_href(b)
        }
    }, read_wmc_DescriptionURL: function (a, b) {
        a.descriptionURL =
            this.getOnlineResource_href(b)
    }, read_wmc_ContactInformation: function (a, b) {
        var c = {};
        this.runChildNodes(c, b);
        a.contactInformation = c
    }, read_wmc_ContactPersonPrimary: function (a, b) {
        var c = {};
        this.runChildNodes(c, b);
        a.personPrimary = c
    }, read_wmc_ContactPerson: function (a, b) {
        var c = this.getChildValue(b);
        c && (a.person = c)
    }, read_wmc_ContactOrganization: function (a, b) {
        var c = this.getChildValue(b);
        c && (a.organization = c)
    }, read_wmc_ContactPosition: function (a, b) {
        var c = this.getChildValue(b);
        c && (a.position = c)
    }, read_wmc_ContactAddress: function (a,
                                          b) {
        var c = {};
        this.runChildNodes(c, b);
        a.contactAddress = c
    }, read_wmc_AddressType: function (a, b) {
        var c = this.getChildValue(b);
        c && (a.type = c)
    }, read_wmc_Address: function (a, b) {
        var c = this.getChildValue(b);
        c && (a.address = c)
    }, read_wmc_City: function (a, b) {
        var c = this.getChildValue(b);
        c && (a.city = c)
    }, read_wmc_StateOrProvince: function (a, b) {
        var c = this.getChildValue(b);
        c && (a.stateOrProvince = c)
    }, read_wmc_PostCode: function (a, b) {
        var c = this.getChildValue(b);
        c && (a.postcode = c)
    }, read_wmc_Country: function (a, b) {
        var c = this.getChildValue(b);
        c && (a.country = c)
    }, read_wmc_ContactVoiceTelephone: function (a, b) {
        var c = this.getChildValue(b);
        c && (a.phone = c)
    }, read_wmc_ContactFacsimileTelephone: function (a, b) {
        var c = this.getChildValue(b);
        c && (a.fax = c)
    }, read_wmc_ContactElectronicMailAddress: function (a, b) {
        var c = this.getChildValue(b);
        c && (a.email = c)
    }, read_wmc_DataURL: function (a, b) {
        a.dataURL = this.getOnlineResource_href(b)
    }, read_wmc_LegendURL: function (a, b) {
        var c = {
            width: b.getAttribute("width"), height: b.getAttribute("height"), format: b.getAttribute("format"),
            href: this.getOnlineResource_href(b)
        };
        a.legend = c
    }, read_wmc_DimensionList: function (a, b) {
        a.dimensions = {};
        this.runChildNodes(a.dimensions, b)
    }, read_wmc_Dimension: function (a, b) {
        var c = {
            name: b.getAttribute("name").toLowerCase(),
            units: b.getAttribute("units") || "",
            unitSymbol: b.getAttribute("unitSymbol") || "",
            userValue: b.getAttribute("userValue") || "",
            nearestValue: "1" === b.getAttribute("nearestValue"),
            multipleValues: "1" === b.getAttribute("multipleValues"),
            current: "1" === b.getAttribute("current"),
            "default": b.getAttribute("default") ||
            ""
        }, d = this.getChildValue(b);
        c.values = d.split(",");
        a[c.name] = c
    }, write: function (a, b) {
        var c = this.createElementDefaultNS("ViewContext");
        this.setAttributes(c, {
            version: this.VERSION,
            id: b && "string" == typeof b.id ? b.id : OpenLayers.Util.createUniqueID("OpenLayers_Context_")
        });
        this.setAttributeNS(c, this.namespaces.xsi, "xsi:schemaLocation", this.schemaLocation);
        c.appendChild(this.write_wmc_General(a));
        c.appendChild(this.write_wmc_LayerList(a));
        return OpenLayers.Format.XML.prototype.write.apply(this, [c])
    }, createElementDefaultNS: function (a,
                                         b, c) {
        a = this.createElementNS(this.namespaces[this.defaultPrefix], a);
        b && a.appendChild(this.createTextNode(b));
        c && this.setAttributes(a, c);
        return a
    }, setAttributes: function (a, b) {
        var c, d;
        for (d in b)c = b[d].toString(), c.match(/[A-Z]/) ? this.setAttributeNS(a, null, d, c) : a.setAttribute(d, c)
    }, write_wmc_General: function (a) {
        var b = this.createElementDefaultNS("General");
        a.size && b.appendChild(this.createElementDefaultNS("Window", null, {width: a.size.w, height: a.size.h}));
        var c = a.bounds;
        b.appendChild(this.createElementDefaultNS("BoundingBox",
            null, {
                minx: c.left.toPrecision(18),
                miny: c.bottom.toPrecision(18),
                maxx: c.right.toPrecision(18),
                maxy: c.top.toPrecision(18),
                SRS: a.projection
            }));
        b.appendChild(this.createElementDefaultNS("Title", a.title));
        a.keywords && b.appendChild(this.write_wmc_KeywordList(a.keywords));
        a["abstract"] && b.appendChild(this.createElementDefaultNS("Abstract", a["abstract"]));
        a.logo && b.appendChild(this.write_wmc_URLType("LogoURL", a.logo.href, a.logo));
        a.descriptionURL && b.appendChild(this.write_wmc_URLType("DescriptionURL", a.descriptionURL));
        a.contactInformation && b.appendChild(this.write_wmc_ContactInformation(a.contactInformation));
        b.appendChild(this.write_ol_MapExtension(a));
        return b
    }, write_wmc_KeywordList: function (a) {
        for (var b = this.createElementDefaultNS("KeywordList"), c = 0, d = a.length; c < d; c++)b.appendChild(this.createElementDefaultNS("Keyword", a[c]));
        return b
    }, write_wmc_ContactInformation: function (a) {
        var b = this.createElementDefaultNS("ContactInformation");
        a.personPrimary && b.appendChild(this.write_wmc_ContactPersonPrimary(a.personPrimary));
        a.position && b.appendChild(this.createElementDefaultNS("ContactPosition", a.position));
        a.contactAddress && b.appendChild(this.write_wmc_ContactAddress(a.contactAddress));
        a.phone && b.appendChild(this.createElementDefaultNS("ContactVoiceTelephone", a.phone));
        a.fax && b.appendChild(this.createElementDefaultNS("ContactFacsimileTelephone", a.fax));
        a.email && b.appendChild(this.createElementDefaultNS("ContactElectronicMailAddress", a.email));
        return b
    }, write_wmc_ContactPersonPrimary: function (a) {
        var b = this.createElementDefaultNS("ContactPersonPrimary");
        a.person && b.appendChild(this.createElementDefaultNS("ContactPerson", a.person));
        a.organization && b.appendChild(this.createElementDefaultNS("ContactOrganization", a.organization));
        return b
    }, write_wmc_ContactAddress: function (a) {
        var b = this.createElementDefaultNS("ContactAddress");
        a.type && b.appendChild(this.createElementDefaultNS("AddressType", a.type));
        a.address && b.appendChild(this.createElementDefaultNS("Address", a.address));
        a.city && b.appendChild(this.createElementDefaultNS("City", a.city));
        a.stateOrProvince &&
        b.appendChild(this.createElementDefaultNS("StateOrProvince", a.stateOrProvince));
        a.postcode && b.appendChild(this.createElementDefaultNS("PostCode", a.postcode));
        a.country && b.appendChild(this.createElementDefaultNS("Country", a.country));
        return b
    }, write_ol_MapExtension: function (a) {
        var b = this.createElementDefaultNS("Extension");
        if (a = a.maxExtent) {
            var c = this.createElementNS(this.namespaces.ol, "ol:maxExtent");
            this.setAttributes(c, {
                minx: a.left.toPrecision(18), miny: a.bottom.toPrecision(18), maxx: a.right.toPrecision(18),
                maxy: a.top.toPrecision(18)
            });
            b.appendChild(c)
        }
        return b
    }, write_wmc_LayerList: function (a) {
        for (var b = this.createElementDefaultNS("LayerList"), c = 0, d = a.layersContext.length; c < d; ++c)b.appendChild(this.write_wmc_Layer(a.layersContext[c]));
        return b
    }, write_wmc_Layer: function (a) {
        var b = this.createElementDefaultNS("Layer", null, {
            queryable: a.queryable ? "1" : "0",
            hidden: a.visibility ? "0" : "1"
        });
        b.appendChild(this.write_wmc_Server(a));
        b.appendChild(this.createElementDefaultNS("Name", a.name));
        b.appendChild(this.createElementDefaultNS("Title",
            a.title));
        a["abstract"] && b.appendChild(this.createElementDefaultNS("Abstract", a["abstract"]));
        a.dataURL && b.appendChild(this.write_wmc_URLType("DataURL", a.dataURL));
        a.metadataURL && b.appendChild(this.write_wmc_URLType("MetadataURL", a.metadataURL));
        return b
    }, write_wmc_LayerExtension: function (a) {
        var b = this.createElementDefaultNS("Extension"), c = a.maxExtent, d = this.createElementNS(this.namespaces.ol, "ol:maxExtent");
        this.setAttributes(d, {
            minx: c.left.toPrecision(18), miny: c.bottom.toPrecision(18), maxx: c.right.toPrecision(18),
            maxy: c.top.toPrecision(18)
        });
        b.appendChild(d);
        a.tileSize && !a.singleTile && (c = this.createElementNS(this.namespaces.ol, "ol:tileSize"), this.setAttributes(c, a.tileSize), b.appendChild(c));
        for (var c = "transparent,numZoomLevels,units,isBaseLayer,opacity,displayInLayerSwitcher,singleTile".split(","), e = 0, f = c.length; e < f; ++e)(d = this.createOLPropertyNode(a, c[e])) && b.appendChild(d);
        return b
    }, createOLPropertyNode: function (a, b) {
        var c = null;
        null != a[b] && (c = this.createElementNS(this.namespaces.ol, "ol:" + b), c.appendChild(this.createTextNode(a[b].toString())));
        return c
    }, write_wmc_Server: function (a) {
        var a = a.server, b = this.createElementDefaultNS("Server"), c = {service: "OGC:WMS", version: a.version};
        a.title && (c.title = a.title);
        this.setAttributes(b, c);
        b.appendChild(this.write_wmc_OnlineResource(a.url));
        return b
    }, write_wmc_URLType: function (a, b, c) {
        a = this.createElementDefaultNS(a);
        a.appendChild(this.write_wmc_OnlineResource(b));
        if (c)for (var b = ["width", "height", "format"], d = 0; d < b.length; d++)b[d]in c && a.setAttribute(b[d], c[b[d]]);
        return a
    }, write_wmc_DimensionList: function (a) {
        var b =
            this.createElementDefaultNS("DimensionList"), c;
        for (c in a.dimensions) {
            var d = {}, e = a.dimensions[c], f;
            for (f in e)d[f] = "boolean" == typeof e[f] ? Number(e[f]) : e[f];
            e = "";
            d.values && (e = d.values.join(","), delete d.values);
            b.appendChild(this.createElementDefaultNS("Dimension", e, d))
        }
        return b
    }, write_wmc_FormatList: function (a) {
        for (var b = this.createElementDefaultNS("FormatList"), c = 0, d = a.formats.length; c < d; c++) {
            var e = a.formats[c];
            b.appendChild(this.createElementDefaultNS("Format", e.value, e.current && !0 == e.current ? {current: "1"} :
                null))
        }
        return b
    }, write_wmc_StyleList: function (a) {
        var b = this.createElementDefaultNS("StyleList");
        if ((a = a.styles) && OpenLayers.Util.isArray(a))for (var c, d = 0, e = a.length; d < e; d++) {
            var f = a[d], g = this.createElementDefaultNS("Style", null, f.current && !0 == f.current ? {current: "1"} : null);
            f.href ? (c = this.createElementDefaultNS("SLD"), f.name && c.appendChild(this.createElementDefaultNS("Name", f.name)), f.title && c.appendChild(this.createElementDefaultNS("Title", f.title)), f.legend && c.appendChild(this.write_wmc_URLType("LegendURL",
                f.legend.href, f.legend)), f = this.write_wmc_OnlineResource(f.href), c.appendChild(f), g.appendChild(c)) : f.body ? (c = this.createElementDefaultNS("SLD"), f.name && c.appendChild(this.createElementDefaultNS("Name", f.name)), f.title && c.appendChild(this.createElementDefaultNS("Title", f.title)), f.legend && c.appendChild(this.write_wmc_URLType("LegendURL", f.legend.href, f.legend)), f = OpenLayers.Format.XML.prototype.read.apply(this, [f.body]).documentElement, c.ownerDocument && c.ownerDocument.importNode && (f = c.ownerDocument.importNode(f,
                !0)), c.appendChild(f), g.appendChild(c)) : (g.appendChild(this.createElementDefaultNS("Name", f.name)), g.appendChild(this.createElementDefaultNS("Title", f.title)), f["abstract"] && g.appendChild(this.createElementDefaultNS("Abstract", f["abstract"])), f.legend && g.appendChild(this.write_wmc_URLType("LegendURL", f.legend.href, f.legend)));
            b.appendChild(g)
        }
        return b
    }, write_wmc_OnlineResource: function (a) {
        var b = this.createElementDefaultNS("OnlineResource");
        this.setAttributeNS(b, this.namespaces.xlink, "xlink:type",
            "simple");
        this.setAttributeNS(b, this.namespaces.xlink, "xlink:href", a);
        return b
    }, getOnlineResource_href: function (a) {
        var b = {}, a = a.getElementsByTagName("OnlineResource");
        0 < a.length && this.read_wmc_OnlineResource(b, a[0]);
        return b.href
    }, CLASS_NAME: "OpenLayers.Format.WMC.v1"
});
OpenLayers.Format.WMC.v1_0_0 = OpenLayers.Class(OpenLayers.Format.WMC.v1, {
    VERSION: "1.0.0",
    schemaLocation: "http://www.opengis.net/context http://schemas.opengis.net/context/1.0.0/context.xsd",
    initialize: function (a) {
        OpenLayers.Format.WMC.v1.prototype.initialize.apply(this, [a])
    },
    read_wmc_SRS: function (a, b) {
        var c = this.getChildValue(b);
        "object" != typeof a.projections && (a.projections = {});
        for (var c = c.split(/ +/), d = 0, e = c.length; d < e; d++)a.projections[c[d]] = !0
    },
    write_wmc_Layer: function (a) {
        var b = OpenLayers.Format.WMC.v1.prototype.write_wmc_Layer.apply(this,
            [a]);
        if (a.srs) {
            var c = [], d;
            for (d in a.srs)c.push(d);
            b.appendChild(this.createElementDefaultNS("SRS", c.join(" ")))
        }
        b.appendChild(this.write_wmc_FormatList(a));
        b.appendChild(this.write_wmc_StyleList(a));
        a.dimensions && b.appendChild(this.write_wmc_DimensionList(a));
        b.appendChild(this.write_wmc_LayerExtension(a))
    },
    CLASS_NAME: "OpenLayers.Format.WMC.v1_0_0"
});
OpenLayers.Format.WMC.v1_1_0 = OpenLayers.Class(OpenLayers.Format.WMC.v1, {
    VERSION: "1.1.0",
    schemaLocation: "http://www.opengis.net/context http://schemas.opengis.net/context/1.1.0/context.xsd",
    initialize: function (a) {
        OpenLayers.Format.WMC.v1.prototype.initialize.apply(this, [a])
    },
    read_sld_MinScaleDenominator: function (a, b) {
        var c = parseFloat(this.getChildValue(b));
        0 < c && (a.maxScale = c)
    },
    read_sld_MaxScaleDenominator: function (a, b) {
        a.minScale = parseFloat(this.getChildValue(b))
    },
    read_wmc_SRS: function (a, b) {
        "srs"in
        a || (a.srs = {});
        a.srs[this.getChildValue(b)] = !0
    },
    write_wmc_Layer: function (a) {
        var b = OpenLayers.Format.WMC.v1.prototype.write_wmc_Layer.apply(this, [a]);
        if (a.maxScale) {
            var c = this.createElementNS(this.namespaces.sld, "sld:MinScaleDenominator");
            c.appendChild(this.createTextNode(a.maxScale.toPrecision(16)));
            b.appendChild(c)
        }
        a.minScale && (c = this.createElementNS(this.namespaces.sld, "sld:MaxScaleDenominator"), c.appendChild(this.createTextNode(a.minScale.toPrecision(16))), b.appendChild(c));
        if (a.srs)for (var d in a.srs)b.appendChild(this.createElementDefaultNS("SRS",
            d));
        b.appendChild(this.write_wmc_FormatList(a));
        b.appendChild(this.write_wmc_StyleList(a));
        a.dimensions && b.appendChild(this.write_wmc_DimensionList(a));
        b.appendChild(this.write_wmc_LayerExtension(a));
        return b
    },
    CLASS_NAME: "OpenLayers.Format.WMC.v1_1_0"
});
OpenLayers.Format.WCSGetCoverage = OpenLayers.Class(OpenLayers.Format.XML, {
    namespaces: {
        ows: "http://www.opengis.net/ows/1.1",
        wcs: "http://www.opengis.net/wcs/1.1",
        xlink: "http://www.w3.org/1999/xlink",
        xsi: "http://www.w3.org/2001/XMLSchema-instance"
    },
    regExes: {trimSpace: /^\s*|\s*$/g, removeSpace: /\s*/g, splitSpace: /\s+/, trimComma: /\s*,\s*/g},
    VERSION: "1.1.2",
    schemaLocation: "http://www.opengis.net/wcs/1.1 http://schemas.opengis.net/wcs/1.1/wcsGetCoverage.xsd",
    write: function (a) {
        a = this.writeNode("wcs:GetCoverage",
            a);
        this.setAttributeNS(a, this.namespaces.xsi, "xsi:schemaLocation", this.schemaLocation);
        return OpenLayers.Format.XML.prototype.write.apply(this, [a])
    },
    writers: {
        wcs: {
            GetCoverage: function (a) {
                var b = this.createElementNSPlus("wcs:GetCoverage", {
                    attributes: {
                        version: a.version || this.VERSION,
                        service: "WCS"
                    }
                });
                this.writeNode("ows:Identifier", a.identifier, b);
                this.writeNode("wcs:DomainSubset", a.domainSubset, b);
                this.writeNode("wcs:Output", a.output, b);
                return b
            }, DomainSubset: function (a) {
                var b = this.createElementNSPlus("wcs:DomainSubset",
                    {});
                this.writeNode("ows:BoundingBox", a.boundingBox, b);
                a.temporalSubset && this.writeNode("wcs:TemporalSubset", a.temporalSubset, b);
                return b
            }, TemporalSubset: function (a) {
                for (var b = this.createElementNSPlus("wcs:TemporalSubset", {}), c = 0, d = a.timePeriods.length; c < d; ++c)this.writeNode("wcs:TimePeriod", a.timePeriods[c], b);
                return b
            }, TimePeriod: function (a) {
                var b = this.createElementNSPlus("wcs:TimePeriod", {});
                this.writeNode("wcs:BeginPosition", a.begin, b);
                this.writeNode("wcs:EndPosition", a.end, b);
                a.resolution && this.writeNode("wcs:TimeResolution",
                    a.resolution, b);
                return b
            }, BeginPosition: function (a) {
                return this.createElementNSPlus("wcs:BeginPosition", {value: a})
            }, EndPosition: function (a) {
                return this.createElementNSPlus("wcs:EndPosition", {value: a})
            }, TimeResolution: function (a) {
                return this.createElementNSPlus("wcs:TimeResolution", {value: a})
            }, Output: function (a) {
                var b = this.createElementNSPlus("wcs:Output", {attributes: {format: a.format, store: a.store}});
                a.gridCRS && this.writeNode("wcs:GridCRS", a.gridCRS, b);
                return b
            }, GridCRS: function (a) {
                var b = this.createElementNSPlus("wcs:GridCRS",
                    {});
                this.writeNode("wcs:GridBaseCRS", a.baseCRS, b);
                a.type && this.writeNode("wcs:GridType", a.type, b);
                a.origin && this.writeNode("wcs:GridOrigin", a.origin, b);
                this.writeNode("wcs:GridOffsets", a.offsets, b);
                a.CS && this.writeNode("wcs:GridCS", a.CS, b);
                return b
            }, GridBaseCRS: function (a) {
                return this.createElementNSPlus("wcs:GridBaseCRS", {value: a})
            }, GridOrigin: function (a) {
                return this.createElementNSPlus("wcs:GridOrigin", {value: a})
            }, GridType: function (a) {
                return this.createElementNSPlus("wcs:GridType", {value: a})
            }, GridOffsets: function (a) {
                return this.createElementNSPlus("wcs:GridOffsets",
                    {value: a})
            }, GridCS: function (a) {
                return this.createElementNSPlus("wcs:GridCS", {value: a})
            }
        }, ows: OpenLayers.Format.OWSCommon.v1_1_0.prototype.writers.ows
    },
    CLASS_NAME: "OpenLayers.Format.WCSGetCoverage"
});
OpenLayers.Format.WMSCapabilities = OpenLayers.Class(OpenLayers.Format.XML.VersionedOGC, {
    defaultVersion: "1.1.1",
    profile: null,
    CLASS_NAME: "OpenLayers.Format.WMSCapabilities"
});
OpenLayers.Format.WMSCapabilities.v1 = OpenLayers.Class(OpenLayers.Format.XML, {
    namespaces: {
        wms: "http://www.opengis.net/wms",
        xlink: "http://www.w3.org/1999/xlink",
        xsi: "http://www.w3.org/2001/XMLSchema-instance"
    }, defaultPrefix: "wms", read: function (a) {
        "string" == typeof a && (a = OpenLayers.Format.XML.prototype.read.apply(this, [a]));
        var b = a;
        a && 9 == a.nodeType && (a = a.documentElement);
        var c = {};
        this.readNode(a, c);
        void 0 === c.service && (a = new OpenLayers.Format.OGCExceptionReport, c.error = a.read(b));
        return c
    }, readers: {
        wms: {
            Service: function (a,
                               b) {
                b.service = {};
                this.readChildNodes(a, b.service)
            }, Name: function (a, b) {
                b.name = this.getChildValue(a)
            }, Title: function (a, b) {
                b.title = this.getChildValue(a)
            }, Abstract: function (a, b) {
                b["abstract"] = this.getChildValue(a)
            }, BoundingBox: function (a) {
                var b = {};
                b.bbox = [parseFloat(a.getAttribute("minx")), parseFloat(a.getAttribute("miny")), parseFloat(a.getAttribute("maxx")), parseFloat(a.getAttribute("maxy"))];
                a = {x: parseFloat(a.getAttribute("resx")), y: parseFloat(a.getAttribute("resy"))};
                if (!isNaN(a.x) || !isNaN(a.y))b.res =
                    a;
                return b
            }, OnlineResource: function (a, b) {
                b.href = this.getAttributeNS(a, this.namespaces.xlink, "href")
            }, ContactInformation: function (a, b) {
                b.contactInformation = {};
                this.readChildNodes(a, b.contactInformation)
            }, ContactPersonPrimary: function (a, b) {
                b.personPrimary = {};
                this.readChildNodes(a, b.personPrimary)
            }, ContactPerson: function (a, b) {
                b.person = this.getChildValue(a)
            }, ContactOrganization: function (a, b) {
                b.organization = this.getChildValue(a)
            }, ContactPosition: function (a, b) {
                b.position = this.getChildValue(a)
            }, ContactAddress: function (a,
                                         b) {
                b.contactAddress = {};
                this.readChildNodes(a, b.contactAddress)
            }, AddressType: function (a, b) {
                b.type = this.getChildValue(a)
            }, Address: function (a, b) {
                b.address = this.getChildValue(a)
            }, City: function (a, b) {
                b.city = this.getChildValue(a)
            }, StateOrProvince: function (a, b) {
                b.stateOrProvince = this.getChildValue(a)
            }, PostCode: function (a, b) {
                b.postcode = this.getChildValue(a)
            }, Country: function (a, b) {
                b.country = this.getChildValue(a)
            }, ContactVoiceTelephone: function (a, b) {
                b.phone = this.getChildValue(a)
            }, ContactFacsimileTelephone: function (a,
                                                    b) {
                b.fax = this.getChildValue(a)
            }, ContactElectronicMailAddress: function (a, b) {
                b.email = this.getChildValue(a)
            }, Fees: function (a, b) {
                var c = this.getChildValue(a);
                c && "none" != c.toLowerCase() && (b.fees = c)
            }, AccessConstraints: function (a, b) {
                var c = this.getChildValue(a);
                c && "none" != c.toLowerCase() && (b.accessConstraints = c)
            }, Capability: function (a, b) {
                b.capability = {nestedLayers: [], layers: []};
                this.readChildNodes(a, b.capability)
            }, Request: function (a, b) {
                b.request = {};
                this.readChildNodes(a, b.request)
            }, GetCapabilities: function (a,
                                          b) {
                b.getcapabilities = {formats: []};
                this.readChildNodes(a, b.getcapabilities)
            }, Format: function (a, b) {
                OpenLayers.Util.isArray(b.formats) ? b.formats.push(this.getChildValue(a)) : b.format = this.getChildValue(a)
            }, DCPType: function (a, b) {
                this.readChildNodes(a, b)
            }, HTTP: function (a, b) {
                this.readChildNodes(a, b)
            }, Get: function (a, b) {
                b.get = {};
                this.readChildNodes(a, b.get);
                b.href || (b.href = b.get.href)
            }, Post: function (a, b) {
                b.post = {};
                this.readChildNodes(a, b.post);
                b.href || (b.href = b.get.href)
            }, GetMap: function (a, b) {
                b.getmap = {formats: []};
                this.readChildNodes(a, b.getmap)
            }, GetFeatureInfo: function (a, b) {
                b.getfeatureinfo = {formats: []};
                this.readChildNodes(a, b.getfeatureinfo)
            }, Exception: function (a, b) {
                b.exception = {formats: []};
                this.readChildNodes(a, b.exception)
            }, Layer: function (a, b) {
                var c, d;
                b.capability ? (d = b.capability, c = b) : d = b;
                var e = a.getAttributeNode("queryable"), f = e && e.specified ? a.getAttribute("queryable") : null, g = (e = a.getAttributeNode("cascaded")) && e.specified ? a.getAttribute("cascaded") : null, e = (e = a.getAttributeNode("opaque")) && e.specified ?
                    a.getAttribute("opaque") : null, h = a.getAttribute("noSubsets"), k = a.getAttribute("fixedWidth"), l = a.getAttribute("fixedHeight"), m = c || {}, n = OpenLayers.Util.extend;
                c = {
                    nestedLayers: [],
                    styles: c ? [].concat(c.styles) : [],
                    srs: c ? n({}, m.srs) : {},
                    metadataURLs: [],
                    bbox: c ? n({}, m.bbox) : {},
                    llbbox: m.llbbox,
                    dimensions: c ? n({}, m.dimensions) : {},
                    authorityURLs: c ? n({}, m.authorityURLs) : {},
                    identifiers: {},
                    keywords: [],
                    queryable: f && "" !== f ? "1" === f || "true" === f : m.queryable || !1,
                    cascaded: null !== g ? parseInt(g) : m.cascaded || 0,
                    opaque: e ? "1" ===
                    e || "true" === e : m.opaque || !1,
                    noSubsets: null !== h ? "1" === h || "true" === h : m.noSubsets || !1,
                    fixedWidth: null != k ? parseInt(k) : m.fixedWidth || 0,
                    fixedHeight: null != l ? parseInt(l) : m.fixedHeight || 0,
                    minScale: m.minScale,
                    maxScale: m.maxScale,
                    attribution: m.attribution
                };
                b.nestedLayers.push(c);
                c.capability = d;
                this.readChildNodes(a, c);
                delete c.capability;
                c.name && (f = c.name.split(":"), g = d.request, e = g.getfeatureinfo, 0 < f.length && (c.prefix = f[0]), d.layers.push(c), void 0 === c.formats && (c.formats = g.getmap.formats), void 0 === c.infoFormats &&
                e && (c.infoFormats = e.formats))
            }, Attribution: function (a, b) {
                b.attribution = {};
                this.readChildNodes(a, b.attribution)
            }, LogoURL: function (a, b) {
                b.logo = {width: a.getAttribute("width"), height: a.getAttribute("height")};
                this.readChildNodes(a, b.logo)
            }, Style: function (a, b) {
                var c = {};
                b.styles.push(c);
                this.readChildNodes(a, c)
            }, LegendURL: function (a, b) {
                var c = {width: a.getAttribute("width"), height: a.getAttribute("height")};
                b.legend = c;
                this.readChildNodes(a, c)
            }, MetadataURL: function (a, b) {
                var c = {type: a.getAttribute("type")};
                b.metadataURLs.push(c);
                this.readChildNodes(a, c)
            }, DataURL: function (a, b) {
                b.dataURL = {};
                this.readChildNodes(a, b.dataURL)
            }, FeatureListURL: function (a, b) {
                b.featureListURL = {};
                this.readChildNodes(a, b.featureListURL)
            }, AuthorityURL: function (a, b) {
                var c = a.getAttribute("name"), d = {};
                this.readChildNodes(a, d);
                b.authorityURLs[c] = d.href
            }, Identifier: function (a, b) {
                var c = a.getAttribute("authority");
                b.identifiers[c] = this.getChildValue(a)
            }, KeywordList: function (a, b) {
                this.readChildNodes(a, b)
            }, SRS: function (a, b) {
                b.srs[this.getChildValue(a)] = !0
            }
        }
    }, CLASS_NAME: "OpenLayers.Format.WMSCapabilities.v1"
});
OpenLayers.Format.WMSCapabilities.v1_1 = OpenLayers.Class(OpenLayers.Format.WMSCapabilities.v1, {
    readers: {
        wms: OpenLayers.Util.applyDefaults({
                WMT_MS_Capabilities: function (a, b) {
                    this.readChildNodes(a, b)
                }, Keyword: function (a, b) {
                    b.keywords && b.keywords.push(this.getChildValue(a))
                }, DescribeLayer: function (a, b) {
                    b.describelayer = {formats: []};
                    this.readChildNodes(a, b.describelayer)
                }, GetLegendGraphic: function (a, b) {
                    b.getlegendgraphic = {formats: []};
                    this.readChildNodes(a, b.getlegendgraphic)
                }, GetStyles: function (a, b) {
                    b.getstyles =
                    {formats: []};
                    this.readChildNodes(a, b.getstyles)
                }, PutStyles: function (a, b) {
                    b.putstyles = {formats: []};
                    this.readChildNodes(a, b.putstyles)
                }, UserDefinedSymbolization: function (a, b) {
                    var c = {
                        supportSLD: 1 == parseInt(a.getAttribute("SupportSLD")),
                        userLayer: 1 == parseInt(a.getAttribute("UserLayer")),
                        userStyle: 1 == parseInt(a.getAttribute("UserStyle")),
                        remoteWFS: 1 == parseInt(a.getAttribute("RemoteWFS"))
                    };
                    b.userSymbols = c
                }, LatLonBoundingBox: function (a, b) {
                    b.llbbox = [parseFloat(a.getAttribute("minx")), parseFloat(a.getAttribute("miny")),
                        parseFloat(a.getAttribute("maxx")), parseFloat(a.getAttribute("maxy"))]
                }, BoundingBox: function (a, b) {
                    var c = OpenLayers.Format.WMSCapabilities.v1.prototype.readers.wms.BoundingBox.apply(this, [a, b]);
                    c.srs = a.getAttribute("SRS");
                    b.bbox[c.srs] = c
                }, ScaleHint: function (a, b) {
                    var c = a.getAttribute("min"), d = a.getAttribute("max"), e = Math.pow(2, 0.5), f = OpenLayers.INCHES_PER_UNIT.m;
                    b.maxScale = parseFloat((c / e * f * OpenLayers.DOTS_PER_INCH).toPrecision(13));
                    b.minScale = parseFloat((d / e * f * OpenLayers.DOTS_PER_INCH).toPrecision(13))
                },
                Dimension: function (a, b) {
                    var c = {
                        name: a.getAttribute("name").toLowerCase(),
                        units: a.getAttribute("units"),
                        unitsymbol: a.getAttribute("unitSymbol")
                    };
                    b.dimensions[c.name] = c
                }, Extent: function (a, b) {
                    var c = a.getAttribute("name").toLowerCase();
                    if (c in b.dimensions) {
                        c = b.dimensions[c];
                        c.nearestVal = "1" === a.getAttribute("nearestValue");
                        c.multipleVal = "1" === a.getAttribute("multipleValues");
                        c.current = "1" === a.getAttribute("current");
                        c["default"] = a.getAttribute("default") || "";
                        var d = this.getChildValue(a);
                        c.values = d.split(",")
                    }
                }
            },
            OpenLayers.Format.WMSCapabilities.v1.prototype.readers.wms)
    }, CLASS_NAME: "OpenLayers.Format.WMSCapabilities.v1_1"
});
OpenLayers.Format.WMSCapabilities.v1_1_0 = OpenLayers.Class(OpenLayers.Format.WMSCapabilities.v1_1, {
    version: "1.1.0",
    readers: {
        wms: OpenLayers.Util.applyDefaults({
            SRS: function (a, b) {
                for (var c = this.getChildValue(a).split(/ +/), d = 0, e = c.length; d < e; d++)b.srs[c[d]] = !0
            }
        }, OpenLayers.Format.WMSCapabilities.v1_1.prototype.readers.wms)
    },
    CLASS_NAME: "OpenLayers.Format.WMSCapabilities.v1_1_0"
});
OpenLayers.Format.WMSCapabilities.v1_1_1 = OpenLayers.Class(OpenLayers.Format.WMSCapabilities.v1_1, {
    version: "1.1.1",
    readers: {
        wms: OpenLayers.Util.applyDefaults({
            SRS: function (a, b) {
                b.srs[this.getChildValue(a)] = !0
            }
        }, OpenLayers.Format.WMSCapabilities.v1_1.prototype.readers.wms)
    },
    CLASS_NAME: "OpenLayers.Format.WMSCapabilities.v1_1_1"
});
OpenLayers.Format.WMSCapabilities.v1_3 = OpenLayers.Class(OpenLayers.Format.WMSCapabilities.v1, {
    readers: {
        wms: OpenLayers.Util.applyDefaults({
            WMS_Capabilities: function (a, b) {
                this.readChildNodes(a, b)
            }, LayerLimit: function (a, b) {
                b.layerLimit = parseInt(this.getChildValue(a))
            }, MaxWidth: function (a, b) {
                b.maxWidth = parseInt(this.getChildValue(a))
            }, MaxHeight: function (a, b) {
                b.maxHeight = parseInt(this.getChildValue(a))
            }, BoundingBox: function (a, b) {
                var c = OpenLayers.Format.WMSCapabilities.v1.prototype.readers.wms.BoundingBox.apply(this,
                    [a, b]);
                c.srs = a.getAttribute("CRS");
                b.bbox[c.srs] = c
            }, CRS: function (a, b) {
                this.readers.wms.SRS.apply(this, [a, b])
            }, EX_GeographicBoundingBox: function (a, b) {
                b.llbbox = [];
                this.readChildNodes(a, b.llbbox)
            }, westBoundLongitude: function (a, b) {
                b[0] = this.getChildValue(a)
            }, eastBoundLongitude: function (a, b) {
                b[2] = this.getChildValue(a)
            }, southBoundLatitude: function (a, b) {
                b[1] = this.getChildValue(a)
            }, northBoundLatitude: function (a, b) {
                b[3] = this.getChildValue(a)
            }, MinScaleDenominator: function (a, b) {
                b.maxScale = parseFloat(this.getChildValue(a)).toPrecision(16)
            },
            MaxScaleDenominator: function (a, b) {
                b.minScale = parseFloat(this.getChildValue(a)).toPrecision(16)
            }, Dimension: function (a, b) {
                var c = {
                    name: a.getAttribute("name").toLowerCase(),
                    units: a.getAttribute("units"),
                    unitsymbol: a.getAttribute("unitSymbol"),
                    nearestVal: "1" === a.getAttribute("nearestValue"),
                    multipleVal: "1" === a.getAttribute("multipleValues"),
                    "default": a.getAttribute("default") || "",
                    current: "1" === a.getAttribute("current"),
                    values: this.getChildValue(a).split(",")
                };
                b.dimensions[c.name] = c
            }, Keyword: function (a,
                                  b) {
                var c = {value: this.getChildValue(a), vocabulary: a.getAttribute("vocabulary")};
                b.keywords && b.keywords.push(c)
            }
        }, OpenLayers.Format.WMSCapabilities.v1.prototype.readers.wms), sld: {
            UserDefinedSymbolization: function (a, b) {
                this.readers.wms.UserDefinedSymbolization.apply(this, [a, b]);
                b.userSymbols.inlineFeature = 1 == parseInt(a.getAttribute("InlineFeature"));
                b.userSymbols.remoteWCS = 1 == parseInt(a.getAttribute("RemoteWCS"))
            }, DescribeLayer: function (a, b) {
                this.readers.wms.DescribeLayer.apply(this, [a, b])
            }, GetLegendGraphic: function (a,
                                           b) {
                this.readers.wms.GetLegendGraphic.apply(this, [a, b])
            }
        }
    }, CLASS_NAME: "OpenLayers.Format.WMSCapabilities.v1_3"
});
OpenLayers.Format.WMSCapabilities.v1_3_0 = OpenLayers.Class(OpenLayers.Format.WMSCapabilities.v1_3, {
    version: "1.3.0",
    CLASS_NAME: "OpenLayers.Format.WMSCapabilities.v1_3_0"
});
OpenLayers.Format.WMSCapabilities.v1_1_1_WMSC = OpenLayers.Class(OpenLayers.Format.WMSCapabilities.v1_1_1, {
    version: "1.1.1", profile: "WMSC", readers: {
        wms: OpenLayers.Util.applyDefaults({
            VendorSpecificCapabilities: function (a, b) {
                b.vendorSpecific = {tileSets: []};
                this.readChildNodes(a, b.vendorSpecific)
            }, TileSet: function (a, b) {
                var c = {srs: {}, bbox: {}, resolutions: []};
                this.readChildNodes(a, c);
                b.tileSets.push(c)
            }, Resolutions: function (a, b) {
                for (var c = this.getChildValue(a).split(" "), d = 0, e = c.length; d < e; d++)"" != c[d] && b.resolutions.push(parseFloat(c[d]))
            },
            Width: function (a, b) {
                b.width = parseInt(this.getChildValue(a))
            }, Height: function (a, b) {
                b.height = parseInt(this.getChildValue(a))
            }, Layers: function (a, b) {
                b.layers = this.getChildValue(a)
            }, Styles: function (a, b) {
                b.styles = this.getChildValue(a)
            }
        }, OpenLayers.Format.WMSCapabilities.v1_1_1.prototype.readers.wms)
    }, CLASS_NAME: "OpenLayers.Format.WMSCapabilities.v1_1_1_WMSC"
});
OpenLayers.Format.WMSGetFeatureInfo = OpenLayers.Class(OpenLayers.Format.XML, {
    layerIdentifier: "_layer",
    featureIdentifier: "_feature",
    regExes: {trimSpace: /^\s*|\s*$/g, removeSpace: /\s*/g, splitSpace: /\s+/, trimComma: /\s*,\s*/g},
    gmlFormat: null,
    read: function (a) {
        "string" == typeof a && (a = OpenLayers.Format.XML.prototype.read.apply(this, [a]));
        var b = a.documentElement;
        if (b)var c = this["read_" + b.nodeName], a = c ? c.call(this, b) : (new OpenLayers.Format.GML(this.options ? this.options : {})).read(a);
        return a
    },
    read_msGMLOutput: function (a) {
        var b =
            [];
        if (a = this.getSiblingNodesByTagCriteria(a, this.layerIdentifier))for (var c = 0, d = a.length; c < d; ++c) {
            var e = a[c], f = e.nodeName;
            e.prefix && (f = f.split(":")[1]);
            f = f.replace(this.layerIdentifier, "");
            if (e = this.getSiblingNodesByTagCriteria(e, this.featureIdentifier))for (var g = 0; g < e.length; g++) {
                var h = e[g], k = this.parseGeometry(h), h = this.parseAttributes(h), h = new OpenLayers.Feature.Vector(k.geometry, h, null);
                h.bounds = k.bounds;
                h.type = f;
                b.push(h)
            }
        }
        return b
    },
    read_FeatureInfoResponse: function (a) {
        for (var b = [], a = this.getElementsByTagNameNS(a,
            "*", "FIELDS"), c = 0, d = a.length; c < d; c++) {
            var e = a[c], f = {}, g, h = e.attributes.length;
            if (0 < h)for (g = 0; g < h; g++) {
                var k = e.attributes[g];
                f[k.nodeName] = k.nodeValue
            } else {
                e = e.childNodes;
                for (g = 0, h = e.length; g < h; ++g)k = e[g], 3 != k.nodeType && (f[k.getAttribute("name")] = k.getAttribute("value"))
            }
            b.push(new OpenLayers.Feature.Vector(null, f, null))
        }
        return b
    },
    getSiblingNodesByTagCriteria: function (a, b) {
        var c = [], d, e, f, g;
        if (a && a.hasChildNodes()) {
            d = a.childNodes;
            f = d.length;
            for (var h = 0; h < f; h++) {
                for (g = d[h]; g && 1 != g.nodeType;)g = g.nextSibling,
                    h++;
                e = g ? g.nodeName : "";
                0 < e.length && -1 < e.indexOf(b) ? c.push(g) : (e = this.getSiblingNodesByTagCriteria(g, b), 0 < e.length && (0 == c.length ? c = e : c.push(e)))
            }
        }
        return c
    },
    parseAttributes: function (a) {
        var b = {};
        if (1 == a.nodeType)for (var a = a.childNodes, c = a.length, d = 0; d < c; ++d) {
            var e = a[d];
            if (1 == e.nodeType) {
                var f = e.childNodes, e = e.prefix ? e.nodeName.split(":")[1] : e.nodeName;
                if (0 == f.length)b[e] = null; else if (1 == f.length && (f = f[0], 3 == f.nodeType || 4 == f.nodeType))f = f.nodeValue.replace(this.regExes.trimSpace, ""), b[e] = f
            }
        }
        return b
    },
    parseGeometry: function (a) {
        this.gmlFormat || (this.gmlFormat = new OpenLayers.Format.GML);
        var a = this.gmlFormat.parseFeature(a), b, c = null;
        a && (b = a.geometry && a.geometry.clone(), c = a.bounds && a.bounds.clone(), a.destroy());
        return {geometry: b, bounds: c}
    },
    CLASS_NAME: "OpenLayers.Format.WMSGetFeatureInfo"
});
OpenLayers.Format.SOSCapabilities = OpenLayers.Class(OpenLayers.Format.XML.VersionedOGC, {
    defaultVersion: "1.0.0",
    CLASS_NAME: "OpenLayers.Format.SOSCapabilities"
});
OpenLayers.Format.SOSCapabilities.v1_0_0 = OpenLayers.Class(OpenLayers.Format.SOSCapabilities, {
    namespaces: {
        ows: "http://www.opengis.net/ows/1.1",
        sos: "http://www.opengis.net/sos/1.0",
        gml: "http://www.opengis.net/gml",
        xlink: "http://www.w3.org/1999/xlink"
    },
    regExes: {trimSpace: /^\s*|\s*$/g, removeSpace: /\s*/g, splitSpace: /\s+/, trimComma: /\s*,\s*/g},
    initialize: function (a) {
        OpenLayers.Format.XML.prototype.initialize.apply(this, [a]);
        this.options = a
    },
    read: function (a) {
        "string" == typeof a && (a = OpenLayers.Format.XML.prototype.read.apply(this,
            [a]));
        a && 9 == a.nodeType && (a = a.documentElement);
        var b = {};
        this.readNode(a, b);
        return b
    },
    readers: {
        gml: OpenLayers.Util.applyDefaults({
            name: function (a, b) {
                b.name = this.getChildValue(a)
            }, TimePeriod: function (a, b) {
                b.timePeriod = {};
                this.readChildNodes(a, b.timePeriod)
            }, beginPosition: function (a, b) {
                b.beginPosition = this.getChildValue(a)
            }, endPosition: function (a, b) {
                b.endPosition = this.getChildValue(a)
            }
        }, OpenLayers.Format.GML.v3.prototype.readers.gml), sos: {
            Capabilities: function (a, b) {
                this.readChildNodes(a, b)
            }, Contents: function (a,
                                   b) {
                b.contents = {};
                this.readChildNodes(a, b.contents)
            }, ObservationOfferingList: function (a, b) {
                b.offeringList = {};
                this.readChildNodes(a, b.offeringList)
            }, ObservationOffering: function (a, b) {
                var c = this.getAttributeNS(a, this.namespaces.gml, "id");
                b[c] = {
                    procedures: [],
                    observedProperties: [],
                    featureOfInterestIds: [],
                    responseFormats: [],
                    resultModels: [],
                    responseModes: []
                };
                this.readChildNodes(a, b[c])
            }, time: function (a, b) {
                b.time = {};
                this.readChildNodes(a, b.time)
            }, procedure: function (a, b) {
                b.procedures.push(this.getAttributeNS(a,
                    this.namespaces.xlink, "href"))
            }, observedProperty: function (a, b) {
                b.observedProperties.push(this.getAttributeNS(a, this.namespaces.xlink, "href"))
            }, featureOfInterest: function (a, b) {
                b.featureOfInterestIds.push(this.getAttributeNS(a, this.namespaces.xlink, "href"))
            }, responseFormat: function (a, b) {
                b.responseFormats.push(this.getChildValue(a))
            }, resultModel: function (a, b) {
                b.resultModels.push(this.getChildValue(a))
            }, responseMode: function (a, b) {
                b.responseModes.push(this.getChildValue(a))
            }
        }, ows: OpenLayers.Format.OWSCommon.v1_1_0.prototype.readers.ows
    },
    CLASS_NAME: "OpenLayers.Format.SOSCapabilities.v1_0_0"
});
OpenLayers.Format.SOSGetFeatureOfInterest = OpenLayers.Class(OpenLayers.Format.XML, {
    VERSION: "1.0.0",
    namespaces: {
        sos: "http://www.opengis.net/sos/1.0",
        gml: "http://www.opengis.net/gml",
        sa: "http://www.opengis.net/sampling/1.0",
        xsi: "http://www.w3.org/2001/XMLSchema-instance"
    },
    schemaLocation: "http://www.opengis.net/sos/1.0 http://schemas.opengis.net/sos/1.0.0/sosAll.xsd",
    defaultPrefix: "sos",
    regExes: {trimSpace: /^\s*|\s*$/g, removeSpace: /\s*/g, splitSpace: /\s+/, trimComma: /\s*,\s*/g},
    read: function (a) {
        "string" == typeof a && (a = OpenLayers.Format.XML.prototype.read.apply(this, [a]));
        a && 9 == a.nodeType && (a = a.documentElement);
        var b = {features: []};
        this.readNode(a, b);
        for (var a = [], c = 0, d = b.features.length; c < d; c++) {
            var e = b.features[c];
            this.internalProjection && this.externalProjection && e.components[0] && e.components[0].transform(this.externalProjection, this.internalProjection);
            e = new OpenLayers.Feature.Vector(e.components[0], e.attributes);
            a.push(e)
        }
        return a
    },
    readers: {
        sa: {
            SamplingPoint: function (a, b) {
                if (!b.attributes) {
                    var c =
                    {attributes: {}};
                    b.features.push(c);
                    b = c
                }
                b.attributes.id = this.getAttributeNS(a, this.namespaces.gml, "id");
                this.readChildNodes(a, b)
            }, position: function (a, b) {
                this.readChildNodes(a, b)
            }
        }, gml: OpenLayers.Util.applyDefaults({
            FeatureCollection: function (a, b) {
                this.readChildNodes(a, b)
            }, featureMember: function (a, b) {
                var c = {attributes: {}};
                b.features.push(c);
                this.readChildNodes(a, c)
            }, name: function (a, b) {
                b.attributes.name = this.getChildValue(a)
            }, pos: function (a, b) {
                this.externalProjection || (this.externalProjection = new OpenLayers.Projection(a.getAttribute("srsName")));
                OpenLayers.Format.GML.v3.prototype.readers.gml.pos.apply(this, [a, b])
            }
        }, OpenLayers.Format.GML.v3.prototype.readers.gml)
    },
    writers: {
        sos: {
            GetFeatureOfInterest: function (a) {
                for (var b = this.createElementNSPlus("GetFeatureOfInterest", {
                    attributes: {
                        version: this.VERSION,
                        service: "SOS",
                        "xsi:schemaLocation": this.schemaLocation
                    }
                }), c = 0, d = a.fois.length; c < d; c++)this.writeNode("FeatureOfInterestId", {foi: a.fois[c]}, b);
                return b
            }, FeatureOfInterestId: function (a) {
                return this.createElementNSPlus("FeatureOfInterestId", {value: a.foi})
            }
        }
    },
    CLASS_NAME: "OpenLayers.Format.SOSGetFeatureOfInterest"
});
OpenLayers.Format.SOSGetObservation = OpenLayers.Class(OpenLayers.Format.XML, {
    namespaces: {
        ows: "http://www.opengis.net/ows",
        gml: "http://www.opengis.net/gml",
        sos: "http://www.opengis.net/sos/1.0",
        ogc: "http://www.opengis.net/ogc",
        om: "http://www.opengis.net/om/1.0",
        sa: "http://www.opengis.net/sampling/1.0",
        xlink: "http://www.w3.org/1999/xlink",
        xsi: "http://www.w3.org/2001/XMLSchema-instance"
    },
    regExes: {trimSpace: /^\s*|\s*$/g, removeSpace: /\s*/g, splitSpace: /\s+/, trimComma: /\s*,\s*/g},
    VERSION: "1.0.0",
    schemaLocation: "http://www.opengis.net/sos/1.0 http://schemas.opengis.net/sos/1.0.0/sosGetObservation.xsd",
    defaultPrefix: "sos",
    read: function (a) {
        "string" == typeof a && (a = OpenLayers.Format.XML.prototype.read.apply(this, [a]));
        a && 9 == a.nodeType && (a = a.documentElement);
        var b = {measurements: [], observations: []};
        this.readNode(a, b);
        return b
    },
    write: function (a) {
        a = this.writeNode("sos:GetObservation", a);
        a.setAttribute("xmlns:om", this.namespaces.om);
        a.setAttribute("xmlns:ogc", this.namespaces.ogc);
        this.setAttributeNS(a, this.namespaces.xsi, "xsi:schemaLocation", this.schemaLocation);
        return OpenLayers.Format.XML.prototype.write.apply(this,
            [a])
    },
    readers: {
        om: {
            ObservationCollection: function (a, b) {
                b.id = this.getAttributeNS(a, this.namespaces.gml, "id");
                this.readChildNodes(a, b)
            }, member: function (a, b) {
                this.readChildNodes(a, b)
            }, Measurement: function (a, b) {
                var c = {};
                b.measurements.push(c);
                this.readChildNodes(a, c)
            }, Observation: function (a, b) {
                var c = {};
                b.observations.push(c);
                this.readChildNodes(a, c)
            }, samplingTime: function (a, b) {
                var c = {};
                b.samplingTime = c;
                this.readChildNodes(a, c)
            }, observedProperty: function (a, b) {
                b.observedProperty = this.getAttributeNS(a, this.namespaces.xlink,
                    "href");
                this.readChildNodes(a, b)
            }, procedure: function (a, b) {
                b.procedure = this.getAttributeNS(a, this.namespaces.xlink, "href");
                this.readChildNodes(a, b)
            }, featureOfInterest: function (a, b) {
                var c = {features: []};
                b.fois = [];
                b.fois.push(c);
                this.readChildNodes(a, c);
                for (var d = [], e = 0, f = c.features.length; e < f; e++) {
                    var g = c.features[e];
                    d.push(new OpenLayers.Feature.Vector(g.components[0], g.attributes))
                }
                c.features = d
            }, result: function (a, b) {
                var c = {};
                b.result = c;
                "" !== this.getChildValue(a) ? (c.value = this.getChildValue(a), c.uom =
                    a.getAttribute("uom")) : this.readChildNodes(a, c)
            }
        },
        sa: OpenLayers.Format.SOSGetFeatureOfInterest.prototype.readers.sa,
        gml: OpenLayers.Util.applyDefaults({
            TimeInstant: function (a, b) {
                var c = {};
                b.timeInstant = c;
                this.readChildNodes(a, c)
            }, timePosition: function (a, b) {
                b.timePosition = this.getChildValue(a)
            }
        }, OpenLayers.Format.SOSGetFeatureOfInterest.prototype.readers.gml)
    },
    writers: {
        sos: {
            GetObservation: function (a) {
                var b = this.createElementNSPlus("GetObservation", {
                    attributes: {
                        version: this.VERSION,
                        service: "SOS"
                    }
                });
                this.writeNode("offering",
                    a, b);
                a.eventTime && this.writeNode("eventTime", a, b);
                for (var c in a.procedures)this.writeNode("procedure", a.procedures[c], b);
                for (var d in a.observedProperties)this.writeNode("observedProperty", a.observedProperties[d], b);
                a.foi && this.writeNode("featureOfInterest", a.foi, b);
                this.writeNode("responseFormat", a, b);
                a.resultModel && this.writeNode("resultModel", a, b);
                a.responseMode && this.writeNode("responseMode", a, b);
                return b
            }, featureOfInterest: function (a) {
                var b = this.createElementNSPlus("featureOfInterest");
                this.writeNode("ObjectID",
                    a.objectId, b);
                return b
            }, ObjectID: function (a) {
                return this.createElementNSPlus("ObjectID", {value: a})
            }, responseFormat: function (a) {
                return this.createElementNSPlus("responseFormat", {value: a.responseFormat})
            }, procedure: function (a) {
                return this.createElementNSPlus("procedure", {value: a})
            }, offering: function (a) {
                return this.createElementNSPlus("offering", {value: a.offering})
            }, observedProperty: function (a) {
                return this.createElementNSPlus("observedProperty", {value: a})
            }, eventTime: function (a) {
                var b = this.createElementNSPlus("eventTime");
                "latest" === a.eventTime && this.writeNode("ogc:TM_Equals", a, b);
                return b
            }, resultModel: function (a) {
                return this.createElementNSPlus("resultModel", {value: a.resultModel})
            }, responseMode: function (a) {
                return this.createElementNSPlus("responseMode", {value: a.responseMode})
            }
        }, ogc: {
            TM_Equals: function (a) {
                var b = this.createElementNSPlus("ogc:TM_Equals");
                this.writeNode("ogc:PropertyName", {property: "urn:ogc:data:time:iso8601"}, b);
                "latest" === a.eventTime && this.writeNode("gml:TimeInstant", {value: "latest"}, b);
                return b
            }, PropertyName: function (a) {
                return this.createElementNSPlus("ogc:PropertyName",
                    {value: a.property})
            }
        }, gml: {
            TimeInstant: function (a) {
                var b = this.createElementNSPlus("gml:TimeInstant");
                this.writeNode("gml:timePosition", a, b);
                return b
            }, timePosition: function (a) {
                return this.createElementNSPlus("gml:timePosition", {value: a.value})
            }
        }
    },
    CLASS_NAME: "OpenLayers.Format.SOSGetObservation"
});
OpenLayers.Format.OWSContext = OpenLayers.Class(OpenLayers.Format.Context, {
    defaultVersion: "0.3.1",
    getVersion: function (a, b) {
        var c = OpenLayers.Format.XML.VersionedOGC.prototype.getVersion.apply(this, arguments);
        "0.3.0" === c && (c = this.defaultVersion);
        return c
    },
    toContext: function (a) {
        var b = {};
        "OpenLayers.Map" == a.CLASS_NAME && (b.bounds = a.getExtent(), b.maxExtent = a.maxExtent, b.projection = a.projection, b.size = a.getSize(), b.layers = a.layers);
        return b
    },
    CLASS_NAME: "OpenLayers.Format.OWSContext"
});
OpenLayers.Format.OWSContext.v0_3_1 = OpenLayers.Class(OpenLayers.Format.XML, {
    namespaces: {
        owc: "http://www.opengis.net/ows-context",
        gml: "http://www.opengis.net/gml",
        kml: "http://www.opengis.net/kml/2.2",
        ogc: "http://www.opengis.net/ogc",
        ows: "http://www.opengis.net/ows",
        sld: "http://www.opengis.net/sld",
        xlink: "http://www.w3.org/1999/xlink",
        xsi: "http://www.w3.org/2001/XMLSchema-instance"
    },
    VERSION: "0.3.1",
    schemaLocation: "http://www.opengis.net/ows-context http://www.ogcnetwork.net/schemas/owc/0.3.1/owsContext.xsd",
    defaultPrefix: "owc",
    extractAttributes: !0,
    xy: !0,
    regExes: {trimSpace: /^\s*|\s*$/g, removeSpace: /\s*/g, splitSpace: /\s+/, trimComma: /\s*,\s*/g},
    featureNS: "http://mapserver.gis.umn.edu/mapserver",
    featureType: "vector",
    geometryName: "geometry",
    nestingLayerLookup: null,
    initialize: function (a) {
        OpenLayers.Format.XML.prototype.initialize.apply(this, [a]);
        OpenLayers.Format.GML.v2.prototype.setGeometryTypes.call(this)
    },
    setNestingPath: function (a) {
        if (a.layersContext)for (var b = 0, c = a.layersContext.length; b < c; b++) {
            var d =
                a.layersContext[b], e = [], f = a.title || "";
            a.metadata && a.metadata.nestingPath && (e = a.metadata.nestingPath.slice());
            "" != f && e.push(f);
            d.metadata.nestingPath = e;
            d.layersContext && this.setNestingPath(d)
        }
    },
    decomposeNestingPath: function (a) {
        var b = [];
        if (OpenLayers.Util.isArray(a)) {
            for (a = a.slice(); 0 < a.length;)b.push(a.slice()), a.pop();
            b.reverse()
        }
        return b
    },
    read: function (a) {
        "string" == typeof a && (a = OpenLayers.Format.XML.prototype.read.apply(this, [a]));
        a && 9 == a.nodeType && (a = a.documentElement);
        var b = {};
        this.readNode(a,
            b);
        this.setNestingPath({layersContext: b.layersContext});
        a = [];
        this.processLayer(a, b);
        delete b.layersContext;
        b.layersContext = a;
        return b
    },
    processLayer: function (a, b) {
        if (b.layersContext)for (var c = 0, d = b.layersContext.length; c < d; c++) {
            var e = b.layersContext[c];
            a.push(e);
            e.layersContext && this.processLayer(a, e)
        }
    },
    write: function (a, b) {
        this.nestingLayerLookup = {};
        b = b || {};
        OpenLayers.Util.applyDefaults(b, a);
        var c = this.writeNode("OWSContext", b);
        this.nestingLayerLookup = null;
        this.setAttributeNS(c, this.namespaces.xsi,
            "xsi:schemaLocation", this.schemaLocation);
        return OpenLayers.Format.XML.prototype.write.apply(this, [c])
    },
    readers: {
        kml: {
            Document: function (a, b) {
                b.features = (new OpenLayers.Format.KML({kmlns: this.namespaces.kml, extractStyles: !0})).read(a)
            }
        },
        owc: {
            OWSContext: function (a, b) {
                this.readChildNodes(a, b)
            }, General: function (a, b) {
                this.readChildNodes(a, b)
            }, ResourceList: function (a, b) {
                this.readChildNodes(a, b)
            }, Layer: function (a, b) {
                var c = {
                    metadata: {},
                    visibility: "1" != a.getAttribute("hidden"),
                    queryable: "1" == a.getAttribute("queryable"),
                    opacity: null != a.getAttribute("opacity") ? parseFloat(a.getAttribute("opacity")) : null,
                    name: a.getAttribute("name"),
                    categoryLayer: null == a.getAttribute("name"),
                    formats: [],
                    styles: []
                };
                b.layersContext || (b.layersContext = []);
                b.layersContext.push(c);
                this.readChildNodes(a, c)
            }, InlineGeometry: function (a, b) {
                b.features = [];
                var c = this.getElementsByTagNameNS(a, this.namespaces.gml, "featureMember"), d;
                1 <= c.length && (d = c[0]);
                d && d.firstChild && (c = d.firstChild.nextSibling ? d.firstChild.nextSibling : d.firstChild, this.setNamespace("feature",
                    c.namespaceURI), this.featureType = c.localName || c.nodeName.split(":").pop(), this.readChildNodes(a, b))
            }, Server: function (a, b) {
                if (!b.service && !b.version || b.service != OpenLayers.Format.Context.serviceTypes.WMS)b.service = a.getAttribute("service"), b.version = a.getAttribute("version"), this.readChildNodes(a, b)
            }, Name: function (a, b) {
                b.name = this.getChildValue(a);
                this.readChildNodes(a, b)
            }, Title: function (a, b) {
                b.title = this.getChildValue(a);
                this.readChildNodes(a, b)
            }, StyleList: function (a, b) {
                this.readChildNodes(a, b.styles)
            },
            Style: function (a, b) {
                var c = {};
                b.push(c);
                this.readChildNodes(a, c)
            }, LegendURL: function (a, b) {
                var c = {};
                b.legend = c;
                this.readChildNodes(a, c)
            }, OnlineResource: function (a, b) {
                b.url = this.getAttributeNS(a, this.namespaces.xlink, "href");
                this.readChildNodes(a, b)
            }
        },
        ows: OpenLayers.Format.OWSCommon.v1_0_0.prototype.readers.ows,
        gml: OpenLayers.Format.GML.v2.prototype.readers.gml,
        sld: OpenLayers.Format.SLD.v1_0_0.prototype.readers.sld,
        feature: OpenLayers.Format.GML.v2.prototype.readers.feature
    },
    writers: {
        owc: {
            OWSContext: function (a) {
                var b =
                    this.createElementNSPlus("OWSContext", {
                        attributes: {
                            version: this.VERSION,
                            id: a.id || OpenLayers.Util.createUniqueID("OpenLayers_OWSContext_")
                        }
                    });
                this.writeNode("General", a, b);
                this.writeNode("ResourceList", a, b);
                return b
            }, General: function (a) {
                var b = this.createElementNSPlus("General");
                this.writeNode("ows:BoundingBox", a, b);
                this.writeNode("ows:Title", a.title || "OpenLayers OWSContext", b);
                return b
            }, ResourceList: function (a) {
                for (var b = this.createElementNSPlus("ResourceList"), c = 0, d = a.layers.length; c < d; c++) {
                    var e =
                        a.layers[c], f = this.decomposeNestingPath(e.metadata.nestingPath);
                    this.writeNode("_Layer", {layer: e, subPaths: f}, b)
                }
                return b
            }, Server: function (a) {
                var b = this.createElementNSPlus("Server", {attributes: {version: a.version, service: a.service}});
                this.writeNode("OnlineResource", a, b);
                return b
            }, OnlineResource: function (a) {
                return this.createElementNSPlus("OnlineResource", {attributes: {"xlink:href": a.url}})
            }, InlineGeometry: function (a) {
                var b = this.createElementNSPlus("InlineGeometry");
                this.writeNode("gml:boundedBy", a.getDataExtent(),
                    b);
                for (var c = 0, d = a.features.length; c < d; c++)this.writeNode("gml:featureMember", a.features[c], b);
                return b
            }, StyleList: function (a) {
                for (var b = this.createElementNSPlus("StyleList"), c = 0, d = a.length; c < d; c++)this.writeNode("Style", a[c], b);
                return b
            }, Style: function (a) {
                var b = this.createElementNSPlus("Style");
                this.writeNode("Name", a, b);
                this.writeNode("Title", a, b);
                a.legend && this.writeNode("LegendURL", a, b);
                return b
            }, Name: function (a) {
                return this.createElementNSPlus("Name", {value: a.name})
            }, Title: function (a) {
                return this.createElementNSPlus("Title",
                    {value: a.title})
            }, LegendURL: function (a) {
                var b = this.createElementNSPlus("LegendURL");
                this.writeNode("OnlineResource", a.legend, b);
                return b
            }, _WMS: function (a) {
                var b = this.createElementNSPlus("Layer", {
                    attributes: {
                        name: a.params.LAYERS,
                        queryable: a.queryable ? "1" : "0",
                        hidden: a.visibility ? "0" : "1",
                        opacity: a.hasOwnProperty("opacity") ? a.opacity : null
                    }
                });
                this.writeNode("ows:Title", a.name, b);
                this.writeNode("ows:OutputFormat", a.params.FORMAT, b);
                this.writeNode("Server", {
                    service: OpenLayers.Format.Context.serviceTypes.WMS,
                    version: a.params.VERSION, url: a.url
                }, b);
                a.metadata.styles && 0 < a.metadata.styles.length && this.writeNode("StyleList", a.metadata.styles, b);
                return b
            }, _Layer: function (a) {
                var b, c, d;
                b = a.layer;
                c = a.subPaths;
                d = null;
                0 < c.length ? (b = c[0].join("/"), c = b.lastIndexOf("/"), d = this.nestingLayerLookup[b], c = 0 < c ? b.substring(c + 1, b.length) : b, d || (d = this.createElementNSPlus("Layer"), this.writeNode("ows:Title", c, d), this.nestingLayerLookup[b] = d), a.subPaths.shift(), this.writeNode("_Layer", a, d)) : (b instanceof OpenLayers.Layer.WMS ?
                    d = this.writeNode("_WMS", b) : b instanceof OpenLayers.Layer.Vector && (b.protocol instanceof OpenLayers.Protocol.WFS.v1 ? d = this.writeNode("_WFS", b) : b.protocol instanceof OpenLayers.Protocol.HTTP ? b.protocol.format instanceof OpenLayers.Format.GML ? (b.protocol.format.version = "2.1.2", d = this.writeNode("_GML", b)) : b.protocol.format instanceof OpenLayers.Format.KML && (b.protocol.format.version = "2.2", d = this.writeNode("_KML", b)) : (this.setNamespace("feature", this.featureNS), d = this.writeNode("_InlineGeometry", b))),
                b.options.maxScale && this.writeNode("sld:MinScaleDenominator", b.options.maxScale, d), b.options.minScale && this.writeNode("sld:MaxScaleDenominator", b.options.minScale, d), this.nestingLayerLookup[b.name] = d);
                return d
            }, _WFS: function (a) {
                var b = this.createElementNSPlus("Layer", {
                    attributes: {
                        name: a.protocol.featurePrefix + ":" + a.protocol.featureType,
                        hidden: a.visibility ? "0" : "1"
                    }
                });
                this.writeNode("ows:Title", a.name, b);
                this.writeNode("Server", {
                    service: OpenLayers.Format.Context.serviceTypes.WFS, version: a.protocol.version,
                    url: a.protocol.url
                }, b);
                return b
            }, _InlineGeometry: function (a) {
                var b = this.createElementNSPlus("Layer", {
                    attributes: {
                        name: this.featureType,
                        hidden: a.visibility ? "0" : "1"
                    }
                });
                this.writeNode("ows:Title", a.name, b);
                this.writeNode("InlineGeometry", a, b);
                return b
            }, _GML: function (a) {
                var b = this.createElementNSPlus("Layer");
                this.writeNode("ows:Title", a.name, b);
                this.writeNode("Server", {
                    service: OpenLayers.Format.Context.serviceTypes.GML,
                    url: a.protocol.url,
                    version: a.protocol.format.version
                }, b);
                return b
            }, _KML: function (a) {
                var b =
                    this.createElementNSPlus("Layer");
                this.writeNode("ows:Title", a.name, b);
                this.writeNode("Server", {
                    service: OpenLayers.Format.Context.serviceTypes.KML,
                    version: a.protocol.format.version,
                    url: a.protocol.url
                }, b);
                return b
            }
        },
        gml: OpenLayers.Util.applyDefaults({
            boundedBy: function (a) {
                var b = this.createElementNSPlus("gml:boundedBy");
                this.writeNode("gml:Box", a, b);
                return b
            }
        }, OpenLayers.Format.GML.v2.prototype.writers.gml),
        ows: OpenLayers.Format.OWSCommon.v1_0_0.prototype.writers.ows,
        sld: OpenLayers.Format.SLD.v1_0_0.prototype.writers.sld,
        feature: OpenLayers.Format.GML.v2.prototype.writers.feature
    },
    CLASS_NAME: "OpenLayers.Format.OWSContext.v0_3_1"
});
OpenLayers.Format.WMTSCapabilities = OpenLayers.Class(OpenLayers.Format.XML.VersionedOGC, {
    defaultVersion: "1.0.0", yx: {"urn:ogc:def:crs:EPSG::4326": !0}, createLayer: function (a, b) {
        var c, d = {layer: !0, matrixSet: !0}, e;
        for (e in d)if (!(e in b))throw Error("Missing property '" + e + "' in layer configuration.");
        d = a.contents;
        e = d.tileMatrixSets[b.matrixSet];
        for (var f, g = 0, h = d.layers.length; g < h; ++g)if (d.layers[g].identifier === b.layer) {
            f = d.layers[g];
            break
        }
        if (f && e) {
            for (var k, g = 0, h = f.styles.length; g < h && !(k = f.styles[g], k.isDefault); ++g);
            c = new OpenLayers.Layer.WMTS(OpenLayers.Util.applyDefaults(b, {
                url: "REST" === b.requestEncoding && f.resourceUrl ? f.resourceUrl.tile.template : a.operationsMetadata.GetTile.dcp.http.get[0].url,
                name: f.title,
                style: k.identifier,
                matrixIds: e.matrixIds,
                tileFullExtent: e.bounds
            }))
        }
        return c
    }, CLASS_NAME: "OpenLayers.Format.WMTSCapabilities"
});
OpenLayers.Format.WMTSCapabilities.v1_0_0 = OpenLayers.Class(OpenLayers.Format.OWSCommon.v1_1_0, {
    version: "1.0.0",
    namespaces: {
        ows: "http://www.opengis.net/ows/1.1",
        wmts: "http://www.opengis.net/wmts/1.0",
        xlink: "http://www.w3.org/1999/xlink"
    },
    yx: null,
    defaultPrefix: "wmts",
    initialize: function (a) {
        OpenLayers.Format.XML.prototype.initialize.apply(this, [a]);
        this.options = a;
        a = OpenLayers.Util.extend({}, OpenLayers.Format.WMTSCapabilities.prototype.yx);
        this.yx = OpenLayers.Util.extend(a, this.yx)
    },
    read: function (a) {
        "string" == typeof a && (a = OpenLayers.Format.XML.prototype.read.apply(this, [a]));
        a && 9 == a.nodeType && (a = a.documentElement);
        var b = {};
        this.readNode(a, b);
        b.version = this.version;
        return b
    },
    readers: {
        wmts: {
            Capabilities: function (a, b) {
                this.readChildNodes(a, b)
            }, Contents: function (a, b) {
                b.contents = {};
                b.contents.layers = [];
                b.contents.tileMatrixSets = {};
                this.readChildNodes(a, b.contents)
            }, Layer: function (a, b) {
                var c = {styles: [], formats: [], dimensions: [], tileMatrixSetLinks: [], layers: []};
                this.readChildNodes(a, c);
                b.layers.push(c)
            }, Style: function (a,
                                b) {
                var c = {};
                c.isDefault = "true" === a.getAttribute("isDefault");
                this.readChildNodes(a, c);
                b.styles.push(c)
            }, Format: function (a, b) {
                b.formats.push(this.getChildValue(a))
            }, TileMatrixSetLink: function (a, b) {
                var c = {};
                this.readChildNodes(a, c);
                b.tileMatrixSetLinks.push(c)
            }, TileMatrixSet: function (a, b) {
                if (b.layers) {
                    var c = {matrixIds: []};
                    this.readChildNodes(a, c);
                    b.tileMatrixSets[c.identifier] = c
                } else b.tileMatrixSet = this.getChildValue(a)
            }, TileMatrix: function (a, b) {
                var c = {supportedCRS: b.supportedCRS};
                this.readChildNodes(a,
                    c);
                b.matrixIds.push(c)
            }, ScaleDenominator: function (a, b) {
                b.scaleDenominator = parseFloat(this.getChildValue(a))
            }, TopLeftCorner: function (a, b) {
                var c = this.getChildValue(a).split(" "), d;
                b.supportedCRS && (d = !!this.yx[b.supportedCRS.replace(/urn:ogc:def:crs:(\w+):.+:(\w+)$/, "urn:ogc:def:crs:$1::$2")]);
                b.topLeftCorner = d ? new OpenLayers.LonLat(c[1], c[0]) : new OpenLayers.LonLat(c[0], c[1])
            }, TileWidth: function (a, b) {
                b.tileWidth = parseInt(this.getChildValue(a))
            }, TileHeight: function (a, b) {
                b.tileHeight = parseInt(this.getChildValue(a))
            },
            MatrixWidth: function (a, b) {
                b.matrixWidth = parseInt(this.getChildValue(a))
            }, MatrixHeight: function (a, b) {
                b.matrixHeight = parseInt(this.getChildValue(a))
            }, ResourceURL: function (a, b) {
                b.resourceUrl = b.resourceUrl || {};
                b.resourceUrl[a.getAttribute("resourceType")] = {
                    format: a.getAttribute("format"),
                    template: a.getAttribute("template")
                }
            }, WSDL: function (a, b) {
                b.wsdl = {};
                b.wsdl.href = a.getAttribute("xlink:href")
            }, ServiceMetadataURL: function (a, b) {
                b.serviceMetadataUrl = {};
                b.serviceMetadataUrl.href = a.getAttribute("xlink:href")
            },
            LegendURL: function (a, b) {
                b.legend = {};
                b.legend.href = a.getAttribute("xlink:href");
                b.legend.format = a.getAttribute("format")
            }, Dimension: function (a, b) {
                var c = {values: []};
                this.readChildNodes(a, c);
                b.dimensions.push(c)
            }, Default: function (a, b) {
                b["default"] = this.getChildValue(a)
            }, Value: function (a, b) {
                b.values.push(this.getChildValue(a))
            }
        }, ows: OpenLayers.Format.OWSCommon.v1_1_0.prototype.readers.ows
    },
    CLASS_NAME: "OpenLayers.Format.WMTSCapabilities.v1_0_0"
});
OpenLayers.Format.WPSCapabilities = OpenLayers.Class(OpenLayers.Format.XML.VersionedOGC, {
    defaultVersion: "1.0.0",
    CLASS_NAME: "OpenLayers.Format.WPSCapabilities"
});
OpenLayers.Format.WPSCapabilities.v1_0_0 = OpenLayers.Class(OpenLayers.Format.XML, {
    namespaces: {
        ows: "http://www.opengis.net/ows/1.1",
        wps: "http://www.opengis.net/wps/1.0.0",
        xlink: "http://www.w3.org/1999/xlink"
    },
    regExes: {trimSpace: /^\s*|\s*$/g, removeSpace: /\s*/g, splitSpace: /\s+/, trimComma: /\s*,\s*/g},
    initialize: function (a) {
        OpenLayers.Format.XML.prototype.initialize.apply(this, [a])
    },
    read: function (a) {
        "string" == typeof a && (a = OpenLayers.Format.XML.prototype.read.apply(this, [a]));
        a && 9 == a.nodeType && (a = a.documentElement);
        var b = {};
        this.readNode(a, b);
        return b
    },
    readers: {
        wps: {
            Capabilities: function (a, b) {
                this.readChildNodes(a, b)
            }, ProcessOfferings: function (a, b) {
                b.processOfferings = {};
                this.readChildNodes(a, b.processOfferings)
            }, Process: function (a, b) {
                var c = {processVersion: this.getAttributeNS(a, this.namespaces.wps, "processVersion")};
                this.readChildNodes(a, c);
                b[c.identifier] = c
            }, Languages: function (a, b) {
                b.languages = [];
                this.readChildNodes(a, b.languages)
            }, Default: function (a, b) {
                var c = {isDefault: !0};
                this.readChildNodes(a, c);
                b.push(c)
            },
            Supported: function (a, b) {
                var c = {};
                this.readChildNodes(a, c);
                b.push(c)
            }
        }, ows: OpenLayers.Format.OWSCommon.v1_1_0.prototype.readers.ows
    },
    CLASS_NAME: "OpenLayers.Format.WPSCapabilities.v1_0_0"
});
OpenLayers.Format.WPSDescribeProcess = OpenLayers.Class(OpenLayers.Format.XML, {
    VERSION: "1.0.0",
    namespaces: {
        wps: "http://www.opengis.net/wps/1.0.0",
        ows: "http://www.opengis.net/ows/1.1",
        xsi: "http://www.w3.org/2001/XMLSchema-instance"
    },
    schemaLocation: "http://www.opengis.net/wps/1.0.0 http://schemas.opengis.net/wps/1.0.0/wpsAll.xsd",
    defaultPrefix: "wps",
    regExes: {trimSpace: /^\s*|\s*$/g, removeSpace: /\s*/g, splitSpace: /\s+/, trimComma: /\s*,\s*/g},
    read: function (a) {
        "string" == typeof a && (a = OpenLayers.Format.XML.prototype.read.apply(this,
            [a]));
        a && 9 == a.nodeType && (a = a.documentElement);
        var b = {};
        this.readNode(a, b);
        return b
    },
    readers: {
        wps: {
            ProcessDescriptions: function (a, b) {
                b.processDescriptions = {};
                this.readChildNodes(a, b.processDescriptions)
            }, ProcessDescription: function (a, b) {
                var c = {
                    processVersion: this.getAttributeNS(a, this.namespaces.wps, "processVersion"),
                    statusSupported: "true" === a.getAttribute("statusSupported"),
                    storeSupported: "true" === a.getAttribute("storeSupported")
                };
                this.readChildNodes(a, c);
                b[c.identifier] = c
            }, DataInputs: function (a,
                                     b) {
                b.dataInputs = [];
                this.readChildNodes(a, b.dataInputs)
            }, ProcessOutputs: function (a, b) {
                b.processOutputs = [];
                this.readChildNodes(a, b.processOutputs)
            }, Output: function (a, b) {
                var c = {};
                this.readChildNodes(a, c);
                b.push(c)
            }, ComplexOutput: function (a, b) {
                b.complexOutput = {};
                this.readChildNodes(a, b.complexOutput)
            }, Input: function (a, b) {
                var c = {
                    maxOccurs: parseInt(a.getAttribute("maxOccurs")),
                    minOccurs: parseInt(a.getAttribute("minOccurs"))
                };
                this.readChildNodes(a, c);
                b.push(c)
            }, BoundingBoxData: function (a, b) {
                b.boundingBoxData =
                {};
                this.readChildNodes(a, b.boundingBoxData)
            }, CRS: function (a, b) {
                b.CRSs || (b.CRSs = {});
                b.CRSs[this.getChildValue(a)] = !0
            }, LiteralData: function (a, b) {
                b.literalData = {};
                this.readChildNodes(a, b.literalData)
            }, ComplexData: function (a, b) {
                b.complexData = {};
                this.readChildNodes(a, b.complexData)
            }, Default: function (a, b) {
                b["default"] = {};
                this.readChildNodes(a, b["default"])
            }, Supported: function (a, b) {
                b.supported = {};
                this.readChildNodes(a, b.supported)
            }, Format: function (a, b) {
                var c = {};
                this.readChildNodes(a, c);
                b.formats || (b.formats =
                {});
                b.formats[c.mimeType] = !0
            }, MimeType: function (a, b) {
                b.mimeType = this.getChildValue(a)
            }
        }, ows: OpenLayers.Format.OWSCommon.v1_1_0.prototype.readers.ows
    },
    CLASS_NAME: "OpenLayers.Format.WPSDescribeProcess"
});
OpenLayers.Format.WPSExecute = OpenLayers.Class(OpenLayers.Format.XML, {
    namespaces: {
        ows: "http://www.opengis.net/ows/1.1",
        gml: "http://www.opengis.net/gml",
        wps: "http://www.opengis.net/wps/1.0.0",
        wfs: "http://www.opengis.net/wfs",
        ogc: "http://www.opengis.net/ogc",
        wcs: "http://www.opengis.net/wcs",
        xlink: "http://www.w3.org/1999/xlink",
        xsi: "http://www.w3.org/2001/XMLSchema-instance"
    },
    regExes: {trimSpace: /^\s*|\s*$/g, removeSpace: /\s*/g, splitSpace: /\s+/, trimComma: /\s*,\s*/g},
    VERSION: "1.0.0",
    schemaLocation: "http://www.opengis.net/wps/1.0.0 http://schemas.opengis.net/wps/1.0.0/wpsAll.xsd",
    schemaLocationAttr: function () {
    },
    write: function (a) {
        var b;
        window.ActiveXObject ? this.xmldom = b = new ActiveXObject("Microsoft.XMLDOM") : b = document.implementation.createDocument("", "", null);
        a = this.writeNode("wps:Execute", a, b);
        this.setAttributeNS(a, this.namespaces.xsi, "xsi:schemaLocation", this.schemaLocation);
        return OpenLayers.Format.XML.prototype.write.apply(this, [a])
    },
    writers: {
        wps: {
            Execute: function (a) {
                var b = this.createElementNSPlus("wps:Execute", {attributes: {version: this.VERSION, service: "WPS"}});
                this.writeNode("ows:Identifier",
                    a.identifier, b);
                this.writeNode("wps:DataInputs", a.dataInputs, b);
                this.writeNode("wps:ResponseForm", a.responseForm, b);
                return b
            }, ResponseForm: function (a) {
                var b = this.createElementNSPlus("wps:ResponseForm", {});
                a.rawDataOutput && this.writeNode("wps:RawDataOutput", a.rawDataOutput, b);
                a.responseDocument && this.writeNode("wps:ResponseDocument", a.responseDocument, b);
                return b
            }, ResponseDocument: function (a) {
                var b = this.createElementNSPlus("wps:ResponseDocument", {
                    attributes: {
                        storeExecuteResponse: a.storeExecuteResponse,
                        lineage: a.lineage, status: a.status
                    }
                });
                a.output && this.writeNode("wps:Output", a.output, b);
                return b
            }, Output: function (a) {
                var b = this.createElementNSPlus("wps:Output", {attributes: {asReference: a.asReference}});
                this.writeNode("ows:Identifier", a.identifier, b);
                this.writeNode("ows:Title", a.title, b);
                this.writeNode("ows:Abstract", a["abstract"], b);
                return b
            }, RawDataOutput: function (a) {
                var b = this.createElementNSPlus("wps:RawDataOutput", {attributes: {mimeType: a.mimeType}});
                this.writeNode("ows:Identifier", a.identifier,
                    b);
                return b
            }, DataInputs: function (a) {
                for (var b = this.createElementNSPlus("wps:DataInputs", {}), c = 0, d = a.length; c < d; ++c)this.writeNode("wps:Input", a[c], b);
                return b
            }, Input: function (a) {
                var b = this.createElementNSPlus("wps:Input", {});
                this.writeNode("ows:Identifier", a.identifier, b);
                a.title && this.writeNode("ows:Title", a.title, b);
                a.data && this.writeNode("wps:Data", a.data, b);
                a.reference && this.writeNode("wps:Reference", a.reference, b);
                return b
            }, Data: function (a) {
                var b = this.createElementNSPlus("wps:Data", {});
                a.literalData ?
                    this.writeNode("wps:LiteralData", a.literalData, b) : a.complexData && this.writeNode("wps:ComplexData", a.complexData, b);
                return b
            }, LiteralData: function (a) {
                return this.createElementNSPlus("wps:LiteralData", {attributes: {uom: a.uom}, value: a.value})
            }, ComplexData: function (a) {
                var b = this.createElementNSPlus("wps:ComplexData", {
                    attributes: {
                        mimeType: a.mimeType,
                        encoding: a.encoding,
                        schema: a.schema
                    }
                }), c = a.value;
                "string" === typeof c ? b.appendChild(this.getXMLDoc().createCDATASection(a.value)) : b.appendChild(c);
                return b
            },
            Reference: function (a) {
                var b = this.createElementNSPlus("wps:Reference", {
                    attributes: {
                        mimeType: a.mimeType,
                        "xlink:href": a.href,
                        method: a.method,
                        encoding: a.encoding,
                        schema: a.schema
                    }
                });
                a.body && this.writeNode("wps:Body", a.body, b);
                return b
            }, Body: function (a) {
                var b = this.createElementNSPlus("wps:Body", {});
                a.wcs ? this.writeNode("wcs:GetCoverage", a.wcs, b) : a.wfs ? (this.featureType = a.wfs.featureType, this.version = a.wfs.version, this.writeNode("wfs:GetFeature", a.wfs, b)) : this.writeNode("wps:Execute", a, b);
                return b
            }
        },
        wcs: OpenLayers.Format.WCSGetCoverage.prototype.writers.wcs,
        wfs: OpenLayers.Format.WFST.v1_1_0.prototype.writers.wfs,
        ogc: OpenLayers.Format.Filter.v1_1_0.prototype.writers.ogc,
        ows: OpenLayers.Format.OWSCommon.v1_1_0.prototype.writers.ows
    },
    CLASS_NAME: "OpenLayers.Format.WPSExecute"
});
OpenLayers.Format.XLS = OpenLayers.Class(OpenLayers.Format.XML.VersionedOGC, {
    defaultVersion: "1.1.0",
    stringifyOutput: !0,
    CLASS_NAME: "OpenLayers.Format.XLS"
});
OpenLayers.Format.XLS.v1 = OpenLayers.Class(OpenLayers.Format.XML, {
    namespaces: {
        xls: "http://www.opengis.net/xls",
        gml: "http://www.opengis.net/gml",
        xsi: "http://www.w3.org/2001/XMLSchema-instance"
    },
    regExes: {trimSpace: /^\s*|\s*$/g, removeSpace: /\s*/g, splitSpace: /\s+/, trimComma: /\s*,\s*/g},
    xy: !0,
    defaultPrefix: "xls",
    schemaLocation: null,
    read: function (a, b) {
        OpenLayers.Util.applyDefaults(b, this.options);
        var c = {};
        this.readChildNodes(a, c);
        return c
    },
    readers: {
        xls: {
            XLS: function (a, b) {
                b.version = a.getAttribute("version");
                this.readChildNodes(a, b)
            }, Response: function (a, b) {
                this.readChildNodes(a, b)
            }, GeocodeResponse: function (a, b) {
                b.responseLists = [];
                this.readChildNodes(a, b)
            }, GeocodeResponseList: function (a, b) {
                var c = {
                    features: [],
                    numberOfGeocodedAddresses: parseInt(a.getAttribute("numberOfGeocodedAddresses"))
                };
                b.responseLists.push(c);
                this.readChildNodes(a, c)
            }, GeocodedAddress: function (a, b) {
                var c = new OpenLayers.Feature.Vector;
                b.features.push(c);
                this.readChildNodes(a, c);
                c.geometry = c.components[0]
            }, GeocodeMatchCode: function (a, b) {
                b.attributes.matchCode =
                {accuracy: parseFloat(a.getAttribute("accuracy")), matchType: a.getAttribute("matchType")}
            }, Address: function (a, b) {
                var c = {
                    countryCode: a.getAttribute("countryCode"),
                    addressee: a.getAttribute("addressee"),
                    street: [],
                    place: []
                };
                b.attributes.address = c;
                this.readChildNodes(a, c)
            }, freeFormAddress: function (a, b) {
                b.freeFormAddress = this.getChildValue(a)
            }, StreetAddress: function (a, b) {
                this.readChildNodes(a, b)
            }, Building: function (a, b) {
                b.building = {
                    number: a.getAttribute("number"), subdivision: a.getAttribute("subdivision"),
                    buildingName: a.getAttribute("buildingName")
                }
            }, Street: function (a, b) {
                b.street.push(this.getChildValue(a))
            }, Place: function (a, b) {
                b.place[a.getAttribute("type")] = this.getChildValue(a)
            }, PostalCode: function (a, b) {
                b.postalCode = this.getChildValue(a)
            }
        }, gml: OpenLayers.Format.GML.v3.prototype.readers.gml
    },
    write: function (a) {
        return this.writers.xls.XLS.apply(this, [a])
    },
    writers: {
        xls: {
            XLS: function (a) {
                var b = this.createElementNSPlus("xls:XLS", {
                    attributes: {
                        version: this.VERSION,
                        "xsi:schemaLocation": this.schemaLocation
                    }
                });
                this.writeNode("RequestHeader", a.header, b);
                this.writeNode("Request", a, b);
                return b
            }, RequestHeader: function () {
                return this.createElementNSPlus("xls:RequestHeader")
            }, Request: function (a) {
                var b = this.createElementNSPlus("xls:Request", {
                    attributes: {
                        methodName: "GeocodeRequest",
                        requestID: a.requestID || "",
                        version: this.VERSION
                    }
                });
                this.writeNode("GeocodeRequest", a.addresses, b);
                return b
            }, GeocodeRequest: function (a) {
                for (var b = this.createElementNSPlus("xls:GeocodeRequest"), c = 0, d = a.length; c < d; c++)this.writeNode("Address",
                    a[c], b);
                return b
            }, Address: function (a) {
                var b = this.createElementNSPlus("xls:Address", {attributes: {countryCode: a.countryCode}});
                a.freeFormAddress ? this.writeNode("freeFormAddress", a.freeFormAddress, b) : (a.street && this.writeNode("StreetAddress", a, b), a.municipality && this.writeNode("Municipality", a.municipality, b), a.countrySubdivision && this.writeNode("CountrySubdivision", a.countrySubdivision, b), a.postalCode && this.writeNode("PostalCode", a.postalCode, b));
                return b
            }, freeFormAddress: function (a) {
                return this.createElementNSPlus("freeFormAddress",
                    {value: a})
            }, StreetAddress: function (a) {
                var b = this.createElementNSPlus("xls:StreetAddress");
                a.building && this.writeNode(b, "Building", a.building);
                a = a.street;
                OpenLayers.Util.isArray(a) || (a = [a]);
                for (var c = 0, d = a.length; c < d; c++)this.writeNode("Street", a[c], b);
                return b
            }, Building: function (a) {
                return this.createElementNSPlus("xls:Building", {
                    attributes: {
                        number: a.number,
                        subdivision: a.subdivision,
                        buildingName: a.buildingName
                    }
                })
            }, Street: function (a) {
                return this.createElementNSPlus("xls:Street", {value: a})
            }, Municipality: function (a) {
                return this.createElementNSPlus("xls:Place",
                    {attributes: {type: "Municipality"}, value: a})
            }, CountrySubdivision: function (a) {
                return this.createElementNSPlus("xls:Place", {attributes: {type: "CountrySubdivision"}, value: a})
            }, PostalCode: function (a) {
                return this.createElementNSPlus("xls:PostalCode", {value: a})
            }
        }
    },
    CLASS_NAME: "OpenLayers.Format.XLS.v1"
});
OpenLayers.Format.XLS.v1_1_0 = OpenLayers.Class(OpenLayers.Format.XLS.v1, {
    VERSION: "1.1",
    schemaLocation: "http://www.opengis.net/xls http://schemas.opengis.net/ols/1.1.0/LocationUtilityService.xsd",
    CLASS_NAME: "OpenLayers.Format.XLS.v1_1_0"
});
OpenLayers.Format.XLS.v1_1 = OpenLayers.Format.XLS.v1_1_0;
OpenLayers.Format.OGCExceptionReport = OpenLayers.Class(OpenLayers.Format.XML, {
    namespaces: {ogc: "http://www.opengis.net/ogc"},
    regExes: {trimSpace: /^\s*|\s*$/g, removeSpace: /\s*/g, splitSpace: /\s+/, trimComma: /\s*,\s*/g},
    defaultPrefix: "ogc",
    read: function (a) {
        "string" == typeof a && (a = OpenLayers.Format.XML.prototype.read.apply(this, [a]));
        var b = {exceptionReport: null};
        a.documentElement && (this.readChildNodes(a, b), null === b.exceptionReport && (b = (new OpenLayers.Format.OWSCommon).read(a)));
        return b
    },
    readers: {
        ogc: {
            ServiceExceptionReport: function (a,
                                              b) {
                b.exceptionReport = {exceptions: []};
                this.readChildNodes(a, b.exceptionReport)
            }, ServiceException: function (a, b) {
                var c = {code: a.getAttribute("code"), locator: a.getAttribute("locator"), text: this.getChildValue(a)};
                b.exceptions.push(c)
            }
        }
    },
    CLASS_NAME: "OpenLayers.Format.OGCExceptionReport"
});
OpenLayers.Control.GetFeature = OpenLayers.Class(OpenLayers.Control, {
    protocol: null,
    multipleKey: null,
    toggleKey: null,
    modifiers: null,
    multiple: !1,
    click: !0,
    single: !0,
    clickout: !0,
    toggle: !1,
    clickTolerance: 5,
    hover: !1,
    box: !1,
    maxFeatures: 10,
    features: null,
    hoverFeature: null,
    handlerOptions: null,
    handlers: null,
    hoverResponse: null,
    filterType: OpenLayers.Filter.Spatial.BBOX,
    initialize: function (a) {
        a.handlerOptions = a.handlerOptions || {};
        OpenLayers.Control.prototype.initialize.apply(this, [a]);
        this.features = {};
        this.handlers =
        {};
        this.click && (this.handlers.click = new OpenLayers.Handler.Click(this, {click: this.selectClick}, this.handlerOptions.click || {}));
        this.box && (this.handlers.box = new OpenLayers.Handler.Box(this, {done: this.selectBox}, OpenLayers.Util.extend(this.handlerOptions.box, {boxDivClassName: "olHandlerBoxSelectFeature"})));
        this.hover && (this.handlers.hover = new OpenLayers.Handler.Hover(this, {
            move: this.cancelHover,
            pause: this.selectHover
        }, OpenLayers.Util.extend(this.handlerOptions.hover, {delay: 250, pixelTolerance: 2})))
    },
    activate: function () {
        if (!this.active)for (var a in this.handlers)this.handlers[a].activate();
        return OpenLayers.Control.prototype.activate.apply(this, arguments)
    },
    deactivate: function () {
        if (this.active)for (var a in this.handlers)this.handlers[a].deactivate();
        return OpenLayers.Control.prototype.deactivate.apply(this, arguments)
    },
    selectClick: function (a) {
        var b = this.pixelToBounds(a.xy);
        this.setModifiers(a);
        this.request(b, {single: this.single})
    },
    selectBox: function (a) {
        var b;
        if (a instanceof OpenLayers.Bounds)b =
            this.map.getLonLatFromPixel({x: a.left, y: a.bottom}), a = this.map.getLonLatFromPixel({
            x: a.right,
            y: a.top
        }), b = new OpenLayers.Bounds(b.lon, b.lat, a.lon, a.lat); else {
            if (this.click)return;
            b = this.pixelToBounds(a)
        }
        this.setModifiers(this.handlers.box.dragHandler.evt);
        this.request(b)
    },
    selectHover: function (a) {
        this.request(this.pixelToBounds(a.xy), {single: !0, hover: !0})
    },
    cancelHover: function () {
        this.hoverResponse && (this.protocol.abort(this.hoverResponse), this.hoverResponse = null, OpenLayers.Element.removeClass(this.map.viewPortDiv,
            "olCursorWait"))
    },
    request: function (a, b) {
        var b = b || {}, c = new OpenLayers.Filter.Spatial({type: this.filterType, value: a});
        OpenLayers.Element.addClass(this.map.viewPortDiv, "olCursorWait");
        c = this.protocol.read({
            maxFeatures: !0 == b.single ? this.maxFeatures : void 0, filter: c, callback: function (c) {
                c.success() && (c.features.length ? !0 == b.single ? this.selectBestFeature(c.features, a.getCenterLonLat(), b) : this.select(c.features) : b.hover ? this.hoverSelect() : (this.events.triggerEvent("clickout"), this.clickout && this.unselectAll()));
                OpenLayers.Element.removeClass(this.map.viewPortDiv, "olCursorWait")
            }, scope: this
        });
        !0 == b.hover && (this.hoverResponse = c)
    },
    selectBestFeature: function (a, b, c) {
        c = c || {};
        if (a.length) {
            for (var b = new OpenLayers.Geometry.Point(b.lon, b.lat), d, e, f, g = Number.MAX_VALUE, h = 0; h < a.length && !(d = a[h], d.geometry && (f = b.distanceTo(d.geometry, {edge: !1}), f < g && (g = f, e = d, 0 == g))); ++h);
            !0 == c.hover ? this.hoverSelect(e) : this.select(e || a)
        }
    },
    setModifiers: function (a) {
        this.modifiers = {
            multiple: this.multiple || this.multipleKey && a[this.multipleKey],
            toggle: this.toggle || this.toggleKey && a[this.toggleKey]
        }
    },
    select: function (a) {
        !this.modifiers.multiple && !this.modifiers.toggle && this.unselectAll();
        OpenLayers.Util.isArray(a) || (a = [a]);
        var b = this.events.triggerEvent("beforefeaturesselected", {features: a});
        if (!1 !== b) {
            for (var c = [], d, e = 0, f = a.length; e < f; ++e)d = a[e], this.features[d.fid || d.id] ? this.modifiers.toggle && this.unselect(this.features[d.fid || d.id]) : (b = this.events.triggerEvent("beforefeatureselected", {feature: d}), !1 !== b && (this.features[d.fid || d.id] = d,
                c.push(d), this.events.triggerEvent("featureselected", {feature: d})));
            this.events.triggerEvent("featuresselected", {features: c})
        }
    },
    hoverSelect: function (a) {
        var b = a ? a.fid || a.id : null, c = this.hoverFeature ? this.hoverFeature.fid || this.hoverFeature.id : null;
        c && c != b && (this.events.triggerEvent("outfeature", {feature: this.hoverFeature}), this.hoverFeature = null);
        b && b != c && (this.events.triggerEvent("hoverfeature", {feature: a}), this.hoverFeature = a)
    },
    unselect: function (a) {
        delete this.features[a.fid || a.id];
        this.events.triggerEvent("featureunselected",
            {feature: a})
    },
    unselectAll: function () {
        for (var a in this.features)this.unselect(this.features[a])
    },
    setMap: function (a) {
        for (var b in this.handlers)this.handlers[b].setMap(a);
        OpenLayers.Control.prototype.setMap.apply(this, arguments)
    },
    pixelToBounds: function (a) {
        var b = a.add(-this.clickTolerance / 2, this.clickTolerance / 2), a = a.add(this.clickTolerance / 2, -this.clickTolerance / 2), b = this.map.getLonLatFromPixel(b), a = this.map.getLonLatFromPixel(a);
        return new OpenLayers.Bounds(b.lon, b.lat, a.lon, a.lat)
    },
    CLASS_NAME: "OpenLayers.Control.GetFeature"
});
OpenLayers.Control.NavToolbar = OpenLayers.Class(OpenLayers.Control.Panel, {
    initialize: function (a) {
        OpenLayers.Control.Panel.prototype.initialize.apply(this, [a]);
        this.addControls([new OpenLayers.Control.Navigation, new OpenLayers.Control.ZoomBox])
    }, draw: function () {
        var a = OpenLayers.Control.Panel.prototype.draw.apply(this, arguments);
        null === this.defaultControl && (this.defaultControl = this.controls[0]);
        return a
    }, CLASS_NAME: "OpenLayers.Control.NavToolbar"
});
OpenLayers.Control.PanPanel = OpenLayers.Class(OpenLayers.Control.Panel, {
    slideFactor: 50, slideRatio: null, initialize: function (a) {
        OpenLayers.Control.Panel.prototype.initialize.apply(this, [a]);
        a = {slideFactor: this.slideFactor, slideRatio: this.slideRatio};
        this.addControls([new OpenLayers.Control.Pan(OpenLayers.Control.Pan.NORTH, a), new OpenLayers.Control.Pan(OpenLayers.Control.Pan.SOUTH, a), new OpenLayers.Control.Pan(OpenLayers.Control.Pan.EAST, a), new OpenLayers.Control.Pan(OpenLayers.Control.Pan.WEST, a)])
    },
    CLASS_NAME: "OpenLayers.Control.PanPanel"
});
OpenLayers.Control.Pan = OpenLayers.Class(OpenLayers.Control, {
    slideFactor: 50,
    slideRatio: null,
    direction: null,
    type: OpenLayers.Control.TYPE_BUTTON,
    initialize: function (a, b) {
        this.direction = a;
        this.CLASS_NAME += this.direction;
        OpenLayers.Control.prototype.initialize.apply(this, [b])
    },
    trigger: function () {
        var a = OpenLayers.Function.bind(function (a) {
            return this.slideRatio ? this.map.getSize()[a] * this.slideRatio : this.slideFactor
        }, this);
        switch (this.direction) {
            case OpenLayers.Control.Pan.NORTH:
                this.map.pan(0, -a("h"));
                break;
            case OpenLayers.Control.Pan.SOUTH:
                this.map.pan(0, a("h"));
                break;
            case OpenLayers.Control.Pan.WEST:
                this.map.pan(-a("w"), 0);
                break;
            case OpenLayers.Control.Pan.EAST:
                this.map.pan(a("w"), 0)
        }
    },
    CLASS_NAME: "OpenLayers.Control.Pan"
});
OpenLayers.Control.Pan.NORTH = "North";
OpenLayers.Control.Pan.SOUTH = "South";
OpenLayers.Control.Pan.EAST = "East";
OpenLayers.Control.Pan.WEST = "West";
OpenLayers.Control.ZoomIn = OpenLayers.Class(OpenLayers.Control, {
    type: OpenLayers.Control.TYPE_BUTTON,
    trigger: function () {
        this.map.zoomIn()
    },
    CLASS_NAME: "OpenLayers.Control.ZoomIn"
});
OpenLayers.Control.ZoomOut = OpenLayers.Class(OpenLayers.Control, {
    type: OpenLayers.Control.TYPE_BUTTON,
    trigger: function () {
        this.map.zoomOut()
    },
    CLASS_NAME: "OpenLayers.Control.ZoomOut"
});
OpenLayers.Control.ZoomPanel = OpenLayers.Class(OpenLayers.Control.Panel, {
    initialize: function (a) {
        OpenLayers.Control.Panel.prototype.initialize.apply(this, [a]);
        this.addControls([new OpenLayers.Control.ZoomIn, new OpenLayers.Control.ZoomToMaxExtent, new OpenLayers.Control.ZoomOut])
    }, CLASS_NAME: "OpenLayers.Control.ZoomPanel"
});
OpenLayers.Control.EditingToolbar = OpenLayers.Class(OpenLayers.Control.Panel, {
    citeCompliant: !1, initialize: function (a, b) {
        OpenLayers.Control.Panel.prototype.initialize.apply(this, [b]);
        this.addControls([new OpenLayers.Control.Navigation]);
        this.addControls([new OpenLayers.Control.DrawFeature(a, OpenLayers.Handler.Point, {
            displayClass: "olControlDrawFeaturePoint",
            handlerOptions: {citeCompliant: this.citeCompliant}
        }), new OpenLayers.Control.DrawFeature(a, OpenLayers.Handler.Path, {
            displayClass: "olControlDrawFeaturePath",
            handlerOptions: {citeCompliant: this.citeCompliant}
        }), new OpenLayers.Control.DrawFeature(a, OpenLayers.Handler.Polygon, {
            displayClass: "olControlDrawFeaturePolygon",
            handlerOptions: {citeCompliant: this.citeCompliant}
        })])
    }, draw: function () {
        var a = OpenLayers.Control.Panel.prototype.draw.apply(this, arguments);
        null === this.defaultControl && (this.defaultControl = this.controls[0]);
        return a
    }, CLASS_NAME: "OpenLayers.Control.EditingToolbar"
});
OpenLayers.Control.Geolocate = OpenLayers.Class(OpenLayers.Control, {
    geolocation: navigator.geolocation, bind: !0, watch: !1, geolocationOptions: null, destroy: function () {
        this.deactivate();
        OpenLayers.Control.prototype.destroy.apply(this, arguments)
    }, activate: function () {
        return !this.geolocation ? (this.events.triggerEvent("locationuncapable"), !1) : OpenLayers.Control.prototype.activate.apply(this, arguments) ? (this.watch ? this.watchId = this.geolocation.watchPosition(OpenLayers.Function.bind(this.geolocate, this), OpenLayers.Function.bind(this.failure,
            this), this.geolocationOptions) : this.getCurrentLocation(), !0) : !1
    }, deactivate: function () {
        this.active && null !== this.watchId && this.geolocation.clearWatch(this.watchId);
        return OpenLayers.Control.prototype.deactivate.apply(this, arguments)
    }, geolocate: function (a) {
        var b = (new OpenLayers.LonLat(a.coords.longitude, a.coords.latitude)).transform(new OpenLayers.Projection("EPSG:4326"), this.map.getProjectionObject());
        this.bind && this.map.setCenter(b);
        this.events.triggerEvent("locationupdated", {
            position: a, point: new OpenLayers.Geometry.Point(b.lon,
                b.lat)
        })
    }, getCurrentLocation: function () {
        if (!this.active || this.watch)return !1;
        this.geolocation.getCurrentPosition(OpenLayers.Function.bind(this.geolocate, this), OpenLayers.Function.bind(this.failure, this), this.geolocationOptions);
        return !0
    }, failure: function (a) {
        this.events.triggerEvent("locationfailed", {error: a})
    }, CLASS_NAME: "OpenLayers.Control.Geolocate"
});
OpenLayers.Symbolizer = OpenLayers.Class({
    zIndex: 0, initialize: function (a) {
        OpenLayers.Util.extend(this, a)
    }, clone: function () {
        return new (eval(this.CLASS_NAME))(OpenLayers.Util.extend({}, this))
    }, CLASS_NAME: "OpenLayers.Symbolizer"
});
OpenLayers.Symbolizer.Point = OpenLayers.Class(OpenLayers.Symbolizer, {
    initialize: function (a) {
        OpenLayers.Symbolizer.prototype.initialize.apply(this, arguments)
    }, CLASS_NAME: "OpenLayers.Symbolizer.Point"
});
OpenLayers.Symbolizer.Line = OpenLayers.Class(OpenLayers.Symbolizer, {
    initialize: function (a) {
        OpenLayers.Symbolizer.prototype.initialize.apply(this, arguments)
    }, CLASS_NAME: "OpenLayers.Symbolizer.Line"
});
OpenLayers.Symbolizer.Polygon = OpenLayers.Class(OpenLayers.Symbolizer, {
    initialize: function (a) {
        OpenLayers.Symbolizer.prototype.initialize.apply(this, arguments)
    }, CLASS_NAME: "OpenLayers.Symbolizer.Polygon"
});
OpenLayers.Symbolizer.Text = OpenLayers.Class(OpenLayers.Symbolizer, {
    initialize: function (a) {
        OpenLayers.Symbolizer.prototype.initialize.apply(this, arguments)
    }, CLASS_NAME: "OpenLayers.Symbolizer.Text"
});
OpenLayers.Symbolizer.Raster = OpenLayers.Class(OpenLayers.Symbolizer, {
    initialize: function (a) {
        OpenLayers.Symbolizer.prototype.initialize.apply(this, arguments)
    }, CLASS_NAME: "OpenLayers.Symbolizer.Raster"
});
OpenLayers.Lang = {
    code: null, defaultCode: "en", getCode: function () {
        OpenLayers.Lang.code || OpenLayers.Lang.setCode();
        return OpenLayers.Lang.code
    }, setCode: function (a) {
        var b;
        a || (a = "msie" == OpenLayers.BROWSER_NAME ? navigator.userLanguage : navigator.language);
        a = a.split("-");
        a[0] = a[0].toLowerCase();
        "object" == typeof OpenLayers.Lang[a[0]] && (b = a[0]);
        if (a[1]) {
            var c = a[0] + "-" + a[1].toUpperCase();
            "object" == typeof OpenLayers.Lang[c] && (b = c)
        }
        b || (OpenLayers.Console.warn("Failed to find OpenLayers.Lang." + a.join("-") + " dictionary, falling back to default language"),
            b = OpenLayers.Lang.defaultCode);
        OpenLayers.Lang.code = b
    }, translate: function (a, b) {
        var c = OpenLayers.Lang[OpenLayers.Lang.getCode()];
        (c = c && c[a]) || (c = a);
        b && (c = OpenLayers.String.format(c, b));
        return c
    }
};
OpenLayers.i18n = OpenLayers.Lang.translate;
OpenLayers.Lang.en = {
    unhandledRequest: "Unhandled request return ${statusText}",
    Permalink: "Permalink",
    Overlays: "Overlays",
    "Base Layer": "Base Layer",
    noFID: "Can't update a feature for which there is no FID.",
    browserNotSupported: "Your browser does not support vector rendering. Currently supported renderers are:\n${renderers}",
    minZoomLevelError: "The minZoomLevel property is only intended for use with the FixedZoomLevels-descendent layers. That this wfs layer checks for minZoomLevel is a relic of thepast. We cannot, however, remove it without possibly breaking OL based applications that may depend on it. Therefore we are deprecating it -- the minZoomLevel check below will be removed at 3.0. Please instead use min/max resolution setting as described here: http://trac.openlayers.org/wiki/SettingZoomLevels",
    commitSuccess: "WFS Transaction: SUCCESS ${response}",
    commitFailed: "WFS Transaction: FAILED ${response}",
    googleWarning: "The Google Layer was unable to load correctly.<br><br>To get rid of this message, select a new BaseLayer in the layer switcher in the upper-right corner.<br><br>Most likely, this is because the Google Maps library script was either not included, or does not contain the correct API key for your site.<br><br>Developers: For help getting this working correctly, <a href='http://trac.openlayers.org/wiki/Google' target='_blank'>click here</a>",
    getLayerWarning: "The ${layerType} Layer was unable to load correctly.<br><br>To get rid of this message, select a new BaseLayer in the layer switcher in the upper-right corner.<br><br>Most likely, this is because the ${layerLib} library script was not correctly included.<br><br>Developers: For help getting this working correctly, <a href='http://trac.openlayers.org/wiki/${layerLib}' target='_blank'>click here</a>",
    "Scale = 1 : ${scaleDenom}": "Scale = 1 : ${scaleDenom}",
    W: "W",
    E: "E",
    N: "N",
    S: "S",
    Graticule: "Graticule",
    reprojectDeprecated: "You are using the 'reproject' option on the ${layerName} layer. This option is deprecated: its use was designed to support displaying data over commercial basemaps, but that functionality should now be achieved by using Spherical Mercator support. More information is available from http://trac.openlayers.org/wiki/SphericalMercator.",
    methodDeprecated: "This method has been deprecated and will be removed in 3.0. Please use ${newMethod} instead.",
    proxyNeeded: "You probably need to set OpenLayers.ProxyHost to access ${url}.See http://trac.osgeo.org/openlayers/wiki/FrequentlyAskedQuestions#ProxyHost",
    end: ""
};
OpenLayers.Spherical = OpenLayers.Spherical || {};
OpenLayers.Spherical.DEFAULT_RADIUS = 6378137;
OpenLayers.Spherical.computeDistanceBetween = function (a, b, c) {
    var c = c || OpenLayers.Spherical.DEFAULT_RADIUS, d = Math.sin(Math.PI * (b.lon - a.lon) / 360), e = Math.sin(Math.PI * (b.lat - a.lat) / 360), a = e * e + d * d * Math.cos(Math.PI * a.lat / 180) * Math.cos(Math.PI * b.lat / 180);
    return 2 * c * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a))
};
OpenLayers.Spherical.computeHeading = function (a, b) {
    var c = Math.sin(Math.PI * (a.lon - b.lon) / 180) * Math.cos(Math.PI * b.lat / 180), d = Math.cos(Math.PI * a.lat / 180) * Math.sin(Math.PI * b.lat / 180) - Math.sin(Math.PI * a.lat / 180) * Math.cos(Math.PI * b.lat / 180) * Math.cos(Math.PI * (a.lon - b.lon) / 180);
    return 180 * Math.atan2(c, d) / Math.PI
};
var loadVTMapAPI = function () {
    "undefined" == typeof viettel && (viettel = {});
    viettel.VTObjType = {};
    viettel.VTObjType.Map = "Map";
    viettel.VTObjType.Marker = "Marker";
    viettel.VTObjType.Polyline = "Polyline";
    viettel.VTObjType.Polyline = "Polygon";
    viettel.MVCObject = function () {
        var a = new Hashtable, b = new Hashtable;
        this.mvcObj = {};
        this.set = function (d, c) {
            this.mvcObj[d] = c;
            var g = !1;
            null != a.get(d) && a.get(d) != c && (g = !0);
            if (null == c)a.remove(d); else {
                a.put(d, c);
                var h = b.get(d);
                null != h && (h.each = function (a, d) {
                    for (var b = 0; b < d.values().length; b++) {
                        var c = d.values()[b];
                        a.set(c, d)
                    }
                });
                g && viettel.Events.trigger(this, d + "_changed")
            }
        };
        this.get = function (d) {
            return a.get(d)
        };
        this.bindTo = function (a, f, g) {
            var h;
            h = VTObjChecker.isObject(h) ? g : a;
            d(a, f, h) || (a = c(b, a), f = c(a, f), f instanceof
            Hashtable && (f = new HashSet), f.add(h))
        };
        this.unbind = function (a) {
            b.remove(a)
        };
        this.getBindPropers = function () {
            return b
        };
        var c = function (a, d) {
            var b = a.get(d);
            null == b && (b = new Hashtable, a.put(d, b));
            return b
        }, d = function (a, d, b) {
            d = d.getBindPropers().get(b);
            return d.containsKey(this) && d.get(this).contains(a) ? !0 : !1
        }
    };
    viettel.LatLng = function (a, b) {
        var c = a, d = b;
        this.lat = function () {
            return c
        };
        this.lng = function () {
            return d
        };
        this.clone = function () {
            return new viettel.LatLng(c, d)
        };
        this.equals = function (a) {
            return c == a.lat() && d == a.lng()
        };
        this.toString = function () {
            return c.toString().substring(0, 10) + "," + d.toString().substring(0, 10)
        };
        this.toUrlValue = function (a) {
            return VTUtil.roundNumber(c, a) + "," + VTUtil.roundNumber(d, a)
        };
        this.getOriginalObj = function () {
            return this
        };
        this.setLat = function (a) {
            c = a
        };
        this.setLng = function (a) {
            d = a
        }
    };
    viettel.LatLngBounds = function (a, b) {
        var c = null, d = null, e = function () {
            null != c && null == d ? d = new viettel.LatLng(c.lat(), c.lng()) : null == c && null != d && (c = new viettel.LatLng(d.lat(), d.lng()));
            if (null != c && null != d) {
                var a = VTUtil.min(c.lat(), d.lat()), b = VTUtil.min(c.lng(), d.lng()), e = VTUtil.max(c.lat(), d.lat()), f = VTUtil.max(c.lng(), d.lng());
                c = new viettel.LatLng(a, b);
                d = new viettel.LatLng(e, f)
            }
        };
        VTObjChecker.isLatLngObj(a) ? c = new viettel.LatLng(a.lat(), a.lng()) : VTObjChecker.isObject(a) && VTUtil.throwVTError("Tham so 'sw' phai la doi tuong kieu viettel.LatLng");
        VTObjChecker.isLatLngObj(b) ? d = new viettel.LatLng(b.lat(), b.lng()) : VTObjChecker.isObject(b) && VTUtil.throwVTError("Tham so 'ne' phai la doi tuong kieu viettel.LatLng");
        e();
        this.clone = function () {
            return new viettel.LatLngBounds(c, d)
        };
        var f = function () {
            (null == c || null == d) && VTUtil.throwVTError("Bien thanh vien cua doi tuong chua duoc thiet lap")
        };
        this.contains = function (a) {
            f();
            return a.lat() >= c.lat() && a.lat() <= d.lat() && a.lng() >= c.lng() && a.lng() <= d.lng() ? !0 : !1
        };
        this.equals = function (a) {
            f();
            return c.equals(a.getSouthWest()) &&
            d.equals(a.getNorthEast()) ? !0 : !1
        };
        this.extendEx = function (a) {
            var b = a.lat(), a = a.lng();
            null == c || null == d ? (c = new viettel.LatLng(b, a), d = new viettel.LatLng(b, a), e()) : (c.lat() > b && c.setLat(b), d.lat() < b && d.setLat(b), c.lng() > a && c.setLng(a), d.lng() < a && d.setLng(a))
        };
        this.extend = function (a) {
            var d = this.clone();
            d.extendEx(a);
            return d
        };
        this.getCenter = function () {
            f();
            return new viettel.LatLng((c.lat() + d.lat()) / 2, (c.lng() + d.lng()) / 2)
        };
        this.getNorthEast = function () {
            return d
        };
        this.getSouthWest = function () {
            return c
        };
        this.intersects =
            function (a) {
                f();
                return c.lat() > a.getNorthEast().lat() || d.lat() < a.getSouthWest().lat() || c.lng() > a.getNorthEast().lng() || d.lng() < a.getSouthWest().lng() ? !1 : !0
            };
        this.isEmpty = function () {
            return null == c || null == d || c.lat() == d.lat() && c.lng() == d.lng() ? !0 : !1
        };
        this.toString = function () {
            return null == c || null == d ? "null,null" : c.toString() + "," + d.toString()
        };
        this.toUrlValue = function (a) {
            return null == c || null == d ? "null,null" : c.toUrlValue(a) + "," + d.toUrlValue(a)
        };
        this.union = function (a) {
            if (null == c && null == d)return new viettel.LatLngBounds(a.getSouthWest(),
                a.getNorthEast());
            if (null != c && null == d) {
                var b = new viettel.LatLngBounds(a.getSouthWest(), a.getNorthEast());
                return b = b.extendEx(c)
            }
            if (null == c && null != d)return b = new viettel.LatLngBounds(a.getSouthWest(), a.getNorthEast()), b = b.extendEx(d);
            var e = VTUtil.min(c.lat(), a.getSouthWest().lat()), f = VTUtil.min(c.lng(), a.getSouthWest().lng()), b = VTUtil.max(d.lat(), a.getNorthEast().lat()), a = VTUtil.max(d.lng(), a.getNorthEast().lng()), e = new viettel.LatLng(e, f), b = new viettel.LatLng(b, a);
            return new viettel.LatLngBounds(e,
                b)
        };
        this.getOriginalObj = function () {
            return this
        }
    };
    viettel.Point = function (a, b) {
        this.x = a;
        this.y = b;
        this.equals = function (a) {
            return this.x == a.x && this.y == a.y ? !0 : !1
        };
        this.toString = function () {
            return this.x.toString() + "," + this.y.toString()
        };
        this.clone = function () {
            return new viettel.Point(this.x, this.y)
        };
        this.getOriginalObj = function () {
            return this
        }
    };
    viettel.Size = function (a, b) {
        this.width = a;
        this.height = b;
        this.equals = function (a) {
            return this.width == a.width && this.height == a.height ? !0 : !1
        };
        this.clone = function () {
            return new viettel.Size(this.width, this.height)
        };
        this.toString = function () {
            return this.width.toString() + "," + this.height.toString()
        };
        this.getOriginalObj = function () {
            return new OpenLayers.Size(a, b)
        }
    };
    VTObjChecker = {
        isBoolean: function (a) {
            return "boolean" == typeof a
        }, isObject: function (a) {
            return a instanceof Object
        }, isArray: function (a) {
            return a instanceof Array
        }, isTwoDimensionalArray: function (a) {
            if (a instanceof Array)return a[0]instanceof Array
        }, isArrayOfMVCArray: function (a) {
            if (a instanceof Array)return this.isArrayOfMVCArray(a[0])
        }, isNumber: function (a) {
            return "number" == typeof a
        }, isString: function (a) {
            return "string" == typeof a
        }, isPointObj: function (a) {
            return a instanceof viettel.Point
        }, isMapObj: function (a) {
            return a instanceof
                viettel.Map
        }, isMapOptionObj: function (a) {
            return a instanceof viettel.MapOptions
        }, isMarkerObj: function (a) {
            return a instanceof viettel.Marker
        }, isMarkerOption: function (a) {
            return a instanceof viettel.MarkerOptions
        }, isMarkerImage: function (a) {
            return a instanceof viettel.MarkerImage
        }, isLatLngObj: function (a) {
            return a instanceof viettel.LatLng
        }, isLatLngBoundObj: function (a) {
            return a instanceof viettel.LatLngBounds
        }, isPolylineObj: function (a) {
            return a instanceof viettel.Polyline
        }, isPolylineOption: function (a) {
            return a instanceof
                viettel.PolylineOptions
        }, isPolygonObj: function (a) {
            return a instanceof viettel.Polygon
        }, isPolygonOption: function (a) {
            return a instanceof viettel.PolygonOptions
        }, isCircleObj: function (a) {
            return a instanceof viettel.Circle
        }, isMVCArray: function (a) {
            return a instanceof viettel.MVCArray
        }, isStringEmpty: function (a) {
            return null == a || void 0 == a || null == a.length || void 0 == a.length || 0 >= a.length
        }, isNode: function (a) {
            return "object" === typeof Node ? a instanceof Node : a && "object" === typeof a && "number" === typeof a.nodeType && "string" === typeof a.nodeName
        }
    };
    VTHexaConversion = {
        d2h: function (a) {
            return a.toString(16)
        }, h2d: function (a) {
            return parseInt(a, 16)
        }, stringToHex: function (a) {
            for (var b = "", c = 0, d = a.length, e; c < d; c += 1)e = a.charCodeAt(c), e ^= 28215, b += VTHexaConversion.d2h(e) + " ";
            return b
        }, hexToString: function (a) {
            for (var a = a.split(" "), b = "", c = 0, d = a.length, e; c < d; c += 1)e = String.fromCharCode(VTHexaConversion.h2d(a[c]) ^ 28215), b += e;
            return b
        }
    };
    VTUtil = {
        throwVTError: function (a) {
            throw Error(a);
        }, isIEBrowser: function () {
            return "msie" == this.BROWSER_NAME
        }, standardizeEvent: function (a) {
            this.isIEBrowser() && this.standardizeIEEvent(a)
        }, standardizeIEEvent: function (a) {
            var b = document.documentElement, c = document.body;
            null == a.pageX && null == a.pageY && (a.pageX = a.clientX + (b && b.scrollLeft || c.scrollLeft || 0), a.pageY = a.clientY + (b && b.scrollTop || c.scrollTop || 0));
            1 == a.button ? a.which = 1 : 2 == a.button ? a.which = 3 : 4 == a.button && (a.which = 2)
        }, getBrowserName: function () {
            var a = "",
                b = navigator.userAgent.toLowerCase();
            -1 != b.indexOf("opera") ? a = "opera" : -1 != b.indexOf("msie") ? a = "msie" : -1 != b.indexOf("safari") ? a = "safari" : -1 != b.indexOf("mozilla") && (a = -1 != b.indexOf("firefox") ? "firefox" : "mozilla");
            return a
        }, getObjectFromID: function (a) {
            var b = null;
            document.layers ? b = document.layers[a] : document.all ? b = document.all[a] : document.getElementById && (b = document.getElementById(a));
            return b
        }, setDivContent: function (a, b) {
            VTUtil.isObject(a) && (a.innerHTML = b)
        }, min: function (a, b) {
            return a > b ? b : a
        }, max: function (a,
                          b) {
            return a > b ? a : b
        }, replaceAll: function (a, b, c) {
            for (var d = a.indexOf(b); -1 != d;)a = a.replace(b, c), d = a.indexOf(b);
            return a
        }, removeVnAccent: function (a) {
            for (var b = 0; 181 > b; b++)a = VTUtil.replaceAll(a, "\u0105\u00e0\u00e1\u1ea3\u00e3\u1ea1\u00e4\u00e5\u0101\u0104\u00c0\u00c1\u1ea2\u00c3\u1ea0\u00c4\u00c5\u0100\u00e2\u1ea7\u1ea5\u1ea9\u1eab\u1ead\u00c2\u1ea6\u1ea4\u1ea8\u1eaa\u1eac\u0103\u1eb1\u1eaf\u1eb3\u1eb5\u1eb7\u0102\u1eb0\u1eae\u1eb2\u1eb4\u1eb6\u0119\u00e8\u00e9\u1ebb\u1ebd\u1eb9\u00eb\u0113\u0115\u0117\u011b\u0118\u00c8\u00c9\u1eba\u1ebc\u1eb8\u0112\u0114\u0116\u011a\u00ea\u1ec1\u1ebf\u1ec3\u1ec5\u1ec7\u00ca\u1ec0\u1ebe\u1ec2\u1ec4\u1ec6\u00ec\u00ed\u1ec9\u0129\u1ecb\u00ee\u00ef\u0129\u012b\u012d\u00cc\u00cd\u1ec8\u0128\u1eca\u00ce\u00cf\u0128\u012a\u012c\u00f2\u00f3\u1ecf\u00f5\u1ecd\u00f6\u014d\u014f\u0151\u00d2\u00d3\u1ece\u00d5\u1ecc\u00d6\u014c\u014e\u0150\u00f4\u1ed3\u1ed1\u1ed5\u1ed7\u1ed9\u00d4\u1ed2\u1ed0\u1ed4\u1ed6\u1ed8\u01a1\u1edd\u1edb\u1edf\u1ee1\u1ee3\u01a0\u1edc\u1eda\u1ede\u1ee0\u1ee2\u00f9\u00fa\u1ee7\u0169\u1ee5\u00fb\u00fc\u016b\u016d\u016f\u00d9\u00da\u1ee6\u0168\u1ee4\u00db\u00dc\u016a\u016c\u016e\u01b0\u1eeb\u1ee9\u1eed\u1eef\u1ef1\u01af\u1eea\u1ee8\u1eec\u1eee\u1ef0\u0111\u0110\u1ef3\u00fd\u1ef7\u1ef9\u1ef5\u1ef2\u00dd\u1ef6\u1ef8\u1ef4"[b],
                "aaaaaaaaaAAAAAAAAAaaaaaaAAAAAAaaaaaaAAAAAAeeeeeeeeeeeEEEEEEEEEEeeeeeeEEEEEEiiiiiiiiiiIIIIIIIIIIoooooooooOOOOOOOOOooooooOOOOOOooooooOOOOOOuuuuuuuuuuUUUUUUUUUUuuuuuuUUUUUUdDyyyyyYYYYY"[b]);
            return a
        }, randomNumber: function (a, b) {
            return a + Math.floor(Math.random() * (b - a))
        }, randomString: function (a) {
            for (var b = "", c = 0; c < a; c++)b += "qwertyuiopasdfghjklzxcvbnm".charAt(VTUtil.randomNumber(0, 25));
            return b
        }, getTimeStamp: function () {
            return (new Date).getTime()
        }, loadJSFile: function (a) {
            var b = document.createElement("script");
            b.setAttribute("type", "text/javascript");
            b.setAttribute("src", a);
            document.getElementsByTagName("head")[0].appendChild(b)
        }, loadCSSFile: function (a) {
            var b = document.createElement("link");
            b.setAttribute("rel", "stylesheet");
            b.setAttribute("type", "text/css");
            b.setAttribute("href", a);
            document.getElementsByTagName("head")[0].appendChild(b)
        }, disableBrowserContextMenu: function (a) {
            a.oncontextmenu = function (a) {
                a = a ? a : window.event;
                return a.preventDefault ? a.preventDefault() : !1
            }
        }, loadURL: function (a, b) {
            var a = -1 < a.indexOf("?") ?
            a + "&vtcallback=" : a + "?vtcallback=", a = a + b + ("&k=" + key) + ("&d=" + VTUtil.encodeString(window.location.host)), c = document.createElement("script");
            c.setAttribute("src", a);
            c.setAttribute("type", "text/javascript");
            document.body.appendChild(c)
        }, getImageURL: function (a, b) {
            var c;
            return c = urlServer + imageService + ("?id=" + a) + ("&fullimage=" + (b ? "false" : "true")) + ("&k=" + key) + ("&d=" + VTUtil.encodeString(window.location.host))
        }, roundNumber: function (a, b) {
            if (!VTObjChecker.isNumber(b) || 0 > b)b = 6;
            var c = parseFloat(Math.pow(10, b));
            return parseInt(Math.round(a * c)) / c
        }, getDistanceStr: function (a) {
            var b = "";
            1E4 <= a ? (b = VTUtil.roundNumber(a / 1E3, 1), b += " km") : 1E3 <= a ? (b = VTUtil.roundNumber(a / 1E3, 2), b += " km") : (b = VTUtil.roundNumber(a, 0), b += " m");
            return b
        }, parseInteger: function (a) {
            return parseInt(a)
        }, parseDouble: function (a) {
            return isNaN(parseInt(a)) ? NaN : 1 * a
        }, parseLatLon: function (a) {
            if (VTUtil.isStringEmpty(a))return null;
            var b = a.split(",");
            return VTUtil.isObject(b) && 2 == b.length && (a = VTUtil.parseDouble(b[0]), b = VTUtil.parseDouble(b[1]), 0 != a &&
            0 != b) ? new VTLatLng(a, b) : null
        }, getHeightOfDiv: function (a, b) {
            var c = document.createElement("div");
            c.style.cssText = "display: block; height: auto; width: " + a + "px;";
            c.innerHTML = b;
            document.body.appendChild(c);
            var d = c.clientHeight;
            document.body.removeChild(c);
            return d
        }, encodeString: function (a) {
            var b = "";
            null != a && (b = VTHexaConversion.stringToHex(a), null != b && (b = VTUtil.replaceAll(b, " ", ".")));
            return b
        }, decodePoints: function (a, b) {
            for (var b = Math.pow(10, -b), c = a.length, d = 0, e = 0, f = 0, g = []; d < c;) {
                var h, i = 0, j = 0;
                do h = a.charCodeAt(d++) -
                63, j |= (h & 31) << i, i += 5; while (32 <= h);
                e += j & 1 ? ~(j >> 1) : j >> 1;
                j = i = 0;
                do h = a.charCodeAt(d++) - 63, j |= (h & 31) << i, i += 5; while (32 <= h);
                f += j & 1 ? ~(j >> 1) : j >> 1;
                g.push(new viettel.LatLng(e * b, f * b))
            }
            return g
        }, decryptPoints: function (a) {
            if (null == a)return null;
            var b = a.length, c = 0;
            if (0 >= b)return null;
            for (var d = [], e, f, g, h; c < b;) {
                g = f = 0;
                do e = a.charCodeAt(c++) - 63, g |= (e & 31) << f, f += 5; while (32 <= e);
                h = 0 != (g & 1) ? ~(g >> 1) : g >> 1;
                g = f = 0;
                do e = a.charCodeAt(c++) - 63, g |= (e & 31) << f, f += 5; while (32 <= e);
                e = 0 != (g & 1) ? ~(g >> 1) : g >> 1;
                pt = new viettel.LatLng(1.0E-6 *
                h, 1.0E-6 * e);
                d.push(pt)
            }
            return d
        }, decryptPoint: function (a) {
            if (null == a)return null;
            var b = a.length, c = 0;
            if (0 >= b)return null;
            var d, e, f;
            d = null;
            if (c < b) {
                e = d = 0;
                do b = a.charCodeAt(c++) - 63, e |= (b & 31) << d, d += 5; while (32 <= b);
                f = 0 != (e & 1) ? ~(e >> 1) : e >> 1;
                e = d = 0;
                do b = a.charCodeAt(c++) - 63, e |= (b & 31) << d, d += 5; while (32 <= b);
                d = new viettel.LatLng(1.0E-6 * f, 1.0E-6 * (0 != (e & 1) ? ~(e >> 1) : e >> 1))
            }
            return d
        }, vtType: function () {
            return "VTUtil"
        }
    };
    function CallbackQueue() {
        var a = !1, b;
        this.callMethod = function (c, d) {
            null == d && (d = 100);
            a && clearTimeout(b);
            b = setTimeout(function () {
                c();
                a = !1
            }, d);
            a = !0
        }
    }

    viettel.GeometryUtil = {
        getLength: function (a) {
            for (var b = 0, c = 0; c < a.length - 1; c++)b += this.getDistanceBetween(a[c], a[c + 1]);
            return Math.round(b)
        }, getDistanceBetween: function (a, b, c) {
            var d = EARTH_RADIUS;
            VTObjChecker.isObject(c) && (d = c);
            "undefined" === typeof Number.prototype.toRad && (Number.prototype.toRad = function () {
                return this * Math.PI / 180
            });
            var c = (b.lat() - a.lat()).toRad(), e = (b.lng() - a.lng()).toRad(), a = Math.sin(c / 2) * Math.sin(c / 2) + Math.cos(a.lat().toRad()) * Math.cos(b.lat().toRad()) * Math.sin(e / 2) * Math.sin(e / 2),
                a = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return Number(d * a)
        }, checkPointInPolygon: function (a, b) {
            var c = b.length;
            if (0 >= c)return !1;
            var d, e = c - 1, f = !1;
            for (d = 0; d < c; d++) {
                if (b[d].lat() < a.lat() && b[e].lat() >= a.lat() || b[e].lat() < a.lat() && b[d].lat() >= a.lat())b[d].lng() + (a.lat() - b[d].lat()) / (b[e].lat() - b[d].lat()) * (b[e].lng() - b[d].lng()) < a.lng() && (f = !f);
                e = d
            }
            return f
        }, computeOffset: function (a, b, c, d) {
            var e = EARTH_RADIUS / 1E3;
            VTObjChecker.isObject(d) && (e = d);
            "undefined" === typeof Number.prototype.toRad && (Number.prototype.toRad =
                function () {
                    return this * Math.PI / 180
                });
            var d = b / 1E3 / e, b = Math.sin(d), d = Math.cos(d), f = this.degreesToRadians(a.lat()), a = this.degreesToRadians(a.lng()), e = Math.cos(f), g = Math.sin(f), f = Math.asin(g * d + e * b * Math.cos(c.toRad())), c = a + Math.atan2(Math.sin(c.toRad()) * b * e, d - g * Math.sin(f));
            return new viettel.LatLng(this.radiansToDegrees(f), this.radiansToDegrees(c))
        }, degreesToRadians: function (a) {
            return a * (Math.PI / 180)
        }, radiansToDegrees: function (a) {
            return a * (180 / Math.PI)
        }, computeArea: function (a) {
            var b = 0, c = VTObjChecker.isObject(a) ?
                a.length : 0;
            if (2 < c) {
                for (var d, e, f = 0; f < c; f++)d = a[f], e = f + 1 < c ? a[f + 1] : a[0], b += viettel.GeometryUtil.degreesToRadians(e.lng() - d.lng()) * (2 + Math.sin(viettel.GeometryUtil.degreesToRadians(d.lat())) + Math.sin(viettel.GeometryUtil.degreesToRadians(e.lat())));
                b = b * EARTH_RADIUS * EARTH_RADIUS / 2
            }
            return Math.abs(b)
        }, _distance2: function (a, b) {
            var c = b.lng() - a.lng(), d = b.lat() - a.lat();
            return c * c + d * d
        }, _projectPointOnSegment: function (a, b, c) {
            var d = {distance: 0, pt: null, flag: -1}, e = c.lng() - b.lng(), f = c.lat() - b.lat();
            if (0 == e && 0 ==
                f)return d.pt = new viettel.LatLng(b.lat(), b.lng()), d.flag = 0, d.distance = viettel.GeometryUtil._distance2(a, d.pt), d;
            var g = -e, h = f * b.lng() - e * b.lat(), i = e * a.lng() + f * a.lat(), j = f * f - e * g, g = (h * f - i * g) / j, e = (f * i - e * h) / j;
            d.pt = new viettel.LatLng(e, g);
            d.flag = 0;
            d.distance = viettel.GeometryUtil._distance2(a, d.pt);
            a = (b.lng() - g) * (c.lng() - g) + (b.lat() - e) * (c.lat() - e);
            0 < a && (a = (g - b.lng()) * (c.lng() - b.lng()) + (e - b.lat()) * (c.lat() - b.lat()), d.flag = 0 > a ? -1 : 1);
            return d
        }, projectPointOnSegment: function (a, b, c) {
            b = viettel.GeometryUtil._projectPointOnSegment(a,
                b, c);
            b.distance = null != b.pt ? viettel.GeometryUtil.getDistanceBetween(a, b.pt) : 0;
            return b
        }, distancePointToPoly: function (a, b) {
            var c = {distance: 0, pt: null, index: -1}, d = VTObjChecker.isObject(b) ? b.length : 0;
            if (2 > d)return c;
            for (var e = b[0].lng(), f = b[0].lat(), g = -1, h = 1E12, i = 0; i < d - 1; i++) {
                var j = viettel.GeometryUtil._projectPointOnSegment(a, b[i], b[i + 1]);
                if (0 != j.flag) {
                    var k = viettel.GeometryUtil._distance2(a, b[i]), m = viettel.GeometryUtil._distance2(a, b[i + 1]);
                    k < m ? (j.distance = k, j.pt = b[i]) : (j.distance = m, j.pt = b[i + 1])
                }
                j.distance <
                h && (e = j.pt.lng(), f = j.pt.lat(), h = j.distance, g = i)
            }
            c.index = g;
            c.pt = new viettel.LatLng(f, e);
            c.distance = viettel.GeometryUtil.getDistanceBetween(a, c.pt);
            return c
        }
    };
    OpenLayers.Control.ExNavigation = function (a) {
        OpenLayers.Control.Navigation.call(this, a);
        this.ovrDefaultDblClick = this.defaultDblClick;
        this.defaultDblClick = function (b) {
            a.disableDoubleClickZoom || this.ovrDefaultDblClick(b)
        }
    };
    OpenLayers.Control.ExNavigation.prototype = new OpenLayers.Control.Navigation;
    OpenLayers.Control.ExNavigation.constructor = OpenLayers.Control.ExNavigation;
    OpenLayers.Marker.Label = OpenLayers.Class(OpenLayers.Marker, {
        labelDiv: null,
        labelContent: null,
        mouseOver: !1,
        labelClass: "olMarkerLabel",
        events: null,
        div: null,
        onlyOnMouseOver: !1,
        mouseover: !1,
        labelOffset: "10px",
        labelVisible: !0,
        initialize: function (a, b, c, d) {
            var e = [];
            OpenLayers.Util.extend(this, d);
            e.push(a, b, c);
            OpenLayers.Marker.prototype.initialize.apply(this, e)
        },
        destroy: function () {
            this.labelDiv = this.labelContent = null;
            OpenLayers.Marker.prototype.destroy.apply(this, arguments)
        },
        draw: function (a) {
            this.div = OpenLayers.Marker.prototype.draw.apply(this,
                arguments);
            null != this.labelDiv && (this.div.appendChild(this.labelDiv, this.div.firstChild), this.updateLabelAnchor(this.anchor));
            return this.div
        },
        setLabelContent: function (a) {
            null == this.labelDiv && this.setLabel();
            this.labelContent = a;
            this.labelDiv.innerHTML = a
        },
        setLabel: function () {
            this.labelDiv = OpenLayers.Util.createDiv(this.icon.id + "_Text", null, null);
            this.updateLabelClass(this.labelClass);
            null != this.div && this.div.appendChild(this.labelDiv, this.div.firstChild)
        },
        setLabelAnchor: function (a) {
            null != a && (this.anchor =
                a, null != this.labelDiv && this.updateLabelAnchor(this.anchor))
        },
        updateLabelAnchor: function (a) {
            if (null != a && null != this.div) {
                var b = parseInt(this.div.style.width), c = parseInt(this.div.style.height), b = b / 2;
                null != this.anchor && (b -= a.x, c -= a.y);
                this.labelDiv.style.top = c + "px";
                this.labelDiv.style.left = b + "px"
            }
        },
        setLabelClass: function (a) {
            null != a && (this.labelClass = a, this.updateLabelClass(a))
        },
        updateLabelClass: function (a) {
            null != this.labelDiv && (this.labelDiv.className = a)
        },
        setLabelVisible: function (a) {
            this.labelVisble !=
            a && (this.labelVisble = a, null != this.labelDiv && this.updateLabelVisible(this.labelVisble))
        },
        updateLabelVisible: function (a) {
            this.labelDiv.style.visibility = a ? "visible" : "hidden"
        },
        CLASS_NAME: "OpenLayers.Marker.Label"
    });
    viettel.MapTypeId = {};
    viettel.MapTypeId.TRAFFIC = 0;
    viettel.MapTypeId.ADMIN = 1;
    viettel.MapTypeId.GTRAFFIC = 2;
    viettel.MapTypeId.GSATELLITE = 3;
    viettel.MapConfig = function () {
        var a = null, b = null, c = null, d = null, e = null, f = null, g = null;
        this.getResolutions = function () {
            return a
        };
        this.getZoomLevelNum = function () {
            return a.length
        };
        this.getMapWorldBounds = function () {
            return b
        };
        this.getMapBounds = function () {
            return c
        };
        this.getMapDefaultCenter = function () {
            return d
        };
        this.getMapProjection = function () {
            return e
        };
        this.getUserProjection = function () {
            return f
        };
        this.isSphericalMercator = function () {
            return "EPSG:900913" == originalProjectionName ? !0 : !1
        };
        this.convertRawLatLngToOLPoint =
            function (a, d) {
                if (null == a || null == d)return null;
                var b = new OpenLayers.Geometry.Point(d, a);
                "EPSG:4326" !== originalProjectionName && (b = b.transform(f, e));
                return b
            };
        this.convertLatLngToOLPoint = function (a) {
            if (null == a)return null;
            a = new OpenLayers.Geometry.Point(a.lng(), a.lat());
            "EPSG:4326" !== originalProjectionName && (a = a.transform(f, e));
            return a
        };
        this.convertRawLatLngToOLLonLat = function (a, d) {
            if (null == a || null == d)return null;
            var b = new OpenLayers.LonLat(d, a);
            "EPSG:4326" !== originalProjectionName && (b = b.transform(f,
                e));
            return b
        };
        this.convertLatLngToOLLonLat = function (a) {
            if (null == a)return null;
            a = new OpenLayers.LonLat(a.lng(), a.lat());
            "EPSG:4326" !== originalProjectionName && (a = a.transform(f, e));
            return a
        };
        this.convertOLLonLatToLatLng = function (a) {
            if (null == a)return null;
            a = a.clone();
            "EPSG:4326" !== originalProjectionName && (a = a.transform(e, f));
            return new viettel.LatLng(a.lat, a.lon)
        };
        this.convertLatLngBoundToOLBound = function (a) {
            if (null == a)return null;
            var d = new OpenLayers.Bounds, b = a.getSouthWest(), a = a.getNorthEast();
            d.extend(new OpenLayers.LonLat(b.lng(),
                b.lat()));
            d.extend(new OpenLayers.LonLat(a.lng(), a.lat()));
            "EPSG:4326" !== originalProjectionName && (d = d.transform(f, e));
            return d
        };
        this.convertOLBoundToLatLngBound = function (a) {
            if (null == a)return null;
            var d = a.clone();
            "EPSG:4326" !== originalProjectionName && (d = d.transform(e, f));
            a = new viettel.LatLng(d.bottom, d.left);
            d = new viettel.LatLng(d.top, d.right);
            return new viettel.LatLngBounds(a, d)
        };
        this.getWMSLayerInfo = function (a) {
            for (var d = g[0], b = 0; b < g.length; b++) {
                var c = g[b];
                if (c.id == a) {
                    d = c;
                    break
                }
            }
            return d
        };
        "EPSG:900913" ==
        originalProjectionName ? (a = [156543.03390625, 78271.516953125, 39135.7584765625, 19567.87923828125, 9783.939619140625, 4891.9698095703125, 2445.9849047851562, 1222.9924523925781, 611.4962261962891, 305.74811309814453, 152.87405654907226, 76.43702827453613, 38.218514137268066, 19.109257068634033, 9.554628534317017, 4.777314267158508, 2.388657133579254, 1.194328566789627, 0.5971642833948135, 0.2985821416974068], b = new OpenLayers.Bounds(-2.003750834E7, -2.003750834E7, 2.003750834E7, 2.003750834E7), c = new viettel.LatLngBounds(new viettel.LatLng(2.26794937474E7,
            1.13706180676E7), new viettel.LatLng(557305.257275, 1.28017414412E7)), g = [{
            id: viettel.MapTypeId.TRAFFIC,
            image: "layer_trans.png",
            title: viettel.Language.MapType.TrafficTitle,
            name: "VTrans",
            format: "png8"
        }, {
            id: viettel.MapTypeId.ADMIN,
            image: "layer_admin.png",
            title: viettel.Language.MapType.AdminTitle,
            name: "VAdmin",
            format: "png8"
        }, {
            id: viettel.MapTypeId.GTRAFFIC,
            image: "layer_gtrans.png",
            title: viettel.Language.MapType.GTrafficTitle,
            name: "GTrans",
            format: "png"
        }, {
            id: viettel.MapTypeId.GSATELLITE, image: "layer_gsat.png",
            title: viettel.Language.MapType.GSatelliteTitle, name: "GSat", format: "jpeg"
        }]) : (originalProjectionName = "EPSG:4326", a = [0.703125, 0.3515625, 0.17578125, 0.087890625, 0.0439453125, 0.02197265625, 0.010986328125, 0.0054931640625, 0.00274658203125, 0.001373291015625, 6.866455078125E-4, 3.4332275390625E-4, 1.71661376953125E-4, 8.58306884765625E-5, 4.291534423828125E-5, 2.1457672119140625E-5, 1.0728836059570312E-5, 5.364418029785156E-6, 2.682209014892578E-6, 1.341104507446289E-6], b = new OpenLayers.Bounds(-180, -90, 180, 90), c = new viettel.LatLngBounds(new viettel.LatLng(5,
            102.144), new viettel.LatLng(23.392, 115)), g = [{
            id: viettel.MapTypeId.TRAFFIC,
            image: "layer_trans.png",
            title: viettel.Language.MapType.TrafficTitle,
            name: "Trans_02",
            format: "png8"
        }, {
            id: viettel.MapTypeId.ADMIN,
            image: "layer_admin.png",
            title: viettel.Language.MapType.AdminTitle,
            name: "Admin_02",
            format: "png8"
        }]);
        d = new viettel.LatLng(21.0279143, 105.844878);
        e = new OpenLayers.Projection(originalProjectionName);
        f = new OpenLayers.Projection("EPSG:4326")
    };
    OpenLayers.IMAGE_RELOAD_ATTEMPTS = 5;
    OpenLayers.DOTS_PER_INCH = 72;
    OpenLayers.Util.onImageLoadErrorColor = "transparent";
    VTUtil.loadCSSFile(OpenLayersEX_CSSLoc);
    VTUtil.loadCSSFile(OpenLayersEX_DrawCSSLoc);
    VTUtil.BROWSER_NAME = VTUtil.getBrowserName();
    -1 == wmsService.indexOf("?k=") && (wmsService += "?k=" + key + "&d=" + VTUtil.encodeString(window.location.host));
    viettel.Map = function (a, b) {
        viettel.MVCObject.call(this);
        var c;
        this.controls = [];
        this.loadedMap = !1;
        var d = this;
        this.fitBounds = function (a) {
            l.zoomToExtent(d.convertLatLngBoundToOLBound(a), !1)
        };
        this.getBounds = function () {
            var a = l.getExtent();
            return VTObjChecker.isObject(a) ? d.convertOLBoundToLatLngBound(a) : null
        };
        this.getCenter = function () {
            var a = l.getCenter();
            return VTObjChecker.isObject(a) ? d.convertOLLonLatToLatLng(a) : null
        };
        this.getDiv = function () {
            return l.div
        };
        this.getZoom = function () {
            return l.zoom
        };
        this.setCenter =
            function (a) {
                this.setOptions({center: a});
                viettel.Events.trigger(d, "idle")
            };
        this.setScale = function (a) {
            l.setScale(a)
        };
        this.getScale = function () {
            return l.getScale()
        };
        this.panBy = function (a, b) {
            if (!(0 == a && 0 == b)) {
                var c = l.getCenter(), c = l.getPixelFromLonLat(c);
                c.x += a;
                c.y += b;
                c = l.getLonLatFromPixel(c);
                l.panTo(c);
                viettel.Events.trigger(l, "bounds_changed");
                viettel.Events.trigger(l, "center_changed");
                viettel.Events.trigger(d, "idle")
            }
        };
        this.panTo = function (a) {
            this.get("center").lat() == a.lat() && this.get("center").lng() ==
            a.lng() || (l.panTo(d.convertLatLngToOLLonLat(a)), viettel.Events.trigger(l, "bounds_changed"), viettel.Events.trigger(l, "center_changed"), viettel.Events.trigger(d, "idle"))
        };
        var e = !1, f = null, g = null, h = null, i = null, j, k;
        this.setOptions = function (b) {
            VTObjChecker.isNumber(b.zoom) && (0 > b.zoom ? b.zoom = 0 : b.zoom >= m.getZoomLevelNum() && (b.zoom = m.getZoomLevelNum() - 1));
            VTObjChecker.isLatLngObj(b.center) && (this.set("center", b.center), e && l.setCenter(d.convertLatLngToOLLonLat(d.get("center"))));
            if (VTObjChecker.isNumber(b.zoom)) {
                if (this.getZoom ==
                    b.zoom)return;
                this.set("zoom", b.zoom);
                e && (l.setCenter(null, b.zoom), viettel.Events.trigger(l, "bounds_changed"), viettel.Events.trigger(l, "zoom_changed"))
            }
            if (VTObjChecker.isNumber(b.mapTypeId)) {
                if (this.get("mapTypeId") == b.mapTypeId)return;
                this.set("mapTypeId", b.mapTypeId);
                e && q && (q = !1, l.events.register("removelayer", l, p), l.removeLayer(s, !1))
            }
            VTObjChecker.isArray(b.enablePlugins) && this.set("enablePlugins", b.enablePlugins);
            var f = !1;
            VTObjChecker.isBoolean(b.panZoomControl) && (f = !0, d.set("panZoomControl",
                b.panZoomControl));
            VTObjChecker.isObject(b.panZoomControlOptions) && (f = !0, d.set("panZoomControlOptions", b.panZoomControlOptions));
            f && e && B();
            VTObjChecker.isBoolean(b.overviewMapControl) && (d.set("overviewMapControl", b.overviewMapControl), e && A());
            VTObjChecker.isBoolean(b.searchControl) && (d.set("searchControl", b.searchControl), e && w());
            f = !1;
            VTObjChecker.isBoolean(b.disableDoubleClickZoom) && (f = !0, d.set("disableDoubleClickZoom", b.disableDoubleClickZoom));
            VTObjChecker.isBoolean(b.draggable) && (f = !0, d.set("draggable",
                b.draggable));
            VTObjChecker.isBoolean(b.scrollwheel) && (f = !0, d.set("scrollwheel", b.scrollwheel));
            e && f && y();
            !e && null != d.get("zoom") && null != d.get("center") && (b = {
                maxExtent: m.getMapWorldBounds(),
                resolutions: m.getResolutions(),
                projection: m.getMapProjection(),
                units: mapUnit,
                sphericalMercator: m.isSphericalMercator(),
                numZoomLevels: m.getZoomLevelNum(),
                controls: []
            }, l = new OpenLayers.Map(a, b), VTUtil.disableBrowserContextMenu(a), s = C(), l.div.style.cursor = "default", n = new OpenLayers.Layer.Vector("vectorDefault"), o =
                new OpenLayers.Layer.Markers("markerDefault"), l.addLayers([s, n, o]), b = jQuery4Map(l.div).offset(), m.mapPosition = b, l.setCenter(d.convertLatLngToOLLonLat(d.get("center"))), l.setCenter(null, d.get("zoom")), new VectorEventController(d, n), v = document.createElement("DIV"), v.style.left = "0px", v.style.top = "0px", v.style.position = "absolute", v.style.zIndex = DOM_LAYER_ZINDEX, l.layerContainerDiv.appendChild(v), x = document.createElement("DIV"), x.style.left = "0px", x.style.top = "0px", x.style.position = "absolute", x.style.zIndex =
                EVENT_LAYER_ZINDEX, l.layerContainerDiv.appendChild(x), b = d.getDiv(), "relative" != b.style.position && "absolute" != b.style.position && (b.style.position = "relative"), b.style.overflow = "hidden", d.controls.paddingWidth = 10, d.controls.paddingHeight = 10, d.controls[viettel.ControlPosition.TOP_LEFT] = new viettel.TopLeftControl(d.controls, d), d.controls[viettel.ControlPosition.LEFT_TOP] = new viettel.LeftTopControl(d.controls, d), d.controls[viettel.ControlPosition.TOP_RIGHT] = new viettel.TopRightControl(d.controls, d), d.controls[viettel.ControlPosition.RIGHT_TOP] =
                new viettel.RightTopControl(d.controls, d), d.controls[viettel.ControlPosition.BOTTOM_LEFT] = new viettel.BottomLeftControl(d.controls, d), d.controls[viettel.ControlPosition.LEFT_BOTTOM] = new viettel.LeftBottomControl(d.controls, d), d.controls[viettel.ControlPosition.BOTTOM_RIGHT] = new viettel.BottomRightControl(d.controls, d), d.controls[viettel.ControlPosition.RIGHT_BOTTOM] = new viettel.RightBottomControl(d.controls, d), d.controls[viettel.ControlPosition.TOP_CENTER] = new viettel.TopCenterControl(d.controls,
                d), d.controls[viettel.ControlPosition.BOTTOM_CENTER] = new viettel.BottomCenterControl(d.controls, d), d.controls[viettel.ControlPosition.LEFT_CENTER] = new viettel.LeftCenterControl(d.controls, d), d.controls[viettel.ControlPosition.RIGHT_CENTER] = new viettel.RightCenterControl(d.controls, d), r = new viettel.MapTypeControl(d), r.addPosition(viettel.ControlPosition.TOP_RIGHT, d.get("mapTypeId")), copyrightControl = new viettel.CopyRightControl(d), copyrightControl.addPosition(viettel.ControlPosition.BOTTOM_LEFT), j =
                new viettel.MapEvent(d), j.init(), k = new viettel.MarkerEvent(d), y(), B(), w(), A(), e = !0, viettel.Events.trigger(d, "idle"), c = new viettel.MapPlugin(d), c.initPlugins())
        };
        this.getEnablePlugins = function () {
            return this.get("enablePlugins")
        };
        this.getZoomControl = function () {
            return f
        };
        this.getOverviewControl = function () {
            return g
        };
        this.getSearchControl = function () {
            return i
        };
        this.getMapTypeControl = function () {
            return r
        };
        var m = new viettel.MapConfig;
        this.getMapConfig = function () {
            return m
        };
        this.getMapId = function () {
            return u
        };
        this.getMapTypeId = function () {
            return d.get("mapTypeId")
        };
        this.setMapTypeId = function (a) {
            this.setOptions({mapTypeId: a})
        };
        this.convertRawLatLngToOLPoint = function (a, b) {
            return m.convertRawLatLngToOLPoint(a, b)
        };
        this.convertLatLngToOLPoint = function (a) {
            return m.convertLatLngToOLPoint(a)
        };
        this.convertRawLatLngToOLLonLat = function (a, b) {
            return m.convertRawLatLngToOLLonLat(a, b)
        };
        this.convertLatLngToOLLonLat = function (a) {
            return m.convertLatLngToOLLonLat(a)
        };
        this.convertOLLonLatToLatLng = function (a) {
            return m.convertOLLonLatToLatLng(a)
        };
        this.convertLatLngBoundToOLBound = function (a) {
            return m.convertLatLngBoundToOLBound(a)
        };
        this.convertOLBoundToLatLngBound = function (a) {
            return m.convertOLBoundToLatLngBound(a)
        };
        var l, n, o, r, s, u = VTUtil.randomString(8), q = !0, t = function () {
            null != f && (f.updatePosition(), l.events.unregister("addlayer", l, t))
        }, p = function () {
            q = !0;
            s = C();
            l.events.register("addlayer", l, t);
            l.addLayer(s, !0);
            l.events.unregister("removelayer", l, p);
            c.updatePlugins()
        }, C = function () {
            var a = urlServer + wmsService, b = m.getMapBounds().getSouthWest(),
                c = m.getWMSLayerInfo(d.get("mapTypeId"));
            return s = new OpenLayers.Layer.WMS("VTMapWMSLayer", a, {
                LAYERS: c.name,
                bgColor: bgMapColor,
                format: "image/" + c.format,
                tiled: !0,
                tilesOrigin: b.lng() + "," + b.lat()
            }, {tileSize: new OpenLayers.Size(256, 256), buffer: enableSlideDragging ? 4 : 0}, {layers: "basic"})
        }, y = function () {
            null != h && (d.removeControl(h), h.control.destroy());
            var a = {};
            a.disableDoubleClickZoom = d.get("disableDoubleClickZoom");
            a.draggable = d.get("draggable");
            a.scrollwheel = d.get("scrollwheel");
            h = new viettel.NavigatorControl(d,
                a)
        }, w = function () {
            d.get("searchControl") ? (null == i && (i = new viettel.SearchControl(d)), i.addPosition(viettel.ControlPosition.BOTTOM_CENTER)) : null != i && (i.removePosition(d), i = null)
        }, B = function () {
            var a = d.get("panZoomControl"), b = d.get("panZoomControlOptions");
            d.get("searchControl");
            a ? (null == f ? f = new viettel.ZoomBarControl(d) : f.removePosition(), f.addPosition(b)) : null != f && (f.removePosition(d), f = null)
        }, A = function () {
            d.get("overviewMapControl") ? (null != g && (d.removeControl(g), g.removePosition()), g = new viettel.OverviewMap(d)) :
            null != g && (d.removeControl(g), g.removePosition(), g = null)
        };
        this.setZoom = function (a) {
            this.setOptions({zoom: a})
        };
        this.fromLatLngToDivPixel = function (a) {
            a = l.getPixelFromLonLat(d.convertLatLngToOLLonLat(a));
            return new viettel.Point(a.x - l.layerContainerDiv.offsetLeft, a.y - l.layerContainerDiv.offsetTop)
        };
        this.fromDivPixelToLatLng = function (a) {
            a = l.getLonLatFromPixel(new OpenLayers.Pixel(a.x + l.layerContainerDiv.offsetLeft, a.y + l.layerContainerDiv.offsetTop));
            return d.convertOLLonLatToLatLng(a)
        };
        this.fromLatLngToContainerPixel =
            function (a) {
                a = l.getPixelFromLonLat(d.convertLatLngToOLLonLat(a));
                return new viettel.Point(a.x, a.y)
            };
        this.fromContainerPixelToLatLng = function (a) {
            a = l.getLonLatFromPixel(new OpenLayers.Pixel(a.x, a.y));
            return d.convertOLLonLatToLatLng(a)
        };
        this.getOriginalObj = function () {
            return l
        };
        this.addControl = function (a) {
            l.addControl(a.control)
        };
        this.removeControl = function (a) {
            l.removeControl(a.control)
        };
        this.setLayer = function (a) {
            l.addLayer(a)
        };
        this.getVectorDefault = function () {
            return n
        };
        this.getMarkerDefault = function () {
            return o
        };
        this.getOriginalObj = function () {
            return l
        };
        this.getSize = function () {
            var a = l.getSize();
            return new viettel.Size(a.w, a.h)
        };
        this.getMapEvent = function () {
            return j
        };
        this.getMarkerEvent = function () {
            return k
        };
        var v, x;
        this.getDOMLayer = function () {
            return v
        };
        this.getEventLayer = function () {
            return x
        };
        VTObjChecker.isObject(b) || (b = {});
        VTObjChecker.isBoolean(b.disableDoubleClickZoom) || (b.disableDoubleClickZoom = !1);
        VTObjChecker.isBoolean(b.draggable) || (b.draggable = !0);
        VTObjChecker.isBoolean(b.scrollwheel) || (b.scrollwheel = !0);
        VTObjChecker.isBoolean(b.panZoomControl) || (b.panZoomControl = !0);
        VTObjChecker.isBoolean(b.searchControl) || (b.searchControl = !1);
        VTObjChecker.isObject(b.panZoomControlOptions) || (b.panZoomControlOptions = {position: viettel.ControlPosition.TOP_LEFT});
        VTObjChecker.isBoolean(b.overviewMapControl) || (b.overviewMapControl = !0);
        VTObjChecker.isNumber(b.zoom) || (b.zoom = 10);
        VTObjChecker.isLatLngObj(b.center) || (b.center = m.getMapDefaultCenter());
        VTObjChecker.isNumber(b.mapTypeId) || (b.mapTypeId = 0);
        this.setOptions(b)
    };
    viettel.Map.prototype = new viettel.MVCObject;
    viettel.Map.prototype.constructor = viettel.Map;
    viettel.MapOptions = function () {
        var a, b, c;
        this.setOptions = function (d) {
            VTObjChecker.isObject(d) && (a = d.center, c = b = d.zoom)
        };
        this.updateToMap = function (d, e) {
            !0 != e && (e = !1);
            !VTObjChecker.isBoolean(c) || VTObjChecker.isBoolean(c);
            VTObjChecker.isNumber(b) ? d.setZoom(b) : e && d.setZoom(VTMAP_ZOOM_DEFAULT);
            VTObjChecker.isLatLngObj(a) ? d.setCenter(a) : e && d.setCenter(new viettel.LatLng(21.0279143, 105.844878))
        }
    };
    viettel.NavigatorControl = function (a, b) {
        this.control = new OpenLayers.Control.ExNavigation({
            disableDoubleClickZoom: b.disableDoubleClickZoom,
            zoomWheelEnabled: b.scrollwheel
        });
        a.addControl(this);
        var c = a.getDiv();
        b.draggable ? c.style.cursor = "url('" + OpenLayersEx_OpenHandCursor + "'), default" : (this.control.dragPan.deactivate(), c.style.cursor = "default");
        this.control.dragPan.handler.stopDown = !1;
        this.control.handlers.click.stopDouble = !1
    };
    viettel.ZoomBarControl = function (a) {
        var b, c = this, d, e;
        this.addPosition = function (c) {
            d = null == c ? viettel.ControlPosition.TOP_LEFT : c.position;
            e = document.createElement("DIV");
            "ORG_ZOOM" == b ? (e.style.width = "30px", e.style.height = "320px") : (e.style.width = "30px", e.style.height = "120px");
            a.controls[d].push(e);
            g()
        };
        this.updatePosition = function () {
            this.removePosition();
            this.addPosition({position: d})
        };
        this.getIndex = function () {
            return a.controls[d].getIndex(e)
        };
        this.getPosition = function () {
            return d
        };
        this.removePosition =
            function () {
                null != d && (a.controls[d].removeAt(this.getIndex()), this.control && (a.getOriginalObj().removeControl(this.control), this.control.destroy(), this.control = null))
            };
        var f = function () {
            return b = 400 < a.getSize().height ? "ORG_ZOOM" : "MIN_ZOOM"
        };
        this.update = function () {
            var h = b;
            f();
            b != h ? (h = a.controls[d].getIndex(e), c.removePosition(), a.controls[d].insertAt(e, h), g()) : this.updatePosition()
        };
        var g = function () {
            var d = jQuery4Map(e).parent().offset(), f = jQuery4Map(a.getDiv()).offset(), d = new OpenLayers.Pixel(parseInt(d.left -
            f.left), parseInt(d.top - f.top));
            c.control = "ORG_ZOOM" == b ? new OpenLayers.Control.PanZoomBar({position: new OpenLayers.Pixel(0, 0)}) : new OpenLayers.Control.PanZoom({position: new OpenLayers.Pixel(0, 0)});
            a.addControl(c);
            c.control.div.style.left = d.x + "px";
            c.control.div.style.top = d.y + "px"
        };
        this.vtType = function () {
            return "VTZoomBarControl"
        };
        f()
    };
    viettel.OverviewMap = function (a) {
        var b = urlServer + wmsService, c = this, d = a.getMapConfig().getMapBounds().getSouthWest();
        this.changeMapType = function () {
            a.removeControl(c);
            e()
        };
        var e = function () {
            var e;
            e = a.getMapConfig().getWMSLayerInfo(a.get("mapTypeId"));
            e = {
                layers: [new OpenLayers.Layer.WMS("VTWMSOverview", b, {
                    LAYERS: e.name,
                    bgColor: bgMapColor,
                    format: "image/" + e.format,
                    tiled: !0,
                    tilesOrigin: d.lng() + "," + d.lat()
                }, {tileSize: new OpenLayers.Size(256, 256)})], mapOptions: {
                    projection: a.getMapConfig().getMapProjection(),
                    maxExtent: a.getMapConfig().getMapWorldBounds(),
                    units: mapUnit,
                    resolutions: a.getMapConfig().getResolutions(),
                    sphericalMercator: a.getMapConfig().isSphericalMercator()
                }, autoPan: !0, numZoomLevels: 5
            };
            c.control = new OpenLayers.Control.OverviewMap(e);
            a.addControl(c)
        };
        e();
        this.removePosition = function () {
        }
    };
    function VTClickControl(a) {
        OpenLayers.Control.Click = OpenLayers.Class(OpenLayers.Control, {
            defaultHandlerOptions: {
                single: !0,
                "double": !0,
                pixelTolerance: 5,
                stopSingle: !1,
                stopDouble: !1,
                delay: 100
            }, handleRightClicks: !0, initialize: function (a) {
                this.handlerOptions = OpenLayers.Util.extend({}, this.defaultHandlerOptions);
                OpenLayers.Control.prototype.initialize.apply(this, arguments);
                this.handler = new OpenLayers.Handler.Click(this, this.eventMethods, this.handlerOptions)
            }, CLASS_NAME: "OpenLayers.Control.Click"
        });
        this.onClick =
            null;
        this.control = new OpenLayers.Control.Click({
            eventMethods: {
                rightclick: function (b) {
                    tmpEventSetter.checkEvent(viettel.VTObjType.Map, "rightclick") || (VTUtil.standardizeEvent(b), viettel.Events.trigger(a, "rightclick", new viettel.MouseEvent(b, a, {
                        x: b.pageX - a.getMapConfig().mapPosition.left,
                        y: b.pageY - a.getMapConfig().mapPosition.top
                    }), a))
                }, dblclick: function (b) {
                    VTUtil.isIEBrowser() && viettel.Events.trigger(a, "dblclick", new viettel.MouseEvent(b, a, {
                        x: b.clientX,
                        y: b.clientY
                    }), a)
                }, click: function (b) {
                    VTUtil.isIEBrowser() && !tmpEventSetter.checkEvent(viettel.VTObjType.Map, "click") && (VTUtil.standardizeEvent(b), b = new viettel.MouseEvent(b, a, {
                        x: b.pageX - a.getMapConfig().mapPosition.left,
                        y: b.pageY - a.getMapConfig().mapPosition.top
                    }, a), viettel.Events.trigger(a, "click", b))
                }
            }
        });
        this.activate = function () {
            VTObjChecker.isObject(this.control) && this.control.activate()
        };
        this.vtType = function () {
            return "VTClickControl"
        }
    }

    function VTDragControl(a) {
        OpenLayers.Control.Drag = OpenLayers.Class(OpenLayers.Control, {
            defaultHandlerOptions: {stopDown: !0},
            initialize: function (a) {
                this.handlerOptions = OpenLayers.Util.extend({}, this.defaultHandlerOptions);
                OpenLayers.Control.prototype.initialize.apply(this, arguments);
                this.handler = new OpenLayers.Handler.Drag(this, this.eventMethods, this.handlerOptions)
            },
            CLASS_NAME: "OpenLayers.Control.Drag"
        });
        this.isMousemove = this.isMousedown = !1;
        this.control = new OpenLayers.Control.Drag({
            eventMethods: {
                down: function (b) {
                    this.isMousedown = !0;
                    a.getDiv().style.cursor = "url('" + OpenLayersEx_ClosedHandCursor + "'), default";
                    b = new viettel.MouseEvent(b, a, {x: b.x, y: b.y}, a);
                    tmpEventSetter.checkEvent(viettel.VTObjType.Map, "mousedown") || viettel.Events.trigger(a, "mousedown", b)
                }, up: function (b) {
                    b = new viettel.MouseEvent(b, a, {x: b.x, y: b.y}, a);
                    a.getDiv().style.cursor = "url('" + OpenLayersEx_OpenHandCursor + "'), default";
                    tmpEventSetter.checkEvent(viettel.VTObjType.Map, "mouseup") || (viettel.Events.trigger(a, "mouseup", b), this.isMousemove && (viettel.Events.trigger(a,
                        "dragend", b), this.isMousemove = !1, viettel.Events.trigger(a, "bounds_changed"), viettel.Events.trigger(a, "center_changed")))
                }, move: function (b) {
                    b = new viettel.MouseEvent(b, a, {x: b.x, y: b.y}, a);
                    this.isMousedown && (viettel.Events.trigger(a, "dragstart", b), this.isMousedown = !1, this.isMousemove = !0, viettel.Events.trigger(a, "drag", b), viettel.Events.trigger(a, "bounds_changed"), viettel.Events.trigger(a, "center_changed"))
                }
            }
        });
        this.activate = function () {
            VTObjChecker.isObject(this.control) && this.control.activate()
        };
        this.vtType =
            function () {
                return "VTDragControl"
            }
    }

    viettel.SearchControl = function (a) {
        var b = document.createElement("DIV"), c = !1;
        b.style.width = "200px";
        b.index = 1;
        var d, e;
        b.style.padding = "5px";
        var f, g = "locationValueDiv_" + a.getMapId(), h = "locationValue_" + a.getMapId(), i = "searchDiv_" + a.getMapId(), j = "searchButton_" + a.getMapId(), k = "<div style='width:130px; position: absolute; bottom:0px' id='" + g + "'><input type='textbox' style='width:100%; color:rgb(180, 180, 180);' id='" + h + "' value='' onclick='onfocusTextbox()'/></div><div style='left:140px; position: absolute; bottom:0px' id='" + i +
            "'><input type='button' value='' id='" + j + "'' /></div>", m = document.createElement("div");
        m.id = "searchControl" + a.getMapId();
        m.innerHTML = k;
        m.style.position = "absolute";
        b.appendChild(m);
        this.addPosition = function (c) {
            e = c;
            d = a.controls[e].push(b)
        };
        this.removePosition = function () {
            a.controls[e].removeAt(d)
        };
        this.setVisible = function (a) {
            m.style.display = a ? "block" : "none"
        };
        var l = function () {
            if (c) {
                var b = document.getElementById(h).value;
                "" != b && (new viettel.GeoService).getLocations(b, function (b, d) {
                    d == viettel.GeoServiceStatus.OK &&
                    (a.setCenter(b.items[0].location), null == f && (f = new viettel.Marker, f.setMap(a)), f.setPosition(b.items[0].location))
                })
            }
        }, n = function () {
            document.getElementById(h).value = "";
            c = !0;
            document.getElementById(g).style.width = "200px";
            document.getElementById(i).style.left = "210px";
            viettel.Events.addListenerOnce(a, "click", function () {
                c = !1;
                document.getElementById(h).value = viettel.Language.SearchControl.defaultText;
                document.getElementById(h).style.color = "rgb(180, 180, 180)";
                document.getElementById(g).style.width = "130px";
                document.getElementById(i).style.left = "140px";
                jQuery4Map(document).unbind("keypress", o)
            });
            document.getElementById(h).style.color = "rgb(0, 0, 0)";
            jQuery4Map(document).bind("keypress", o)
        }, o = function (a) {
            if (13 == a.keyCode)return l(), !1
        }, r = setInterval(function () {
            null != document.getElementById(h) && null != document.getElementById(j) && (document.getElementById(h).value = viettel.Language.SearchControl.defaultText, document.getElementById(j).value = viettel.Language.SearchControl.searchButtonValue, document.getElementById(h).onclick =
                n, document.getElementById(j).onclick = l, clearInterval(r))
        }, 100)
    };
    viettel.MapTypeControl = function (a, b) {
        var c = b, d = null, e = null, f = "mapTypeImg_" + a.getMapId(), g = "mapTypeText_" + a.getMapId(), h = function () {
            document.getElementById(f).src = OpenLayersEX_ImgLoc + d.image;
            document.getElementById(g).innerHTML = d.title
        }, i = function () {
            var a = document.getElementById(f);
            null != a ? a.onclick = j : setTimeout(i, 100)
        }, j = function () {
            for (var b = a.getMapTypeId(), d = 0, e = 0; e < c.length; e++)if (b == c[e]) {
                d = e;
                break
            }
            d = (d + 1) % c.length;
            b = c[d];
            k(b)
        }, k = function (b) {
            d = a.getMapConfig().getWMSLayerInfo(b);
            h();
            a.setOptions({mapTypeId: b});
            null != a.getOverviewControl() && a.getOverviewControl().changeMapType()
        };
        this.addPosition = function (b, c) {
            mapTypeId = c;
            d = a.getMapConfig().getWMSLayerInfo(mapTypeId);
            setTimeout(function () {
                h()
            }, 100);
            a.controls[b].push(e)
        };
        this.updateMapTypes = function (b) {
            if (!(null == b || 0 >= b.length)) {
                c = [];
                for (var d = 0; d < b.length; d++)c.push(b[d]);
                null != a && a.getMapTypeId() != c[0] && k(c[0])
            }
        };
        (function () {
            null == c && (c = [], c.push(viettel.MapTypeId.TRAFFIC), c.push(viettel.MapTypeId.ADMIN), c.push(viettel.MapTypeId.GTRAFFIC), c.push(viettel.MapTypeId.GSATELLITE));
            var b = a.getMapTypeId();
            d = a.getMapConfig().getWMSLayerInfo(b);
            b = "<div style='width: 70px; border-style: solid; border-width: 1px '><div style='top: 0px; left: 0px; width: 100%; height: 45px;' ><img src='" + OpenLayersEX_ImgLoc + d.image + "' style='height: 100%; width: 100%' id='" + f + "' /> </div> <div style='top: 45px; left: 0px; width: 100%; background-color: white; font-size: 11px; ; text-align: center' id='" + g + "'>" + d.title + "</div></div>";
            e = document.createElement("div");
            e.innerHTML = b;
            i()
        })()
    };
    viettel.CopyRightControl = function (a) {
        var b;
        this.addPosition = function (c) {
            a.controls[c].push(b)
        };
        b = document.createElement("div");
        b.innerHTML = "<div style=' font-size: 12px; font-family: &quot;Segoe UI&quot;,helvetica,Tahoma,Arial,sans-serif; color: rgb(149, 154, 157); text-shadow: 0.1em 0.1em 0.05em rgb(255, 255, 255); left: 400px; bottom: 10px;'>\u00a92012 GP&THHT \u2013 VTT. All rights reserved</div>"
    };
    viettel.OverlayView = function () {
        var a, b, c = this;
        this.draw = function () {
        };
        this.onAdd = function () {
        };
        this.onRemove = function () {
        };
        this.setMap = function (f) {
            c = this;
            setTimeout(function () {
                if (VTObjChecker.isMapObj(f))a = new viettel.Projection(f), c.map = f.getOriginalObj(), b = new viettel.MapPanes(f), c.onAdd(), c.map.addPopup(c), d(), e(); else if ("undefined" != typeof f && null == f)c.onRemove()
            }, viettel.Timeout.DRAW_TIMEOUT)
        };
        this.getPanes = function () {
            return b
        };
        this.updatePosition = function () {
            c = this;
            setTimeout(function () {
                c.draw();
                d();
                e()
            }, viettel.Timeout.DRAW_TIMEOUT)
        };
        this.getProjection = function () {
            return a
        };
        var d = function () {
            for (var a = 0; a < b.getDOMDiv().length; a++)b.getDOMDiv()[a].style.zIndex = DOM_LAYER_ZINDEX
        }, e = function () {
            for (var a = 0; a < b.getEventDiv().length; a++)b.getEventDiv()[a].style.zIndex = EVENT_LAYER_ZINDEX
        }
    };
    viettel.MapPanes = function (a) {
        var b = [], c = [];
        this.appendDOM = function (d) {
            a.getDOMLayer().appendChild(d);
            b.push(d)
        };
        this.appendEvent = function (b) {
            a.getEventLayer().appendChild(b);
            c.push(b)
        };
        this.getDOMDiv = function () {
            return b
        };
        this.getEventDiv = function () {
            return c
        }
    };
    viettel.Projection = function (a) {
        this.fromDivPixelToLatLng = function (b) {
            return a.fromDivPixelToLatLng(b)
        };
        this.fromLatLngToDivPixel = function (b) {
            return a.fromLatLngToDivPixel(b.getOriginalObj())
        }
    };
    viettel.InfoWindow = function (a) {
        viettel.MVCObject.call(this);
        var b = new viettel.InfoWindowOptions, c = null;
        b.setOptions(a);
        var d = this;
        this.close = function () {
            VTObjChecker.isObject(c) && (e.getOriginalObj().removePopup(c), c.destroy(), viettel.Events.trigger(d, "closeclick"));
            c = null
        };
        this.setContent = function (a) {
            b.content = a;
            f()
        };
        this.getContent = function () {
            return b.content
        };
        this.setPosition = function (a) {
            b.position = a;
            f()
        };
        this.getPosition = function () {
            return b.position
        };
        this.setZIndex = function (a) {
            b.zIndex = a;
            f()
        };
        this.getZIndex =
            function () {
                return b.zIndex
            };
        this.setOffset = function (a, b) {
            anchoredBubbleSupport.offsetTop = a;
            anchoredBubbleSupport.offsetBottom = b
        };
        this.setOptions = function (a) {
            b.setOptions(a);
            f()
        };
        var e = null;
        this.open = function (a, d) {
            e = a;
            if (VTObjChecker.isObject(d))if (VTObjChecker.isMarkerObj(d)) {
                b.position = d.getPosition();
                var c = d.getOriginalObj();
                null != c && (c = c.icon, null != c.offset && null != c.size && (b.offset = new OpenLayers.Pixel(c.offset.x + c.size.w / 2, c.offset.y)))
            } else VTObjChecker.isLatLngObj(d) && (b.position = d);
            f()
        };
        var f =
            function () {
                d.close();
                if (!(null == b.content || 0 == b.content.replace(/^\s+|\s+$/g, "").length) && VTObjChecker.isObject(b.position) && VTObjChecker.isObject(e)) {
                    var a = b.offset;
                    null == a && (a = new OpenLayers.Pixel(0, 0));
                    var f = e.convertLatLngToOLLonLat(b.position), i = OpenLayers.Popup.AnchoredBubble, j = e.getOriginalObj(), k = "", k = null != b.maxWidth ? "<div style='overflow: auto; width:" + b.maxWidth + "px;'>" + b.content + "</div>" : "<div>" + b.content + "</div>";
                    c = new i(null, j, f, null, k, {offset: new OpenLayers.Pixel(a.x, a.y + 15)}, !0, null);
                    e.getOriginalObj().addPopup(c);
                    c.div.style.zIndex = null != b.zIndex ? b.zIndex : INFOWINDOW_ZINDEX_DEFAULT
                }
            }
    };
    viettel.InfoWindow.prototype = new viettel.MVCObject;
    viettel.InfoWindow.prototype.constructor = viettel.InfoWindow;
    viettel.InfoWindowOptions = function () {
        this.maxWidth;
        this.content;
        this.position;
        this.offset;
        this.zIndex;
        this.setOptions = function (a) {
            VTObjChecker.isObject(a) && (this.maxWidth = a.maxWidth, this.content = a.content, this.position = a.position, this.offset = a.offset, this.zIndex = a.zIndex)
        }
    };
    viettel.Marker = function (a) {
        viettel.MVCObject.call(this);
        var b = this, c = new viettel.MarkerImage, d, e = this.isDragable = !1;
        this.basePoint = this.onDropCompleteHandler = this.map = null;
        this.startY = this.startX = 0;
        var f, g = !1, h = !1, i = function () {
            var a = b.get("map"), d = b.get("position");
            return null == a || null == d ? null : a.convertLatLngToOLLonLat(d)
        }, j = function () {
            var a = b.get("draggable");
            VTObjChecker.isBoolean(a) && (e = a);
            e ? (b.set("mousedown", !1), b.set("mouseup", !1), b.set("mousemove", !1), b.registerEvent("mousedown", k)) : d.events.unregister("mousedown",
                d, k)
        }, k = function (a) {
            VTUtil.standardizeEvent(a);
            1 == a.which && (tmpEventSetter.removeEvent(viettel.VTObjType.Map, "mouseup"), tmpEventSetter.removeEvent(viettel.VTObjType.Map, "click"), clickable = h = !1, b.reDrawMarker(a))
        }, m = function () {
            b.get("clickable") ? d.icon.imageDiv.style.cursor = "pointer" : b.set("draggable", b.get("draggable"))
        };
        this.getMap = function () {
            return this.get("map")
        };
        this.setMap = function (a) {
            this.setOptions({map: a})
        };
        this.getPosition = function () {
            return this.get("position")
        };
        this.setPosition = function (a) {
            this.setOptions({position: a})
        };
        this.getVisible = function () {
            return d.onScreen()
        };
        this.setVisible = function (a) {
            this.setOptions({visible: a})
        };
        this.getIcon = function () {
            return this.get("icon")
        };
        this.setIcon = function (a) {
            this.setOptions({icon: a})
        };
        this.setZIndex = function (a) {
            this.setOptions({zIndex: a})
        };
        this.getZIndex = function () {
            return parseInt(d.icon.imageDiv.style.zIndex)
        };
        this.getTitle = function () {
            return this.get("title")
        };
        this.setTitle = function (a) {
            return this.set("title", a)
        };
        this.setDraggable = function (a) {
            this.setOptions({draggable: a})
        };
        this.setOptions = function (a) {
            if (VTObjChecker.isLatLngObj(a.position) && (this.set("position", a.position), g)) {
                d.lonlat = i();
                var e = i();
                null != e && (e = b.get("map").getOriginalObj().getLayerPxFromLonLat(e), d.draw(e))
            }
            if (VTObjChecker.isObject(a.icon) || VTObjChecker.isString(a.icon))this.set("icon", a.icon), g && c.setImage(this.get("icon"), d.icon);
            if (VTObjChecker.isMapObj(a.map))this.set("map", a.map), f = b.get("map").getMarkerDefault(); else if ("undefined" != typeof a.map && null == a.map && null != this.get("map")) {
                this.set("map",
                    {});
                g = !1;
                f.removeMarker(d);
                d.erase();
                return
            }
            VTObjChecker.isBoolean(a.visible) && (this.set("visible", a.visible), g && d.display(this.get("visible")));
            VTObjChecker.isNumber(a.zIndex) && (this.set("zIndex", a.zIndex), g && (d.icon.imageDiv.style.zIndex = this.get("zIndex").toString()));
            VTObjChecker.isBoolean(a.clickable) && (this.set("clickable", a.clickable), g && m());
            VTObjChecker.isBoolean(a.draggable) && (this.set("draggable", a.draggable), g && j());
            VTObjChecker.isString(a.title) && this.set("title", a.title);
            g || g || (a = i(),
            null != a && (e = null, null != b.get("icon") && (e = c.setImage(b.get("icon"))), d = new OpenLayers.Marker.Label(a, e), d.display(b.get("visible")), null != b.get("zIndex") && (d.icon.imageDiv.style.zIndex = b.get("zIndex").toString()), m(), j(), l(), f.addMarker(d), g = !0));
            this.set("mousedown", !0);
            this.set("mouseup", !0);
            this.set("mousemove", !0)
        };
        this.getLayer = function () {
            return f
        };
        this.reDrawMarker = function (a) {
            var c = parseInt(a.pageX), e = parseInt(a.pageY), a = d.icon.px, f = new viettel.Point(a.x, a.y), g = this, i = !1, k = viettel.Events.addDomListener(document,
                "mousemove", function (a) {
                    i = !0;
                    tmpEventSetter.removeEvent(viettel.VTObjType.Marker, "click");
                    if (VTObjChecker.isPointObj(f)) {
                        var d = a.pageX + f.x - c, k = a.pageY + f.y - e;
                        g.moveTo(new viettel.Point(d, k));
                        a = new viettel.MouseEvent(a, g.get("map"), {
                            x: d + g.get("map").getOriginalObj().layerContainerDiv.offsetLeft,
                            y: k + g.get("map").getOriginalObj().layerContainerDiv.offsetTop
                        }, g);
                        b.setPosition(a.latLng);
                        h || viettel.Events.trigger(g, "dragstart", a);
                        viettel.Events.trigger(g, "drag", a);
                        h = !0
                    }
                }), j = viettel.Events.addDomListener(document,
                "mouseup", function (a) {
                    var d = a.pageX + f.x - c, l = a.pageY + f.y - e;
                    viettel.Events.removeListener(k);
                    viettel.Events.removeListener(j);
                    i && (a = new viettel.MouseEvent(a, g.get("map"), {
                        x: d + g.get("map").getOriginalObj().layerContainerDiv.offsetLeft,
                        y: l + g.get("map").getOriginalObj().layerContainerDiv.offsetTop
                    }, g.get("map")), b.setPosition(a.latLng), h = !1, viettel.Events.trigger(g, "dragend", a));
                    setTimeout(function () {
                        clickable = !0;
                        g.set("mousedown", !0);
                        g.set("mouseup", !0);
                        g.set("mousemove", !0)
                    }, 20);
                    setTimeout(function () {
                        tmpEventSetter.restoreEvent(viettel.VTObjType.Map,
                            "mouseup");
                        tmpEventSetter.restoreEvent(viettel.VTObjType.Map, "click");
                        tmpEventSetter.restoreEvent(viettel.VTObjType.Marker, "click")
                    }, 20)
                })
        };
        this.registerEvent = function (a, b) {
            d.events.register(a, d, b)
        };
        this.unregister = function (a, b) {
            "undefined" == typeof b || null == b ? d.events.remove(a, d) : d.events.unregister(a, d, b)
        };
        this.removeEvent = function (a) {
            d.events.remove(a)
        };
        this.moveTo = function (a) {
            d.moveTo(new OpenLayers.Pixel(a.x, a.y))
        };
        this.getDraggable = function () {
            return this.get("draggable")
        };
        this.getClickable = function () {
            return this.get("clickable")
        };
        this.setClickable = function (a) {
            this.setOptions({clickable: a})
        };
        this.setCursor = function () {
        };
        this.getCursor = function () {
        };
        this.getOriginalObj = function () {
            return d
        };
        var l = function () {
            var a = b.get("map");
            null != a && (d.events.register("click", d, function (d) {
                OpenLayers.Event.stop(d);
                tmpEventSetter.checkEvent(viettel.VTObjType.Marker, "click") || (d = new viettel.MouseEvent(d, a, {
                    x: d.pageX - a.getMapConfig().mapPosition.left,
                    y: d.pageY - a.getMapConfig().mapPosition.top
                }, b), clickHandler.call({evt: d, instance: b}, function (a,
                                                                          d) {
                    d ? viettel.Events.triggerHandlerWapper(b, "dblclick", a.evt) : viettel.Events.triggerHandlerWapper(b, "click", a.evt)
                }))
            }), d.events.register("dblclick", d, function (a) {
                OpenLayers.Event.stop(a)
            }))
        };
        null == a && (a = {});
        null == a.clickable && (a.clickable = !0);
        null == a.visible && (a.visible = !0);
        b.setOptions(a)
    };
    viettel.Marker.prototype = new viettel.MVCObject;
    viettel.Marker.prototype.constructor = viettel.Marker;
    viettel.MarkerOptions = function () {
        this.icon;
        this.map;
        this.position;
        this.title;
        this.visible;
        this.zIndex;
        this.draggable
    };
    viettel.MarkerImage = function (a, b, c, d, e) {
        this.scaledSize = e;
        this.anchor = d;
        this.url = a;
        this.setImage = function (a, b) {
            if (!VTObjChecker.isObject(a) && !VTObjChecker.isString(a))return !1;
            if (VTObjChecker.isString(a))return null != b && b.setUrl(a), new OpenLayers.Icon(a, {
                w: 21,
                h: 25
            }, {x: -10.5, y: -25});
            var d, c, e;
            d = null != a.url ? a.url : OpenLayers.Util.getImageLocation("marker.png");
            c = null != a.scaledSize ? {w: a.scaledSize.width, h: a.scaledSize.height} : {w: 21, h: 25};
            e = null != a.anchor ? {x: -c.w + a.anchor.x, y: -c.h + a.anchor.y} : {
                x: -c.w /
                2, y: -c.h
            };
            if (null != b)b.url = d, b.size = c, b.offset = e, b.draw(); else return new OpenLayers.Icon(d, c, e)
        }
    };
    viettel.LabelMarker = function (a) {
        viettel.Marker.call(this, a);
        var b = this.getOriginalObj();
        this.overrideSetOptions = this.setOptions;
        this.setOptions = function (a) {
            this.overrideSetOptions(a);
            null != a.labelClass && b.setLabelClass(a.labelClass);
            null != a.labelContent && b.setLabelContent(a.labelContent);
            null != a.labelAnchor && b.setLabelAnchor(a.labelAnchor);
            null != a.labelVisible && b.setLabelVisible(a.labelVisible)
        };
        this.getLabelContent = function () {
            return b.labelContent
        };
        this.setOptions(a)
    };
    viettel.LabelMarker.prototype = new viettel.Marker;
    viettel.LabelMarker.prototype.constructor = viettel.LabelMarker;
    viettel.Polyline = function (a) {
        viettel.MVCObject.call(this);
        var b = this, c = new OpenLayers.Feature.Vector;
        c.child = this;
        var d, e = null, f = {}, g;
        this.getMap = function () {
            return this.get("map")
        };
        this.setMap = function (a) {
            VTObjChecker.isMapObj(a) ? (this.set("map", a), null != e && (d = this.get("map").getVectorDefault(), d.addFeatures(c), d.drawFeature(c, f))) : "undefined" != typeof a && null == a && (this.set("map", null), k && b.setDrawing(!1), i && b.setEditable(!1), d.removeFeatures(c))
        };
        this.getPath = function () {
            return this.get("path")
        };
        this.setPath =
            function (a) {
                e = a;
                if (null != e) {
                    var a = e, h = b.getMap();
                    if (null != h) {
                        VTObjChecker.isMVCArray(a) && (a = a.getArray());
                        g.components = [];
                        for (var i = 0; i < a.length; i++)g.addPoint(h.convertLatLngToOLPoint(a[i]))
                    }
                    null != this.get("map") && (d = b.get("map").getVectorDefault(), d.addFeatures(c), c.style = f, d.drawFeature(c, f))
                }
            };
        this.setOptions = function (a) {
            null != a && (null != a.clickable && (this.setClickable(a.clickable), this.set("clickable", a.clickable)), null != a.strokeColor && (f.strokeColor = a.strokeColor, this.set("strokeColor", a.strokeColor)),
            null != a.strokeOpacity && (f.strokeOpacity = a.strokeOpacity, this.set("strokeOpacity", a.strokeOpacity)), null != a.strokeWeight && (f.strokeWidth = a.strokeWeight, this.set("strokeWeight", a.strokeWeight)), null != a.zIndex && (f.graphicZIndex = a.graphicZIndex, this.set("graphicZIndex", a.graphicZIndex)), null != a.strokeDashstyle && (f.strokeDashstyle = a.strokeDashstyle, this.set("strokeDashstyle", a.strokeDashstyle)), null != a.map && this.setMap(a.map), null != a.path && this.setPath(a.path), null != this.get("map") && null != e && (c.style =
                f, d.drawFeature(c, f)))
        };
        this.getLength = function () {
            return viettel.GeometryUtil.getLength(this.getPath().getArray())
        };
        this.getBounds = function () {
            if (null == e)return null;
            for (var a = new viettel.LatLngBounds, b = 0; b < e.length; b++)a = a.extend(e[b]);
            return a
        };
        var h, i;
        this.setEditable = function (a) {
            (i = a) ? (i = !0, null == h && (h = new DrawingPolyline(this), h.disableDrawLine(), h.init())) : (i = !1, null != h && (h.disableEditable(), h = null))
        };
        this.getEditable = function () {
            return i
        };
        var j, k = !1;
        this.setDrawing = function (a) {
            a ? (k = !0, null ==
            j && (j = new DrawingPolyline(this), j.init())) : (k = !1, null != j && (j.onCompleDraw(), j = null))
        };
        this.setDrawingState = function () {
            k = !1
        };
        this.getDrawing = function () {
            return k
        };
        this.getVectorLayer = function () {
            return d
        };
        var m;
        this.getClickable = function () {
            return m
        };
        this.setClickable = function (a) {
            if (m = a)f.cursor = "pointer"
        };
        this.getOriginalObj = function () {
            return c
        };
        (function () {
            var a = new viettel.MVCArray;
            g = new OpenLayers.Geometry.LineString;
            c.geometry = g;
            a.setGeometry(g);
            a.setVector(b);
            b.set("path", a)
        })();
        b.setPath([]);
        null ==
        a && (a = {});
        null == a.clickable && (a.clickable = !0);
        VTObjChecker.isObject(a) && b.setOptions(a)
    };
    viettel.Polyline.prototype = new viettel.MVCObject;
    viettel.Polyline.prototype.constructor = viettel.Polyline;
    function PolylineOptions() {
        this.map;
        this.path;
        this.strokeColor;
        this.strokeOpacity;
        this.strokeWeight;
        this.zIndex;
        this.clickable
    }

    viettel.Polygon = function (a) {
        viettel.MVCObject.call(this);
        var b = new OpenLayers.Feature.Vector;
        b.child = this;
        var c, d = {}, e, f = this, g = !1;
        this.getMap = function () {
            return this.get("map")
        };
        this.setMap = function (a) {
            VTObjChecker.isMapObj(a) ? (this.set("map", a), g && (c = this.get("map").getVectorDefault(), c.addFeatures(b), b.style = d, c.drawFeature(b, d))) : null == a && (this.set("map", null), c.removeFeatures(b))
        };
        this.getPath = function () {
            return this.get("paths")[0]
        };
        this.getPaths = function () {
            return this.get("paths")
        };
        this.setPath =
            function (a) {
                VTObjChecker.isMVCArray(a) && (a = a.getArray());
                if (VTObjChecker.isArray(a)) {
                    var b;
                    g ? (b = i(), b[0] = a) : (b = [a], g = !0);
                    h(b)
                }
            };
        this.setPaths = function (a) {
            a = VTObjChecker.isArrayOfMVCArray(a) ? i(a) : VTObjChecker.isTwoDimensionalArray(a) ? a : VTObjChecker.isArray(a) ? [a] : null;
            null != a && (g = !0, h(a))
        };
        var h = function (a) {
            var g = [];
            e.components = [];
            if (0 == a[0].length)g.push(j([])); else for (var h = 0; h < a.length; h++)g.push(j(a[h]));
            f.set("paths", g);
            null != f.get("map") && (c = f.get("map").getVectorDefault(), c.addFeatures(b),
                b.style = d, c.drawFeature(b, d))
        }, i = function (a) {
            null == a && (a = f.get("paths"));
            for (var b = [], d = 0; d < a.length; d++)b.push(a[d].getArray());
            return b
        }, j = function (a) {
            var b = new OpenLayers.Geometry.LinearRing, d = new viettel.MVCArray;
            d.setGeometry(b);
            d.setVector(f);
            d.setArray(a);
            e.components.push(b);
            return d
        };
        this.setOptions = function (a) {
            null != a && (null != a.clickable && this.setClickable(a.clickable), VTObjChecker.isMapObj(a.map) && this.setMap(a.map), null != a.paths && this.setPaths(a.paths), null != a.setClickable && this.setClickable(a.clickable),
            null != a.strokeColor && (d.strokeColor = a.strokeColor), null != a.strokeOpacity && (d.strokeOpacity = a.strokeOpacity), null != a.strokeWeight && (d.strokeWeight = a.strokeWeight), null != a.zIndex && (d.graphicZIndex = a.graphicZIndex), null != a.zIndex && (d.graphicZIndex = a.graphicZIndex), null != a.fillColor && (d.fillColor = a.fillColor), null != a.fillOpacity && (d.fillOpacity = a.fillOpacity), null != this.get("map") && g && (b.style = d, c.drawFeature(b, d)))
        };
        this.containPoint = function (a) {
            return viettel.GeometryUtil.checkPointInPolygon(a, this.getPath().getArray())
        };
        this.getPerimeter = function () {
            for (var a = 0, b = this.getPaths(), d = 0; d < b.length; d++)a += viettel.GeometryUtil.getLength(b[d].getArray());
            return a
        };
        this.getArea = function () {
            return b.geometry.getGeodesicArea()
        };
        this.registerEvent = function () {
        };
        this.callFunctionAfterEvent = function () {
        };
        this.getClickable = function () {
            return this.get("clickable")
        };
        this.setClickable = function (a) {
            this.set("clickable", a);
            a && (d.cursor = "pointer")
        };
        this.getVectorLayer = function () {
            return c
        };
        this.getOriginalObj = function () {
            return b
        };
        e = new OpenLayers.Geometry.Polygon;
        b.geometry = e;
        null == a && (a = {});
        null == a.clickable && (a.clickable = !0);
        null == a.paths && (a.paths = []);
        VTObjChecker.isObject(a) && f.setOptions(a)
    };
    viettel.Polygon.prototype = new viettel.MVCObject;
    viettel.Polygon.prototype.constructor = viettel.Polygon;
    function PolygonOptions() {
        this.map;
        this.path;
        this.strokeColor;
        this.strokeOpacity;
        this.strokeWeight;
        this.zIndex;
        this.clickable;
        this.fillColor;
        this.fillOpacity
    }

    viettel.Circle = function (a) {
        viettel.MVCObject.call(this);
        var b, c, d, e = this, f = {}, g = !1, h = [];
        this.getMap = function () {
            return this.get("map")
        };
        this.setMap = function (a) {
            VTObjChecker.isMapObj(a) ? this.setOptions({map: a}) : "undefined" != typeof a && null == a && (this.set("map", null), d.removeFeatures(c))
        };
        this.setRadius = function (a) {
            null != a && this.setOptions({radius: a})
        };
        this.getRadius = function () {
            return this.get("radius")
        };
        this.setCenter = function (a) {
            VTObjChecker.isLatLngObj(a) && this.setOptions({center: a})
        };
        this.getCenter =
            function () {
                return this.get("center")
            };
        this.getBounds = function () {
            return b.getBounds()
        };
        this.setOptions = function (a) {
            var b = !1;
            null != a.map && this.set("map", a.map);
            VTObjChecker.isLatLngObj(a.center) && this.set("center", a.center);
            null != a.radius && this.set("radius", a.radius);
            null != a.strokeColor && (b = !0, f.strokeColor = a.strokeColor);
            null != a.strokeOpacity && (b = !0, f.strokeOpacity = a.strokeOpacity);
            null != a.strokeWeight && (b = !0, f.strokeWeight = a.strokeWeight);
            null != a.zIndex && (b = !0, f.graphicZIndex = a.graphicZIndex);
            null !=
            a.fillColor && (b = !0, f.fillColor = a.fillColor);
            null != a.fillOpacity && (b = !0, f.fillOpacity = a.fillOpacity);
            null != a.clickable && this.setClickable(a.clickable);
            g ? VTObjChecker.isLatLngObj(a.center) || null != a.radius || null != a.map ? (d.removeFeatures(c), i()) : b && (c.style = f, d.drawFeature(c, f)) : i()
        };
        this.containPoint = function (a) {
            return viettel.GeometryUtil.checkPointInPolygon(a, b.getPointListByLatLng())
        };
        this.getPerimeter = function () {
            return viettel.GeometryUtil.getLength(b.getPointListByLatLng())
        };
        this.getArea = function () {
            return c.geometry.getGeodesicArea()
        };
        var i = function () {
            if (VTObjChecker.isLatLngObj(e.get("center")) && VTObjChecker.isNumber(e.get("radius")) && VTObjChecker.isMapObj(e.get("map"))) {
                b = new GeoCircle(e.get("map"));
                g = !0;
                h = b.getPointList(e.get("center").lat(), e.get("center").lng(), e.get("radius"));
                var a = new OpenLayers.Geometry.Polygon(new OpenLayers.Geometry.LinearRing(h));
                c = new OpenLayers.Feature.Vector(a);
                c.child = e;
                d = e.get("map").getVectorDefault();
                d.addFeatures(c);
                console.log(d);
                c.style = f;
                d.drawFeature(c, f)
            }
        }, j;
        this.getClickable = function () {
            return j
        };
        this.setClickable = function (a) {
            if (j = a)f.cursor = "pointer"
        };
        null == a && (a = {});
        null == a.clickable && (a.clickable = !0);
        VTObjChecker.isObject(a) && e.setOptions(a)
    };
    viettel.Circle.prototype = new viettel.MVCObject;
    viettel.Circle.prototype.constructor = viettel.Circle;
    viettel.CircleOptions = function () {
        this.center;
        this.fillColor;
        this.fillOpacity;
        this.map;
        this.radius;
        this.strokeColor;
        this.strokeOpacity;
        this.strokeWeight;
        this.zIndex
    };
    function GeoCircle(a) {
        var b, c, d, e = [], f, g, h, i, j, k, m, l, n = function (b, d) {
            var e = b / 90 * Math.PI / 2, h = Math.asin(f * j + g * k * Math.cos(e)), h = 180 * h / Math.PI, e = 0 == g ? c : (i - Math.asin(Math.sin(e) * k / g) + Math.PI) % (2 * Math.PI) - Math.PI, e = 180 * e / Math.PI, m = null;
            null != d && d ? m = new viettel.LatLng(h, e) : null != a && (m = a.convertRawLatLngToOLPoint(h, e));
            return m
        };
        this.getPointList = function (a, r, s) {
            b = a;
            c = r;
            d = s;
            h = b * Math.PI / 180;
            f = Math.sin(h);
            g = Math.cos(h);
            i = c * Math.PI / 180;
            m = d / EARTH_RADIUS;
            k = Math.sin(m);
            j = Math.cos(m);
            for (l = 0; 360 >= l; l += 6)a = n(l),
                e.push(a);
            return e
        };
        this.getPointListByLatLng = function () {
            for (var a = [], b = 0; b < e.length; b++)a.push(new viettel.LatLng(e[b].y, e[b].x));
            return a
        };
        this.getBounds = function () {
            var a = n(45, !0), b = n(225, !0);
            return new viettel.LatLngBounds(a, b)
        }
    }

    viettel.MVCArray = function () {
        var a, b;
        this.setGeometry = function (b) {
            a = b
        };
        this.setVector = function (a) {
            b = a
        };
        this.clear = function () {
            a.components = [];
            c()
        };
        this.getArray = function () {
            for (var b = [], c = 0; c < a.components.length; c++)b[c] = new viettel.LatLng(a.components[c].y, a.components[c].x);
            return b
        };
        this.getAt = function (b) {
            b = a.components[b];
            return new viettel.LatLng(b.y, b.x)
        };
        this.getLength = function () {
            return a.components.length
        };
        this.insertAt = function (b, e) {
            a.components.splice(b, 0, new OpenLayers.Geometry.Point(e.lng(),
                e.lat()));
            c()
        };
        this.pop = function () {
            var b = a.components[a.components.length - 1];
            a.components.pop();
            c();
            return new viettel.LatLng(b.y, b.x)
        };
        var c = function () {
            null != b && null != b.get("map") && (a.calculateBounds(), b.getVectorLayer().drawFeature(b.getOriginalObj()))
        };
        this.push = function (b) {
            a.components.push(new OpenLayers.Geometry.Point(b.lng(), b.lat()));
            c()
        };
        this.removeAt = function (b) {
            a.components.splice(b, 1);
            c()
        };
        this.setAt = function (a, b) {
            this.removeAt(a);
            this.insertAt(a, b)
        };
        this.setArray = function (d) {
            if (!(null ==
                a || null == b)) {
                var c = b.getMap();
                if (null != c)for (var f = 0; f < d.length; f++)a.addPoint(c.convertLatLngToOLPoint(d[f]))
            }
        }
    };
    viettel.AdminFeaturesLayer = function (a) {
        var b = [], c = [], d = "#FF0000,#808080,#808000,#0000FF,#4AA02C,#FFA500".split(","), e = new CallbackQueue;
        this.registerLayer = function () {
            viettel.Events.addListenerOnce(a, "idle", function () {
                e.callMethod(g, 500)
            });
            b.push(viettel.Events.addListener(a, "dragend", function () {
                e.callMethod(g, 500)
            }));
            b.push(viettel.Events.addListener(a, "zoom_changed", function () {
                e.callMethod(g, 500)
            }))
        };
        this.removeLayer = function () {
            f();
            for (var a = 0; a < b.length; a++)viettel.Events.removeListener(b[a]);
            b =
                []
        };
        this.setColor = function (a) {
            d = a
        };
        this.getPolygon = function () {
            return c
        };
        var f = function () {
            for (var a = 0; a < c.length; a++)c[a].setMap(null);
            c = []
        }, g = function () {
            (new viettel.AdministrationService).getFeatureFromView(a, function (b, e) {
                f();
                if (b == viettel.AdminStatus.OK)for (var g = e.items, k = 0; k < g.length; k++) {
                    var m = g[k], l = "";
                    null != m.code && (l = m.name);
                    var n = a.getVectorDefault(), m = new viettel.Polygon({
                        paths: m.paths,
                        strokeColor: d[m.colorIndex],
                        strokeOpacity: 1,
                        strokeWeight: 1,
                        fillColor: d[m.colorIndex],
                        fillOpacity: 0.1,
                        clickable: !0,
                        map: a
                    });
                    m.code = l;
                    var o = m.getOriginalObj(), r = o.style;
                    r.label = l;
                    r.fontSize = 10;
                    r.fontOpacity = 1;
                    o.style = r;
                    n.drawFeature(o, r);
                    c.push(m)
                }
            })
        }
    };
    viettel.EventContainer = function () {
        var a = [];
        this.push = function (b) {
            a.push(b)
        };
        this.findById = function (b) {
            for (var c = 0; c < a.length; c++)if (a[c].id == b)return a[c]
        };
        this.removeById = function (b) {
            for (var c = 0; c < a.length; c++)a[c].id == b && a.splice(c, 1)
        };
        this.hasContainEvent = function (b) {
            for (var c = 0; c < a.length; c++)if (a[c].eventName == b)return !0;
            return !1
        };
        this.getHandlersByEvent = function (b, c) {
            for (var d = [], e = 0; e < a.length; e++)a[e].eventName == b && c == a[e].instance && d.push(a[e]);
            return d
        };
        this.removeHandlerByInstance = function (b,
                                                 c) {
            if (null == c)for (var d = a.length - 1; 0 <= d; d--)b == a[d].instance && a.splice(d, 1); else for (d = a.length - 1; 0 <= d; d--)a[d].eventName == c && b == a[d].instance && a.splice(d, 1)
        }
    };
    viettel.Timeout = {};
    viettel.Timeout.TRIGGER_TIMEOUT = 50;
    viettel.Timeout.DRAW_TIMEOUT = 20;
    viettel.Events = function () {
        var a = new viettel.EventContainer, b = 0;
        return {
            addListener: function (c, d, e) {
                var f = {
                    instance: c,
                    eventName: d,
                    id: b,
                    orginalHandler: e
                }, g = new viettel.MapEventListener(b, a, d);
                eventChecker(c, d, e, f);
                a.push(f);
                b++;
                return g
            }, addListenerOnce: function (a, b, e) {
                var f = viettel.Events.addListener(a, b, function (b) {
                    viettel.Events.removeListener(f);
                    e.call(a, b)
                })
            }, addDomListener: function (c, d, e) {
                var f = {
                    instance: c,
                    eventName: d,
                    id: b,
                    handler: e,
                    orginalHandler: e
                }, g = new viettel.MapEventListener(b, a, d);
                a.push(f);
                b++;
                jQuery4Map(c).bind(d, e);
                return g
            }, addDomListenerOnce: function (a, b, e) {
                var f = viettel.Events.addDomListener(a, b, function (a) {
                    viettel.Events.removeListener(f);
                    e(a)
                })
            }, removeListener: function (a) {
                a.remove()
            }, clearListeners: function (b, d) {
                var e = a.getHandlersByEvent(d, b);
                if (null != e)for (var f = 0; f < e.length; f++)eventRemover(b, d, e[f].handler);
                a.removeHandlerByInstance(b, d)
            }, trigger: function () {
                for (var a = arguments[0], b = arguments[1], e = Array.prototype.slice.call(arguments), b = viettel.Events.getEventContainer().getHandlersByEvent(b,
                    a), f = 0; f < b.length; f++)b[f].orginalHandler.apply(a, e.slice(2))
            }, triggerHandlerWapper: function () {
                var a = arguments[0], b = arguments[1], e = Array.prototype.slice.call(arguments), f = viettel.Events.getEventContainer().getHandlersByEvent(b, a);
                setTimeout(function () {
                    for (var b = 0; b < f.length; b++)f[b].handler.apply(a, e.slice(2))
                }, viettel.Timeout.TRIGGER_TIMEOUT)
            }, triggerAsyn: function () {
                for (var a = arguments[0], b = arguments[1], e = Array.prototype.slice.call(arguments), b = viettel.Events.getEventContainer().getHandlersByEvent(b,
                    a), f = 0; f < b.length; f++)b[f].orginalHandler.apply(a, e.slice(2))
            }, stopEvent: function () {
            }, getEventContainer: function () {
                return a
            }
        }
    }();
    function TmpEventSetter() {
        var a = new Hashtable;
        a.put(viettel.VTObjType.Map, new Hashtable);
        a.put(viettel.VTObjType.Marker, new Hashtable);
        this.removeEvent = function (b, c) {
            a.get(b).put(c, "")
        };
        this.restoreEvent = function (b, c) {
            a.get(b).remove(c)
        };
        this.checkEvent = function (b, c) {
            return null != a.get(b).get(c) ? !0 : !1
        }
    }

    var tmpEventSetter = new TmpEventSetter;

    function eventChecker(a, b, c, d) {
        VTObjChecker.isMarkerObj(a) ? a.getMap().getMarkerEvent().registerEvent(b, c, d) : VTObjChecker.isMapObj(a) ? a.getMapEvent().registerEvent(b, c, d) : d.handler = VTObjChecker.isPolylineObj(a) || VTObjChecker.isPolygonObj(a) || VTObjChecker.isCircleObj(a) ? function (d) {
            if ("click" != b || a.getClickable())d.trigger ? c.call(a, d.arg) : (d = new viettel.MouseEvent(d, a.getMap(), {
                x: d.clientX,
                y: d.clientY
            }, a), c.call(a, d))
        } : c
    }

    function argChecker(a, b) {
        return a.trigger ? a.arg : new viettel.MouseEvent(a, b, {x: a.clientX, y: a.clientY})
    }

    function eventRemover(a, b, c) {
        VTObjChecker.isMarkerObj(a) ? "rightclick" == b ? a.unregister("mousedown", c) : a.unregister(b, c) : VTObjChecker.isMapObj(a) ? a.getMapEvent().unregisterEvent(b, c) : VTObjChecker.isNode(a) && jQuery4Map(a).unbind(b, c)
    }

    viettel.MouseEvent = function (a, b, c, d) {
        this.latLng;
        this.pixel;
        null != a && (this.pixel = c, this.latLng = b.fromContainerPixelToLatLng(this.pixel), this.object = d);
        this.getEvt = function () {
            return a
        }
    };
    viettel.MapEventListener = function (a, b) {
        this.id = a;
        this.remove = function () {
            var a = b.findById(this.id);
            null != a && (b.removeById(this.id), eventRemover(a.instance, a.eventName, a.handler))
        }
    };
    viettel.MarkerEvent = function () {
        this.registerEvent = function (a, b, c) {
            var d, e = c.instance;
            "rightclick" == a ? (d = function (d) {
                tmpEventSetter.removeEvent(viettel.VTObjType.Map, "rightclick");
                if (!tmpEventSetter.checkEvent(viettel.VTObjType.Marker, a)) {
                    var c = new viettel.MouseEvent(d, e.getMap(), {x: d.clientX, y: d.clientY}, e);
                    OpenLayers.Event.isRightClick(d) && b.call(e, c)
                }
            }, e.registerEvent("mousedown", d)) : "click" == a || "dblclick" == a ? (d = function (d) {
                if (!tmpEventSetter.checkEvent(viettel.VTObjType.Marker, a) && e.getClickable()) {
                    var c =
                        null, c = d instanceof viettel.MouseEvent ? d : new viettel.MouseEvent(d, e.getMap(), {
                        x: d.clientX,
                        y: d.clientY
                    }, e);
                    b.call(e, c)
                }
            }, c.handler = d) : (d = function (d) {
                if (!(tmpEventSetter.checkEvent(viettel.VTObjType.Marker, a) || "click" == a && !e.getClickable()))if (!("dragstart" == a || "drag" == a || "dragend" == a) || e.getDraggable()) {
                    var c = null, c = d instanceof viettel.MouseEvent ? d : new viettel.MouseEvent(d, e.getMap(), {
                        x: d.clientX,
                        y: d.clientY
                    }, e);
                    b.call(e, c)
                }
            }, e.registerEvent(a, d));
            c.handler = d
        }
    };
    viettel.MapEvent = function (a) {
        var b = a.getCenter();
        this.registerEvent = function (b, d, c) {
            var e;
            "rightclick" == b ? (c.handler = function (c) {
                if (!tmpEventSetter.checkEvent(viettel.VTObjType.Map, b)) {
                    VTUtil.standardizeEvent(c);
                    var e = new viettel.MouseEvent(c, a, {
                        x: c.pageX - a.getMapConfig().mapPosition.left,
                        y: c.pageY - a.getMapConfig().mapPosition.top
                    }, a);
                    OpenLayers.Event.isRightClick(c) && d.call(a, e)
                }
            }, a.getOriginalObj().events.register("mousedown", a.getOriginalObj(), function (a) {
                OpenLayers.Event.isRightClick(a) && tmpEventSetter.restoreEvent(viettel.VTObjType.Map,
                    "rightclick")
            })) : ("zoom_changed" == b ? e = function () {
                tmpEventSetter.checkEvent(viettel.VTObjType.Map, b) || d.call(a)
            } : "mouseover" == b || "mouseout" == b || "mousemove" == b ? (e = function (c) {
                if (!tmpEventSetter.checkEvent(viettel.VTObjType.Map, b)) {
                    VTUtil.standardizeEvent(c);
                    var e = new viettel.MouseEvent(c, a, {
                        x: c.pageX - a.getMapConfig().mapPosition.left,
                        y: c.pageY - a.getMapConfig().mapPosition.top
                    }, a);
                    "mouseout" == b && (e = new viettel.MouseEvent(c, a, {x: c.clientX, y: c.clientY}, a));
                    d.call(a, e)
                }
            }, a.getOriginalObj().events.register(b,
                a.getOriginalObj(), e)) : e = "click" == b || "dblclick" == b ? function (c) {
                tmpEventSetter.checkEvent(viettel.VTObjType.Map, b) || d.call(a, c)
            } : function (c) {
                tmpEventSetter.checkEvent(viettel.VTObjType.Map, b) || (c = new viettel.MouseEvent(c, a, {
                    x: c.layerX,
                    y: c.layerY
                }, a), d.call(a, c))
            }, c.handler = e)
        };
        this.unregisterEvent = function (b, d) {
            "rightclick" == b ? a.getOriginalObj().events.unregister("mousedown", a.getOriginalObj(), d) : "zoom_changed" == b ? a.getOriginalObj().events.unregister("zoomend", a.getOriginalObj(), d) : ("mouseup" == b ||
            "mousedown" == b || "mouseover" == b || "mouseout" == b || "mousemove" == b) && a.getOriginalObj().events.unregister(b, a.getOriginalObj(), d)
        };
        this.callEvent = function () {
        };
        this.init = function () {
            c = new VTClickControl(a);
            a.addControl(c);
            c.activate();
            d = new VTDragControl(a);
            a.addControl(d);
            d.activate();
            e();
            f();
            g();
            h()
        };
        var c, d, e = function () {
                VTUtil.isIEBrowser() || a.getOriginalObj().events.register("click", a.getOriginalObj(), function (b) {
                    tmpEventSetter.checkEvent(viettel.VTObjType.Map, "click") || (VTUtil.standardizeEvent(b), b =
                        new viettel.MouseEvent(b, a, {
                            x: b.pageX - a.getMapConfig().mapPosition.left,
                            y: b.pageY - a.getMapConfig().mapPosition.top
                        }, a), clickHandler.call({evt: b, instance: a}, function (b, d) {
                        d ? viettel.Events.trigger(a, "dblclick", b.evt) : viettel.Events.trigger(a, "click", b.evt)
                    }))
                })
            }, f = function () {
                a.getOriginalObj().events.register("zoomend", a.getOriginalObj(), function () {
                    var d = a.getCenter();
                    viettel.Events.trigger(a, "zoom_changed");
                    viettel.Events.trigger(a, "bounds_changed");
                    d.equals(b) || viettel.Events.trigger(a, "center_changed")
                })
            },
            g = function () {
                jQuery4Map(window).resize(function () {
                    viettel.Events.trigger(a, "resize")
                });
                viettel.Events.addListener(a, "resize", function () {
                    a.getOriginalObj().updateSize();
                    a.getOriginalObj().calculateBounds();
                    a.getMapConfig().mapPosition = jQuery4Map(a.getDiv()).offset();
                    for (var b = 0; b < a.controls.length; b++)a.controls[b].reDraw();
                    null != a.getZoomControl() && a.getZoomControl().update()
                })
            }, h = function () {
                viettel.Events.addListenerOnce(a, "idle", function () {
                    a.loadedMap = !0
                })
            }
    };
    function VectorEventController(a, b) {
        var c = null, d, e, f;
        (function () {
            e = new OpenLayers.Control.SelectFeature([b], {
                clickout: !1,
                toggle: !1,
                multiple: !1,
                hover: !0,
                toggleKey: "ctrlKey",
                multipleKey: "shiftKey"
            });
            a.getOriginalObj().addControl(e);
            e.activate();
            b.events.on({
                featureselected: function (b) {
                    var d = e.handlers.feature.evt.xy, f = a.fromContainerPixelToLatLng(d), d = {pixel: d, latLng: f};
                    c = b.feature.child;
                    viettel.Events.triggerAsyn(c, "mouseover", d)
                }, featureunselected: function (a) {
                    a = a.feature.child;
                    c = null;
                    viettel.Events.triggerAsyn(a,
                        "mouseout")
                }
            })
        })();
        (function () {
            f = new (OpenLayers.Class(OpenLayers.Control, {
                initialize: function (e, f) {
                    OpenLayers.Control.prototype.initialize.apply(this, [f]);
                    this.handler = new OpenLayers.Handler.Feature(this, e, {
                        click: this.click,
                        dblclick: this.dblclick,
                        stopDouble: !0,
                        stopSingle: !0
                    });
                    this.handler.mouseup = function (e) {
                        VTUtil.standardizeEvent(e);
                        d = new viettel.MouseEvent(e, a, {
                            x: e.pageX - a.getMapConfig().mapPosition.left,
                            y: e.pageY - a.getMapConfig().mapPosition.top
                        }, b);
                        if (null == c)return !0;
                        OpenLayers.Event.isRightClick(d.getEvt()) &&
                        viettel.Events.trigger(c, "rightclick", d);
                        viettel.Events.trigger(c, "mouseup", d);
                        return !1
                    };
                    this.handler.mousedown = function (e) {
                        VTUtil.standardizeEvent(e);
                        d = new viettel.MouseEvent(e, a, {
                            x: e.pageX - a.getMapConfig().mapPosition.left,
                            y: e.pageY - a.getMapConfig().mapPosition.top
                        }, b);
                        if (null == c)return !0;
                        viettel.Events.trigger(c, "mousedown", d);
                        return !1
                    }
                }
            }))(b, {
                click: function (b) {
                    clickHandler.call({evt: d, instance: b.child}, function (b, d) {
                        b.instance.getClickable() ? d ? viettel.Events.trigger(b.instance, "dblclick", b.evt) :
                            viettel.Events.trigger(b.instance, "click", b.evt) : d ? viettel.Events.trigger(a, "dblclick", b.evt) : viettel.Events.trigger(a, "click", b.evt)
                    })
                }
            });
            a.getOriginalObj().addControl(f);
            f.activate()
        })()
    }

    viettel.ClickHandler = function () {
        var a, b = !0, c;
        this.call = function (d, e) {
            b ? (c = d.evt, e(d), b = !1, a = setTimeout(function () {
                b = !0;
                clearTimeout(a);
                a = null
            }, 300)) : 15 > Math.abs(c.pixel.x - d.evt.pixel.x) && 15 > Math.abs(c.pixel.y - d.evt.pixel.y) ? (clearTimeout(a), a = null, b = !0, e(d, !0)) : (c = d.evt, e(d), b = !1, a = setTimeout(function () {
                b = !0;
                clearTimeout(a);
                a = null
            }, 300))
        }
    };
    var clickHandler = new viettel.ClickHandler;
    viettel.ControlPosition = {
        TOP_LEFT: 0,
        TOP_CENTER: 1,
        TOP_RIGHT: 2,
        LEFT_TOP: 3,
        RIGHT_TOP: 4,
        LEFT_CENTER: 5,
        RIGHT_CENTER: 6,
        LEFT_BOTTOM: 7,
        RIGHT_BOTTOM: 8,
        BOTTOM_LEFT: 9,
        BOTTOM_CENTER: 10,
        BOTTOM_RIGHT: 11
    };
    viettel.ControlArray = function (a) {
        var b = [], c = [];
        this.push = function (a) {
            c.push(a);
            a = this.createDiv(a);
            this.calDivPos(a);
            a = this.createCtrElement(a);
            a.index = b.length;
            b.push(a);
            return a.index
        };
        this.insertAt = function (a, e) {
            if (!(e > b.length))if (e == b.length)this.push(a); else {
                for (var f = [], g = c.length - 1; g >= e; g--)f.push(c[g]), this.removeAt(g);
                this.push(a);
                for (g = 0; g < f.length; g++)this.push(f[g])
            }
        };
        this.getIndex = function (a) {
            for (var b = 0; b < c.length; b++)if (a == c[b])return b;
            return -1
        };
        this.reDraw = function () {
            for (var a = [],
                     e = 0; e < c.length; e++)a.push(c[e]);
            for (e = b.length - 1; 0 <= e; e--)this.removeAt(e);
            for (e = 0; e < a.length; e++)this.push(a[e])
        };
        this.pop = function () {
            b.pop();
            c.pop()
        };
        this.removeAt = function (a) {
            b.splice(a, 1);
            c.splice(a, 1)
        };
        this.getLength = function () {
            return b.length
        };
        this.calDivPos = function () {
        };
        this.createCtrElement = function () {
        };
        this.getControlArray = function () {
            return b
        };
        this.createDiv = function (b) {
            var c = document.createElement("DIV");
            c.style.position = "absolute";
            c.style.width = "auto";
            c.style.height = "auto";
            c.appendChild(b);
            c.style.zIndex = CONTROL_ZINDEX;
            a.getDiv().appendChild(c);
            return c
        }
    };
    viettel.BottomLeftElement = function (a, b) {
        viettel.ControlArray.call(this, b);
        this.offsetLeft = 10;
        this.offsetWidth = this.offsetRight;
        this.offsetBottom = 10;
        this.createCtrElement = function (a) {
            var b = {};
            a.style.left = this.offsetLeft + "px";
            a.style.bottom = this.offsetBottom + "px";
            b.div = a;
            b.offsetLeft = this.offsetLeft;
            b.offsetBottom = this.offsetBottom;
            b.offsetHeight = b.offsetBottom + jQuery4Map(a).height();
            b.offsetWidth = b.offsetLeft + jQuery4Map(a).width();
            return b
        };
        this.removeAtBase = this.removeAt;
        this.removeAt = function (c) {
            b.getDiv().removeChild(this.getControlArray()[c].div);
            var d;
            if (c == this.getControlArray().length - 1)d = this.getControlArray()[c].offsetWidth - this.getControlArray()[c].offsetLeft, this.offsetLeft = 0 != c ? this.offsetLeft - d : 10, this.removeAtBase(c); else {
                d = this.getControlArray()[c].offsetWidth - this.getControlArray()[c].offsetLeft + a.paddingWidth;
                this.offsetWidth -= d;
                for (this.removeAtBase(c); c < this.getControlArray().length; c++)this.getControlArray()[c].offsetLeft -= d, this.getControlArray()[c].offsetWidth -= d, this.getControlArray()[c].div.style.left = this.getControlArray()[c].offsetLeft +
                "px"
            }
        }
    };
    viettel.BottomLeftElement.prototype = new viettel.ControlArray;
    viettel.BottomLeftElement.constructor = viettel.BottomLeftElement;
    viettel.BottomRightElement = function (a, b) {
        viettel.ControlArray.call(this, b);
        this.offsetBottom = this.offsetWidth = this.offsetRight = 10;
        this.createCtrElement = function (a) {
            var b = {};
            a.style.right = this.offsetRight + "px";
            a.style.bottom = this.offsetBottom + "px";
            b.div = a;
            b.offsetRight = this.offsetRight;
            b.offsetBottom = this.offsetBottom;
            b.offsetHeight = b.offsetBottom + jQuery4Map(a).height();
            b.offsetWidth = b.offsetRight + jQuery4Map(a).width();
            return b
        };
        this.removeAtBase = this.removeAt;
        this.removeAt = function (c) {
            b.getDiv().removeChild(this.getControlArray()[c].div);
            var d;
            if (c == this.getControlArray().length - 1)d = this.getControlArray()[c].offsetWidth - this.getControlArray()[c].offsetRight, this.offsetRight = 0 != c ? this.offsetRight - d : 10, this.removeAtBase(c); else {
                d = this.getControlArray()[c].offsetWidth - this.getControlArray()[c].offsetRight + a.paddingWidth;
                this.offsetWidth -= d;
                for (this.removeAtBase(c); c < this.getControlArray().length; c++)this.getControlArray()[c].offsetRight -= d, this.getControlArray()[c].offsetWidth -= d, this.getControlArray()[c].div.style.right = this.getControlArray()[c].offsetRight +
                "px"
            }
        }
    };
    viettel.BottomRightElement.prototype = new viettel.ControlArray;
    viettel.BottomRightElement.constructor = viettel.BottomRightElement;
    viettel.TopLeftElement = function (a, b) {
        viettel.ControlArray.call(this, b);
        this.offsetTop = this.offsetWidth = this.offsetLeft = 10;
        this.createCtrElement = function (a) {
            var b = {};
            a.style.left = this.offsetLeft + "px";
            a.style.top = this.offsetTop + "px";
            b.div = a;
            b.offsetLeft = this.offsetLeft;
            b.offsetTop = this.offsetTop;
            b.offsetHeight = b.offsetTop + jQuery4Map(a).height();
            b.offsetWidth = b.offsetLeft + jQuery4Map(a).width();
            return b
        };
        this.removeAtBase = this.removeAt;
        this.removeAt = function (c) {
            b.getDiv().removeChild(this.getControlArray()[c].div);
            var d;
            if (c == this.getControlArray().length - 1)d = this.getControlArray()[c].offsetWidth - this.getControlArray()[c].offsetRight, this.offsetWidth -= d, this.offsetLeft = 0 != c ? this.offsetLeft - d : 10, this.removeAtBase(c); else {
                d = this.getControlArray()[c].offsetWidth - this.getControlArray()[c].offsetLeft + a.paddingWidth;
                this.offsetWidth -= d;
                for (this.removeAtBase(c); c < this.getControlArray().length; c++)this.getControlArray()[c].offsetLeft -= d, this.getControlArray()[c].offsetWidth -= d, this.getControlArray()[c].div.style.left =
                    this.getControlArray()[c].offsetLeft + "px"
            }
        }
    };
    viettel.TopLeftElement.prototype = viettel.ControlArray();
    viettel.TopLeftElement.constructor = viettel.TopLeftElement;
    viettel.TopRightElement = function (a, b) {
        viettel.ControlArray.call(this, b);
        this.offsetTop = this.offsetWidth = this.offsetRight = this.offsetTop = this.offsetWidth = this.offsetRight = 10;
        this.createCtrElement = function (a) {
            var b = {};
            a.style.right = this.offsetRight + "px";
            a.style.top = this.offsetTop + "px";
            b.div = a;
            b.offsetRight = this.offsetRight;
            b.offsetTop = this.offsetTop;
            b.offsetHeight = b.offsetTop + jQuery4Map(a).height();
            b.offsetWidth = b.offsetRight + jQuery4Map(a).width();
            return b
        };
        this.removeAtBase = this.removeAt;
        this.removeAt =
            function (c) {
                b.getDiv().removeChild(this.getControlArray()[c].div);
                var d;
                if (c == this.getControlArray().length - 1)d = this.getControlArray()[c].offsetWidth - this.getControlArray()[c].offsetRight, this.offsetWidth = this.offsetWidth - d - a.paddingWidth, 0 == c && (this.offsetRight = 10), this.removeAtBase(c); else {
                    d = this.getControlArray()[c].offsetWidth - this.getControlArray()[c].offsetRight + a.paddingWidth;
                    this.offsetWidth -= d;
                    for (this.removeAtBase(c); c < this.getControlArray().length; c++)this.getControlArray()[c].offsetRight -=
                        d, this.getControlArray()[c].offsetWidth -= d, this.getControlArray()[c].div.style.right = this.getControlArray()[c].offsetRight + "px"
                }
            }
    };
    viettel.TopRightElement.prototype = new viettel.ControlArray;
    viettel.TopRightElement.constructor = viettel.TopRightElement;
    viettel.TopLeftControl = function (a, b) {
        viettel.TopLeftElement.call(this, a, b);
        this.calDivPos = function (b) {
            b = jQuery4Map(b).width();
            0 != this.getLength() && (this.offsetLeft = this.offsetWidth + a.paddingWidth);
            this.offsetWidth = this.offsetLeft + b
        };
        var c = this.push;
        this.push = function (b) {
            b = c.call(this, b);
            a[viettel.ControlPosition.LEFT_TOP].reDraw();
            return b
        };
        var d = this.removeAt;
        this.removeAt = function (b) {
            d.call(this, b);
            a[viettel.ControlPosition.LEFT_TOP].reDraw()
        }
    };
    viettel.TopLeftControl.prototype = viettel.TopLeftElement();
    viettel.TopLeftControl.constructor = viettel.TopLeftControl;
    viettel.LeftTopControl = function (a, b) {
        viettel.TopLeftElement.call(this, a, b);
        this.offsetLeft = 10;
        var c = this;
        this.calDivPos = function (b) {
            jQuery4Map(b).width();
            var e = jQuery4Map(b).height();
            if (0 != this.getLength())this.offsetTop = this.offsetHeight; else {
                var b = jQuery4Map(b).width() + a.paddingWidth, f = 10, g = a[viettel.ControlPosition.TOP_LEFT], h = g.getLength();
                if (0 != h) {
                    for (var i = 0; i < h; i++) {
                        var j = g.getControlArray()[i];
                        if (b > j.offsetLeft) {
                            f < j.offsetHeight && (f = j.offsetHeight);
                            break
                        }
                    }
                    c.offsetTop = f
                }
            }
            this.offsetTop += a.paddingHeight;
            this.offsetHeight = this.offsetTop + e
        };
        this.removeAt = function (d) {
            b.getDiv().removeChild(this.getControlArray()[d].div);
            var c;
            if (d == this.getControlArray().length - 1)c = this.getControlArray()[d].offsetHeight - this.getControlArray()[d].offsetTop, this.offsetHeight -= c, this.offsetTop = 0 != d ? this.offsetTop - c : 10, this.removeAtBase(d); else {
                c = this.getControlArray()[d].offsetHeight - this.getControlArray()[d].offsetTop + a.paddingHeight;
                this.offsetHeight -= c;
                for (this.removeAtBase(d); d < this.getControlArray().length; d++)this.getControlArray()[d].offsetTop -=
                    c, this.getControlArray()[d].div.style.top = this.getControlArray()[d].offsetTop + "px"
            }
        }
    };
    viettel.LeftTopControl.prototype = new viettel.TopLeftElement;
    viettel.LeftTopControl.constructor = viettel.LeftTopControl;
    viettel.TopRightControl = function (a, b) {
        viettel.TopRightElement.call(this, a, b);
        this.calDivPos = function (b) {
            b = jQuery4Map(b).width();
            0 != this.getLength() && (this.offsetRight = this.offsetWidth + a.paddingWidth);
            this.offsetWidth = this.offsetRight + b
        };
        var c = this.push;
        this.push = function (b) {
            b = c.call(this, b);
            a[viettel.ControlPosition.RIGHT_TOP].reDraw();
            return b
        };
        var d = this.removeAt;
        this.removeAt = function (b) {
            d.call(this, b);
            a[viettel.ControlPosition.RIGHT_TOP].reDraw()
        }
    };
    viettel.TopRightControl.prototype = new viettel.ControlArray;
    viettel.TopRightControl.constructor = viettel.TopRightElement;
    viettel.RightTopControl = function (a, b) {
        viettel.TopRightElement.call(this, a, b);
        this.offsetRight = 10;
        var c = this;
        this.calDivPos = function (b) {
            jQuery4Map(b).width();
            var e = jQuery4Map(b).height();
            if (0 != this.getLength())this.offsetTop = this.offsetHeight; else {
                var b = jQuery4Map(b).width() + a.paddingWidth, f = 10, g = a[viettel.ControlPosition.TOP_RIGHT], h = g.getLength();
                if (0 != h) {
                    for (var i = 0; i < h; i++) {
                        var j = g.getControlArray()[i];
                        b > j.offsetRight && f < j.offsetHeight && (f = Math.max(j.offsetHeight, f))
                    }
                    c.offsetTop = f
                }
            }
            this.offsetTop +=
                a.paddingHeight;
            this.offsetHeight = this.offsetTop + e
        };
        this.removeAt = function (d) {
            b.getDiv().removeChild(this.getControlArray()[d].div);
            var c;
            if (d == this.getControlArray().length - 1)c = this.getControlArray()[d].offsetHeight - this.getControlArray()[d].offsetTop, this.offsetHeight -= c, this.offsetTop = 0 != d ? this.offsetTop - c : 10, this.removeAtBase(d); else {
                c = this.getControlArray()[d].offsetHeight - this.getControlArray()[d].offsetTop + a.paddingHeight;
                this.offsetTop -= c;
                this.offsetHeight -= c;
                for (this.removeAtBase(d); d < this.getControlArray().length; d++)this.getControlArray()[d].offsetTop -=
                    c, this.getControlArray()[d].div.style.top = this.getControlArray()[d].offsetTop + "px"
            }
        }
    };
    viettel.RightTopControl.prototype = new viettel.TopRightElement;
    viettel.RightTopControl.constructor = viettel.RightTopControl;
    viettel.BottomLeftControl = function (a, b) {
        viettel.BottomLeftElement.call(this, a, b);
        this.calDivPos = function (b) {
            b = jQuery4Map(b).width();
            0 != this.getLength() && (this.offsetLeft = this.offsetWidth + a.paddingWidth);
            this.offsetWidth = this.offsetLeft + b
        };
        this.pushAtBase = this.push;
        this.push = function (b) {
            this.pushAtBase(b);
            a[viettel.ControlPosition.LEFT_BOTTOM].reDraw()
        };
        var c = this.removeAt;
        this.removeAt = function (b) {
            c.call(this, b);
            a[viettel.ControlPosition.LEFT_BOTTOM].reDraw()
        }
    };
    viettel.BottomLeftControl.prototype = new viettel.BottomLeftElement;
    viettel.BottomLeftControl.constructor = viettel.BottomLeftControl;
    viettel.LeftBottomControl = function (a, b) {
        viettel.BottomLeftElement.call(this, a, b);
        this.offsetBottom = 10;
        var c = this;
        this.calDivPos = function (b) {
            jQuery4Map(b).width();
            var e = jQuery4Map(b).height();
            if (0 != this.getLength())this.offsetBottom = this.offsetHeight; else {
                var b = jQuery4Map(b).width() + a.paddingWidth, f = 10, g = a[viettel.ControlPosition.BOTTOM_LEFT], h = g.getLength();
                if (0 != h) {
                    for (var i = 0; i < h; i++) {
                        var j = g.getControlArray()[i];
                        if (b > j.offsetLeft) {
                            f < j.offsetHeight && (f = j.offsetHeight);
                            break
                        }
                    }
                    c.offsetBottom = f
                }
            }
            this.offsetBottom +=
                a.paddingHeight;
            this.offsetHeight = this.offsetBottom + e
        };
        this.removeAt = function (c) {
            b.getDiv().removeChild(this.getControlArray()[c].div);
            var e;
            if (c == this.getControlArray().length - 1)e = this.getControlArray()[c].offsetHeight - this.getControlArray()[c].offsetTop, this.offsetHeight -= e, this.offsetBottom = 0 != c ? this.offsetBottom - e : 10, this.removeAtBase(c); else {
                e = this.getControlArray()[c].offsetHeight - this.getControlArray()[c].offsetBottom + a.paddingHeight;
                this.offsetHeight -= e;
                for (this.removeAtBase(c); c < this.getControlArray().length; c++)this.getControlArray()[c].offsetBottom -=
                    e, this.getControlArray()[c].div.style.bottom = this.getControlArray()[c].offsetBottom + "px"
            }
        }
    };
    viettel.LeftBottomControl.prototype = new viettel.BottomLeftElement;
    viettel.LeftBottomControl.constructor = viettel.LeftBottomControl;
    viettel.BottomRightControl = function (a, b) {
        viettel.BottomRightElement.call(this, a, b);
        this.calDivPos = function (b) {
            b = jQuery4Map(b).width();
            0 != this.getLength() && (this.offsetRight = this.offsetWidth + a.paddingWidth);
            this.offsetWidth = this.offsetRight + b
        };
        this.pushAtBase = this.push;
        this.push = function (b) {
            this.pushAtBase(b);
            a[viettel.ControlPosition.RIGHT_BOTTOM].reDraw()
        };
        var c = this.removeAt;
        this.removeAt = function (b) {
            c.call(this, b);
            a[viettel.ControlPosition.RIGHT_BOTTOM].reDraw()
        }
    };
    viettel.BottomRightControl.prototype = new viettel.BottomRightElement;
    viettel.BottomRightControl.constructor = viettel.BottomRightControl;
    viettel.RightBottomControl = function (a, b) {
        viettel.BottomRightElement.call(this, a, b);
        this.offsetRight = 10;
        var c = this;
        this.calDivPos = function (b) {
            jQuery4Map(b).width();
            var e = jQuery4Map(b).height();
            if (0 != this.getLength())this.offsetBottom = this.offsetHeight; else {
                var b = jQuery4Map(b).width() + a.paddingWidth, f = 10, g = a[viettel.ControlPosition.BOTTOM_RIGHT], h = g.getLength();
                if (0 != h) {
                    for (var i = 0; i < h; i++) {
                        var j = g.getControlArray()[i];
                        if (b > j.offsetRight) {
                            f < j.offsetHeight && (f = j.offsetHeight);
                            break
                        }
                    }
                    c.offsetBottom = f
                }
            }
            this.offsetBottom +=
                a.paddingHeight;
            this.offsetHeight = this.offsetBottom + e
        };
        this.removeAt = function (c) {
            b.getDiv().removeChild(this.getControlArray()[c].div);
            var e;
            if (c == this.getControlArray().length - 1)e = this.getControlArray()[c].offsetHeight - this.getControlArray()[c].offsetBottom, this.offsetHeight -= e, this.offsetBottom = 0 != c ? this.offsetBottom - e : 10, this.removeAtBase(c); else {
                e = this.getControlArray()[c].offsetHeight - this.getControlArray()[c].offsetBottom + a.paddingHeight;
                this.offsetHeight -= e;
                for (this.removeAtBase(c); c < this.getControlArray().length; c++)this.getControlArray()[c].offsetBottom -=
                    e, this.getControlArray()[c].div.style.bottom = this.getControlArray()[c].offsetBottom + "px"
            }
        }
    };
    viettel.RightBottomControl.prototype = new viettel.BottomRightElement;
    viettel.RightBottomControl.constructor = viettel.RightBottomControl;
    viettel.BottomCenterControl = function (a, b) {
        viettel.ControlArray.call(this, b);
        null != b && (this.offsetLeft = b.getSize().width / 2);
        this.offsetWidth = this.offsetRight;
        this.offsetBottom = 10;
        this.createCtrElement = function (a) {
            var b = {};
            a.style.left = this.offsetLeft + "px";
            a.style.bottom = this.offsetBottom + "px";
            b.div = a;
            b.offsetLeft = this.offsetLeft;
            b.offsetBottom = this.offsetBottom;
            b.offsetHeight = b.offsetBottom + jQuery4Map(a).height();
            b.offsetWidth = b.offsetLeft + jQuery4Map(a).width();
            return b
        };
        this.getNewOffsetLeft = function (c) {
            var d =
                this.getControlArray(), c = 0 != d.length ? d[d.length - 1].div.offsetWidth + a.paddingWidth + c : c;
            return this.offsetLeft = b.getSize().width / 2 - c / 2
        };
        this.resetOffsetLeft = function (b) {
            for (var d = this.getControlArray(), b = this.getNewOffsetLeft(jQuery4Map(b).width()), e = 0; e < d.length; e++) {
                var f = d[e];
                f.div.style.left = b + "px";
                f.offsetLeft = b;
                f.offsetWidth = b + f.div.offsetWidth;
                this.offsetLeft = f.offsetLeft;
                this.offsetWidth = f.offsetWidth;
                b = f.offsetWidth + a.paddingWidth
            }
        };
        this.calDivPos = function (b) {
            this.resetOffsetLeft(b);
            b = jQuery4Map(b).width();
            0 != this.getLength() && (this.offsetLeft = this.offsetWidth + a.paddingWidth);
            this.offsetWidth = this.offsetLeft + b + a.paddingWidth
        };
        this.removeAtBase = this.removeAt;
        this.removeAt = function (c) {
            b.getDiv().removeChild(this.getControlArray()[c].div);
            var d = this.getControlArray()[c].offsetWidth - this.getControlArray()[c].offsetLeft + a.paddingWidth;
            this.removeAtBase(c);
            this.offsetLeft -= d;
            for (var e = c; e < this.getControlArray().length; e++)this.getControlArray()[c].offsetLeft -= d, this.getControlArray()[c].div.style.left = this.getControlArray()[c].offsetLeft +
            "px"
        }
    };
    viettel.BottomCenterControl.prototype = new viettel.ControlArray;
    viettel.BottomCenterControl.constructor = viettel.BottomCenterControl;
    viettel.TopCenterControl = function (a, b) {
        viettel.BottomCenterControl.call(this, a, b);
        this.offsetTop = 10;
        this.createCtrElement = function (a) {
            var b = {};
            a.style.left = this.offsetLeft + "px";
            a.style.top = this.offsetTop + "px";
            b.div = a;
            b.offsetLeft = this.offsetLeft;
            b.offsetTop = this.offsetTop;
            b.offsetHeight = b.offsetTop + jQuery4Map(a).height();
            b.offsetWidth = b.offsetLeft + jQuery4Map(a).width();
            return b
        };
        this.calDivPos = function (b) {
            this.resetOffsetLeft(b);
            b = jQuery4Map(b).width();
            0 != this.getLength() && (this.offsetLeft = this.offsetWidth +
            a.paddingWidth);
            this.offsetWidth = this.offsetLeft + b + a.paddingWidth
        }
    };
    viettel.TopCenterControl.prototype = new viettel.BottomCenterControl;
    viettel.TopCenterControl.constructor = viettel.TopCenterControl;
    viettel.LeftCenterControl = function (a, b) {
        viettel.ControlArray.call(this, b);
        null != b && (this.offsetTop = b.getSize().height / 2);
        this.offsetHeight = this.offsetTop;
        this.offsetLeft = 10;
        this.createCtrElement = function (a) {
            var b = {};
            a.style.left = this.offsetLeft + "px";
            a.style.top = this.offsetTop + "px";
            b.div = a;
            b.offsetTop = this.offsetTop;
            b.offsetHeight = b.offsetTop + jQuery4Map(a).height();
            b.offsetWidth = jQuery4Map(a).width();
            return b
        };
        this.getNewOffsetTop = function (c) {
            var d = this.getControlArray(), c = 0 != d.length ? d[d.length - 1].div.offsetHeight +
            a.paddingHeight + c : c;
            return this.offsetTop = b.getSize().height / 2 - c / 2
        };
        this.resetOffsetTop = function (b) {
            for (var d = this.getControlArray(), b = this.getNewOffsetTop(jQuery4Map(b).height()), e = 0; e < d.length; e++) {
                var f = d[e];
                f.div.style.top = b + "px";
                f.offsetTop = b;
                f.offsetHeight = b + f.div.offsetHeight;
                this.offsetTop = f.offsetTop;
                this.offsetHeight = f.offsetHeight;
                b = f.offsetHeight + a.paddingHeight
            }
        };
        this.calDivPos = function (b) {
            this.resetOffsetTop(b);
            b = jQuery4Map(b).height();
            0 != this.getLength() && (this.offsetTop = this.offsetHeight +
            a.paddingHeight);
            this.offsetHeight = this.offsetTop + b + a.paddingHeight
        };
        this.removeAtBase = this.removeAt;
        this.removeAt = function (c) {
            b.getDiv().removeChild(this.getControlArray()[c].div);
            var d = this.getControlArray()[c].offsetHeight - this.getControlArray()[c].offsetTop + a.paddingHeight;
            this.removeAtBase(c);
            this.offsetTop -= d;
            for (var e = c; e < this.getControlArray().length; e++)this.getControlArray()[c].offsetTop -= d, this.getControlArray()[c].div.style.top = this.getControlArray()[c].offsetTop + "px"
        }
    };
    viettel.LeftCenterControl.prototype = new viettel.ControlArray;
    viettel.LeftCenterControl.constructor = viettel.LeftCenterControl;
    viettel.RightCenterControl = function (a, b) {
        viettel.LeftCenterControl.call(this, a, b);
        this.offsetRight = 10;
        this.createCtrElement = function (a) {
            var b = {};
            a.style.right = this.offsetRight + "px";
            a.style.top = this.offsetTop + "px";
            b.div = a;
            b.offsetTop = this.offsetTop;
            b.offsetHeight = b.offsetTop + jQuery4Map(a).height();
            b.offsetWidth = jQuery4Map(a).width();
            return b
        }
    };
    viettel.RightCenterControl.prototype = new viettel.LeftCenterControl;
    viettel.RightCenterControl.constructor = viettel.RightCenterControl;
    viettel.GeoObjType = {
        ALL: 0,
        GAS_STATION: 1,
        CAR_SERVICE: 2,
        ATM: 3,
        BANK: 4,
        EDUCATION: 5,
        HEALTHCARE: 6,
        ENTERTAINMENT: 7,
        GOVERNMENT: 8,
        RECREATION: 9,
        SERVICE: 10,
        BUILDING: 11,
        SHOPPING: 12,
        SIGHT: 13,
        TRANSPORTATION: 14,
        COMMITTEE: 15,
        ROAD: 16,
        OTHER: 17
    };
    viettel.GeoServiceItem = function () {
        this.id = 0;
        this.tourismInfo = this.description = this.email = this.fax = this.phone = this.website = this.type = this.address = this.name = this.location = null;
        this.hasImage = !1;
        this.getImageLink = function (a) {
            return null != this.hasImage && this.hasImage && null != this.id && 0 < this.id ? VTUtil.getImageURL(this.id, a) : null
        }
    };
    viettel.GeoServiceStatus = {};
    viettel.GeoServiceStatus.OK = 0;
    viettel.GeoServiceStatus.INVALID_REQUEST = 1;
    viettel.GeoServiceStatus.REQUEST_DENIED = 2;
    viettel.GeoServiceStatus.UNKNOWN_ERROR = 3;
    viettel.GeoServiceStatus.ZERO_RESULTS = 4;
    viettel.GeoServiceStatus.ERROR = 5;
    viettel.GeoServiceStatus.MAX_POINTS_EXCEEDED = 6;
    viettel.GeoServiceCallback = function (a, b) {
        var c;
        this.onGetAddrComplete = function (c, e) {
            var f = null;
            if (c == viettel.GeoServiceStatus.OK) {
                var g = new viettel.GeoServiceItem;
                g.id = 0;
                g.location = b;
                g.name = e;
                g.address = e;
                g.type = viettel.GeoObjType.ALL;
                g.website = "";
                g.phone = "";
                g.fax = "";
                g.email = "";
                g.description = "";
                g.tourismInfo = "";
                g.hasImage = !1;
                f = [];
                f.push(g)
            }
            a({items: f, total: null != f ? f.length : 0}, c)
        };
        this.onGetMultiAddrComplete = function (c, e) {
            var f = [];
            if (c == viettel.GeoServiceStatus.OK)for (var g = 0; g < e.addresses.length; g++) {
                var h =
                    e.addresses[g], i = new viettel.GeoServiceItem;
                i.id = 0;
                i.location = null;
                VTObjChecker.isArray(b) && (i.location = b[g]);
                i.name = h.address;
                i.address = h.address;
                i.type = viettel.GeoObjType.ALL;
                i.website = "";
                i.phone = "";
                i.fax = "";
                i.email = "";
                i.description = "";
                i.tourismInfo = "";
                i.hasImage = !1;
                f.push(i)
            }
            a({items: f, total: null != f ? f.length : 0}, c)
        };
        this.onGeocodeComplete = function (b, c) {
            if (b == viettel.RoutingStatus.OK && (b == viettel.GeoServiceStatus.OK && VTObjChecker.isString(c) && (c = (new OpenLayers.Format.JSON).read(c)), VTObjChecker.isObject(c) &&
                VTObjChecker.isObject(c.items)))for (var f = c.items.length, g = 0; g < f; g++) {
                var h = c.items[g], i = new viettel.GeoServiceItem;
                i.id = h.id;
                i.location = VTUtil.decryptPoint(h.location);
                i.name = h.name;
                i.address = h.address;
                i.type = h.type;
                i.website = h.website;
                i.phone = h.phone;
                i.fax = h.fax;
                i.email = h.email;
                i.description = h.description;
                i.tourismInfo = h.tourismInfo;
                i.hasImage = h.hasImage;
                c.items[g] = i
            }
            a(c, b)
        };
        this.getPreRequest = function () {
            return c
        };
        this.setPreRequest = function (a) {
            c = a
        };
        this.onRoutingComplete = function (b, e) {
            if (b == viettel.RoutingStatus.OK &&
                (VTObjChecker.isString(e) && (e = (new OpenLayers.Format.JSON).read(e)), VTObjChecker.isObject(e))) {
                e.preRequest = c;
                e.path = null != e.algo && e.algo == viettel.RoutingAlgoType.Osrm ? VTUtil.decodePoints(e.path, 5) : VTUtil.decryptPoints(e.path);
                if (VTObjChecker.isObject(e.alternative_geometries))for (var f = e.alternative_geometries.length, g = 0; g < f; g++)e.alternative_geometries[g] = null != e.algo && e.algo == viettel.RoutingAlgoType.Osrm ? VTUtil.decodePoints(e.alternative_geometries[g], 5) : VTUtil.decryptPoints(e.alternative_geometries[g]);
                if (!VTObjChecker.isObject(e.bounds)) {
                    f = e.path;
                    e.bounds = new viettel.LatLngBounds;
                    for (g = 0; g < e.path.length; g++)e.bounds.extendEx(e.path[g])
                }
                if (null == e.algo && VTObjChecker.isObject(e.directions)) {
                    e.directions.splice(0, 0, {
                        turn: viettel.RoutingTurn.HEAD_ON,
                        name: e.directions[0].name,
                        distance: 0,
                        duration: 0,
                        roundAbout: !1,
                        instruction: null,
                        index: 0
                    });
                    for (g = 0; g < e.directions.length - 1; g++)e.directions[g].name = e.directions[g + 1].name, e.directions[g].distance = e.directions[g + 1].distance;
                    e.directions[e.directions.length -
                    1].distance = 0;
                    for (g = 1; g < e.directions.length; g++) {
                        f = e.directions[g].turn;
                        switch (f) {
                            case viettel.RoutingTurnOld.HEAD_ON:
                                f = viettel.RoutingTurn.HEAD_ON;
                                break;
                            case viettel.RoutingTurnOld.GO_AHEAD:
                                f = viettel.RoutingTurn.GO_AHEAD;
                                break;
                            case viettel.RoutingTurnOld.LEFT_LANE:
                                f = viettel.RoutingTurn.LEFT_LANE;
                                break;
                            case viettel.RoutingTurnOld.RIGHT_LANE:
                                f = viettel.RoutingTurn.RIGHT_LANE;
                                break;
                            case viettel.RoutingTurnOld.TURN_LEFT:
                                f = viettel.RoutingTurn.TURN_LEFT;
                                break;
                            case viettel.RoutingTurnOld.TURN_RIGHT:
                                f = viettel.RoutingTurn.TURN_RIGHT;
                                break;
                            case viettel.RoutingTurnOld.TWIST_LEFT:
                                f = viettel.RoutingTurn.TWIST_LEFT;
                                break;
                            case viettel.RoutingTurnOld.TWIST_RIGHT:
                                f = viettel.RoutingTurn.TWIST_RIGHT;
                                break;
                            case viettel.RoutingTurnOld.TURN_BACK:
                                f = viettel.RoutingTurn.TURN_BACK;
                                break;
                            case viettel.RoutingTurnOld.TO_DESTINATION:
                                f = viettel.RoutingTurn.TO_DESTINATION
                        }
                        e.directions[g].turn = f
                    }
                }
                for (g = 0; g < e.directions.length; g++) {
                    var h = e.directions[g].index;
                    e.directions[g].duration = 0;
                    e.directions[g].location = e.path[h]
                }
                if (VTObjChecker.isObject(e.alternative_geometries) &&
                    VTObjChecker.isObject(e.alternative_instructions))for (var i = 0; i < e.alternative_instructions.length; i++)for (var j = e.alternative_instructions[i], f = e.alternative_geometries[i], g = 0; g < j.length; g++)h = j[g].index, j[g].duration = 0, j[g].location = f[h];
                e.start_location = e.path[0];
                e.start_address = e.directions[0].start_address;
                VTObjChecker.isStringEmpty(e.start_address) && (e.start_address = e.directions[0].name);
                e.end_location = e.path[e.path.length - 1];
                e.end_address = e.directions[e.directions.length - 1].end_address;
                VTObjChecker.isStringEmpty(e.end_address) &&
                (e.end_address = e.directions[e.directions.length - 1].name)
            }
            a(e, b)
        }
    };
    GeoServiceObj = {};
    viettel.GeoService = function () {
        this.offset = 0;
        this.limit = 10;
        var a = this;
        this.setOffset = function (a) {
            this.offset = a
        };
        this.setLimit = function (a) {
            this.limit = a
        };
        this.getAddress = function (a, b) {
            if (VTObjChecker.isLatLngObj(a)) {
                var c;
                c = urlServer + geoprocessingService + "?f=getaddr" + ("&pt=" + a.toUrlValue());
                var d = "GeoServiceObj." + VTUtil.randomString(8) + "_" + VTUtil.getTimeStamp(), e = new viettel.GeoServiceCallback(b, a);
                window.geoCallback = e;
                eval(d + "= geoCallback;");
                VTUtil.loadURL(c, d + ".onGetAddrComplete")
            } else VTUtil.throwVTError("Input is empty")
        };
        this.getAddresses = function (a, b) {
            if (VTObjChecker.isObject(a)) {
                var c;
                c = urlServer + geoprocessingService + "?f=getmultiaddr";
                for (var d = "", e = 0; e < a.length; e++)d += a[e].toUrlValue(), e < a.length - 1 && (d += ";");
                c += "&pt=" + d;
                d = "GeoServiceObj." + VTUtil.randomString(8) + "_" + VTUtil.getTimeStamp();
                e = new viettel.GeoServiceCallback(b, a);
                window.geoCallback = e;
                eval(d + "= geoCallback;");
                VTUtil.loadURL(c, d + ".onGetMultiAddrComplete")
            } else VTUtil.throwVTError("Input is empty")
        };
        var b = function (b, c) {
            if (VTObjChecker.isString(b)) {
                var d;
                d = urlServer + geocodeService + ("?t=" + encodeURIComponent(b));
                d += "&off=" + a.offset;
                d += "&lm=" + a.limit;
                var e = "GeoServiceObj." + VTUtil.randomString(8) + "_" + VTUtil.getTimeStamp(), f = new viettel.GeoServiceCallback(c);
                window.geoCallback = f;
                eval(e + "= geoCallback;");
                VTUtil.loadURL(d, e + ".onGeocodeComplete")
            } else VTUtil.throwVTError("Input is empty")
        }, c = function (b, c, d, e) {
            !VTObjChecker.isLatLngObj(b) && 0 < c && (!VTObjChecker.isNumber(d) || !VTObjChecker.isObject(d)) && null != callback ? VTUtil.throwVTError("Input is invalid") : (b =
                urlServer + geoprocessingService + "?f=search" + ("&pt=" + b.toUrlValue()), b += "&t=" + a.typesToURL(d), b = b + ("&r=" + c) + ("&off=" + a.offset), b += "&lm=" + a.limit, c = "GeoServiceObj." + VTUtil.randomString(8) + "_" + VTUtil.getTimeStamp(), e = new viettel.GeoServiceCallback(e), window.geoCallback = e, eval(c + "= geoCallback;"), VTUtil.loadURL(b, c + ".onGeocodeComplete"))
        }, d = function (b, c, d, e, f) {
            !VTObjChecker.isLatLngObj(b) && 0 < c && (!VTObjChecker.isNumber(d) || !VTObjChecker.isObject(d)) && null != callback ? VTUtil.throwVTError("Input is invalid") :
                (b = urlServer + geoprocessingService + "?f=search" + ("&pt=" + b.toUrlValue()), b += "&t=" + a.typesToURL(d), b += "&r=" + c, VTObjChecker.isString(e) && (b += "&text=" + encodeURIComponent(e)), b += "&off=" + a.offset, b += "&lm=" + a.limit, c = "GeoServiceObj." + VTUtil.randomString(8) + "_" + VTUtil.getTimeStamp(), f = new viettel.GeoServiceCallback(f), window.geoCallback = f, eval(c + "= geoCallback;"), VTUtil.loadURL(b, c + ".onGeocodeComplete"))
        }, e = function (b, c, d) {
            !VTObjChecker.isLatLngBoundObj(b) && (!VTObjChecker.isNumber(c) || !VTObjChecker.isObject(c)) &&
            null != callback ? VTUtil.throwVTError("Input is invalid") : (b = urlServer + geoprocessingService + "?f=bsearch" + ("&b=" + b.toUrlValue()), b += "&t=" + a.typesToURL(c), b += "&off=" + a.offset, b += "&lm=" + a.limit, c = "GeoServiceObj." + VTUtil.randomString(8) + "_" + VTUtil.getTimeStamp(), d = new viettel.GeoServiceCallback(d), window.geoCallback = d, eval(c + "= geoCallback;"), VTUtil.loadURL(b, c + ".onGeocodeComplete"))
        }, f = function (b, c, d, e) {
            !VTObjChecker.isLatLngBoundObj(b) && (!VTObjChecker.isNumber(c) || !VTObjChecker.isObject(c)) && null != callback ?
                VTUtil.throwVTError("Input is invalid") : (b = urlServer + geoprocessingService + "?f=bsearch" + ("&b=" + b.toUrlValue()), b += "&t=" + a.typesToURL(c), VTObjChecker.isString(d) && (b += "&text=" + encodeURIComponent(d)), b += "&off=" + a.offset, b += "&lm=" + a.limit, c = "GeoServiceObj." + VTUtil.randomString(8) + "_" + VTUtil.getTimeStamp(), e = new viettel.GeoServiceCallback(e), window.geoCallback = e, eval(c + "= geoCallback;"), VTUtil.loadURL(b, c + ".onGeocodeComplete"))
        };
        this.typesToURL = function (a) {
            var b = "0";
            if (VTObjChecker.isObject(a) && 0 < a.length)for (var b =
                "", c = 0; c < a.length; c++)0 < c && (b += ","), b += a[c];
            return b
        };
        this.getLocations = function (a, h, i, j, k) {
            VTObjChecker.isString(a) ? (callback = h, b(a, h)) : VTObjChecker.isLatLngBoundObj(a) ? VTObjChecker.isObject(j) && null != j ? (callback = j, f(a, h, i, j)) : (callback = i, e(a, h, i)) : VTObjChecker.isLatLngObj(a) ? VTObjChecker.isObject(k) && null != k ? (d(a, h, i, j, k), callback = k) : (c(a, h, i, j), callback = j) : VTUtil.throwVTError("Input is invalid")
        }
    };
    viettel.RoutingAlgoType = {PgRouting: 0, PgRouting_Ex: 1, Osrm: 2};
    viettel.TravelMode = {WALKING: 0, MOTOR: 1, CAR: 2, LORRY: 3};
    viettel.RoutingResult = function () {
        this.bounds;
        this.directions;
        this.path;
        this.waypoint_order;
        this.length
    };
    viettel.RoutingItem = function () {
        this.turn;
        this.name;
        this.distance;
        this.duration;
        this.roundAbout;
        this.instruction;
        this.index;
        this.location
    };
    viettel.RoutingStatus = {};
    viettel.RoutingStatus.INVALID_REQUEST = 1;
    viettel.RoutingStatus.OK = 0;
    viettel.RoutingStatus.REQUEST_DENIED = 2;
    viettel.RoutingStatus.UNKNOWN_ERROR = 3;
    viettel.RoutingStatus.ZERO_RESULTS = 4;
    viettel.RoutingStatus.ERROR = 5;
    viettel.RoutingStatus.MAX_WAYPOINTS_EXCEEDED = 6;
    viettel.RoutingStatus.NOT_FOUND = 7;
    viettel.RoutingStatus.OVER_QUERY_LIMIT = 8;
    viettel.RoutingTurn = {
        HEAD_ON: 10,
        GO_AHEAD: 1,
        LEFT_LANE: 8,
        RIGHT_LANE: 2,
        TURN_LEFT: 7,
        TURN_RIGHT: 3,
        TWIST_LEFT: 6,
        TWIST_RIGHT: 4,
        TURN_BACK: 5,
        TO_DESTINATION: 17
    };
    viettel.RoutingTurnOld = {
        HEAD_ON: 9,
        GO_AHEAD: 0,
        LEFT_LANE: 1,
        RIGHT_LANE: 2,
        TURN_LEFT: 3,
        TURN_RIGHT: 4,
        TWIST_LEFT: 5,
        TWIST_RIGHT: 6,
        TURN_BACK: 7,
        TO_DESTINATION: 8
    };
    viettel.RoutingRequest = function () {
        this.destination;
        this.origin;
        this.travelMode;
        this.provideRouteAlternatives;
        this.wayPoints
    };
    viettel.RoutingService = function () {
        this.route = function (a, b) {
            if (!VTObjChecker.isLatLngObj(a.origin) || !VTObjChecker.isLatLngObj(a.destination))VTUtil.throwVTError("Input is invalid"); else {
                var c;
                c = urlServer + routingService + ("?sp=" + a.origin.toUrlValue());
                c += "&ep=" + a.destination.toUrlValue();
                c += "&tt=" + a.travelMode;
                c += "&at=1";
                if (VTObjChecker.isObject(a.wayPoints)) {
                    var d = "";
                    0 != a.wayPoints.length && (d = "&wp=");
                    for (var e = 0; e < a.wayPoints.length; e++)0 < e && (d += ";"), d += a.wayPoints[e].toUrlValue();
                    c += d
                }
                VTObjChecker.isBoolean(a.provideRouteAlternatives) &&
                (c += "&alt=" + a.provideRouteAlternatives);
                d = "GeoServiceObj." + VTUtil.randomString(8) + "_" + VTUtil.getTimeStamp();
                e = new viettel.GeoServiceCallback(b);
                e.setPreRequest(a);
                window.routingCallback = e;
                eval(d + "= routingCallback;");
                VTUtil.loadURL(c, d + ".onRoutingComplete")
            }
        }
    };
    viettel.RoutingRender = function (a) {
        viettel.MVCObject.call(this);
        var b = this, c = null, d = new viettel.RoutingService, e = null, f = null, g = new viettel.RoutingReporter(function (a) {
            null != b.mvcObj.itemClickCallback && b.mvcObj.itemClickCallback(a);
            b.zoomTo(a, g.getInstructionItem(a))
        }, function (a) {
            var b = f.path;
            f.path = f.alternative_geometries[a];
            f.alternative_geometries[a] = b;
            b = f.directions;
            f.directions = f.alternative_instructions[a];
            f.alternative_instructions[a] = b;
            b = f.length;
            f.length = f.alternative_summaries[a].total_distance;
            f.alternative_summaries[a].total_distance = b;
            b = f.time;
            f.time = f.alternative_summaries[a].total_time;
            f.alternative_summaries[a].total_time = b;
            a = f.path;
            f.bounds = new viettel.LatLngBounds;
            for (b = 0; b < f.path.length; b++)pt = f.path[b], f.bounds.extendEx(f.path[b]);
            f.start_location = f.path[0];
            f.start_address = f.directions[0].start_address;
            VTObjChecker.isStringEmpty(f.start_address) && (f.start_address = f.directions[0].name);
            f.end_location = f.path[a.length - 1];
            f.end_address = f.directions[f.directions.length - 1].end_address;
            VTObjChecker.isStringEmpty(f.end_address) && (f.end_address = f.directions[f.directions.length - 1].name);
            p(f, viettel.RoutingStatus.OK)
        }), h = null, i = null, j = [], k = null, m = null, l = null, n = 0, o = [], r = null, s = null, u = null;
        this.setRoutingRequest = function (a) {
            q();
            e = a;
            null != e && t()
        };
        this.setOptions = function (a) {
            x(a, !1);
            this.setRoutingRequest(e)
        };
        this.onItemClickCallback = function (a) {
            null != a && (this.mvcObj.itemClickCallback = a)
        };
        this.zoomTo = function (a, c) {
            if (null != f) {
                var d = f.directions[a];
                b.mvcObj.map.setCenter(d.location);
                b.mvcObj.infoWindow &&
                A(c, d.location);
                var d = d.location, e = this.mvcObj.map;
                w();
                r = new viettel.Marker({
                    position: d,
                    map: e,
                    icon: {
                        url: OpenLayersEX_ImgLoc + "dot_blink.gif",
                        scaledSize: new viettel.Size(10, 10),
                        anchor: new viettel.Point(5, 5)
                    }
                })
            }
        };
        this.clear = function () {
            q();
            f = null
        };
        this.onRoutingCompleteCallback = function (a) {
            c = a
        };
        var q = function () {
                w();
                null != k && (k.setMap(null), k = null);
                null != m && (m.setMap(null), m = null);
                null != l && (l.setMap(null), l = null);
                n = 0;
                z = !1;
                for (var a = 0; a < o.length; a++)o[a].setMap(null), o[a] = null;
                o = [];
                null != i && (i.setMap(null),
                    i = null);
                y();
                null != b.mvcObj.mainPanel && (b.mvcObj.mainPanel.innerHTML = "");
                null != b.mvcObj.alternativePanel && (b.mvcObj.alternativePanel.innerHTML = "");
                null != h && (h.close(), h = null)
            }, t = function () {
                v();
                D = null;
                null != l && (l.setMap(null), l = null);
                z = !1;
                e.travelMode = b.get("travelMode");
                e.provideRouteAlternatives = b.get("showAlternativeRoute");
                d.route(e, function (a, b) {
                    p(a, b);
                    null != c && c(b)
                })
            }, p = function (a, c) {
                f = c == viettel.RoutingStatus.OK ? a : null;
                q();
                g.setRoutingResult(f);
                C();
                null != f && null != f.path && (i = new viettel.Polyline(b.mvcObj.polylineOptions),
                    i.setPath(f.path), i.setMap(b.mvcObj.map));
                b.get("hideMarker") || B();
                b.get("fitBound") && null != f && b.get("map").fitBounds(f.bounds)
            }, C = function () {
                null != b.mvcObj.mainPanel && jQuery4Map(b.mvcObj.mainPanel).html(g.getReportHTML());
                if (b.get("showAlternativeRoute") && b.get("alternativePanel") && null != f && null != f.alternative_geometries && 0 < f.alternative_geometries.length) {
                    jQuery4Map(b.mvcObj.alternativePanel).html(g.getAlternativeSummary());
                    for (var a = f.alternative_geometries.length, c = 0; c < a; c++)jQuery4Map("#alterNativeItem" +
                    c).hover(function (a) {
                        a = parseInt(a.currentTarget.value);
                        y();
                        if (b.get("showAlternativeRoute") && VTObjChecker.isObject(f.alternative_geometries))for (var c = f.alternative_geometries.length, d = 0; d < c; d++)if (-1 == a) {
                            var e = new viettel.Polyline(b.mvcObj.alternativePolylineOptions);
                            e.setPath(f.alternative_geometries[d]);
                            e.setMap(b.mvcObj.map);
                            j.push(e)
                        } else a == d && (e = new viettel.Polyline(b.mvcObj.alternativePolylineOptions), e.setPath(f.alternative_geometries[d]), e.setMap(b.mvcObj.map), j.push(e))
                    }, function () {
                        y()
                    })
                }
            },
            y = function () {
                for (var a = 0; a < j.length; a++)null != j[a] && (j[a].setMap(null), j[a] = null);
                j = []
            }, w = function () {
                null != r && r.setMap(null);
                r = null
            }, B = function () {
                var a = {};
                null != b.mvcObj.draggable && (a.draggable = b.mvcObj.draggable);
                if (null != f && (a.map = b.get("map"), a.position = f.start_location, a.icon = new viettel.MarkerImage(OpenLayersEX_ImgLoc + "start_point.png", null, null, null, new viettel.Size(30, 30)), k = new viettel.Marker(a), viettel.Events.addListener(k, "click", function () {
                        A(f.start_address, k)
                    }), viettel.Events.addListener(k,
                        "dragend", function () {
                            e.origin = k.getPosition();
                            t()
                        }), a.position = f.end_location, a.icon = new viettel.MarkerImage(OpenLayersEX_ImgLoc + "destination_point.png", null, null, null, new viettel.Size(30, 30)), m = new viettel.Marker(a), viettel.Events.addListener(m, "click", function () {
                        A(f.end_address, m)
                    }), viettel.Events.addListener(m, "dragend", function () {
                        e.destination = m.getPosition();
                        t()
                    }), o = [], b.get("showAlternativeRoute") && null != e && null != e.wayPoints))for (a = 0; a < e.wayPoints.length; a++) {
                    var c = {};
                    c.icon = new viettel.MarkerImage(OpenLayersEX_ImgLoc +
                    "middle_point.png", null, null, new viettel.Point(6, 6), new viettel.Size(12, 12));
                    var d = viettel.GeometryUtil.distancePointToPoly(e.wayPoints[a], f.path);
                    c.position = d.pt;
                    c.map = b.get("map");
                    c.draggable = !0;
                    c = new viettel.Marker(c);
                    c.setTitle(a);
                    G(c);
                    o.push(c)
                }
            }, A = function (a, c) {
                null != h && h.close();
                h = new viettel.InfoWindow;
                h.setContent(a);
                h.open(b.mvcObj.map, c)
            }, v = function () {
                if (null != b.mvcObj.mainPanel) {
                    var a = OpenLayersEX_ImgLoc + "waiting.gif";
                    jQuery4Map(b.mvcObj.mainPanel).html('<div class="route_report_list" align="center"><img border="0" src="' +
                    a + '"><br>' + viettel.Language.RoutingRenderer.routeWaitingValue + "</div>")
                }
                null != b.mvcObj.alternativePanel && jQuery4Map(b.mvcObj.alternativePanel).html("")
            }, x = function (a, c) {
                VTObjChecker.isObject(a.map) && b.set("map", a.map);
                VTObjChecker.isObject(a.mainPanel) && b.set("mainPanel", a.mainPanel);
                VTObjChecker.isNumber(a.travelMode) ? b.set("travelMode", a.travelMode) : c && b.set("travelMode", viettel.TravelMode.MOTOR);
                VTObjChecker.isBoolean(a.fitBound) ? b.set("fitBound", a.fitBound) : c && b.set("fitBound", !0);
                VTObjChecker.isBoolean(a.draggable) ?
                    b.set("draggable", a.draggable) : c && b.set("draggable", a.draggable);
                VTObjChecker.isBoolean(a.hideMarker) ? b.set("hideMarker", a.hideMarker) : c && b.set("hideMarker", !1);
                VTObjChecker.isBoolean(a.hideInfoWindow) ? b.set("infoWindow", a.hideInfoWindow) : c && b.set("infoWindow", !0);
                VTObjChecker.isObject(a.polylineOptions) ? b.set("polylineOptions", a.polylineOptions) : c && b.set("polylineOptions", {
                    strokeColor: "#0000FF",
                    strokeOpacity: 0.4,
                    strokeWeight: 6,
                    clickable: !0
                });
                VTObjChecker.isObject(a.alternativePanel) && b.set("alternativePanel",
                    a.alternativePanel);
                VTObjChecker.isBoolean(a.showAlternativeRoute) ? b.set("showAlternativeRoute", a.showAlternativeRoute) : c && b.set("showAlternativeRoute", !1);
                VTObjChecker.isObject(a.alternativePolylineOptions) ? b.set("alternativePolylineOptions", a.alternativePolylineOptions) : c && b.set("alternativePolylineOptions", {
                    strokeColor: "#0000FF",
                    strokeOpacity: 0.4,
                    strokeWeight: 4,
                    clickable: !0
                });
                VTObjChecker.isBoolean(a.enableWayPoints) ? b.set("enableWayPoints", a.enableWayPoints) : c && b.set("enableWayPoints", !1);
                null !=
                s && (viettel.Events.removeListener(s), s = null);
                u && (viettel.Events.removeListener(u), u = null);
                b.get("enableWayPoints") && (s = viettel.Events.addListener(b.get("map"), "mousemove", function (a) {
                    F(a)
                }))
            }, z = !1, D = null, F = function (a) {
                if (VTObjChecker.isObject(f) && VTObjChecker.isObject(f.path)) {
                    var c = a.pixel;
                    if (!(null != D && 5 > E(D, c)) && (D = new viettel.Point(c.x, c.y), !z)) {
                        null != l && (l.setMap(null), l = null);
                        var d = viettel.GeometryUtil.distancePointToPoly(a.latLng, f.path);
                        if (null != d) {
                            var a = d.pt, g = b.get("map").fromLatLngToContainerPixel(a),
                                h = E(g, c);
                            if (25 > h) {
                                if (null != o && 0 < o.length)for (g = 0; g < o.length; g++)if (h = b.get("map").fromLatLngToContainerPixel(o[g].getPosition()), h = E(h, c), 25 > h)return;
                                n = 0;
                                if (null != e && null != e.wayPoints)for (g = 0; g < e.wayPoints.length; g++)if (c = viettel.GeometryUtil.distancePointToPoly(e.wayPoints[g], f.path), d.index < c.index) {
                                    n = g;
                                    break
                                }
                                c = {};
                                c.icon = new viettel.MarkerImage(OpenLayersEX_ImgLoc + "middle_point.png", null, null, new viettel.Point(6, 6), new viettel.Size(12, 12));
                                c.position = a;
                                c.map = b.get("map");
                                c.draggable = !0;
                                l = new viettel.Marker(c);
                                viettel.Events.addListener(l, "click", function () {
                                    z = !0
                                });
                                viettel.Events.addListener(l, "dragstart", function () {
                                    z = !0
                                });
                                viettel.Events.addListener(l, "mousedown", function () {
                                    z = !0
                                });
                                viettel.Events.addListener(l, "dragend", function () {
                                    var a = null;
                                    null != l && (a = l.getPosition(), l.setMap(null), l = null);
                                    z = !1;
                                    null != a && null != e && (null == e.wayPoints ? (e.wayPoints = [], e.wayPoints.push(a)) : e.wayPoints.splice(n, 0, a), t())
                                });
                                z = !1
                            }
                        }
                    }
                }
            }, G = function (a) {
                viettel.Events.addListener(a, "dragend", function () {
                    var b = parseInt(a.getTitle());
                    0 <=
                    b && b < e.wayPoints.length && (e.wayPoints[b] = a.getPosition(), t())
                });
                viettel.Events.addListener(a, "dblclick", function () {
                    var b = parseInt(a.getTitle());
                    if (0 <= b && b < e.wayPoints.length) {
                        for (var c = [], d = 0; d < e.wayPoints.length; d++)d != b && c.push(e.wayPoints[d]);
                        e.wayPoints = c;
                        t()
                    }
                })
            }, E = function (a, b) {
                return (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y)
            };
        x(a, !0)
    };
    viettel.RoutingRender.prototype = new viettel.MVCObject;
    viettel.RoutingRender.prototype.constructor = viettel.RoutingRender;
    viettel.RoutingRenderOptions = function () {
    };
    viettel.RoutingReporter = function (a, b) {
        var c = null, d = null, e = [], f = [], g = [], h = "instructionClickCallbackName_" + VTUtil.randomString(8) + "_" + VTUtil.getTimeStamp();
        window._instructionClickCallback = a;
        eval(h + "= _instructionClickCallback;");
        var i = "alternativeClickCallbackName_" + VTUtil.randomString(8) + "_" + VTUtil.getTimeStamp();
        window._alternativeClickCallback = b;
        eval(i + "= _alternativeClickCallback;");
        this.setRoutingResult = function (a) {
            d = null;
            c = a
        };
        this.getReportHTML = function () {
            if (null == c)return "<div class='route_report_list'>" +
                viettel.Language.RoutingRenderer.routeErrorValue + "</div>";
            if (null == c.directions || 0 >= c.directions.length)return "<div class='route_report_list'>" + viettel.Language.RoutingRenderer.routeNoResultValue + "</div>";
            var a = c.directions, b;
            d = [];
            b = "" + ('<div class="route_report_source">' + l(a[0].name) + "</div>");
            b += '<ol class="route_report_list">';
            for (var i = !1, k = 0, u = 0; u < a.length; u++) {
                var q = {instruction: "", roadName: ""}, t = a[u], i = t.roundAbout, p = "";
                m(t.instruction) ? (k = t.turn, p = 0 < u ? i ? p + ('<div class="' + f[k] + '">') : p + ('<div class="' +
                e[k] + '">') : p + '<div class="route_noturn">', p += '<span class="route_instruction">', 0 == u ? q.instruction = viettel.Language.RoutingRenderer.instructionStartValue : i ? (q.instruction += viettel.Language.RoutingRenderer.instructionRoundAboutValue, q.instruction += g[k].toLowerCase(), q.instruction += viettel.Language.RoutingRenderer.instructionToValue) : u == a.length - 1 ? (q.instruction += g[k], q.instruction += viettel.Language.RoutingRenderer.instructionAtValue) : (q.instruction += g[k], q.instruction += viettel.Language.RoutingRenderer.instructionIntoValue),
                    p += q.instruction, q.roadName = l(t.name), p += ' <span class="route_roadname">', p += q.roadName, p += "</span></span>") : (q.instruction = t.instruction, p += '<div class="route_noturn">', p += '<span class="route_instruction">', p += q.instruction, p += "</span>");
                p += '<span class="route_distance">' + j(t.distance) + "</span>";
                p += "</div>";
                d.push(q);
                b += '<li id="htmlReportItems' + u + '"onclick="' + h + "(" + u + ');">' + p;
                b += "</li>"
            }
            b = b + "</ol>" + ('<div class="route_report_target">' + l(a[a.length - 1].name) + "</div>");
            return b += '<div class="route_report_summary">' +
            viettel.Language.RoutingRenderer.lengthTotalValue + ": <b>" + j(c.length) + "</b></div>"
        };
        this.getAlternativeSummary = function () {
            var a;
            a = "" + ('<div class="route_report_source">' + viettel.Language.RoutingRenderer.alternativeRouteTitle + ";</div>");
            if (null != c && null != c.alternative_summaries) {
                a += '<ol class="route_report_list">';
                for (var b = c.alternative_summaries.length, d = 0; d < b; d++)a += '<li id="alterNativeItem' + d + '" name="' + d + '" onclick="' + i + "(" + d + ');">', a += '<span class="route_roadname">', a += l(c.alternative_summaries[d].start_point),
                    a += "</span>", a += " => ", a += ' <span class="route_roadname">', a += l(c.alternative_summaries[d].end_point), a += "</span>", a += " (" + j(c.alternative_summaries[d].total_distance) + ")", a += "</li>";
                a += "</ol>"
            }
            return a
        };
        this.getInstructionItem = function (a) {
            return d[a].instruction + " " + d[a].roadName
        };
        var j = function (a) {
            var b = "";
            1E4 <= a ? (b = k(a / 1E3, 1), b += " km") : 1E3 <= a ? (b = k(a / 1E3, 2), b += " km") : (b = k(a, 0), b += " m");
            return b
        }, k = function (a, b) {
            var c = parseFloat(Math.pow(10, b));
            return parseInt(Math.round(a * c)) / c
        }, m = function (a) {
            if (!VTObjChecker.isString(a))return !0;
            a = a.trim();
            return 0 >= a.length
        }, l = function (a) {
            return m(a) ? viettel.Language.RoutingRenderer.unknownRoadName : a
        };
        e[viettel.RoutingTurn.HEAD_ON] = "route_headon";
        e[viettel.RoutingTurn.GO_AHEAD] = "route_goahead";
        e[viettel.RoutingTurn.LEFT_LANE] = "route_leftlane";
        e[viettel.RoutingTurn.RIGHT_LANE] = "route_rightlane";
        e[viettel.RoutingTurn.TURN_LEFT] = "route_turnleft";
        e[viettel.RoutingTurn.TURN_RIGHT] = "route_turnright";
        e[viettel.RoutingTurn.TWIST_LEFT] = "route_twistleft";
        e[viettel.RoutingTurn.TWIST_RIGHT] = "route_twistright";
        e[viettel.RoutingTurn.TURN_BACK] = "route_turnback";
        e[viettel.RoutingTurn.TO_DESTINATION] = "route_todestination";
        f[viettel.RoutingTurn.HEAD_ON] = "route_bb_goahead";
        f[viettel.RoutingTurn.GO_AHEAD] = "route_bb_goahead";
        f[viettel.RoutingTurn.LEFT_LANE] = "route_bb_leftlane";
        f[viettel.RoutingTurn.RIGHT_LANE] = "route_bb_rightlane";
        f[viettel.RoutingTurn.TURN_LEFT] = "route_bb_turnleft";
        f[viettel.RoutingTurn.TURN_RIGHT] = "route_bb_turnright";
        f[viettel.RoutingTurn.TWIST_LEFT] = "route_bb_twistleft";
        f[viettel.RoutingTurn.TWIST_RIGHT] =
            "route_bb_twistright";
        f[viettel.RoutingTurn.TURN_BACK] = "route_bb_turnback";
        f[viettel.RoutingTurn.TO_DESTINATION] = "route_todestination";
        g[viettel.RoutingTurn.HEAD_ON] = viettel.Language.RoutingRenderer.instructionHeadOnValue;
        g[viettel.RoutingTurn.GO_AHEAD] = viettel.Language.RoutingRenderer.instructionGoAheadValue;
        g[viettel.RoutingTurn.LEFT_LANE] = viettel.Language.RoutingRenderer.instructionLeftLaneValue;
        g[viettel.RoutingTurn.RIGHT_LANE] = viettel.Language.RoutingRenderer.instructionRightLaneValue;
        g[viettel.RoutingTurn.TURN_LEFT] =
            viettel.Language.RoutingRenderer.instructionTurnLeftValue;
        g[viettel.RoutingTurn.TURN_RIGHT] = viettel.Language.RoutingRenderer.instructionTurnRightValue;
        g[viettel.RoutingTurn.TWIST_LEFT] = viettel.Language.RoutingRenderer.instructionTwistLeftValue;
        g[viettel.RoutingTurn.TWIST_RIGHT] = viettel.Language.RoutingRenderer.instructionTwistRightValue;
        g[viettel.RoutingTurn.TURN_BACK] = viettel.Language.RoutingRenderer.instructionTurnBackValue;
        g[viettel.RoutingTurn.TO_DESTINATION] = viettel.Language.RoutingRenderer.instructionToDestinationValue
    };
    viettel.RoadDrawTool = function (a) {
        var b = this, c = !1, d, e, f = new viettel.Polyline({
            strokeColor: "#FF0000",
            strokeOpacity: 0.8,
            strokeWeight: 4,
            path: [],
            clickable: !1
        }), g = OpenLayersEX_ImgLoc + "polylineMarker.png", h = [], i = !1;
        this.enableDrawing = function () {
            i || (f.setMap(a), i = !0, j(), k(), a.setOptions({disableDoubleClickZoom: !0}))
        };
        this.resetDrawing = function () {
            c = i = !1;
            this.removeRoad();
            this.enableDrawing()
        };
        this.getRoad = function () {
            return f
        };
        this.removeRoad = function () {
            f.setPath([]);
            f.setMap(null);
            setTimeout(function () {
                for (var a =
                    h.length - 1; 0 <= a; a--)h[a].setMap(null), h.pop()
            }, 300)
        };
        this.getPointList = function () {
            return f.getPath().getArray()
        };
        this.restore = function () {
        };
        this.disableDrawing = function () {
        };
        var j = function () {
            d = viettel.Events.addListener(a, "click", function (a) {
                m(a.latLng)
            })
        }, k = function () {
            e = viettel.Events.addListener(a, "dblclick", function () {
                viettel.Events.removeListener(d);
                viettel.Events.removeListener(e);
                viettel.Events.trigger(b, "endDraw");
                a.setOptions({disableDoubleClickZoom: !1});
                c = i = !1
            })
        }, m = function (b) {
            viettel.Events.removeListener(d);
            viettel.Events.removeListener(e);
            var f = new viettel.Marker({
                position: b,
                icon: new viettel.MarkerImage(g, null, null, new viettel.Point(5, 5), new viettel.Size(10, 10))
            });
            setTimeout(function () {
                f.setMap(a)
            }, 300);
            h.push(f);
            c ? n(h[h.length - 2].getPosition(), b) : l(b)
        }, l = function (a) {
            var a = urlServer + geodataService + "?f=rddata" + ("&pt=" + a.toUrlValue()), b = "GeoServiceObj." + VTUtil.randomString(8) + "_" + VTUtil.getTimeStamp();
            eval(b + "= geoCallback;");
            VTUtil.loadURL(a, b + ".resHandlerOfPerpendiculaPtSrv")
        }, n = function (a, c) {
            var d;
            d = urlServer + geodataService + "?f=rddata" + ("&pt=" + a.toUrlValue() + ";" + c.toUrlValue());
            var e = "GeoServiceObj." + VTUtil.randomString(8) + "_" + VTUtil.getTimeStamp();
            window.geoCallback = b;
            eval(e + "= geoCallback;");
            VTUtil.loadURL(d, e + ".resHandlerOfLineBetTwoPtSrv")
        };
        this.resHandlerOfPerpendiculaPtSrv = function (a, b) {
            0 == a && (b.points = VTUtil.decryptPoints(b.points));
            var d = h[h.length - 1];
            0 != a ? (j(), setTimeout(function () {
                d.setMap(null)
            }, 300), h.pop(), viettel.Events.trigger(this, "invalidPoint")) : (h[h.length - 1].setPosition(b.points[0]),
                f.getPath().push(new viettel.LatLng(b.points[0].lat(), b.points[0].lng())), j(), k(), c = !0)
        };
        this.resHandlerOfLineBetTwoPtSrv = function (a, b) {
            0 == a && (b.points = VTUtil.decryptPoints(b.points));
            var c = h[h.length - 1];
            if (0 != a)j(), setTimeout(function () {
                c.setMap(null)
            }, 300), h.pop(), viettel.Events.trigger(this, "invalidPoint"); else {
                var d = b.points;
                h[h.length - 1].setPosition(d[d.length - 1]);
                for (var e = 1; e < d.length; e++)f.getPath().push(new viettel.LatLng(d[e].lat(), d[e].lng()));
                j();
                k()
            }
        }
    };
    viettel.AdminReturnType = {};
    viettel.AdminReturnType.CODE = 1;
    viettel.AdminReturnType.NAME = 2;
    viettel.AdminReturnType.PATH = 4;
    viettel.AdminReturnType.GEOM = 4;
    viettel.AdminReturnType.INDEX_COLOR = 8;
    viettel.AdminReturnType.OBJ_ID = 16;
    viettel.AdminReturnType.BOUND = 32;
    viettel.AdminReturnType.ALL = 255;
    viettel.AdminStatus = {};
    viettel.AdminStatus.OK = 0;
    viettel.AdminStatus.INVALID_REQUEST = 1;
    viettel.AdminStatus.REQUEST_DENIED = 2;
    viettel.AdminStatus.UNKNOWN_ERROR = 3;
    viettel.AdminStatus.ZERO_RESULTS = 4;
    viettel.AdminStatus.ERROR = 5;
    viettel.AdminStatus.MAX_POINTS_EXCEEDED = 6;
    viettel.AdminLevelType = {};
    viettel.AdminLevelType.PROVINCE = 1;
    viettel.AdminLevelType.DISTRICT = 2;
    viettel.AdminLevelType.COMMUNE = 3;
    viettel.AdministrationService = function () {
        var a = viettel.AdminReturnType.CODE, b = viettel.AdminLevelType.COMMUNE, c;
        this.setReturnType = function (b) {
            a = b
        };
        this.setLevel = function (a) {
            b = a
        };
        this.getFeatureInCircle = function (d, e, f) {
            VTObjChecker.isLatLngObj(d) ? (c = urlServer, c += administrationService, c += "?pt=" + d.toUrlValue(), c += "&r=" + e, c += "&rt=" + a, c += "&l=" + b, c += "&f=circle", d = "GeoServiceObj." + VTUtil.randomString(8) + "_" + VTUtil.getTimeStamp(), f = new viettel.AdminServiceCallback(f), window.geoCallback = f, eval(d + "= geoCallback;"),
                VTUtil.loadURL(c, d + ".onFeatureComplete")) : VTUtil.throwVTError("Input is empty")
        };
        this.getFeatureFromLatLng = function (d, e) {
            if (VTObjChecker.isLatLngObj(d)) {
                c = urlServer;
                c += administrationService;
                c += "?pt=" + d.toUrlValue();
                c += "&rt=" + a;
                c += "&l=" + b;
                c += "&f=point";
                var f = "GeoServiceObj." + VTUtil.randomString(8) + "_" + VTUtil.getTimeStamp(), g = new viettel.AdminServiceCallback(e);
                window.geoCallback = g;
                eval(f + "= geoCallback;");
                VTUtil.loadURL(c, f + ".onFeatureComplete")
            } else VTUtil.throwVTError("Input is empty")
        };
        this.getFeatureFromViewByLatLng =
            function (d, e, f) {
                VTObjChecker.isLatLngObj(e) ? (c = urlServer, c += administrationService, c += "?pt=" + e.toUrlValue(), c += "&rt=" + a, c += "&l=" + b, c += "&f=point", null != d && (c += "&sc=" + d.getScale()), d = "GeoServiceObj." + VTUtil.randomString(8) + "_" + VTUtil.getTimeStamp(), f = new viettel.AdminServiceCallback(f), window.geoCallback = f, eval(d + "= geoCallback;"), VTUtil.loadURL(c, d + ".onFeatureComplete")) : VTUtil.throwVTError("Input is empty")
            };
        this.getFeatureFromCode = function (d, e) {
            c = urlServer;
            c += administrationService;
            c += "?code=" + d;
            c +=
                "&rt=" + a;
            c += "&l=" + b;
            c += "&f=code";
            var f = "GeoServiceObj." + VTUtil.randomString(8) + "_" + VTUtil.getTimeStamp(), g = new viettel.AdminServiceCallback(e);
            window.geoCallback = g;
            eval(f + "= geoCallback;");
            VTUtil.loadURL(c, f + ".onFeatureComplete")
        };
        this.getFeatureFromView = function (a, e) {
            c = urlServer;
            c += administrationService;
            c += "?b=" + a.getBounds().toUrlValue();
            c += "&rt=" + viettel.AdminReturnType.ALL;
            c += "&l=" + b;
            c += "&f=view";
            c += "&sc=" + a.getOriginalObj().getScale();
            var f = "GeoServiceObj." + VTUtil.randomString(8) + "_" + VTUtil.getTimeStamp(),
                g = new viettel.AdminServiceCallback(e);
            window.geoCallback = g;
            eval(f + "= geoCallback;");
            VTUtil.loadURL(c, f + ".onFeatureComplete")
        }
    };
    viettel.AdminServiceCallback = function (a) {
        this.onFeatureComplete = function (b, c) {
            if (b == viettel.GeoServiceStatus.OK)for (var d = c.items, e = 0; e < d.length; e++) {
                var f = d[e];
                null != f.bound && (f.bound = new viettel.LatLngBounds(new viettel.LatLng(f.bound.sw.y, f.bound.sw.x), new viettel.LatLng(f.bound.ne.y, f.bound.ne.x)));
                if (null != f.paths) {
                    for (var g = f, f = f.paths, h = [], i = 0; i < f.length; i++)h.push(VTUtil.decryptPoints(f[i]));
                    g.paths = h
                }
            }
            a(b, c)
        }
    };
    viettel.POIEventHandler = function (a) {
        var b = new viettel.ToolTip(a);
        this.overHandler = function (c, d) {
            a.style.cursor = "pointer";
            b.getVisible() || (b.setPosition(c.x + 20, c.y), b.setContent(d), b.setVisible(!0))
        };
        this.outHandler = function () {
            a.style.cursor = "default";
            b.setVisible(!1)
        }
    };
    viettel.POIEventManager = function (a) {
        var b = this, c = new CallbackQueue, d = [], e = new viettel.POIEventHandler(a.getDiv()), f = new viettel.Point(6, 6), g = [], h = function () {
            var b = viettel.Events.addListener(a, "bounds_changed", function () {
                c.callMethod(i, 500)
            });
            g.push(b)
        };
        this.init = function () {
            i();
            k();
            h()
        };
        this.destroy = function () {
            for (var a = 0; a < g.length; a++)viettel.Events.removeListener(g[a])
        };
        this.createRectanges = function (a) {
            for (var b = 0; b < a.length; b++)d.push(j(new viettel.Point(a[b].x, a[b].y), a[b].content))
        };
        var i = function () {
            d =
                [];
            (new viettel.POIEventService(a)).sendRequest(a.getBounds(), a.getZoom(), b.createRectanges)
        }, j = function (a, b) {
            return new viettel.POIObj(new viettel.Point(a.x - f.x / 2, a.y + f.y / 2), new viettel.Point(a.x + f.x / 2, a.y - f.y / 2), b)
        }, k = function () {
            var b = viettel.Events.addListener(a, "mousemove", function (b) {
                for (var c = getWorldPixel(a, b.latLng), b = b.pixel, f = !1, g = 0; g < d.length; g++)if (c.x >= d[g].getSouth().x && c.x <= d[g].getWest().x && c.y <= d[g].getSouth().y && c.y >= d[g].getWest().y) {
                    f = !0;
                    e.overHandler(b, d[g].getContent());
                    break
                }
                f ||
                e.outHandler()
            });
            g.push(b)
        }
    };
    function getWorldPixel(a, b) {
        var c = a.getOriginalObj().getResolution(), d = parseInt(b.lat() / c), c = parseInt(b.lng() / c);
        return new viettel.Point(c, d)
    }

    viettel.POIEventService = function (a) {
        var b;
        this.sendRequest = function (c, d, e) {
            b = e;
            c = urlServer + pointService + ("?b=" + c.toUrlValue());
            c += "&sc=" + a.getScale();
            window.responseCallback = this;
            d = "GeoServiceObj." + VTUtil.randomString(8) + "_" + VTUtil.getTimeStamp();
            eval(d + "= responseCallback;");
            VTUtil.loadURL(c, d + ".recieveResponse")
        };
        this.recieveResponse = function (a, d) {
            0 == a && b(d.items)
        }
    };
    viettel.POIObj = function (a, b, c) {
        this.getSouth = function () {
            return a
        };
        this.getWest = function () {
            return b
        };
        this.getContent = function () {
            return c
        }
    };
    viettel.ToolTip = function (a) {
        var b, c = !1;
        b = document.createElement("div");
        b.style.position = "absolute";
        b.style.zIndex = "2000";
        b.setAttribute("class", "poiToolTip");
        a.appendChild(b);
        this.setContent = function (a) {
            b.innerHTML = a
        };
        this.setPosition = function (a, c) {
            b.style.left = a + "px";
            b.style.top = c + "px"
        };
        this.setVisible = function (a) {
            c = a;
            b.style.visibility = a ? "visible" : "hidden"
        };
        this.getVisible = function () {
            return c
        }
    };
    viettel.AdminSelector = function (a) {
        var b = [], c = this;
        this.init = function () {
            d()
        };
        var d = function () {
            b.push(viettel.Events.addListener(a, "click", function (a) {
                e(a.latLng)
            }));
            viettel.Events.addListener(c, "destroy", function () {
                for (var a = 0; a < b.length; a++)viettel.Events.removeListener(b[a])
            })
        }, e = function (b) {
            var c = new viettel.AdministrationService;
            c.setReturnType(viettel.AdminReturnType.CODE | viettel.AdminReturnType.NAME);
            c.getFeatureFromViewByLatLng(a, b, function (a, c) {
                f(a, c, b)
            })
        }, f = function (b, d, e) {
            if (b == viettel.AdminStatus.OK) {
                viettel.Events.trigger(c,
                    "closeInfo");
                var b = g(d), f = new viettel.InfoWindow;
                f.setContent(b);
                f.open(a, e);
                viettel.Events.addListener(c, "destroy", function () {
                    f.close()
                });
                viettel.Events.addListener(c, "closeInfo", function () {
                    f.close()
                })
            }
        }, g = function (a) {
            var a = a.items[0], b;
            b = "" + ("M\u00e3: " + a.code + "<br/>");
            return b += "T\u00ean: " + a.name + "<br/>"
        };
        this.destroy = function () {
            viettel.Events.trigger(this, "destroy");
            viettel.Events.trigger(c, "closeInfo")
        }
    };
    viettel.MapPlugin = function (a) {
        var b = [], c = [], d = [], e = new viettel.MapPluginFactory(a);
        this.initPlugins = function () {
            for (var a = 0; a < b.length; a++)b[a].init()
        };
        this.updatePlugins = function () {
            for (var a = 0; a < b.length; a++)b[a].destroy();
            b = [];
            g();
            this.initPlugins()
        };
        var f = function (a) {
            for (var c = 0; c < a.length; c++) {
                var d = e.createPlugin(a[c]);
                null != d && b.push(d)
            }
        }, g = function () {
            var b = a.getMapTypeId();
            b == viettel.MapTypeId.ADMIN ? f(d) : b == viettel.MapTypeId.TRAFFIC && f(c)
        };
        (function () {
            var b = a.getEnablePlugins();
            if (null != b)for (var e =
                0; e < b.length; e++) {
                var f = b[e], g = f.mapTypeId;
                g == viettel.MapTypeId.ADMIN && -1 == d.indexOf(f.plugins) ? d = d.concat(f.plugins) : g == viettel.MapTypeId.TRAFFIC && -1 == c.indexOf(f.plugins) ? c = c.concat(f.plugins) : (-1 == c.indexOf(f.plugins) && (c = c.concat(f.plugins)), -1 == d.indexOf(f.plugins) && (d = d.concat(f.plugins)))
            }
        })();
        g()
    };
    viettel.MapPluginName = {};
    viettel.MapPluginName.POI_SELECTOR = "pointEvent";
    viettel.MapPluginName.ADMIN_SELECTOR = "adminSelector";
    viettel.MapPluginFactory = function (a) {
        this.createPlugin = function (b) {
            return null != viettel.POIEventManager && b == viettel.MapPluginName.POI_SELECTOR ? new viettel.POIEventManager(a) : null != viettel.AdminSelector && b == viettel.MapPluginName.ADMIN_SELECTOR ? new viettel.AdminSelector(a) : null
        }
    };
    viettel.Command = function () {
        this.execute = function () {
        }
    };
    viettel.UndoCommand = function () {
        viettel.Command.call(this);
        this.undo = function () {
        }
    };
    viettel.UndoCommand.prototype = new viettel.Command;
    viettel.UndoCommand.prototype.constructor = viettel.UndoCommand;
    viettel.EventRoadDrawer = function (a) {
        var b, c, d, e = [], f = !1, g = this;
        this.active = function () {
            f = !0;
            b = a.getRoad();
            c = b.getMap();
            a.getRoadMarkers();
            d = new viettel.EventRoadEditer(a);
            h();
            j();
            k();
            c.setOptions({disableDoubleClickZoom: !0})
        };
        var h = function () {
            e.push(viettel.Events.addListener(c, "click", function (a) {
                i(a.latLng)
            }))
        }, i = function (b) {
            a.getEventState() && (viettel.Events.trigger(a, "waiting"), a.setEventState(!1), setTimeout(function () {
                a.add(b)
            }, 500))
        }, j = function () {
            e.push(viettel.Events.addListener(c, "dblclick",
                function () {
                    setTimeout(function () {
                        g.destroy();
                        c.setOptions({disableDoubleClickZoom: !1});
                        a.setEndDraw(!0)
                    }, 300)
                }))
        }, k = function () {
            jQuery4Map(document).keydown(function (b) {
                if (a.getEventState() && (8 == b.which || 90 == b.which))a.undo(), b.preventDefault()
            })
        };
        this.isActive = function () {
            return f
        };
        this.destroy = function () {
            f = !1;
            for (var a = 0; a < e.length; a++)viettel.Events.removeListener(e[a]);
            e = [];
            jQuery4Map(document).unbind("keypress");
            d.destroy()
        }
    };
    viettel.EventRoadEditer = function (a) {
        var b = a.getRoad(), c = a.getRoadMarkers(), d = b.getMap(), e = !0, f, g = !1, h = !1, i = new viettel.TmpPolylineStyle(b), j = new viettel.RoadUtil(d), k, m = !0, l = [], n;
        viettel.Events.addListener(b, "mouseover", function (f) {
            if (a.getEventState() && m) {
                var i = j.checkPointInLine(f.latLng, b.getPath().getArray(), 4);
                k = c.findIndex(i);
                o(d, f.latLng);
                g = !1;
                e = !0;
                m = h = !1
            }
        });
        var o = function (d, j) {
            f = new viettel.Marker({
                map: d, position: j, icon: new viettel.MarkerImage(OpenLayersEX_ImgLoc + "polylineMarker.png", null,
                    null, new viettel.Point(5, 5), new viettel.Size(10, 10))
            });
            f.setDraggable(!0);
            l.push(viettel.Events.addListener(f, "mouseout", function () {
                e = !0;
                !g && !h && s()
            }));
            l.push(viettel.Events.addListener(f, "dragstart", function (a) {
                g = !0;
                -1 != k && (i.initPolyline(c.getAt(k).index, c.getAt(k + 1).index), i.addPoint(a.latLng))
            }));
            l.push(viettel.Events.addListener(f, "mousedown", function () {
                h = !0
            }));
            l.push(viettel.Events.addListener(f, "mouseup", function (a) {
                viettel.Events.trigger(document, "mouseup", a.getEvt());
                g || (h = !1, s())
            }));
            l.push(viettel.Events.addListener(f,
                "drag", function (a) {
                    n = a.latLng;
                    i.addPoint(a.latLng)
                }));
            l.push(viettel.Events.addListener(f, "dragend", function () {
                viettel.Events.trigger(a, "waiting");
                a.setEventState(!1);
                h = g = !1;
                s();
                (new viettel.RoutingViaPoint(c.getAt(k).marker.getPosition(), c.getAt(k + 1).marker.getPosition(), n, u)).routing()
            }));
            l.push(viettel.Events.addListener(f, "mouseover", function () {
                e = !1
            }));
            l.push(viettel.Events.addListener(b, "mouseout", function () {
                e && !g && !h && s()
            }))
        };
        this.destroy = function () {
            r()
        };
        var r = function () {
            for (var a = 0; a < l.length; a++)viettel.Events.removeListener(l[a]);
            l = []
        }, s = function () {
            "undefined" != typeof f && f.setMap(null);
            r();
            m = !0
        }, u = function (b, c, d) {
            b == viettel.RoutingStatus.OK ? (a.insertAt(k, n, c, d), i.clear(), viettel.Events.trigger(a, "addPoint", viettel.RoadDrawerStatus.OK)) : (i.clear(), a.getCallback()(), viettel.Events.trigger(a, "addPoint", viettel.RoadDrawerStatus.ERROR))
        }
    };
    viettel.InfoBox = function (a, b) {
        var c = this, d, e = !1, f = [], g = '<div class="road_draw_title"><span>' + viettel.Language.RoutingRenderer.infoBoxRouteTitle + '</span><a id="measureFormCloser" href="#"></a></div><div class="road_draw_distance_row"><span class="road_draw_distance_title">' + viettel.Language.RoadDrawer.infoBoxTotalLengthTitle + ': </span><span id="total_distance" class="road_draw_distance_text">0 m</span></div><div><div id="InfoBox_Status"></div></div><div class="road_draw_button_row"><div id="InfoBox_Undo"></div><div id="InfoBox_Refresh"></div></div>',
            h = document.createElement("div");
        h.innerHTML = g;
        h.setAttribute("class", "road_draw_infobox");
        this.updateDistance = function () {
        };
        this.reset = function () {
        };
        this.open = function () {
            e || (e = !0, d = a.controls[viettel.ControlPosition.TOP_RIGHT].push(h), j(), i())
        };
        this.close = function () {
            e = !1;
            for (var c = 0; c < f.length; c++)viettel.Events.removeListener(f[c]);
            f = [];
            jQuery("#InfoBox_Undo").unbind();
            jQuery("#InfoBox_Refresh").unbind();
            jQuery("#measureFormCloser").unbind();
            a.controls[viettel.ControlPosition.TOP_RIGHT].removeAt(d);
            viettel.Events.trigger(b,
                "destroy")
        };
        this.waiting = function () {
            document.getElementById("InfoBox_Status").innerHTML = "<div id='InfoBox_Waiting' ></div>";
            document.getElementById("InfoBox_Status").style.display = "block"
        };
        this.log = function (a) {
            document.getElementById("InfoBox_Status").innerHTML = "<div id='InfoBox_Log' ></div>";
            document.getElementById("InfoBox_Log").innerHTML = a;
            document.getElementById("InfoBox_Status").style.display = "block"
        };
        this.disableLog = function () {
            document.getElementById("InfoBox_Status").style.display = "none"
        };
        var i = function () {
            c.disableLog();
            jQuery("#total_distance").html(viettel.GeometryUtil.getLength(b.getPoints()) + " m")
        }, j = function () {
            jQuery("#InfoBox_Undo").click(function () {
                b.undo()
            });
            jQuery("#InfoBox_Refresh").click(function () {
                b.refresh();
                i()
            });
            jQuery("#measureFormCloser").click(function () {
                confirm(viettel.Language.RoadDrawer.routeStopDrawMessage) && (b.destroy(), c.close())
            })
        }, k = function (a) {
            a == viettel.RoadDrawerStatus.OK ? i() : c.log(viettel.Language.RoadDrawer.noRouteToPointMessage)
        };
        (function () {
            f.push(viettel.Events.addListener(b,
                "waiting", function () {
                    c.waiting()
                }));
            f.push(viettel.Events.addListener(b, "addPoint", function (a) {
                k(a)
            }));
            f.push(viettel.Events.addListener(b, "editPoint", function (a) {
                k(a)
            }));
            f.push(viettel.Events.addListener(b, "removePoint", function (a) {
                k(a)
            }));
            f.push(viettel.Events.addListener(b, "endDraw", function () {
                c.log(viettel.Language.RoadDrawer.routeDrawCompleteMessage)
            }));
            f.push(viettel.Events.addListener(b, "updateRoad", function () {
                i()
            }))
        })()
    };
    viettel.PointAdderToRoadCommand = function (a, b, c) {
        viettel.UndoCommand.call(this);
        var d, e, f = a.getRoad(), g = a.getRoadMarkers(), h = new viettel.TmpPolylineStyle(f), i, j;
        this.execute = function (m) {
            j = m;
            d = f.getPath();
            e = f.getMap();
            0 <= g.getLength() - 1 && (h.initPolyline(g.getAt(g.getLength() - 1).index), h.addPoint(b));
            g.push({map: e, position: b}, 0);
            i = g.getLength() - 1;
            "undefined" == typeof c && (c = d.getLength());
            if (1 > d.getLength())d.insertAt(c, b), j(), viettel.Events.trigger(a, "addPoint", viettel.RoadDrawerStatus.OK); else {
                var m =
                    g.getAt(g.getLength() - 2).marker.getPosition(), l = g.getAt(g.getLength() - 1).marker.getPosition(), m = {
                    origin: m,
                    destination: l,
                    travelMode: viettel.TravelMode.CAR
                };
                (new viettel.RoutingService).route(m, k)
            }
        };
        this.undo = function () {
            var b = [];
            if (0 != i) {
                var c = g.getAt(i - 1).index + 1;
                0 != c && (b = d.getArray().slice(0, c));
                f.setPath(b)
            } else f.setPath([]);
            g.getAt(i).marker.setMap(null);
            g.pop();
            viettel.Events.trigger(a, "removePoint", viettel.RoadDrawerStatus.OK)
        };
        var k = function (b, c) {
            if (c == viettel.RoutingStatus.OK) {
                h.clear();
                var e =
                    b.path;
                g.updateIndex(g.getLength() - 1, e);
                g.updatePosition(g.getLength() - 1, d.getAt(d.getLength() - 1));
                2 == g.getLength() && g.updatePosition(0, e[0]);
                viettel.Events.trigger(a, "addPoint", viettel.RoadDrawerStatus.OK)
            } else viettel.Events.trigger(a, "addPoint", viettel.RoadDrawerStatus.ERROR), g.pop(), h.clear();
            j()
        }
    };
    viettel.PointAdderToRoadCommand.prototype = new viettel.UndoCommand;
    viettel.PointAdderToRoadCommand.prototype.constructor = viettel.PointAdderToRoadCommand;
    viettel.RoutingViaPoint = function (a, b, c, d) {
        this.routing = function () {
            i(a, c, g)
        };
        var e, f, g = function (a, f) {
            f == viettel.RoutingStatus.OK ? (e = a.path, i(c, b, h)) : d(f)
        }, h = function (a, b) {
            b == viettel.RoutingStatus.OK ? (f = a.path, d(b, e, f)) : d(b)
        }, i = function (a, b, c) {
            a = {origin: a, destination: b, travelMode: viettel.TravelMode.CAR};
            (new viettel.RoutingService).route(a, c)
        }
    };
    viettel.PointEditterCommand = function (a, b, c, d) {
        viettel.UndoCommand.call(this);
        var e;
        this.execute = function (f) {
            e = 0 == b ? new viettel.FirstPointEditterCommand(c) : b == a.getRoadMarkers().getLength() - 1 ? new viettel.LastPointEditterCommand(c) : new viettel.ViaPointEditterCommand(b, c, d);
            e.setRoad(a.getRoad());
            e.setViaMarkers(a.getRoadMarkers());
            e.execute(f)
        };
        this.undo = function () {
            e.undo();
            viettel.Events.trigger(a, "removePoint", viettel.RoadDrawerStatus.OK)
        }
    };
    viettel.PointEditterCommand.prototype = new viettel.UndoCommand;
    viettel.PointEditterCommand.prototype.constructor = viettel.PointEditterCommand;
    viettel.FirstPointEditterCommand = function (a) {
        viettel.UndoCommand.call(this);
        var b = this, c, d;
        this.setRoad = function (a) {
            this.road = a;
            this.path = a.getPath()
        };
        this.setViaMarkers = function (a) {
            this.viaMarkers = a
        };
        this.execute = function (e) {
            d = e;
            c = this.path.getArray().slice(this.viaMarkers.getAt(0).index, this.viaMarkers.getAt(1).index - this.viaMarkers.getAt(0).index + 1);
            b.viaMarkers.updateIndex(0, a);
            d()
        };
        this.undo = function () {
            this.viaMarkers.getAt(0).marker.setPosition(c[0]);
            b.viaMarkers.updateIndex(0, c);
            d()
        }
    };
    viettel.FirstPointEditterCommand.prototype = new viettel.UndoCommand;
    viettel.FirstPointEditterCommand.prototype.constructor = viettel.FirstPointEditterCommand;
    viettel.LastPointEditterCommand = function (a) {
        viettel.UndoCommand.call(this);
        var b = this, c, d, e, f;
        this.setRoad = function (a) {
            this.road = a;
            this.path = a.getPath()
        };
        this.setViaMarkers = function (a) {
            this.viaMarkers = a
        };
        this.execute = function (g) {
            f = g;
            e = b.viaMarkers.getLength();
            c = this.path.getArray().slice(this.viaMarkers.getAt(e - 2).index);
            d = this.viaMarkers.getAt(e - 1).position;
            b.viaMarkers.updateIndex(e - 1, a);
            f()
        };
        this.undo = function () {
            this.viaMarkers.getAt(e - 1).marker.setPosition(d);
            b.viaMarkers.updateIndex(e - 1, c);
            f()
        }
    };
    viettel.LastPointEditterCommand.prototype = new viettel.UndoCommand;
    viettel.LastPointEditterCommand.prototype.constructor = viettel.LastPointEditterCommand;
    viettel.ViaPointEditterCommand = function (a, b, c) {
        viettel.UndoCommand.call(this);
        var d = this, e, f, g, h;
        this.setRoad = function (a) {
            this.road = a;
            this.path = a.getPath()
        };
        this.setViaMarkers = function (a) {
            this.viaMarkers = a
        };
        this.execute = function (i) {
            h = i;
            e = this.path.getArray().slice(this.viaMarkers.getAt(a - 1).index, this.viaMarkers.getAt(a).index);
            f = this.path.getArray().slice(this.viaMarkers.getAt(a).index, this.viaMarkers.getAt(a + 1).index);
            g = this.viaMarkers.getAt(a).position;
            d.viaMarkers.updateIndex(a, b, c);
            h()
        };
        this.undo =
            function () {
                this.viaMarkers.getAt(a).marker.setPosition(g);
                d.viaMarkers.updateIndex(a, e, f);
                h()
            }
    };
    viettel.ViaPointEditterCommand.prototype = new viettel.UndoCommand;
    viettel.ViaPointEditterCommand.prototype.constructor = viettel.ViaPointEditterCommand;
    viettel.ViaPointInserterCommand = function (a, b, c) {
        viettel.UndoCommand.call(this);
        var d = this, e, f;
        this.setRoad = function (a) {
            this.road = a;
            this.path = a.getPath()
        };
        this.setViaMarkers = function (a) {
            this.viaMarkers = a
        };
        this.setPosition = function () {
        };
        this.setEventViaMarker = function () {
        };
        this.execute = function (g) {
            f = g;
            e = this.path.getArray().slice(this.viaMarkers.getAt(a).index, this.viaMarkers.getAt(a + 1).index + 1);
            d.viaMarkers.insertAt({position: c[0]}, a + 1, b, c);
            f()
        };
        this.undo = function () {
            d.viaMarkers.removeAt(a + 1, e)
        }
    };
    viettel.ViaPointInserterCommand.prototype = new viettel.UndoCommand;
    viettel.ViaPointInserterCommand.prototype.constructor = viettel.ViaPointInserterCommand;
    viettel.PointRemoverToRoadCommand = function (a, b) {
        viettel.UndoCommand.call(this);
        a.getRoad().getPath();
        var c;
        this.execute = function (d) {
            viettel.Events.trigger(a, "waiting");
            c = 0 == b ? new viettel.FirstPointRemoverCommand : b == a.getRoadMarkers().getLength() - 1 ? new viettel.LastPointRemoverCommand : new viettel.ViaPointRemoverCommand(b);
            c.setRoad(a);
            c.execute(d)
        };
        this.undo = function () {
            c.undo()
        }
    };
    viettel.PointRemoverToRoadCommand.prototype = new viettel.UndoCommand;
    viettel.PointRemoverToRoadCommand.prototype.constructor = viettel.PointRemoverToRoadCommand;
    viettel.ViaPointRemoverCommand = function (a) {
        viettel.UndoCommand.call(this);
        var b = this, c, d, e;
        this.setRoad = function (a) {
            this.roadDrawer = a;
            this.road = a.getRoad();
            this.path = this.road.getPath();
            this.viaMarkers = a.getRoadMarkers()
        };
        this.setViaMarkers = function (a) {
            this.viaMarkers = a
        };
        this.execute = function () {
            var b = this.path.getArray();
            c = b.slice(this.viaMarkers.getAt(a - 1).index, this.viaMarkers.getAt(a).index + 1);
            d = b.slice(this.viaMarkers.getAt(a).index, this.viaMarkers.getAt(a + 1).index + 1);
            this.viaMarkers.getAt(a +
            1);
            this.viaMarkers.getAt(a - 1);
            e = this.viaMarkers.getAt(a).marker.getPosition();
            var h = this.viaMarkers.getAt(a - 1).marker.getPosition(), i = this.viaMarkers.getAt(a + 1).marker.getPosition(), b = f, h = {
                origin: h,
                destination: i,
                travelMode: viettel.TravelMode.CAR
            };
            (new viettel.RoutingService).route(h, b)
        };
        this.undo = function () {
            this.viaMarkers.insertAt({position: e}, a, c, d);
            viettel.Events.trigger(b.roadDrawer, "addPoint", viettel.RoadDrawerStatus.OK)
        };
        var f = function (c, d) {
            d == viettel.RoutingStatus.OK ? (b.viaMarkers.removeAt(a,
                c.path), viettel.Events.trigger(b.roadDrawer, "removePoint", viettel.RoadDrawerStatus.OK)) : viettel.Events.trigger(b.roadDrawer, "removePoint", viettel.RoadDrawerStatus.ERROR)
        }
    };
    viettel.ViaPointRemoverCommand.prototype = new viettel.UndoCommand;
    viettel.ViaPointRemoverCommand.prototype.constructor = viettel.ViaPointRemoverCommand;
    viettel.LastPointRemoverCommand = function () {
        viettel.UndoCommand.call(this);
        var a = this, b, c;
        this.setRoad = function (a) {
            this.roadDrawer = a;
            this.road = a.getRoad();
            this.path = this.road.getPath();
            this.viaMarkers = a.getRoadMarkers()
        };
        this.execute = function () {
            var d = this.path.getArray(), e = this.viaMarkers.getLength();
            b = d.slice(this.viaMarkers.getAt(e - 2).index, this.viaMarkers.getAt(e - 1).index + 1);
            c = this.viaMarkers.getAt(e - 1).position;
            a.viaMarkers.removeAt(a.viaMarkers.getLength() - 1);
            viettel.Events.trigger(a.roadDrawer,
                "removePoint", viettel.RoadDrawerStatus.OK)
        };
        this.undo = function () {
            this.viaMarkers.insertAt({position: c}, this.viaMarkers.getLength(), b);
            viettel.Events.trigger(a.roadDrawer, "addPoint", viettel.RoadDrawerStatus.OK)
        }
    };
    viettel.LastPointRemoverCommand.prototype = new viettel.UndoCommand;
    viettel.LastPointRemoverCommand.prototype.constructor = viettel.LastPointRemoverCommand;
    viettel.FirstPointRemoverCommand = function () {
        viettel.UndoCommand.call(this);
        var a = this, b, c;
        this.setRoad = function (a) {
            this.roadDrawer = a;
            this.road = a.getRoad();
            this.path = this.road.getPath();
            this.viaMarkers = a.getRoadMarkers()
        };
        this.execute = function () {
            b = this.path.getArray().slice(0, this.viaMarkers.getAt(1).index + 1);
            c = this.viaMarkers.getAt(0).marker.getPosition();
            a.viaMarkers.removeAt(0, b);
            viettel.Events.trigger(a.roadDrawer, "removePoint", viettel.RoadDrawerStatus.OK)
        };
        this.undo = function () {
            this.viaMarkers.insertAt({position: c},
                0, b);
            viettel.Events.trigger(a.roadDrawer, "addPoint", viettel.RoadDrawerStatus.OK)
        }
    };
    viettel.FirstPointRemoverCommand.prototype = new viettel.UndoCommand;
    viettel.FirstPointRemoverCommand.prototype.constructor = viettel.FirstPointRemoverCommand;
    viettel.RoadCommandManager = function () {
        var a = [];
        this.executeCommand = function (b, c) {
            b.execute(c);
            b instanceof viettel.UndoCommand && a.push(b)
        };
        this.undo = function () {
            0 < a.length && a.pop().undo()
        };
        this.destroy = function () {
            a = []
        }
    };
    viettel.RoadDrawerStatus = {};
    viettel.RoadDrawerStatus.OK = 0;
    viettel.RoadDrawerStatus.ERROR = 1;
    viettel.RoadDrawer = function (a) {
        var b = new viettel.RoadCommandManager, c = new viettel.EventRoadDrawer(this), d = new viettel.Polyline({
            map: a,
            strokeColor: "#0000FF",
            strokeOpacity: 0.4,
            strokeWeight: 3
        }), e = this;
        this.add = function (a, c) {
            var d = new viettel.PointAdderToRoadCommand(this, a, c);
            b.executeCommand(d, function () {
                f()
            })
        };
        this.edit = function (a, c, d) {
            a = new viettel.PointEditterCommand(this, a, c, d);
            b.executeCommand(a, function () {
                f()
            })
        };
        this.insertAt = function (a, c, e, g) {
            a = new viettel.ViaPointInserterCommand(a, e, g);
            a.setRoad(d);
            a.setViaMarkers(j);
            a.setPosition(c);
            b.executeCommand(a, function () {
                f()
            })
        };
        this.remove = function (a) {
            a = new viettel.PointRemoverToRoadCommand(this, a);
            b.executeCommand(a)
        };
        this.refresh = function () {
            a = d.getMap();
            d.setPath([]);
            j.clear();
            b.destroy();
            e.setEventState(!0);
            c.isActive() || c.active();
            h = !1;
            k.open()
        };
        this.destroy = function () {
            this.refresh();
            c.destroy();
            k.close()
        };
        this.deactive = function () {
            i && (i = !1, b.destroy(), g = !1)
        };
        this.undo = function () {
            b.undo()
        };
        this.getPoints = function () {
            return d.getPath().getArray()
        };
        this.active = function () {
            i || (i = !0, c.active())
        };
        this.getRoad = function () {
            return d
        };
        this.getRoadMarkers = function () {
            return j
        };
        this.setRoad = function (a, b) {
            this.refresh();
            d.setPath(a);
            if (VTObjChecker.isArray(b))for (var c = 0; c < b.length; c++)b[c].position = a[b[c].index]; else b = [], b[0] = {
                index: 0,
                position: a[0]
            }, b[1] = {index: a.length - 1, position: a[a.length - 1]};
            j.setData(b);
            viettel.Events.trigger(this, "updateRoad")
        };
        this.getViaMarkerData = function () {
            return j.getData()
        };
        var f = function () {
            h ? viettel.Events.trigger(e, "endDraw") :
                e.setEventState(!0)
        };
        this.getCallback = function () {
            return f
        };
        this.setEventState = function (a) {
            (g = a) ? j.unlockEvent() : j.lockEvent()
        };
        this.getEventState = function () {
            return g
        };
        this.getEndDraw = function () {
            return h
        };
        this.setEndDraw = function (a) {
            (h = a) && b.destroy()
        };
        var g = !0, h = !1, i = !1, j = new viettel.ViaMarkers(this), k = new viettel.InfoBox(a, this);
        k.open()
    };
    viettel.RoadReseterCommand = function (a) {
        viettel.UndoCommand.call(this);
        var b = a.getRoad(), c = a.getRoadMarkers(), d = b.getMap();
        this.execute = function () {
            d = b.getMap();
            b.setPath([]);
            c.clear()
        };
        this.undo = function () {
            b.setMap(d)
        }
    };
    viettel.RoadReseterCommand.prototype = new viettel.UndoCommand;
    viettel.RoadReseterCommand.prototype.constructor = viettel.RoadReseterCommand;
    viettel.RoadUtil = function (a) {
        this.checkLatLonPointBetweenTwoPoint = function (b, c, d, e) {
            b = a.fromLatLngToDivPixel(b);
            c = a.fromLatLngToDivPixel(c);
            d = a.fromLatLngToDivPixel(d);
            return this.checkPointBetweenTwoPoint(b, c, d, e)
        };
        this.checkPointBetweenTwoPoint = function (a, c, d, e) {
            c = (d.y - c.y) / (d.x - c.x);
            return Math.abs(c * a.x + d.y - c * d.x - a.y) <= e + 1 ? !0 : !1
        };
        this.checkPointInLine = function (a, c) {
            return viettel.GeometryUtil.distancePointToPoly(a, c).index
        }
    };
    viettel.TmpPolylineStyle = function (a) {
        var b = a.getMap(), c = a.getPath(), d, e = !1, f, g = this, h;
        this.clear = function () {
            d.setMap(null);
            null != f && viettel.Events.removeListener(f)
        };
        this.initPolyline = function (a, f) {
            d = new viettel.Polyline({
                strokeColor: "#FF0000",
                strokeOpacity: 0.8,
                clickable: !1,
                strokeWeight: 1,
                clickable: !1,
                strokeDashstyle: "dash"
            });
            d.setMap(b);
            e = !1;
            try {
                null == f ? (h = 0, d.getPath().push(c.getAt(a))) : (h = 1, d.getPath().push(c.getAt(a)), d.getPath().push(c.getAt(f)))
            } catch (g) {
                throw g;
            }
        };
        this.addPoint = function (a) {
            0 ==
            h ? e ? (d.getPath().pop(), d.getPath().push(a)) : (d.getPath().push(a), e = !0) : (e && d.getPath().removeAt(1), d.getPath().insertAt(1, a), e = !0)
        };
        this.draw = function () {
            f = viettel.Events.addListener(b, "mousemove", function (a) {
                g.addPoint(a.latLng)
            })
        }
    };
    viettel.ViaMarkers = function (a) {
        var b = [], c = a.getRoad(), d = new viettel.EventViaMarker(a, this), e = this, f = !1;
        this.getData = function () {
            for (var a = [], c = 0; c < b.length; c++) {
                var d = {};
                d.index = b[c].index;
                a.push(d)
            }
            return a
        };
        this.setData = function (a) {
            this.clear();
            for (var c = 0; c < a.length; c++) {
                var e = {}, f = a[c], m = d.createMarker({position: f.position}, c);
                e.marker = m;
                e.index = f.index;
                e.position = f.position;
                b.push(e)
            }
            g()
        };
        this.push = function (a, c) {
            var e = d.createMarker(a, b.length), f = {};
            f.marker = e;
            0 != b.length ? (f.index = c + b[b.length -
            1].index, f.position = f.marker.getPosition()) : f.index = 0;
            b.push(f);
            g();
            return e
        };
        this.pop = function () {
            var a = b.pop();
            a.marker.setMap(null);
            g();
            return a
        };
        this.updateIndex = function (a, d, e) {
            var f, m, l = c.getPath().getArray(), n = [];
            null == e ? 0 == a ? (n = n.concat(d), n = n.concat(l.slice(b[1].index + 1))) : a == b.length - 1 && (n = n.concat(l.slice(0, b[b.length - 2].index)), n = n.concat(d)) : (0 <= b[a - 1].index - 1 && (n = n.concat(l.slice(0, b[a - 1].index))), n = n.concat(d), n = n.concat(e.slice(1)), n = n.concat(l.slice(b[a + 1].index + 1)));
            c.setPath(n);
            null != d && (f = d.length);
            null != e && (m = e.length);
            b[a].position = b[a].marker.getPosition();
            0 == a ? (d = f - (b[1].index - b[0].index) - 1, this.updateIndexAt(a, d)) : (b[a].index += f - (b[a].index - b[a - 1].index) - 1, null != m && (d = f + m - (b[a + 1].index - b[a - 1].index) - 2, this.updateIndexAt(a, d)));
            g()
        };
        this.insertAt = function (a, e, f, k) {
            var m, l, n = c.getPath().getArray(), o = [];
            null == k ? 0 == e ? (o = o.concat(f), o = o.concat(n.slice(1))) : e == b.length && (o = o.concat(n.slice(0, n.length - 1)), o = o.concat(f)) : (0 <= b[e - 1].index - 1 && (o = o.concat(n.slice(0, b[e - 1].index))),
                o = o.concat(f), o = o.concat(k.slice(1)), o = o.concat(n.slice(b[e].index + 1)));
            c.setPath(o);
            null != f && (m = f.length);
            null != k && (l = k.length);
            a = d.createMarker(a, e);
            f = 0;
            0 < e && (f = b[e - 1].index + m - 1);
            m = 0 == e ? m - 1 : e >= b.length ? m - 1 : m + l - (b[e].index - b[e - 1].index) - 2;
            b.splice(e, 0, {index: f, marker: a, position: a.getPosition()});
            this.updateIndexAt(e, m);
            g();
            return a
        };
        this.removeAt = function (a, d) {
            var f;
            0 == a ? f = 1 - d.length : 0 != a && a != b.length - 1 && (f = d.length - (b[a + 1].index - b[a - 1].index + 1));
            var k = c.getPath().getArray(), m = [];
            2 > k.length ? c.setPath([]) :
                (0 == a ? m = m.concat(k.slice(b[1].index)) : a == b.length - 1 ? 1 == a ? m.push(k[0]) : m = m.concat(k.slice(0, b[a - 1].index + 1)) : (m = m.concat(k.slice(0, b[a - 1].index)), m = m.concat(d), m = m.concat(k.slice(b[a + 1].index + 1))), c.setPath(m));
            b[a].marker.setMap(null);
            b.splice(a, 1);
            e.updateIndexAt(a - 1, f);
            g()
        };
        this.updateIndexAt = function (a, c) {
            for (var d = a + 1; d < b.length; d++)b[d].index += c
        };
        this.clear = function () {
            for (var a = 0; a < b.length; a++)b[a].marker.setMap(null);
            b = []
        };
        this.findIndex = function (a) {
            for (var c = 0; c < b.length - 1; c++)if (b[c].index <=
                a && a <= b[c + 1].index)return c;
            return -1
        };
        this.getLength = function () {
            return b.length
        };
        this.getAt = function (a) {
            return b[a]
        };
        this.getIndexFrom = function (a) {
            for (var c = 0; c < b.length; c++)if (b[c].marker == a)return c;
            return -1
        };
        this.getMarkers = function () {
            return b
        };
        this.updatePosition = function (a, c) {
            b[a].marker.setPosition(c);
            b[a].position = c
        };
        this.lockEvent = function () {
            for (var a = 0; a < b.length; a++)b[a].marker.setDraggable(!1);
            f = !0
        };
        this.unlockEvent = function () {
            for (var a = 0; a < b.length; a++)b[a].marker.setDraggable(!0);
            f = !1
        };
        this.getLockState = function () {
            return f
        };
        var g = function () {
            null != b[0] && null != b[0].marker.getLabelContent() && b[0].marker.setOptions({labelVisible: !1});
            0 < b.length && b[b.length - 1].marker.setOptions({labelVisible: !1});
            for (var a = 1; a < b.length - 1; a++)b[a].marker.setOptions({labelContent: a, labelVisible: !0})
        }
    };
    viettel.EventViaMarker = function (a, b) {
        var c = a.getRoad(), d = new viettel.TmpPolylineStyle(c), c = a.getRoad(), e = c.getPath(), f = c.getMap(), g, h;
        this.createMarker = function (a, c) {
            var d;
            0 == c || c == b.getLength() ? (a.labelClass = "markerNumberLabel", a.labelVisible = !0) : (a.labelClass = "markerNumberLabel", a.labelVisible = !0, a.labelContent = c);
            a.map = f;
            d = new viettel.LabelMarker(a);
            j(d);
            i(d);
            return d
        };
        var i = function (c) {
                viettel.Events.addListener(c, "click", function () {
                    if (a.getEventState()) {
                        var c = b.getIndexFrom(this);
                        a.remove(c)
                    }
                })
            },
            j = function (c) {
                a.getEventState() && c.setDraggable(!0);
                viettel.Events.addListener(c, "dragend", function (d) {
                    c.setDraggable(!1);
                    a.setEventState(!1);
                    viettel.Events.trigger(a, "waiting");
                    0 == b.getLength() ? e.push([d.latLng]) : 0 == g ? n(d.latLng, b.getAt(1).marker.getPosition(), l) : g == b.getLength() - 1 ? n(b.getAt(g - 1).marker.getPosition(), d.latLng, m) : (new viettel.RoutingViaPoint(b.getAt(g - 1).marker.getPosition(), b.getAt(g + 1).marker.getPosition(), c.getPosition(), k)).routing()
                });
                viettel.Events.addListener(c, "dragstart",
                    function (a) {
                        h = a.latLng;
                        g = b.getIndexFrom(c);
                        0 == g && 1 < b.getLength() ? d.initPolyline(b.getAt(1).index) : g == b.getLength() - 1 ? d.initPolyline(b.getAt(g - 1).index) : d.initPolyline(b.getAt(g - 1).index, b.getAt(g + 1).index)
                    });
                viettel.Events.addListener(c, "drag", function (a) {
                    d.addPoint(a.latLng)
                })
            }, k = function (c, e, f) {
                c == viettel.RoutingStatus.OK ? (a.edit(g, e, f), d.clear(), b.getAt(g).marker.setPosition(f[0]), viettel.Events.trigger(a, "editPoint", viettel.RoadDrawerStatus.OK)) : (o(), viettel.Events.trigger(a, "editPoint", viettel.RoadDrawerStatus.ERROR))
            },
            m = function (c, e) {
                e == viettel.RoutingStatus.OK ? (a.edit(b.getLength() - 1, c.path), d.clear(), b.getAt(g).marker.setPosition(c.path[c.path.length - 1]), viettel.Events.trigger(a, "editPoint", viettel.RoadDrawerStatus.OK)) : (o(), viettel.Events.trigger(a, "editPoint", viettel.RoadDrawerStatus.ERROR))
            }, l = function (c, e) {
                e == viettel.RoutingStatus.OK ? (a.edit(0, c.path), d.clear(), b.getAt(g).marker.setPosition(c.path[0]), viettel.Events.trigger(a, "editPoint", viettel.RoadDrawerStatus.OK)) : (o(), viettel.Events.trigger(a, "editPoint",
                    viettel.RoadDrawerStatus.ERROR))
            }, n = function (a, b, c) {
                a = {origin: a, destination: b, travelMode: viettel.TravelMode.CAR};
                (new viettel.RoutingService).route(a, c)
            }, o = function () {
                d.clear();
                b.getAt(g).marker.setPosition(h);
                a.getCallback()()
            }
    };
    viettel.MarkerManager = function (a, b) {
        var c = this;
        c.map_ = a;
        c.mapZoom_ = a.getZoom();
        c.projectionHelper_ = new ProjectionHelperOverlay(a);
        viettel.Events.addListener(c.projectionHelper_, "ready", function () {
            c.projection_ = c.projectionHelper_.getProjection();
            c.initialize(a, b)
        })
    };
    viettel.MarkerManager.prototype.initialize = function (a, b) {
        var c = this, b = b || {};
        c.tileSize_ = viettel.MarkerManager.DEFAULT_TILE_SIZE_;
        var d = a.mapTypes, e = 1, f;
        for (f in d)if ("object" === typeof a.mapTypes.get(f) && "number" === typeof a.mapTypes.get(f).maxZoom) {
            var g = a.mapTypes.get(f).maxZoom;
            g > e && (e = g)
        }
        c.maxZoom_ = b.maxZoom || 19;
        c.trackMarkers_ = b.trackMarkers;
        c.show_ = b.show || !0;
        d = "number" === typeof b.borderPadding ? b.borderPadding : viettel.MarkerManager.DEFAULT_BORDER_PADDING_;
        c.swPadding_ = new viettel.Size(-d, d);
        c.nePadding_ =
            new viettel.Size(d, -d);
        c.borderPadding_ = d;
        c.gridWidth_ = {};
        c.grid_ = {};
        c.grid_[c.maxZoom_] = {};
        c.numMarkers_ = {};
        c.numMarkers_[c.maxZoom_] = 0;
        c.isLoadedMap = !1;
        viettel.Events.addListener(a, "dragend", function () {
            c.onMapMoveEnd_()
        });
        viettel.Events.addListener(a, "idle", function () {
            c.isLoadedMap = !0;
            c.onMapMoveEnd_()
        });
        viettel.Events.addListener(a, "zoom_changed", function () {
            c.onMapMoveEnd_()
        });
        var h = setInterval(function () {
                c.isLoadedMap ? clearInterval(h) : a.loadedMap && (c.isLoadedMap = !0, c.onMapMoveEnd_(), clearInterval(h))
            },
            100);
        c.removeOverlay_ = function (a) {
            a.setMap(null);
            c.shownMarkers_--;
            viettel.Events.clearListeners(a)
        };
        c.addOverlay_ = function (a) {
            c.show_ && (a.setMap(c.map_), c.shownMarkers_++)
        };
        c.resetManager_();
        c.shownMarkers_ = 0;
        c.shownBounds_ = c.getMapGridBounds_();
        viettel.Events.trigger(c, "loaded")
    };
    viettel.MarkerManager.DEFAULT_TILE_SIZE_ = 1024;
    viettel.MarkerManager.DEFAULT_BORDER_PADDING_ = 100;
    viettel.MarkerManager.MERCATOR_ZOOM_LEVEL_ZERO_RANGE = 256;
    viettel.MarkerManager.prototype.getMarkerByIndex = function (a) {
        return a
    };
    viettel.MarkerManager.prototype.getAllMarkersByZoom = function (a) {
        var b = [], c = 0, c = null != a || "" != a ? a : this.map_.getZoom(), a = this.grid_[c], d;
        for (d in a)for (var c = a[d], e = 0; e < c.length; e++)if ("undefined" != typeof c[e])for (var f = 0; f < c[e].length; f++)b.push(c[e][f]);
        return b
    };
    viettel.MarkerManager.prototype.resetManager_ = function () {
        for (var a = viettel.MarkerManager.MERCATOR_ZOOM_LEVEL_ZERO_RANGE, b = 0; b <= this.maxZoom_; ++b)this.grid_[b] = {}, this.numMarkers_[b] = 0, this.gridWidth_[b] = Math.ceil(a / this.tileSize_), a <<= 1
    };
    viettel.MarkerManager.prototype.clearMarkers = function () {
        this.processAll_(this.shownBounds_, this.removeOverlay_);
        this.resetManager_()
    };
    viettel.MarkerManager.prototype.getTilePoint_ = function (a, b, c) {
        a = this.projectionHelper_.LatLngToPixel(a, b);
        return new viettel.Point(Math.floor((a.x + c.width) / this.tileSize_), Math.floor((a.y + c.height) / this.tileSize_))
    };
    viettel.MarkerManager.prototype.addMarkerBatch_ = function (a, b, c) {
        var d = this, e = a.getPosition();
        a.MarkerManager_minZoom = b;
        this.trackMarkers_ && viettel.Events.addListener(a, "changed", function (a, b, c) {
            d.onMarkerMoved_(a, b, c)
        });
        for (e = this.getTilePoint_(e, c, new viettel.Size(0, 0, 0, 0)); c >= b; c--)this.getGridCellCreate_(e.x, e.y, c).push(a), e.x >>= 1, e.y >>= 1
    };
    viettel.MarkerManager.prototype.isGridPointVisible_ = function (a) {
        var b = this.shownBounds_.minY <= a.y && a.y <= this.shownBounds_.maxY, c = this.shownBounds_.minX, d = c <= a.x && a.x <= this.shownBounds_.maxX;
        !d && 0 > c && (d = this.gridWidth_[this.shownBounds_.z], d = c + d <= a.x && a.x <= d - 1);
        return b && d
    };
    viettel.MarkerManager.prototype.onMarkerMoved_ = function (a, b, c) {
        for (var d = this.maxZoom_, e = !1, b = this.getTilePoint_(b, d, new viettel.Size(0, 0, 0, 0)), c = this.getTilePoint_(c, d, new viettel.Size(0, 0, 0, 0)); 0 <= d && (b.x !== c.x || b.y !== c.y);) {
            var f = this.getGridCellNoCreate_(b.x, b.y, d);
            f && this.removeFromArray_(f, a) && this.getGridCellCreate_(c.x, c.y, d).push(a);
            d === this.mapZoom_ && (this.isGridPointVisible_(b) ? this.isGridPointVisible_(c) || (this.removeOverlay_(a), e = !0) : this.isGridPointVisible_(c) && (this.addOverlay_(a),
                e = !0));
            b.x >>= 1;
            b.y >>= 1;
            c.x >>= 1;
            c.y >>= 1;
            --d
        }
        e && this.notifyListeners_()
    };
    viettel.MarkerManager.prototype.removeMarker = function (a) {
        for (var b = this.maxZoom_, c = !1, d = this.getTilePoint_(a.getPosition(), b, new viettel.Size(0, 0, 0, 0)); 0 <= b;) {
            var e = this.getGridCellNoCreate_(d.x, d.y, b);
            e && this.removeFromArray_(e, a);
            b === this.mapZoom_ && this.isGridPointVisible_(d) && (this.removeOverlay_(a), c = !0);
            d.x >>= 1;
            d.y >>= 1;
            --b
        }
        c && this.notifyListeners_();
        this.numMarkers_[a.MarkerManager_minZoom]--
    };
    viettel.MarkerManager.prototype.addMarkers = function (a, b, c) {
        null == b && (b = 0);
        null == c && (c = 21);
        for (var c = this.getOptMaxZoom_(c), d = a.length - 1; 0 <= d; d--)this.addMarkerBatch_(a[d], b, c);
        this.numMarkers_[b] += a.length
    };
    viettel.MarkerManager.prototype.getOptMaxZoom_ = function (a) {
        return a || this.maxZoom_
    };
    viettel.MarkerManager.prototype.getMarkerCount = function (a) {
        for (var b = 0, c = 0; c <= a; c++)b += this.numMarkers_[c];
        return b
    };
    viettel.MarkerManager.prototype.getMarker = function (a, b, c) {
        var d = new viettel.LatLng(a, b), e = this.getTilePoint_(d, c, new viettel.Size(0, 0, 0, 0)), d = new viettel.Marker({position: d}), c = this.getGridCellNoCreate_(e.x, e.y, c);
        if (void 0 !== c)for (e = 0; e < c.length; e++)a === c[e].getPosition().lat() && b === c[e].getPosition().lng() && (d = c[e]);
        return d
    };
    viettel.MarkerManager.prototype.addMarker = function (a, b, c) {
        null == b && (b = 0);
        null == c && (c = 21);
        c = this.getOptMaxZoom_(c);
        this.addMarkerBatch_(a, b, c);
        this.isGridPointVisible_(this.getTilePoint_(a.getPosition(), this.mapZoom_, new viettel.Size(0, 0, 0, 0))) && b <= this.shownBounds_.z && this.shownBounds_.z <= c && (this.addOverlay_(a), this.notifyListeners_());
        this.numMarkers_[b]++
    };
    function GridBounds(a) {
        this.minX = Math.min(a[0].x, a[1].x);
        this.maxX = Math.max(a[0].x, a[1].x);
        this.minY = Math.min(a[0].y, a[1].y);
        this.maxY = Math.max(a[0].y, a[1].y)
    }

    GridBounds.prototype.equals = function (a) {
        return this.maxX === a.maxX && this.maxY === a.maxY && this.minX === a.minX && this.minY === a.minY ? !0 : !1
    };
    GridBounds.prototype.containsPoint = function (a) {
        return this.minX <= a.x && this.maxX >= a.x && this.minY <= a.y && this.maxY >= a.y
    };
    viettel.MarkerManager.prototype.getGridCellCreate_ = function (a, b, c) {
        var d = this.grid_[c];
        if (null != d) {
            0 > a && (a += this.gridWidth_[c]);
            c = d[a];
            if (!c)return c = d[a] = [], c[b] = [];
            a = c[b];
            return !a ? c[b] = [] : a
        }
        return []
    };
    viettel.MarkerManager.prototype.getGridCellNoCreate_ = function (a, b, c) {
        var d = this.grid_[c];
        0 > a && (a += this.gridWidth_[c]);
        return (a = d[a]) ? a[b] : void 0
    };
    viettel.MarkerManager.prototype.getGridBounds_ = function (a, b, c, d) {
        var b = Math.min(b, this.maxZoom_), e = a.getSouthWest(), a = a.getNorthEast(), c = this.getTilePoint_(e, b, c), d = this.getTilePoint_(a, b, d), f = this.gridWidth_[b];
        if (a.lng() < e.lng() || d.x < c.x)c.x -= f;
        d.x - c.x + 1 >= f && (c.x = 0, d.x = f - 1);
        e = new GridBounds([c, d]);
        e.z = b;
        return e
    };
    viettel.MarkerManager.prototype.getMapGridBounds_ = function () {
        return this.getGridBounds_(this.map_.getBounds(), this.mapZoom_, this.swPadding_, this.nePadding_)
    };
    viettel.MarkerManager.prototype.onMapMoveEnd_ = function () {
        this.objectSetTimeout_(this, this.updateMarkers_, 0)
    };
    viettel.MarkerManager.prototype.objectSetTimeout_ = function (a, b, c) {
        return window.setTimeout(function () {
            b.call(a)
        }, c)
    };
    viettel.MarkerManager.prototype.visible = function () {
        return this.show_ ? !0 : !1
    };
    viettel.MarkerManager.prototype.isHidden = function () {
        return !this.show_
    };
    viettel.MarkerManager.prototype.show = function () {
        this.show_ = !0;
        this.refresh()
    };
    viettel.MarkerManager.prototype.hide = function () {
        this.show_ = !1;
        this.refresh()
    };
    viettel.MarkerManager.prototype.toggle = function () {
        this.show_ = !this.show_;
        this.refresh()
    };
    viettel.MarkerManager.prototype.refresh = function () {
        0 < this.shownMarkers_ && this.processAll_(this.shownBounds_, this.removeOverlay_);
        this.show_ && this.processAll_(this.shownBounds_, this.addOverlay_);
        this.notifyListeners_()
    };
    viettel.MarkerManager.prototype.updateMarkers_ = function () {
        this.mapZoom_ = this.map_.getZoom();
        var a = this.getMapGridBounds_();
        a.equals(this.shownBounds_) && a.z === this.shownBounds_.z || (a.z !== this.shownBounds_.z ? (this.processAll_(this.shownBounds_, this.removeOverlay_), this.show_ && this.processAll_(a, this.addOverlay_)) : (this.rectangleDiff_(this.shownBounds_, a, this.removeCellMarkers_), this.show_ && this.rectangleDiff_(a, this.shownBounds_, this.addCellMarkers_)), this.shownBounds_ = a, this.notifyListeners_())
    };
    viettel.MarkerManager.prototype.notifyListeners_ = function () {
        viettel.Events.trigger(this, "changed", this.shownBounds_, this.shownMarkers_)
    };
    viettel.MarkerManager.prototype.processAll_ = function (a, b) {
        for (var c = a.minX; c <= a.maxX; c++)for (var d = a.minY; d <= a.maxY; d++)this.processCellMarkers_(c, d, a.z, b)
    };
    viettel.MarkerManager.prototype.processCellMarkers_ = function (a, b, c, d) {
        if (a = this.getGridCellNoCreate_(a, b, c))for (b = a.length - 1; 0 <= b; b--)d(a[b])
    };
    viettel.MarkerManager.prototype.removeCellMarkers_ = function (a, b, c) {
        this.processCellMarkers_(a, b, c, this.removeOverlay_)
    };
    viettel.MarkerManager.prototype.addCellMarkers_ = function (a, b, c) {
        this.processCellMarkers_(a, b, c, this.addOverlay_)
    };
    viettel.MarkerManager.prototype.rectangleDiff_ = function (a, b, c) {
        var d = this;
        d.rectangleDiffCoords_(a, b, function (b, f) {
            c.apply(d, [b, f, a.z])
        })
    };
    viettel.MarkerManager.prototype.rectangleDiffCoords_ = function (a, b, c) {
        var d = a.minX, e = a.minY, f = a.maxX, a = a.maxY, g = b.minX, h = b.minY, i = b.maxX, b = b.maxY, j, k;
        for (j = d; j <= f; j++) {
            for (k = e; k <= a && k < h; k++)c(j, k);
            for (k = Math.max(b + 1, e); k <= a; k++)c(j, k)
        }
        for (k = Math.max(e, h); k <= Math.min(a, b); k++) {
            for (j = Math.min(f + 1, g) - 1; j >= d; j--)c(j, k);
            for (j = Math.max(d, i + 1); j <= f; j++)c(j, k)
        }
    };
    viettel.MarkerManager.prototype.removeFromArray_ = function (a, b, c) {
        for (var d = 0, e = 0; e < a.length; ++e)if (a[e] === b || c && a[e] === b)a.splice(e--, 1), d++;
        return d
    };
    ProjectionHelperOverlay.prototype = new viettel.OverlayView;
    ProjectionHelperOverlay.prototype.constructor = ProjectionHelperOverlay;
    function ProjectionHelperOverlay(a) {
        viettel.OverlayView.call(this);
        this._map = a;
        this._X0 = this._Y0 = this._X1 = this._Y1 = this._zoom = -1;
        this.draw = function () {
            this.ready || (this.ready = !0, viettel.Events.trigger(this, "ready"))
        };
        this.setMap(a)
    }

    ProjectionHelperOverlay.prototype.LngToX_ = function (a) {
        return 1 + a / 180
    };
    ProjectionHelperOverlay.prototype.LatToY_ = function (a) {
        a = Math.sin(a * Math.PI / 180);
        return 1 - 0.5 / Math.PI * Math.log((1 + a) / (1 - a))
    };
    ProjectionHelperOverlay.prototype.LatLngToPixel = function (a, b) {
        this.getProjection().fromLatLngToDivPixel(a);
        return {x: ~~(0.5 + this.LngToX_(a.lng()) * (2 << b + 6)), y: ~~(0.5 + this.LatToY_(a.lat()) * (2 << b + 6))}
    };
    function DrawingPolyline(a) {
        var b = a.getMap(), c = this, d = a.getClickable(), e = OpenLayersEX_ImgLoc + "polylineMarker.png", f = !0;
        this.disableMovingEvent = function () {
            f = !1
        };
        var g = !0;
        this.disableDrawLine = function () {
            g = f = !1
        };
        var h, i = !1, j = !0, k = [], m = [], l;
        this.init = function () {
            b.setOptions({disableDoubleClickZoom: !0});
            a.setClickable(!1);
            f && (h = new viettel.Polyline({
                strokeColor: "#FF0000",
                strokeOpacity: 0.8,
                clickable: !1,
                strokeWeight: 1,
                clickable: !1
            }), h.setMap(b));
            if (0 < a.getPath().getLength()) {
                C();
                for (var c = 0; c < a.getPath().getLength(); c++)y(a.getPath().getAt(c)),
                1 < a.getPath().getLength() && c < a.getPath().getLength() - 1 && w(a.getPath().getAt(c), a.getPath().getAt(c + 1), c)
            }
            g && (r(), s())
        };
        var n, o, r = function () {
            n = viettel.Events.addListener(b, "click", function (b) {
                u(b.latLng);
                viettel.Events.trigger(a, "addPoint", b)
            })
        }, s = function () {
            o = viettel.Events.addListener(b, "dblclick", function () {
                c.onCompleDraw()
            })
        }, u = function (b) {
            p(b);
            setTimeout(function () {
                y(b)
            }, 200);
            1 < a.getPath().getLength() && w(a.getPath().getAt(a.getPath().getLength() - 1), a.getPath().getAt(a.getPath().getLength() - 2),
                a.getPath().getLength() - 2)
        };
        this.onCompleDraw = function () {
            g && (a.setClickable(d), a.setDrawingState(!1), viettel.Events.removeListener(n), viettel.Events.removeListener(o), viettel.Events.removeListener(l), h.setMap(null), setTimeout(function () {
                a.setEditable(!0);
                b.setOptions({disableDoubleClickZoom: !1});
                viettel.Events.trigger(a, "endDraw")
            }, 400));
            setTimeout(q, 400);
            setTimeout(t, 400)
        };
        this.disableEditable = function () {
            q();
            t()
        };
        var q = function () {
                for (var a = 0; a < k.length; a++)k[a].setMap(null), viettel.Events.clearListeners(k[a])
            },
            t = function () {
                for (var a = 0; a < m.length; a++)m[a].setMap(null), viettel.Events.clearListeners(m[a])
            }, p = function (b) {
                a.getPath().push(b);
                C()
            }, C = function () {
                if (f) {
                    var c = a.getPath().getAt(a.getPath().getLength() - 1);
                    h.getPath().clear();
                    i = !1;
                    h.getPath().push(c);
                    j && (j = !1, l = viettel.Events.addListener(b, "mousemove", function (a) {
                        i && h.getPath().pop();
                        i = !0;
                        h.getPath().push(a.latLng)
                    }))
                }
            }, y = function (a) {
                var c = new viettel.Marker;
                c.setMap(b);
                c.setPosition(a);
                c.setDraggable(!0);
                c.setIcon(new viettel.MarkerImage(e, null, null,
                    new viettel.Point(5, 5), new viettel.Size(10, 10)));
                k.push(c);
                viettel.Events.addListener(c, "dragend", B)
            }, w = function (a, c, d) {
                c = v(a, c);
                a = new viettel.Marker;
                a.setMap(b);
                a.setPosition(c);
                a.setDraggable(!0);
                a.setIcon(new viettel.MarkerImage(e, null, null, new viettel.Point(5, 5), new viettel.Size(10, 10)));
                m.splice(d, 0, a);
                for (d = 0; d < m.length; d++);
                viettel.Events.addListener(a, "dragend", A)
            }, B = function (b) {
                var c = k.indexOf(this);
                a.getPath().removeAt(c);
                a.getPath().insertAt(c, b.latLng);
                if (c < k.length - 1) {
                    var d = v(k[c].getPosition(),
                        k[c + 1].getPosition());
                    m[c].setPosition(d)
                }
                0 < c && (d = v(k[c - 1].getPosition(), k[c].getPosition()), m[c - 1].setPosition(d));
                c == k.length - 1 && (b = b.latLng, f && (h.getPath().removeAt(0), h.getPath().insertAt(0, b)));
                viettel.Events.trigger(a, "endEdit")
            }, A = function (b) {
                var c = m.indexOf(this);
                a.getPath().insertAt(c + 1, b.latLng);
                k.splice(c + 1, 0, this);
                m.splice(c, 1);
                viettel.Events.clearListeners(this, "dragend");
                viettel.Events.addListener(this, "dragend", B);
                w(k[c].getPosition(), k[c + 1].getPosition(), c);
                w(k[c + 1].getPosition(),
                    k[c + 2].getPosition(), c + 1);
                viettel.Events.trigger(a, "endEdit")
            }, v = function (a, b) {
                return new viettel.LatLng((a.lat() + b.lat()) / 2, (a.lng() + b.lng()) / 2)
            }
    };
}
initVTMapAPI = function () {
    loadVTMapAPI();
};
var triggerLoadedMap = function (callback) {
    callback()
};
initVTMapAPI(); 

